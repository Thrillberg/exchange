# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

module AMQ
end

class AMQ::BitSet
  def [](i); end

  def check_range(i); end

  def clear(); end

  def get(i); end

  def init_words(nbits); end

  def initialize(nbits); end

  def next_clear_bit(); end

  def set(i); end

  def unset(i); end

  def word_index(i); end

  def words_in_use(); end
  ADDRESS_BITS_PER_WORD = ::T.let(nil, ::T.untyped)
  BITS_PER_WORD = ::T.let(nil, ::T.untyped)
  WORD_MASK = ::T.let(nil, ::T.untyped)
end

class AMQ::BitSet
  def self.number_of_trailing_ones(num); end
end

module AMQ::Endianness
  def big_endian?(); end

  def little_endian?(); end
  BIG_ENDIAN = ::T.let(nil, ::T.untyped)
end

module AMQ::Endianness
  extend ::AMQ::Endianness
  extend ::T::Sig
end

AMQ::Hacks = AMQ::Pack

class AMQ::IntAllocator
  def allocate(); end

  def allocated?(reservation); end

  def free(reservation); end

  def hi(); end

  def initialize(lo, hi); end

  def lo(); end

  def number_of_bits(); end

  def release(reservation); end

  def reset(); end
end

class AMQ::IntAllocator
end

module AMQ::Pack
  INT16 = ::T.let(nil, ::T.untyped)
  UINT16_BE = ::T.let(nil, ::T.untyped)
  UINT64 = ::T.let(nil, ::T.untyped)
end

module AMQ::Pack
  extend ::T::Sig
  def self.pack_int16_big_endian(short); end

  def self.pack_uint64_big_endian(long_long); end

  def self.unpack_int16_big_endian(data); end

  def self.unpack_uint64_big_endian(data); end
end

module AMQ::Protocol
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  PACK_32BIT_FLOAT = ::T.let(nil, ::T.untyped)
  PACK_64BIT_FLOAT = ::T.let(nil, ::T.untyped)
  PACK_CHAR = ::T.let(nil, ::T.untyped)
  PACK_CHAR_UINT16_UINT32 = ::T.let(nil, ::T.untyped)
  PACK_INT64 = ::T.let(nil, ::T.untyped)
  PACK_INT64_BE = ::T.let(nil, ::T.untyped)
  PACK_INT8 = ::T.let(nil, ::T.untyped)
  PACK_UCHAR_UINT32 = ::T.let(nil, ::T.untyped)
  PACK_UINT16 = ::T.let(nil, ::T.untyped)
  PACK_UINT16_X2 = ::T.let(nil, ::T.untyped)
  PACK_UINT32 = ::T.let(nil, ::T.untyped)
  PACK_UINT32_X2 = ::T.let(nil, ::T.untyped)
  PACK_UINT64_BE = ::T.let(nil, ::T.untyped)
  PREAMBLE = ::T.let(nil, ::T.untyped)
  PROTOCOL_VERSION = ::T.let(nil, ::T.untyped)
  SSL_PORT = ::T.let(nil, ::T.untyped)
  TLS_PORT = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::AccessRefused
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::AccessRefused
end

class AMQ::Protocol::BadResponseError
  def initialize(argument, expected, actual); end
end

class AMQ::Protocol::BadResponseError
end

class AMQ::Protocol::Basic
  DECODE_PROPERTIES = ::T.let(nil, ::T.untyped)
  DECODE_PROPERTIES_KEYS = ::T.let(nil, ::T.untyped)
  DECODE_PROPERTIES_TYPE = ::T.let(nil, ::T.untyped)
  PROPERTIES = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::Basic::Ack
  def delivery_tag(); end

  def initialize(delivery_tag, multiple); end

  def multiple(); end
end

class AMQ::Protocol::Basic::Ack
  def self.decode(data); end

  def self.encode(channel, delivery_tag, multiple); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Cancel
  def consumer_tag(); end

  def initialize(consumer_tag, nowait); end

  def nowait(); end
end

class AMQ::Protocol::Basic::Cancel
  def self.decode(data); end

  def self.encode(channel, consumer_tag, nowait); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::CancelOk
  def consumer_tag(); end

  def initialize(consumer_tag); end
end

class AMQ::Protocol::Basic::CancelOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Consume
end

class AMQ::Protocol::Basic::Consume
  def self.encode(channel, queue, consumer_tag, no_local, no_ack, exclusive, nowait, arguments); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::ConsumeOk
  def consumer_tag(); end

  def initialize(consumer_tag); end
end

class AMQ::Protocol::Basic::ConsumeOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Deliver
  def consumer_tag(); end

  def delivery_tag(); end

  def exchange(); end

  def initialize(consumer_tag, delivery_tag, redelivered, exchange, routing_key); end

  def redelivered(); end

  def routing_key(); end
end

class AMQ::Protocol::Basic::Deliver
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Get
end

class AMQ::Protocol::Basic::Get
  def self.encode(channel, queue, no_ack); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::GetEmpty
  def cluster_id(); end

  def initialize(cluster_id); end
end

class AMQ::Protocol::Basic::GetEmpty
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::GetOk
  def delivery_tag(); end

  def delivery_tag=(delivery_tag); end

  def exchange(); end

  def initialize(delivery_tag, redelivered, exchange, routing_key, message_count); end

  def message_count(); end

  def redelivered(); end

  def routing_key(); end
end

class AMQ::Protocol::Basic::GetOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Nack
  def delivery_tag(); end

  def initialize(delivery_tag, multiple, requeue); end

  def multiple(); end

  def requeue(); end
end

class AMQ::Protocol::Basic::Nack
  def self.decode(data); end

  def self.encode(channel, delivery_tag, multiple, requeue); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Publish
end

class AMQ::Protocol::Basic::Publish
  def self.encode(channel, payload, user_headers, exchange, routing_key, mandatory, immediate, frame_size); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Qos
end

class AMQ::Protocol::Basic::Qos
  def self.encode(channel, prefetch_size, prefetch_count, global); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::QosOk
end

class AMQ::Protocol::Basic::QosOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Recover
end

class AMQ::Protocol::Basic::Recover
  def self.encode(channel, requeue); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::RecoverAsync
end

class AMQ::Protocol::Basic::RecoverAsync
  def self.encode(channel, requeue); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::RecoverOk
end

class AMQ::Protocol::Basic::RecoverOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Reject
end

class AMQ::Protocol::Basic::Reject
  def self.encode(channel, delivery_tag, requeue); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic::Return
  def exchange(); end

  def initialize(reply_code, reply_text, exchange, routing_key); end

  def reply_code(); end

  def reply_text(); end

  def routing_key(); end
end

class AMQ::Protocol::Basic::Return
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Basic
  def self.decode_properties(data); end

  def self.encode_app_id(value); end

  def self.encode_cluster_id(value); end

  def self.encode_content_encoding(value); end

  def self.encode_content_type(value); end

  def self.encode_correlation_id(value); end

  def self.encode_delivery_mode(value); end

  def self.encode_expiration(value); end

  def self.encode_headers(value); end

  def self.encode_message_id(value); end

  def self.encode_priority(value); end

  def self.encode_properties(body_size, properties); end

  def self.encode_reply_to(value); end

  def self.encode_timestamp(value); end

  def self.encode_type(value); end

  def self.encode_user_id(value); end
end

class AMQ::Protocol::BodyFrame
  def decode_payload(); end
end

class AMQ::Protocol::BodyFrame
end

class AMQ::Protocol::Channel
end

class AMQ::Protocol::Channel::Close
  def class_id(); end

  def initialize(reply_code, reply_text, class_id, method_id); end

  def method_id(); end

  def reply_code(); end

  def reply_text(); end
end

class AMQ::Protocol::Channel::Close
  def self.decode(data); end

  def self.encode(channel, reply_code, reply_text, class_id, method_id); end

  def self.has_content?(); end
end

class AMQ::Protocol::Channel::CloseOk
end

class AMQ::Protocol::Channel::CloseOk
  def self.decode(data); end

  def self.encode(channel); end

  def self.has_content?(); end
end

class AMQ::Protocol::Channel::Flow
  def active(); end

  def initialize(active); end
end

class AMQ::Protocol::Channel::Flow
  def self.decode(data); end

  def self.encode(channel, active); end

  def self.has_content?(); end
end

class AMQ::Protocol::Channel::FlowOk
  def active(); end

  def initialize(active); end
end

class AMQ::Protocol::Channel::FlowOk
  def self.decode(data); end

  def self.encode(channel, active); end

  def self.has_content?(); end
end

class AMQ::Protocol::Channel::Open
end

class AMQ::Protocol::Channel::Open
  def self.encode(channel, out_of_band); end

  def self.has_content?(); end
end

class AMQ::Protocol::Channel::OpenOk
  def channel_id(); end

  def initialize(channel_id); end
end

class AMQ::Protocol::Channel::OpenOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Channel
end

class AMQ::Protocol::ChannelError
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::ChannelError
end

class AMQ::Protocol::Class
end

class AMQ::Protocol::Class
  def self.classes(); end

  def self.inherited(base); end

  def self.method_id(); end
end

class AMQ::Protocol::CommandInvalid
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::CommandInvalid
end

class AMQ::Protocol::Confirm
end

class AMQ::Protocol::Confirm::Select
  def initialize(nowait); end

  def nowait(); end
end

class AMQ::Protocol::Confirm::Select
  def self.decode(data); end

  def self.encode(channel, nowait); end

  def self.has_content?(); end
end

class AMQ::Protocol::Confirm::SelectOk
end

class AMQ::Protocol::Confirm::SelectOk
  def self.decode(data); end

  def self.encode(channel); end

  def self.has_content?(); end
end

class AMQ::Protocol::Confirm
end

class AMQ::Protocol::Connection
end

class AMQ::Protocol::Connection::Blocked
  def initialize(reason); end

  def reason(); end
end

class AMQ::Protocol::Connection::Blocked
  def self.decode(data); end

  def self.encode(reason); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::Close
  def class_id(); end

  def initialize(reply_code, reply_text, class_id, method_id); end

  def method_id(); end

  def reply_code(); end

  def reply_text(); end
end

class AMQ::Protocol::Connection::Close
  def self.decode(data); end

  def self.encode(reply_code, reply_text, class_id, method_id); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::CloseOk
end

class AMQ::Protocol::Connection::CloseOk
  def self.decode(data); end

  def self.encode(); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::Open
end

class AMQ::Protocol::Connection::Open
  def self.encode(virtual_host); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::OpenOk
  def initialize(known_hosts); end

  def known_hosts(); end
end

class AMQ::Protocol::Connection::OpenOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::Secure
  def challenge(); end

  def initialize(challenge); end
end

class AMQ::Protocol::Connection::Secure
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::SecureOk
end

class AMQ::Protocol::Connection::SecureOk
  def self.encode(response); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::Start
  def initialize(version_major, version_minor, server_properties, mechanisms, locales); end

  def locales(); end

  def mechanisms(); end

  def server_properties(); end

  def version_major(); end

  def version_minor(); end
end

class AMQ::Protocol::Connection::Start
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::StartOk
end

class AMQ::Protocol::Connection::StartOk
  def self.encode(client_properties, mechanism, response, locale); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::Tune
  def channel_max(); end

  def frame_max(); end

  def heartbeat(); end

  def initialize(channel_max, frame_max, heartbeat); end
end

class AMQ::Protocol::Connection::Tune
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::TuneOk
end

class AMQ::Protocol::Connection::TuneOk
  def self.encode(channel_max, frame_max, heartbeat); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection::Unblocked
end

class AMQ::Protocol::Connection::Unblocked
  def self.decode(data); end

  def self.encode(); end

  def self.has_content?(); end
end

class AMQ::Protocol::Connection
end

class AMQ::Protocol::ConnectionForced
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::ConnectionForced
end

class AMQ::Protocol::ContentTooLarge
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::ContentTooLarge
end

class AMQ::Protocol::EmptyResponseError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::EmptyResponseError
end

class AMQ::Protocol::Error
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::Error
  def self.[](code); end

  def self.inherited(subclass); end

  def self.subclasses_with_values(); end
end

class AMQ::Protocol::Exchange
end

class AMQ::Protocol::Exchange::Bind
end

class AMQ::Protocol::Exchange::Bind
  def self.encode(channel, destination, source, routing_key, nowait, arguments); end

  def self.has_content?(); end
end

class AMQ::Protocol::Exchange::BindOk
end

class AMQ::Protocol::Exchange::BindOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Exchange::Declare
end

class AMQ::Protocol::Exchange::Declare
  def self.encode(channel, exchange, type, passive, durable, auto_delete, internal, nowait, arguments); end

  def self.has_content?(); end
end

class AMQ::Protocol::Exchange::DeclareOk
end

class AMQ::Protocol::Exchange::DeclareOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Exchange::Delete
end

class AMQ::Protocol::Exchange::Delete
  def self.encode(channel, exchange, if_unused, nowait); end

  def self.has_content?(); end
end

class AMQ::Protocol::Exchange::DeleteOk
end

class AMQ::Protocol::Exchange::DeleteOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Exchange::Unbind
end

class AMQ::Protocol::Exchange::Unbind
  def self.encode(channel, destination, source, routing_key, nowait, arguments); end

  def self.has_content?(); end
end

class AMQ::Protocol::Exchange::UnbindOk
end

class AMQ::Protocol::Exchange::UnbindOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Exchange
end

class AMQ::Protocol::Float32Bit
  def initialize(value); end

  def value(); end
end

class AMQ::Protocol::Float32Bit
end

class AMQ::Protocol::Frame
  def final?(); end
  CHANNEL_RANGE = ::T.let(nil, ::T.untyped)
  CLASSES = ::T.let(nil, ::T.untyped)
  FINAL_OCTET = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  TYPES_OPTIONS = ::T.let(nil, ::T.untyped)
  TYPES_REVERSE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::Frame
  def self.__new__(*_); end

  def self.decode(*_); end

  def self.decode_header(header); end

  def self.encode(type, payload, channel); end

  def self.encode_to_array(type, payload, channel); end

  def self.encoded_payload(payload); end

  def self.find_type(type); end

  def self.new(original_type, *args); end
end

class AMQ::Protocol::FrameError
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::FrameError
end

class AMQ::Protocol::FrameSubclass
  def channel(); end

  def channel=(channel); end

  def encode(); end

  def encode_to_array(); end

  def initialize(payload, channel); end

  def payload(); end

  def size(); end
end

class AMQ::Protocol::FrameSubclass
  def self.encode(payload, channel); end

  def self.id(); end

  def self.new(*_); end
end

class AMQ::Protocol::FrameTypeError
  def initialize(types); end
end

class AMQ::Protocol::FrameTypeError
end

class AMQ::Protocol::HardError
end

class AMQ::Protocol::HardError
end

class AMQ::Protocol::HeaderFrame
  def body_size(); end

  def decode_payload(); end

  def klass_id(); end

  def properties(); end

  def weight(); end
end

class AMQ::Protocol::HeaderFrame
end

class AMQ::Protocol::HeartbeatFrame
end

class AMQ::Protocol::HeartbeatFrame
  def self.encode(); end
end

class AMQ::Protocol::InternalError
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::InternalError
end

class AMQ::Protocol::InvalidPath
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::InvalidPath
end

class AMQ::Protocol::Method
end

class AMQ::Protocol::Method
  def self.encode_body(body, channel, frame_size); end

  def self.index(); end

  def self.inherited(base); end

  def self.instantiate(*args, &block); end

  def self.method_id(); end

  def self.methods(); end

  def self.split_headers(user_headers); end
end

class AMQ::Protocol::MethodFrame
  def decode_payload(); end

  def method_class(); end
end

class AMQ::Protocol::MethodFrame
end

class AMQ::Protocol::NoConsumers
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::NoConsumers
end

class AMQ::Protocol::NoRoute
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::NoRoute
end

class AMQ::Protocol::NotAllowed
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::NotAllowed
end

class AMQ::Protocol::NotFound
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::NotFound
end

class AMQ::Protocol::NotImplemented
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::NotImplemented
end

class AMQ::Protocol::PreconditionFailed
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::PreconditionFailed
end

class AMQ::Protocol::Queue
end

class AMQ::Protocol::Queue::Bind
end

class AMQ::Protocol::Queue::Bind
  def self.encode(channel, queue, exchange, routing_key, nowait, arguments); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue::BindOk
end

class AMQ::Protocol::Queue::BindOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue::Declare
end

class AMQ::Protocol::Queue::Declare
  def self.encode(channel, queue, passive, durable, exclusive, auto_delete, nowait, arguments); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue::DeclareOk
  def consumer_count(); end

  def initialize(queue, message_count, consumer_count); end

  def message_count(); end

  def queue(); end
end

class AMQ::Protocol::Queue::DeclareOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue::Delete
end

class AMQ::Protocol::Queue::Delete
  def self.encode(channel, queue, if_unused, if_empty, nowait); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue::DeleteOk
  def initialize(message_count); end

  def message_count(); end
end

class AMQ::Protocol::Queue::DeleteOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue::Purge
end

class AMQ::Protocol::Queue::Purge
  def self.encode(channel, queue, nowait); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue::PurgeOk
  def initialize(message_count); end

  def message_count(); end
end

class AMQ::Protocol::Queue::PurgeOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue::Unbind
end

class AMQ::Protocol::Queue::Unbind
  def self.encode(channel, queue, exchange, routing_key, arguments); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue::UnbindOk
end

class AMQ::Protocol::Queue::UnbindOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Queue
end

class AMQ::Protocol::ResourceError
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::ResourceError
end

class AMQ::Protocol::ResourceLocked
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::ResourceLocked
end

class AMQ::Protocol::SoftError
end

class AMQ::Protocol::SoftError
end

class AMQ::Protocol::SyntaxError
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::SyntaxError
end

class AMQ::Protocol::Table
  include ::AMQ::Protocol::TypeConstants
end

class AMQ::Protocol::Table::InvalidTableError
  def initialize(key, value); end
end

class AMQ::Protocol::Table::InvalidTableError
end

class AMQ::Protocol::Table
  def self.decode(data); end

  def self.decode_table_key(data, offset); end

  def self.encode(table); end

  def self.hash_size(value); end

  def self.length(data); end
end

class AMQ::Protocol::TableValueDecoder
  include ::AMQ::Protocol::TypeConstants
end

class AMQ::Protocol::TableValueDecoder
  def self.decode_32bit_float(data, offset); end

  def self.decode_64bit_float(data, offset); end

  def self.decode_array(data, initial_offset); end

  def self.decode_big_decimal(data, offset); end

  def self.decode_boolean(data, offset); end

  def self.decode_byte(data, offset); end

  def self.decode_hash(data, offset); end

  def self.decode_integer(data, offset); end

  def self.decode_long(data, offset); end

  def self.decode_short(data, offset); end

  def self.decode_string(data, offset); end

  def self.decode_time(data, offset); end

  def self.decode_value_type(data, offset); end
end

class AMQ::Protocol::TableValueEncoder
  include ::AMQ::Protocol::TypeConstants
end

class AMQ::Protocol::TableValueEncoder
  def self.array_size(value); end

  def self.encode(value); end

  def self.field_value_size(value); end
end

class AMQ::Protocol::Tx
end

class AMQ::Protocol::Tx::Commit
end

class AMQ::Protocol::Tx::Commit
  def self.encode(channel); end

  def self.has_content?(); end
end

class AMQ::Protocol::Tx::CommitOk
end

class AMQ::Protocol::Tx::CommitOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Tx::Rollback
end

class AMQ::Protocol::Tx::Rollback
  def self.encode(channel); end

  def self.has_content?(); end
end

class AMQ::Protocol::Tx::RollbackOk
end

class AMQ::Protocol::Tx::RollbackOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Tx::Select
end

class AMQ::Protocol::Tx::Select
  def self.encode(channel); end

  def self.has_content?(); end
end

class AMQ::Protocol::Tx::SelectOk
end

class AMQ::Protocol::Tx::SelectOk
  def self.decode(data); end

  def self.has_content?(); end
end

class AMQ::Protocol::Tx
end

module AMQ::Protocol::TypeConstants
  BOOLEAN_FALSE = ::T.let(nil, ::T.untyped)
  BOOLEAN_TRUE = ::T.let(nil, ::T.untyped)
  TEN = ::T.let(nil, ::T.untyped)
  TYPE_32BIT_FLOAT = ::T.let(nil, ::T.untyped)
  TYPE_64BIT_FLOAT = ::T.let(nil, ::T.untyped)
  TYPE_ARRAY = ::T.let(nil, ::T.untyped)
  TYPE_BOOLEAN = ::T.let(nil, ::T.untyped)
  TYPE_BYTE = ::T.let(nil, ::T.untyped)
  TYPE_BYTE_ARRAY = ::T.let(nil, ::T.untyped)
  TYPE_DECIMAL = ::T.let(nil, ::T.untyped)
  TYPE_HASH = ::T.let(nil, ::T.untyped)
  TYPE_INTEGER = ::T.let(nil, ::T.untyped)
  TYPE_SIGNED_16BIT = ::T.let(nil, ::T.untyped)
  TYPE_SIGNED_64BIT = ::T.let(nil, ::T.untyped)
  TYPE_STRING = ::T.let(nil, ::T.untyped)
  TYPE_TIME = ::T.let(nil, ::T.untyped)
  TYPE_VOID = ::T.let(nil, ::T.untyped)
end

module AMQ::Protocol::TypeConstants
  extend ::T::Sig
end

class AMQ::Protocol::UnexpectedFrame
  VALUE = ::T.let(nil, ::T.untyped)
end

class AMQ::Protocol::UnexpectedFrame
end

module AMQ::Protocol
  extend ::T::Sig
  def self.classes(); end

  def self.methods(); end
end

module AMQ::Settings
  AMQPS = ::T.let(nil, ::T.untyped)
end

module AMQ::Settings
  extend ::T::Sig
  def self.configure(settings=T.unsafe(nil)); end

  def self.default(); end

  def self.parse_amqp_url(connection_string); end
end

class AMQ::URI
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class AMQ::URI
  def self.parse(connection_string); end

  def self.parse_amqp_url(s); end
end

module AMQ
  extend ::T::Sig
end

module AST
end

class AST::Node
  def +(array); end

  def <<(element); end

  def ==(other); end

  def append(element); end

  def assign_properties(properties); end

  def children(); end

  def clone(); end

  def concat(array); end

  def eql?(other); end

  def fancy_type(); end

  def initialize(type, children=T.unsafe(nil), properties=T.unsafe(nil)); end

  def inspect(indent=T.unsafe(nil)); end

  def to_a(); end

  def to_ast(); end

  def to_s(indent=T.unsafe(nil)); end

  def to_sexp(indent=T.unsafe(nil)); end

  def to_sexp_array(); end

  def type(); end

  def updated(type=T.unsafe(nil), children=T.unsafe(nil), properties=T.unsafe(nil)); end
end

class AST::Node
end

class AST::Processor
  include ::AST::Processor::Mixin
end

module AST::Processor::Mixin
  def handler_missing(node); end

  def process(node); end

  def process_all(nodes); end
end

module AST::Processor::Mixin
  extend ::T::Sig
end

class AST::Processor
end

module AST::Sexp
  def s(type, *children); end
end

module AST::Sexp
  extend ::T::Sig
end

module AST
  extend ::T::Sig
end

module AbstractController
end

class AbstractController::ActionNotFound
end

class AbstractController::ActionNotFound
end

module AbstractController::AssetPaths
end

module AbstractController::AssetPaths
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class AbstractController::Base
  include ::ActiveSupport::Configurable
  def action_methods(); end

  def action_name(); end

  def action_name=(action_name); end

  def available_action?(action_name); end

  def controller_path(); end

  def formats(); end

  def formats=(formats); end

  def performed?(); end

  def process(action, *args); end

  def response_body(); end

  def response_body=(response_body); end

  def send_action(*_); end
end

class AbstractController::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.abstract(); end

  def self.abstract!(); end

  def self.abstract?(); end

  def self.action_methods(); end

  def self.clear_action_methods!(); end

  def self.controller_path(); end

  def self.inherited(klass); end

  def self.internal_methods(); end

  def self.method_added(name); end

  def self.supports_path?(); end
end

module AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  def view_cache_dependencies(); end
end

module AbstractController::Caching::ClassMethods
  def view_cache_dependency(&dependency); end
end

module AbstractController::Caching::ClassMethods
  extend ::T::Sig
end

module AbstractController::Caching::ConfigMethods
  def cache_store(); end

  def cache_store=(store); end
end

module AbstractController::Caching::ConfigMethods
  extend ::T::Sig
end

module AbstractController::Caching::Fragments
  def combined_fragment_cache_key(key); end

  def expire_fragment(key, options=T.unsafe(nil)); end

  def fragment_cache_key(key); end

  def fragment_exist?(key, options=T.unsafe(nil)); end

  def instrument_fragment_cache(name, key); end

  def read_fragment(key, options=T.unsafe(nil)); end

  def write_fragment(key, content, options=T.unsafe(nil)); end
end

module AbstractController::Caching::Fragments::ClassMethods
  def fragment_cache_key(value=T.unsafe(nil), &key); end
end

module AbstractController::Caching::Fragments::ClassMethods
  extend ::T::Sig
end

module AbstractController::Caching::Fragments
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module AbstractController::Caching
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module AbstractController::Callbacks
  def process_action(*args); end
end

module AbstractController::Callbacks::ClassMethods
  def _insert_callbacks(callbacks, block=T.unsafe(nil)); end

  def _normalize_callback_option(options, from, to); end

  def _normalize_callback_options(options); end

  def after_action(*names, &blk); end

  def append_after_action(*names, &blk); end

  def append_around_action(*names, &blk); end

  def append_before_action(*names, &blk); end

  def around_action(*names, &blk); end

  def before_action(*names, &blk); end

  def prepend_after_action(*names, &blk); end

  def prepend_around_action(*names, &blk); end

  def prepend_before_action(*names, &blk); end

  def skip_after_action(*names); end

  def skip_around_action(*names); end

  def skip_before_action(*names); end
end

module AbstractController::Callbacks::ClassMethods
  extend ::T::Sig
end

module AbstractController::Callbacks
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module AbstractController::Collector
  def atom(*args, &block); end

  def bmp(*args, &block); end

  def css(*args, &block); end

  def csv(*args, &block); end

  def gif(*args, &block); end

  def gzip(*args, &block); end

  def html(*args, &block); end

  def ics(*args, &block); end

  def jpeg(*args, &block); end

  def js(*args, &block); end

  def json(*args, &block); end

  def m4a(*args, &block); end

  def mp3(*args, &block); end

  def mp4(*args, &block); end

  def mpeg(*args, &block); end

  def multipart_form(*args, &block); end

  def ogg(*args, &block); end

  def otf(*args, &block); end

  def pdf(*args, &block); end

  def png(*args, &block); end

  def rss(*args, &block); end

  def svg(*args, &block); end

  def text(*args, &block); end

  def tiff(*args, &block); end

  def ttf(*args, &block); end

  def url_encoded_form(*args, &block); end

  def vcf(*args, &block); end

  def vtt(*args, &block); end

  def webm(*args, &block); end

  def woff(*args, &block); end

  def woff2(*args, &block); end

  def xml(*args, &block); end

  def yaml(*args, &block); end

  def zip(*args, &block); end
end

module AbstractController::Collector
  extend ::T::Sig
  def self.generate_method_for_mime(mime); end
end

class AbstractController::DoubleRenderError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class AbstractController::DoubleRenderError
end

class AbstractController::Error
end

class AbstractController::Error
end

module AbstractController::Helpers
end

module AbstractController::Helpers::ClassMethods
  def clear_helpers(); end

  def helper(*args, &block); end

  def helper_method(*meths); end

  def inherited(klass); end

  def modules_for_helpers(args); end
end

module AbstractController::Helpers::ClassMethods
  extend ::T::Sig
end

class AbstractController::Helpers::MissingHelperError
  def initialize(error, path); end
end

class AbstractController::Helpers::MissingHelperError
end

module AbstractController::Helpers
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module AbstractController::Logger
end

module AbstractController::Logger
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module AbstractController::Railties
end

module AbstractController::Railties::RoutesHelpers
end

module AbstractController::Railties::RoutesHelpers
  extend ::T::Sig
  def self.with(routes, include_path_helpers=T.unsafe(nil)); end
end

module AbstractController::Railties
  extend ::T::Sig
end

module AbstractController::Rendering
  def render(*args, &block); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*args, &block); end

  def rendered_format(); end

  def view_assigns(); end
  DEFAULT_PROTECTED_INSTANCE_VARIABLES = ::T.let(nil, ::T.untyped)
end

module AbstractController::Rendering
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module AbstractController::Translation
  def l(*args); end

  def localize(*args); end

  def t(key, options=T.unsafe(nil)); end

  def translate(key, options=T.unsafe(nil)); end
end

module AbstractController::Translation
  extend ::T::Sig
end

module AbstractController::UrlFor
  def _routes(); end
end

module AbstractController::UrlFor::ClassMethods
  def _routes(); end

  def action_methods(); end
end

module AbstractController::UrlFor::ClassMethods
  extend ::T::Sig
end

module AbstractController::UrlFor
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module AbstractController
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActionCable
  INTERNAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Channel
end

class ActionCable::Channel::Base
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Channel::Callbacks
  include ::ActionCable::Channel::PeriodicTimers
  include ::ActionCable::Channel::Streams
  include ::ActionCable::Channel::Naming
  include ::ActionCable::Channel::Broadcasting
  def __callbacks(); end

  def __callbacks?(); end

  def _run_subscribe_callbacks(&block); end

  def _run_unsubscribe_callbacks(&block); end

  def _subscribe_callbacks(); end

  def _unsubscribe_callbacks(); end

  def connection(); end

  def identifier(); end

  def initialize(connection, identifier, params=T.unsafe(nil)); end

  def logger(*args, &block); end

  def params(); end

  def perform_action(data); end

  def periodic_timers=(val); end

  def subscribe_to_channel(); end

  def unsubscribe_from_channel(); end
end

class ActionCable::Channel::Base
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActionCable::Channel::Callbacks::ClassMethods
  extend ::ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::ActionCable::Channel::Naming::ClassMethods
  extend ::ActionCable::Channel::Broadcasting::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._subscribe_callbacks(); end

  def self._subscribe_callbacks=(value); end

  def self._unsubscribe_callbacks(); end

  def self._unsubscribe_callbacks=(value); end

  def self.action_methods(); end

  def self.periodic_timers(); end

  def self.periodic_timers=(val); end

  def self.periodic_timers?(); end
end

module ActionCable::Channel::Broadcasting
  def broadcasting_for(*args, &block); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
  def broadcast_to(model, message); end

  def broadcasting_for(model); end
end

module ActionCable::Channel::Broadcasting::ClassMethods
  extend ::T::Sig
end

module ActionCable::Channel::Broadcasting
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionCable::Channel::Callbacks
end

module ActionCable::Channel::Callbacks::ClassMethods
  def after_subscribe(*methods, &block); end

  def after_unsubscribe(*methods, &block); end

  def before_subscribe(*methods, &block); end

  def before_unsubscribe(*methods, &block); end

  def on_subscribe(*methods, &block); end

  def on_unsubscribe(*methods, &block); end
end

module ActionCable::Channel::Callbacks::ClassMethods
  extend ::T::Sig
end

module ActionCable::Channel::Callbacks
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionCable::Channel::Naming
  def channel_name(*args, &block); end
end

module ActionCable::Channel::Naming::ClassMethods
  def channel_name(); end
end

module ActionCable::Channel::Naming::ClassMethods
  extend ::T::Sig
end

module ActionCable::Channel::Naming
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionCable::Channel::PeriodicTimers
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
  def periodically(callback_or_method_name=T.unsafe(nil), every:, &block); end
end

module ActionCable::Channel::PeriodicTimers::ClassMethods
  extend ::T::Sig
end

module ActionCable::Channel::PeriodicTimers
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionCable::Channel::Streams
  def pubsub(*args, &block); end

  def stop_all_streams(); end

  def stream_for(model, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end

  def stream_from(broadcasting, callback=T.unsafe(nil), coder: T.unsafe(nil), &block); end
end

module ActionCable::Channel::Streams
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionCable::Channel
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActionCable::Connection
end

module ActionCable::Connection::Authorization
  def reject_unauthorized_connection(); end
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

class ActionCable::Connection::Authorization::UnauthorizedError
end

module ActionCable::Connection::Authorization
  extend ::T::Sig
end

class ActionCable::Connection::Base
  include ::ActionCable::Connection::Identification
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Authorization
  def beat(); end

  def close(); end

  def dispatch_websocket_message(websocket_message); end

  def env(); end

  def event_loop(*args, &block); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, env, coder: T.unsafe(nil)); end

  def logger(); end

  def message_buffer(); end

  def on_close(reason, code); end

  def on_error(message); end

  def on_message(message); end

  def on_open(); end

  def process(); end

  def protocol(); end

  def pubsub(*args, &block); end

  def receive(websocket_message); end

  def send_async(method, *arguments); end

  def server(); end

  def statistics(); end

  def subscriptions(); end

  def transmit(cable_message); end

  def websocket(); end

  def worker_pool(); end
end

class ActionCable::Connection::Base
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::Connection::ClientSocket
  def alive?(); end

  def client_gone(); end

  def close(code=T.unsafe(nil), reason=T.unsafe(nil)); end

  def env(); end

  def initialize(env, event_target, event_loop, protocols); end

  def parse(data); end

  def protocol(); end

  def rack_response(); end

  def start_driver(); end

  def transmit(message); end

  def url(); end

  def write(data); end
  CLOSED = ::T.let(nil, ::T.untyped)
  CLOSING = ::T.let(nil, ::T.untyped)
  CONNECTING = ::T.let(nil, ::T.untyped)
  OPEN = ::T.let(nil, ::T.untyped)
end

class ActionCable::Connection::ClientSocket
  def self.determine_url(env); end

  def self.secure_request?(env); end
end

module ActionCable::Connection::Identification
  def connection_identifier(); end
end

module ActionCable::Connection::Identification::ClassMethods
  def identified_by(*identifiers); end
end

module ActionCable::Connection::Identification::ClassMethods
  extend ::T::Sig
end

module ActionCable::Connection::Identification
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionCable::Connection::InternalChannel
end

module ActionCable::Connection::InternalChannel
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionCable::Connection::MessageBuffer
  def append(message); end

  def buffered_messages(); end

  def connection(); end

  def initialize(connection); end

  def process!(); end

  def processing?(); end
end

class ActionCable::Connection::MessageBuffer
end

class ActionCable::Connection::Stream
  def close(); end

  def each(&callback); end

  def flush_write_buffer(); end

  def hijack_rack_socket(); end

  def initialize(event_loop, socket); end

  def receive(data); end

  def shutdown(); end

  def write(data); end
end

class ActionCable::Connection::Stream
end

class ActionCable::Connection::StreamEventLoop
  def attach(io, stream); end

  def detach(io, stream); end

  def post(task=T.unsafe(nil), &block); end

  def stop(); end

  def timer(interval, &block); end

  def writes_pending(io); end
end

class ActionCable::Connection::StreamEventLoop
end

class ActionCable::Connection::Subscriptions
  def add(data); end

  def connection(); end

  def execute_command(data); end

  def identifiers(); end

  def initialize(connection); end

  def logger(*args, &block); end

  def perform_action(data); end

  def remove(data); end

  def remove_subscription(subscription); end

  def subscriptions(); end

  def unsubscribe_from_all(); end
end

class ActionCable::Connection::Subscriptions
end

class ActionCable::Connection::TaggedLoggerProxy
  def add_tags(*tags); end

  def debug(message); end

  def error(message); end

  def fatal(message); end

  def info(message); end

  def initialize(logger, tags:); end

  def tag(logger); end

  def tags(); end

  def unknown(message); end

  def warn(message); end
end

class ActionCable::Connection::TaggedLoggerProxy
end

class ActionCable::Connection::WebSocket
  def alive?(); end

  def close(); end

  def initialize(env, event_target, event_loop, protocols: T.unsafe(nil)); end

  def possible?(); end

  def protocol(); end

  def rack_response(); end

  def transmit(data); end

  def websocket(); end
end

class ActionCable::Connection::WebSocket
end

module ActionCable::Connection
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

class ActionCable::Engine
end

class ActionCable::Engine
end

module ActionCable::Helpers
end

module ActionCable::Helpers::ActionCableHelper
  def action_cable_meta_tag(); end
end

module ActionCable::Helpers::ActionCableHelper
  extend ::T::Sig
end

module ActionCable::Helpers
  extend ::T::Sig
end

class ActionCable::RemoteConnections
  def initialize(server); end

  def server(); end

  def where(identifier); end
end

class ActionCable::RemoteConnections::RemoteConnection
  include ::ActionCable::Connection::InternalChannel
  include ::ActionCable::Connection::Identification
  def disconnect(); end

  def identifiers(); end

  def identifiers=(val); end

  def identifiers?(); end

  def initialize(server, ids); end

  def server(); end
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection::InvalidIdentifiersError
end

class ActionCable::RemoteConnections::RemoteConnection
  extend ::ActionCable::Connection::Identification::ClassMethods
  def self.identifiers(); end

  def self.identifiers=(val); end

  def self.identifiers?(); end
end

class ActionCable::RemoteConnections
end

module ActionCable::Server
end

class ActionCable::Server::Base
  include ::ActionCable::Server::Broadcasting
  include ::ActionCable::Server::Connections
  def call(env); end

  def config(); end

  def config=(obj); end

  def connection_identifiers(); end

  def disconnect(identifiers); end

  def event_loop(); end

  def logger(*args, &block); end

  def mutex(); end

  def pubsub(); end

  def remote_connections(); end

  def restart(); end

  def worker_pool(); end
end

class ActionCable::Server::Base
  def self.config(); end

  def self.config=(obj); end

  def self.logger(); end
end

module ActionCable::Server::Broadcasting
  def broadcast(broadcasting, message, coder: T.unsafe(nil)); end

  def broadcaster_for(broadcasting, coder: T.unsafe(nil)); end
end

class ActionCable::Server::Broadcasting::Broadcaster
  def broadcast(message); end

  def broadcasting(); end

  def coder(); end

  def initialize(server, broadcasting, coder:); end

  def server(); end
end

class ActionCable::Server::Broadcasting::Broadcaster
end

module ActionCable::Server::Broadcasting
  extend ::T::Sig
end

class ActionCable::Server::Configuration
  def allow_same_origin_as_host(); end

  def allow_same_origin_as_host=(allow_same_origin_as_host); end

  def allowed_request_origins(); end

  def allowed_request_origins=(allowed_request_origins); end

  def cable(); end

  def cable=(cable); end

  def connection_class(); end

  def connection_class=(connection_class); end

  def disable_request_forgery_protection(); end

  def disable_request_forgery_protection=(disable_request_forgery_protection); end

  def log_tags(); end

  def log_tags=(log_tags); end

  def logger(); end

  def logger=(logger); end

  def mount_path(); end

  def mount_path=(mount_path); end

  def pubsub_adapter(); end

  def url(); end

  def url=(url); end

  def worker_pool_size(); end

  def worker_pool_size=(worker_pool_size); end
end

class ActionCable::Server::Configuration
end

module ActionCable::Server::Connections
  def add_connection(connection); end

  def connections(); end

  def open_connections_statistics(); end

  def remove_connection(connection); end

  def setup_heartbeat_timer(); end
  BEAT_INTERVAL = ::T.let(nil, ::T.untyped)
end

module ActionCable::Server::Connections
  extend ::T::Sig
end

class ActionCable::Server::Worker
  include ::ActiveSupport::Callbacks
  include ::ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def __callbacks(); end

  def __callbacks?(); end

  def _run_work_callbacks(&block); end

  def _work_callbacks(); end

  def async_exec(receiver, *args, connection:, &block); end

  def async_invoke(receiver, method, *args, connection: T.unsafe(nil), &block); end

  def connection(); end

  def connection=(obj); end

  def executor(); end

  def halt(); end

  def initialize(max_size: T.unsafe(nil)); end

  def invoke(receiver, method, *args, connection:, &block); end

  def stopping?(); end

  def work(connection); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  def with_database_connections(); end
end

module ActionCable::Server::Worker::ActiveRecordConnectionManagement
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionCable::Server::Worker
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._work_callbacks(); end

  def self._work_callbacks=(value); end

  def self.connection(); end

  def self.connection=(obj); end
end

module ActionCable::Server
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActionCable::SubscriptionAdapter
end

class ActionCable::SubscriptionAdapter::Base
  def broadcast(channel, payload); end

  def initialize(server); end

  def logger(); end

  def server(); end

  def shutdown(); end

  def subscribe(channel, message_callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, message_callback); end
end

class ActionCable::SubscriptionAdapter::Base
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  def broadcast(channel, payload); end

  def subscribe(channel, callback, success_callback=T.unsafe(nil)); end

  def unsubscribe(channel, callback); end
end

module ActionCable::SubscriptionAdapter::ChannelPrefix
  extend ::T::Sig
end

class ActionCable::SubscriptionAdapter::SubscriberMap
  def add_channel(channel, on_success); end

  def add_subscriber(channel, subscriber, on_success); end

  def broadcast(channel, message); end

  def invoke_callback(callback, message); end

  def remove_channel(channel); end

  def remove_subscriber(channel, subscriber); end
end

class ActionCable::SubscriptionAdapter::SubscriberMap
end

module ActionCable::SubscriptionAdapter
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActionCable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionCable::VERSION
  extend ::T::Sig
end

module ActionCable
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.gem_version(); end

  def self.server(); end

  def self.version(); end
end

module ActionController
end

class ActionController::API
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionController::ApiRendering
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::BasicImplicitRender
  include ::ActiveSupport::Rescuable
  include ::ActionController::StrongParameters
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::ForceSSL
  include ::ActionController::DataStreaming
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionController::RespondWith
  include ::PaperTrail::Rails::Controller
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Raven::Rails::ControllerMethods
  include ::Raven::Rails::ControllerTransaction
  include ::Devise::Controllers::Helpers
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  include ::Devise::Controllers::UrlHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _view_paths(); end

  def _view_paths=(val); end

  def _view_paths?(); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(val); end

  def mimes_for_respond_to?(); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(val); end

  def responder?(); end
  MODULES = ::T.let(nil, ::T.untyped)
end

class ActionController::API
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::ActionController::RespondWith::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._view_paths(); end

  def self._view_paths=(val); end

  def self._view_paths?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(val); end

  def self.mimes_for_respond_to?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(val); end

  def self.responder?(); end

  def self.without_modules(*modules); end
end

class ActionController::ActionControllerError
end

class ActionController::ActionControllerError
end

module ActionController::ApiRendering
  def render_to_body(options=T.unsafe(nil)); end
end

module ActionController::ApiRendering
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionController::BadRequest
  def initialize(msg=T.unsafe(nil)); end
end

class ActionController::BadRequest
end

class ActionController::Base
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::AbstractController::Helpers
  include ::ActionController::Helpers
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionController::Rendering
  include ::ActionController::Renderers
  include ::ActionController::Renderers::All
  include ::ActionController::ConditionalGet
  include ::ActionController::Head
  include ::ActionController::EtagWithTemplateDigest
  include ::ActionController::EtagWithFlash
  include ::ActionController::Caching
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionController::MimeResponds
  include ::ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  include ::ActiveSupport::Rescuable
  include ::ActionController::StrongParameters
  include ::ActionController::ParameterEncoding
  include ::ActionController::Cookies
  include ::ActionController::Flash
  include ::ActionController::FormBuilder
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::ActionController::RequestForgeryProtection
  include ::ActionController::ContentSecurityPolicy
  include ::ActionController::ForceSSL
  include ::ActionController::Streaming
  include ::ActionController::DataStreaming
  include ::ActionController::HttpAuthentication::Basic::ControllerMethods
  include ::ActionController::HttpAuthentication::Digest::ControllerMethods
  include ::ActionController::HttpAuthentication::Token::ControllerMethods
  include ::ActionController::Rescue
  include ::ActionController::Instrumentation
  include ::ActionController::ParamsWrapper
  include ::ActionController::RespondWith
  include ::PaperTrail::Rails::Controller
  include ::CanCan::ControllerAdditions
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::ActiveRecord::Railties::ControllerRuntime
  include ::Raven::Rails::ControllerMethods
  include ::Raven::Rails::ControllerTransaction
  include ::Devise::Controllers::Helpers
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  include ::Devise::Controllers::UrlHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _renderers(); end

  def _renderers=(val); end

  def _renderers?(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def _view_paths(); end

  def _view_paths=(val); end

  def _view_paths?(); end

  def _wrapper_options(); end

  def _wrapper_options=(val); end

  def _wrapper_options?(); end

  def alert(); end

  def allow_forgery_protection(); end

  def allow_forgery_protection=(value); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_protect_from_forgery(); end

  def default_protect_from_forgery=(value); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def etag_with_template_digest(); end

  def etag_with_template_digest=(val); end

  def etag_with_template_digest?(); end

  def etaggers(); end

  def etaggers=(val); end

  def etaggers?(); end

  def flash(*args, &block); end

  def forgery_protection_origin_check(); end

  def forgery_protection_origin_check=(value); end

  def forgery_protection_strategy(); end

  def forgery_protection_strategy=(value); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def helpers_path(); end

  def helpers_path=(val); end

  def helpers_path?(); end

  def include_all_helpers(); end

  def include_all_helpers=(val); end

  def include_all_helpers?(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def log_warning_on_csrf_failure(); end

  def log_warning_on_csrf_failure=(value); end

  def logger(); end

  def logger=(value); end

  def mimes_for_respond_to(); end

  def mimes_for_respond_to=(val); end

  def mimes_for_respond_to?(); end

  def notice(); end

  def per_form_csrf_tokens(); end

  def per_form_csrf_tokens=(value); end

  def perform_caching(); end

  def perform_caching=(value); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def request_forgery_protection_token(); end

  def request_forgery_protection_token=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def responder(); end

  def responder=(val); end

  def responder?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end
  MODULES = ::T.let(nil, ::T.untyped)
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionController::Base
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionController::Helpers::ClassMethods
  extend ::AbstractController::UrlFor::ClassMethods
  extend ::ActionController::Rendering::ClassMethods
  extend ::ActionController::Renderers::ClassMethods
  extend ::ActionController::ConditionalGet::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::ActionController::ParameterEncoding::ClassMethods
  extend ::ActionController::Flash::ClassMethods
  extend ::ActionController::FormBuilder::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::ActionController::RequestForgeryProtection::ClassMethods
  extend ::ActionController::ContentSecurityPolicy::ClassMethods
  extend ::ActionController::ForceSSL::ClassMethods
  extend ::ActionController::Instrumentation::ClassMethods
  extend ::ActionController::ParamsWrapper::ClassMethods
  extend ::Responders::ControllerMethod
  extend ::ActionController::RespondWith::ClassMethods
  extend ::ActionController::Railties::Helpers
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._default_form_builder(); end

  def self._default_form_builder=(val); end

  def self._default_form_builder?(); end

  def self._flash_types(); end

  def self._flash_types=(val); end

  def self._flash_types?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._renderers(); end

  def self._renderers=(val); end

  def self._renderers?(); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self._view_paths(); end

  def self._view_paths=(val); end

  def self._view_paths?(); end

  def self._wrapper_options(); end

  def self._wrapper_options=(val); end

  def self._wrapper_options?(); end

  def self.allow_forgery_protection(); end

  def self.allow_forgery_protection=(value); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_protect_from_forgery(); end

  def self.default_protect_from_forgery=(value); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.etag_with_template_digest(); end

  def self.etag_with_template_digest=(val); end

  def self.etag_with_template_digest?(); end

  def self.etaggers(); end

  def self.etaggers=(val); end

  def self.etaggers?(); end

  def self.forgery_protection_origin_check(); end

  def self.forgery_protection_origin_check=(value); end

  def self.forgery_protection_strategy(); end

  def self.forgery_protection_strategy=(value); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.helpers_path(); end

  def self.helpers_path=(val); end

  def self.helpers_path?(); end

  def self.include_all_helpers(); end

  def self.include_all_helpers=(val); end

  def self.include_all_helpers?(); end

  def self.inherit_resources(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.log_warning_on_csrf_failure(); end

  def self.log_warning_on_csrf_failure=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mimes_for_respond_to(); end

  def self.mimes_for_respond_to=(val); end

  def self.mimes_for_respond_to?(); end

  def self.per_form_csrf_tokens(); end

  def self.per_form_csrf_tokens=(value); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.request_forgery_protection_token(); end

  def self.request_forgery_protection_token=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.responder(); end

  def self.responder=(val); end

  def self.responder?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.without_modules(*modules); end
end

module ActionController::BasicImplicitRender
  def default_render(*args); end

  def send_action(method, *args); end
end

module ActionController::BasicImplicitRender
  extend ::T::Sig
end

module ActionController::Caching
end

module ActionController::Caching
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::ConditionalGet
  include ::ActionController::Head
  def expires_in(seconds, options=T.unsafe(nil)); end

  def expires_now(); end

  def fresh_when(object=T.unsafe(nil), etag: T.unsafe(nil), weak_etag: T.unsafe(nil), strong_etag: T.unsafe(nil), last_modified: T.unsafe(nil), public: T.unsafe(nil), template: T.unsafe(nil)); end

  def http_cache_forever(public: T.unsafe(nil)); end

  def stale?(object=T.unsafe(nil), **freshness_kwargs); end
end

module ActionController::ConditionalGet::ClassMethods
  def etag(&etagger); end
end

module ActionController::ConditionalGet::ClassMethods
  extend ::T::Sig
end

module ActionController::ConditionalGet
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::ContentSecurityPolicy
end

module ActionController::ContentSecurityPolicy::ClassMethods
  def content_security_policy(enabled=T.unsafe(nil), **options, &block); end

  def content_security_policy_report_only(report_only=T.unsafe(nil), **options); end
end

module ActionController::ContentSecurityPolicy::ClassMethods
  extend ::T::Sig
end

module ActionController::ContentSecurityPolicy
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::Cookies
end

module ActionController::Cookies
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::DataStreaming
  DEFAULT_SEND_FILE_DISPOSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SEND_FILE_TYPE = ::T.let(nil, ::T.untyped)
end

module ActionController::DataStreaming
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::EtagWithFlash
end

module ActionController::EtagWithFlash
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::EtagWithTemplateDigest
end

module ActionController::EtagWithTemplateDigest
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::Flash
end

module ActionController::Flash::ClassMethods
  def add_flash_types(*types); end
end

module ActionController::Flash::ClassMethods
  extend ::T::Sig
end

module ActionController::Flash
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::ForceSSL
  def force_ssl_redirect(host_or_options=T.unsafe(nil)); end
  ACTION_OPTIONS = ::T.let(nil, ::T.untyped)
  REDIRECT_OPTIONS = ::T.let(nil, ::T.untyped)
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionController::ForceSSL::ClassMethods
  def force_ssl(options=T.unsafe(nil)); end
end

module ActionController::ForceSSL::ClassMethods
  extend ::T::Sig
end

module ActionController::ForceSSL
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::FormBuilder
  def default_form_builder(); end
end

module ActionController::FormBuilder::ClassMethods
  def default_form_builder(builder); end
end

module ActionController::FormBuilder::ClassMethods
  extend ::T::Sig
end

module ActionController::FormBuilder
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::Head
  def head(status, options=T.unsafe(nil)); end
end

module ActionController::Head
  extend ::T::Sig
end

module ActionController::Helpers
  def helpers(); end
end

module ActionController::Helpers::ClassMethods
  def all_helpers_from_path(path); end

  def helper_attr(*attrs); end

  def helpers(); end

  def modules_for_helpers(args); end
end

module ActionController::Helpers::ClassMethods
  extend ::T::Sig
end

module ActionController::Helpers
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.helpers_path(); end

  def self.helpers_path=(helpers_path); end
end

module ActionController::HttpAuthentication
end

module ActionController::HttpAuthentication::Basic
  def auth_param(request); end

  def auth_scheme(request); end

  def authenticate(request, &login_procedure); end

  def authentication_request(controller, realm, message); end

  def decode_credentials(request); end

  def encode_credentials(user_name, password); end

  def has_basic_credentials?(request); end

  def user_name_and_password(request); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  def authenticate_or_request_with_http_basic(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_basic(&login_procedure); end

  def request_http_basic_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Basic::ControllerMethods
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Basic
  extend ::ActionController::HttpAuthentication::Basic
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Digest
  def authenticate(request, realm, &password_procedure); end

  def authentication_header(controller, realm); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def decode_credentials(header); end

  def decode_credentials_header(request); end

  def encode_credentials(http_method, credentials, password, password_is_ha1); end

  def expected_response(http_method, uri, credentials, password, password_is_ha1=T.unsafe(nil)); end

  def ha1(credentials, password); end

  def nonce(secret_key, time=T.unsafe(nil)); end

  def opaque(secret_key); end

  def secret_token(request); end

  def validate_digest_response(request, realm, &password_procedure); end

  def validate_nonce(secret_key, request, value, seconds_to_timeout=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  def authenticate_or_request_with_http_digest(realm=T.unsafe(nil), message=T.unsafe(nil), &password_procedure); end

  def authenticate_with_http_digest(realm=T.unsafe(nil), &password_procedure); end

  def request_http_digest_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Digest::ControllerMethods
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Digest
  extend ::ActionController::HttpAuthentication::Digest
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Token
  def authenticate(controller, &login_procedure); end

  def authentication_request(controller, realm, message=T.unsafe(nil)); end

  def encode_credentials(token, options=T.unsafe(nil)); end

  def params_array_from(raw_params); end

  def raw_params(auth); end

  def rewrite_param_values(array_params); end

  def token_and_options(request); end

  def token_params_from(auth); end
  AUTHN_PAIR_DELIMITERS = ::T.let(nil, ::T.untyped)
  TOKEN_KEY = ::T.let(nil, ::T.untyped)
  TOKEN_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  def authenticate_or_request_with_http_token(realm=T.unsafe(nil), message=T.unsafe(nil), &login_procedure); end

  def authenticate_with_http_token(&login_procedure); end

  def request_http_token_authentication(realm=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::HttpAuthentication::Token::ControllerMethods
  extend ::T::Sig
end

module ActionController::HttpAuthentication::Token
  extend ::ActionController::HttpAuthentication::Token
  extend ::T::Sig
end

module ActionController::HttpAuthentication
  extend ::T::Sig
end

module ActionController::ImplicitRender
  include ::ActionController::BasicImplicitRender
  def default_render(*args); end

  def method_for_action(action_name); end
end

module ActionController::ImplicitRender
  extend ::T::Sig
end

module ActionController::Instrumentation
  def process_action(*args); end

  def redirect_to(*args); end

  def render(*args); end

  def send_data(data, options=T.unsafe(nil)); end

  def send_file(path, options=T.unsafe(nil)); end

  def view_runtime(); end

  def view_runtime=(view_runtime); end
end

module ActionController::Instrumentation::ClassMethods
  def log_process_action(payload); end
end

module ActionController::Instrumentation::ClassMethods
  extend ::T::Sig
end

module ActionController::Instrumentation
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidAuthenticityToken
end

class ActionController::InvalidCrossOriginRequest
end

class ActionController::InvalidCrossOriginRequest
end

module ActionController::Live
  include ::Raven::Rails::Overrides::StreamingReporter
  def log_error(exception); end

  def new_controller_thread(); end

  def process(name); end

  def response_body=(body); end
end

class ActionController::Live::Buffer
  include ::MonitorMixin
  def call_on_error(); end

  def connected?(); end

  def ignore_disconnect(); end

  def ignore_disconnect=(ignore_disconnect); end

  def initialize(response); end

  def on_error(&block); end
end

class ActionController::Live::Buffer
end

module ActionController::Live::ClassMethods
  def make_response!(request); end
end

module ActionController::Live::ClassMethods
  extend ::T::Sig
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::ClientDisconnected
end

class ActionController::Live::Response
end

class ActionController::Live::Response
end

class ActionController::Live::SSE
  def close(); end

  def initialize(stream, options=T.unsafe(nil)); end

  def write(object, options=T.unsafe(nil)); end
  WHITELISTED_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionController::Live::SSE
end

module ActionController::Live
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionController::LogSubscriber
  def exist_fragment?(event); end

  def expire_fragment(event); end

  def expire_page(event); end

  def halted_callback(event); end

  def process_action(event); end

  def read_fragment(event); end

  def redirect_to(event); end

  def send_data(event); end

  def send_file(event); end

  def start_processing(event); end

  def unpermitted_parameters(event); end

  def write_fragment(event); end

  def write_page(event); end
  INTERNAL_PARAMS = ::T.let(nil, ::T.untyped)
end

class ActionController::LogSubscriber
end

class ActionController::Metal
  include ::Datadog::Contrib::Rails::ActionControllerPatch
  include ::ActionController::Testing::Functional
  include ::Datadog::Contrib::Rails::ActionControllerPatch::ProcessActionPatch
  def content_type(*args, &block); end

  def content_type=(arg); end

  def controller_name(); end

  def dispatch(name, request, response); end

  def headers(*args, &block); end

  def location(*args, &block); end

  def location=(arg); end

  def middleware_stack(); end

  def middleware_stack=(val); end

  def middleware_stack?(); end

  def params(); end

  def params=(val); end

  def request(); end

  def request=(request); end

  def reset_session(); end

  def response(); end

  def response=(response); end

  def response_body=(body); end

  def response_code(*args, &block); end

  def session(*args, &block); end

  def set_request!(request); end

  def set_response!(response); end

  def status(*args, &block); end

  def status=(arg); end

  def to_a(); end

  def url_for(string); end
end

class ActionController::Metal
  def self.action(name); end

  def self.binary_params_for?(action); end

  def self.controller_name(); end

  def self.dispatch(name, req, res); end

  def self.inherited(base); end

  def self.make_response!(request); end

  def self.middleware(); end

  def self.middleware_stack(); end

  def self.middleware_stack=(val); end

  def self.middleware_stack?(); end

  def self.use(*args, &block); end
end

class ActionController::MethodNotAllowed
  def initialize(*allowed_methods); end
end

class ActionController::MethodNotAllowed
end

class ActionController::MiddlewareStack
  def build(action, app=T.unsafe(nil)); end
  EXCLUDE = ::T.let(nil, ::T.untyped)
  INCLUDE = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
end

class ActionController::MiddlewareStack::Middleware
  def initialize(klass, args, actions, strategy, block); end

  def valid?(action); end
end

class ActionController::MiddlewareStack::Middleware
end

class ActionController::MiddlewareStack
end

module ActionController::MimeResponds
  def respond_to(*mimes); end
end

class ActionController::MimeResponds::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime_type, &block); end

  def format(); end

  def format=(format); end

  def initialize(mimes, variant=T.unsafe(nil)); end

  def negotiate_format(request); end

  def response(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
  def all(*args, &block); end

  def any(*args, &block); end

  def initialize(variant=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def variant(); end
end

class ActionController::MimeResponds::Collector::VariantCollector
end

class ActionController::MimeResponds::Collector
end

module ActionController::MimeResponds
  extend ::T::Sig
end

class ActionController::MissingFile
end

class ActionController::MissingFile
end

class ActionController::MissingRenderer
  def initialize(format); end
end

class ActionController::MissingRenderer
end

class ActionController::NotImplemented
end

class ActionController::NotImplemented
end

module ActionController::ParameterEncoding
end

module ActionController::ParameterEncoding::ClassMethods
  def binary_params_for?(action); end

  def inherited(klass); end

  def setup_param_encode(); end

  def skip_parameter_encoding(action); end
end

module ActionController::ParameterEncoding::ClassMethods
  extend ::T::Sig
end

module ActionController::ParameterEncoding
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionController::ParameterMissing
  def initialize(param); end

  def param(); end
end

class ActionController::ParameterMissing
end

class ActionController::Parameters
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def always_permitted_parameters(); end

  def always_permitted_parameters=(obj); end

  def as_json(*args, &block); end

  def converted_arrays(); end

  def delete(key, &block); end

  def delete_if(&block); end

  def dig(*keys); end

  def each(&block); end

  def each_pair(&block); end

  def empty?(*args, &block); end

  def except(*keys); end

  def extract!(*keys); end

  def fetch(key, *args); end

  def fields_for_style?(); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def init_with(coder); end

  def initialize(parameters=T.unsafe(nil)); end

  def keep_if(&block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def merge(other_hash); end

  def merge!(other_hash); end

  def parameters(); end

  def permit(*filters); end

  def permit!(); end

  def permitted=(new_permitted); end

  def permitted?(); end

  def reject(&block); end

  def reject!(&block); end

  def require(key); end

  def required(key); end

  def reverse_merge(other_hash); end

  def reverse_merge!(other_hash); end

  def select(&block); end

  def select!(&block); end

  def slice(*keys); end

  def slice!(*keys); end

  def stringify_keys(); end

  def to_h(); end

  def to_hash(); end

  def to_param(*args); end

  def to_query(*args); end

  def to_s(*args, &block); end

  def to_unsafe_h(); end

  def to_unsafe_hash(); end

  def transform_keys(&block); end

  def transform_keys!(&block); end

  def transform_values(); end

  def transform_values!(); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*keys); end

  def with_defaults(other_hash); end

  def with_defaults!(other_hash); end
  EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  PERMITTED_SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

class ActionController::Parameters
  def self.action_on_unpermitted_parameters(); end

  def self.action_on_unpermitted_parameters=(obj); end

  def self.always_permitted_parameters(); end

  def self.always_permitted_parameters=(obj); end

  def self.hook_into_yaml_loading(); end

  def self.permit_all_parameters(); end

  def self.permit_all_parameters=(obj); end
end

module ActionController::ParamsWrapper
  def process_action(*args); end
  EXCLUDE_PARAMETERS = ::T.let(nil, ::T.untyped)
end

module ActionController::ParamsWrapper::ClassMethods
  def _set_wrapper_options(options); end

  def inherited(klass); end

  def wrap_parameters(name_or_model_or_options, options=T.unsafe(nil)); end
end

module ActionController::ParamsWrapper::ClassMethods
  extend ::T::Sig
end

class ActionController::ParamsWrapper::Options
  include ::Mutex_m
  def initialize(name, format, include, exclude, klass, model); end

  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ActionController::ParamsWrapper::Options
  def self.from_hash(hash); end
end

module ActionController::ParamsWrapper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionController::Railtie
end

class ActionController::Railtie
end

module ActionController::Railties
end

module ActionController::Railties::Helpers
  def inherited(klass); end
end

module ActionController::Railties::Helpers
  extend ::T::Sig
end

module ActionController::Railties
  extend ::T::Sig
end

module ActionController::Redirecting
  def _compute_redirect_to_location(request, options); end

  def redirect_back(fallback_location:, allow_other_host: T.unsafe(nil), **args); end

  def redirect_to(options=T.unsafe(nil), response_status=T.unsafe(nil)); end
end

module ActionController::Redirecting
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self._compute_redirect_to_location(request, options); end
end

class ActionController::RenderError
end

class ActionController::RenderError
end

class ActionController::Renderer
  def controller(); end

  def defaults(); end

  def initialize(controller, env, defaults); end

  def new(env=T.unsafe(nil)); end

  def render(*args); end

  def with_defaults(defaults); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  RACK_KEY_TRANSLATION = ::T.let(nil, ::T.untyped)
  RACK_VALUE_TRANSLATION = ::T.let(nil, ::T.untyped)
end

class ActionController::Renderer
  def self.for(controller, env=T.unsafe(nil), defaults=T.unsafe(nil)); end
end

module ActionController::Renderers
  def _render_to_body_with_renderer(options); end

  def _render_with_renderer_js(js, options); end

  def _render_with_renderer_json(json, options); end

  def _render_with_renderer_xml(xml, options); end

  def render_to_body(options); end
  RENDERERS = ::T.let(nil, ::T.untyped)
end

module ActionController::Renderers::All
end

module ActionController::Renderers::All
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::Renderers::ClassMethods
  def use_renderer(*args); end

  def use_renderers(*args); end
end

module ActionController::Renderers::ClassMethods
  extend ::T::Sig
end

module ActionController::Renderers
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self._render_with_renderer_method_name(key); end

  def self.add(key, &block); end

  def self.remove(key); end
end

module ActionController::Rendering
  def process_action(*_); end

  def render(*args); end

  def render_to_body(options=T.unsafe(nil)); end

  def render_to_string(*_); end
  RENDER_FORMATS_IN_PRIORITY = ::T.let(nil, ::T.untyped)
end

module ActionController::Rendering::ClassMethods
  def inherited(klass); end

  def render(*args, &block); end

  def renderer(); end

  def setup_renderer!(); end
end

module ActionController::Rendering::ClassMethods
  extend ::T::Sig
end

module ActionController::Rendering
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::RequestForgeryProtection
  AUTHENTICITY_TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
  NULL_ORIGIN_MESSAGE = ::T.let(nil, ::T.untyped)
end

module ActionController::RequestForgeryProtection::ClassMethods
  def protect_from_forgery(options=T.unsafe(nil)); end

  def skip_forgery_protection(options=T.unsafe(nil)); end
end

module ActionController::RequestForgeryProtection::ClassMethods
  extend ::T::Sig
end

module ActionController::RequestForgeryProtection::ProtectionMethods
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::Exception
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
  def write(*_); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullCookieJar
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
  def initialize(req); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession::NullSessionHash
end

class ActionController::RequestForgeryProtection::ProtectionMethods::NullSession
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
  def handle_unverified_request(); end

  def initialize(controller); end
end

class ActionController::RequestForgeryProtection::ProtectionMethods::ResetSession
end

module ActionController::RequestForgeryProtection::ProtectionMethods
  extend ::T::Sig
end

module ActionController::RequestForgeryProtection
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::Rescue
  def show_detailed_exceptions?(); end
end

module ActionController::Rescue
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::RespondWith
  def collect_mimes_from_class_level(); end

  def respond_with(*resources, &block); end

  def verify_request_format!(); end

  def verify_requested_format!(); end
end

module ActionController::RespondWith::ClassMethods
  def clear_respond_to(); end

  def respond_to(*mimes); end
end

module ActionController::RespondWith::ClassMethods
  extend ::T::Sig
end

module ActionController::RespondWith
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionController::Responder
  def api_behavior(); end

  def api_location(); end

  def controller(); end

  def default_action(); end

  def default_render(); end

  def delete?(*args, &block); end

  def display(resource, given_options=T.unsafe(nil)); end

  def display_errors(); end

  def format(); end

  def get?(*args, &block); end

  def has_errors?(); end

  def has_renderer?(); end

  def has_view_rendering?(); end

  def head(*args, &block); end

  def initialize(controller, resources, options=T.unsafe(nil)); end

  def json_resource_errors(); end

  def navigation_behavior(error); end

  def navigation_location(); end

  def options(); end

  def patch?(*args, &block); end

  def post?(*args, &block); end

  def put?(*args, &block); end

  def redirect_to(*args, &block); end

  def render(*args, &block); end

  def rendering_options(); end

  def request(); end

  def resource(); end

  def resource_errors(); end

  def resource_location(); end

  def resources(); end

  def respond(); end

  def response_overridden?(); end

  def to_format(); end

  def to_html(); end

  def to_js(); end
  DEFAULT_ACTIONS_FOR_VERBS = ::T.let(nil, ::T.untyped)
end

class ActionController::Responder
  def self.call(*args); end
end

class ActionController::RoutingError
  def failures(); end

  def initialize(message, failures=T.unsafe(nil)); end
end

class ActionController::RoutingError
end

class ActionController::SessionOverflowError
  def initialize(message=T.unsafe(nil)); end
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActionController::SessionOverflowError
end

module ActionController::Streaming
end

module ActionController::Streaming
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::StrongParameters
  def params(); end

  def params=(value); end
end

module ActionController::StrongParameters
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionController::TemplateAssertions
  def assert_template(options=T.unsafe(nil), message=T.unsafe(nil)); end
end

module ActionController::TemplateAssertions
  extend ::T::Sig
end

class ActionController::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def _controller_class(); end

  def _controller_class=(val); end

  def _controller_class?(); end
end

module ActionController::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def build_response(klass); end

  def controller_class_name(); end

  def delete(action, **args); end

  def generated_path(generated_extras); end

  def get(action, **args); end

  def head(action, **args); end

  def patch(action, **args); end

  def post(action, **args); end

  def process(action, method: T.unsafe(nil), params: T.unsafe(nil), session: T.unsafe(nil), body: T.unsafe(nil), flash: T.unsafe(nil), format: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def put(action, **args); end

  def query_parameter_names(generated_extras); end

  def request(); end

  def response(); end

  def setup_controller_request_and_response(); end
end

module ActionController::TestCase::Behavior::ClassMethods
  def controller_class(); end

  def controller_class=(new_class); end

  def determine_default_controller_class(name); end

  def tests(controller_class); end
end

module ActionController::TestCase::Behavior::ClassMethods
  extend ::T::Sig
end

module ActionController::TestCase::Behavior
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionController::TestCase
  extend ::ActionController::TestCase::Behavior::ClassMethods
  def self._controller_class(); end

  def self._controller_class=(val); end

  def self._controller_class?(); end
end

module ActionController::Testing
end

module ActionController::Testing::Functional
  def recycle!(); end
end

module ActionController::Testing::Functional
  extend ::T::Sig
end

module ActionController::Testing
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionController::UnfilteredParameters
  def initialize(); end
end

class ActionController::UnfilteredParameters
end

class ActionController::UnknownFormat
end

class ActionController::UnknownFormat
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnknownHttpMethod
end

class ActionController::UnpermittedParameters
  def initialize(params); end

  def params(); end
end

class ActionController::UnpermittedParameters
end

module ActionController::UrlFor
  def url_options(); end
end

module ActionController::UrlFor
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionController::UrlGenerationError
end

class ActionController::UrlGenerationError
end

module ActionController
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.add_renderer(key, &block); end

  def self.remove_renderer(key); end
end

module ActionDispatch
  def test_app(); end

  def test_app=(obj); end
end

class ActionDispatch::AssertionResponse
  def code(); end

  def code_and_name(); end

  def initialize(code_or_name); end

  def name(); end
  GENERIC_RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::AssertionResponse
end

module ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def html_document(); end
end

module ActionDispatch::Assertions::ResponseAssertions
  def assert_redirected_to(options=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_response(type, message=T.unsafe(nil)); end
  RESPONSE_PREDICATES = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Assertions::ResponseAssertions
  extend ::T::Sig
end

module ActionDispatch::Assertions::RoutingAssertions
  def assert_generates(expected_path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def assert_recognizes(expected_options, path, extras=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_routing(path, options, defaults=T.unsafe(nil), extras=T.unsafe(nil), message=T.unsafe(nil)); end

  def method_missing(selector, *args, &block); end

  def with_routing(); end
end

module ActionDispatch::Assertions::RoutingAssertions
  extend ::T::Sig
end

module ActionDispatch::Assertions
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionDispatch::Callbacks
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _call_callbacks(); end

  def _run_call_callbacks(&block); end

  def call(env); end

  def initialize(app); end
end

class ActionDispatch::Callbacks
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._call_callbacks(); end

  def self._call_callbacks=(value); end

  def self.after(*args, &block); end

  def self.before(*args, &block); end
end

class ActionDispatch::ContentSecurityPolicy
  def base_uri(*sources); end

  def block_all_mixed_content(enabled=T.unsafe(nil)); end

  def build(context=T.unsafe(nil), nonce=T.unsafe(nil)); end

  def child_src(*sources); end

  def connect_src(*sources); end

  def default_src(*sources); end

  def directives(); end

  def font_src(*sources); end

  def form_action(*sources); end

  def frame_ancestors(*sources); end

  def frame_src(*sources); end

  def img_src(*sources); end

  def manifest_src(*sources); end

  def media_src(*sources); end

  def object_src(*sources); end

  def plugin_types(*types); end

  def report_uri(uri); end

  def require_sri_for(*types); end

  def sandbox(*values); end

  def script_src(*sources); end

  def style_src(*sources); end

  def upgrade_insecure_requests(enabled=T.unsafe(nil)); end

  def worker_src(*sources); end
end

class ActionDispatch::ContentSecurityPolicy::Middleware
  def call(env); end

  def initialize(app); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ContentSecurityPolicy::Middleware
end

module ActionDispatch::ContentSecurityPolicy::Request
  def content_security_policy(); end

  def content_security_policy=(policy); end

  def content_security_policy_nonce(); end

  def content_security_policy_nonce_generator(); end

  def content_security_policy_nonce_generator=(generator); end

  def content_security_policy_report_only(); end

  def content_security_policy_report_only=(value); end
  NONCE = ::T.let(nil, ::T.untyped)
  NONCE_GENERATOR = ::T.let(nil, ::T.untyped)
  POLICY = ::T.let(nil, ::T.untyped)
  POLICY_REPORT_ONLY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::ContentSecurityPolicy::Request
  extend ::T::Sig
end

class ActionDispatch::ContentSecurityPolicy
end

class ActionDispatch::Cookies
  def call(env); end

  def initialize(app); end
  AUTHENTICATED_ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  COOKIES_DIGEST = ::T.let(nil, ::T.untyped)
  COOKIES_ROTATIONS = ::T.let(nil, ::T.untyped)
  COOKIES_SERIALIZER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_CIPHER = ::T.let(nil, ::T.untyped)
  ENCRYPTED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  ENCRYPTED_SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  GENERATOR_KEY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
  MAX_COOKIE_SIZE = ::T.let(nil, ::T.untyped)
  SECRET_KEY_BASE = ::T.let(nil, ::T.untyped)
  SECRET_TOKEN = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_DIGEST = ::T.let(nil, ::T.untyped)
  SIGNED_COOKIE_SALT = ::T.let(nil, ::T.untyped)
  USE_AUTHENTICATED_COOKIE_ENCRYPTION = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::AbstractCookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  def [](name); end

  def []=(name, options); end

  def initialize(parent_jar); end

  def request(); end
end

class ActionDispatch::Cookies::AbstractCookieJar
end

module ActionDispatch::Cookies::ChainedCookieJars
  def encrypted(); end

  def permanent(); end

  def signed(); end

  def signed_or_encrypted(); end
end

module ActionDispatch::Cookies::ChainedCookieJars
  extend ::T::Sig
end

class ActionDispatch::Cookies::CookieJar
  include ::ActionDispatch::Cookies::ChainedCookieJars
  include ::Enumerable
  def [](name); end

  def []=(name, options); end

  def always_write_cookie(); end

  def always_write_cookie=(obj); end

  def clear(options=T.unsafe(nil)); end

  def commit!(); end

  def committed?(); end

  def delete(name, options=T.unsafe(nil)); end

  def deleted?(name, options=T.unsafe(nil)); end

  def each(&block); end

  def fetch(name, *args, &block); end

  def handle_options(options); end

  def has_key?(name); end

  def initialize(request); end

  def key?(name); end

  def request(); end

  def to_hash(*_); end

  def to_header(); end

  def update(other_hash); end

  def update_cookies_from_jar(); end

  def write(headers); end
  DOMAIN_REGEXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Cookies::CookieJar
  def self.always_write_cookie(); end

  def self.always_write_cookie=(obj); end

  def self.build(req, cookies); end
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::CookieOverflow
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::EncryptedKeyRotatingCookieJar
end

class ActionDispatch::Cookies::JsonSerializer
end

class ActionDispatch::Cookies::JsonSerializer
  def self.dump(value); end

  def self.load(value); end
end

class ActionDispatch::Cookies::PermanentCookieJar
end

class ActionDispatch::Cookies::PermanentCookieJar
end

module ActionDispatch::Cookies::SerializedCookieJars
  def deserialize(name); end

  def digest(); end

  def needs_migration?(value); end

  def serialize(value); end

  def serializer(); end
  MARSHAL_SIGNATURE = ::T.let(nil, ::T.untyped)
end

ActionDispatch::Cookies::SerializedCookieJars::SERIALIZER = ActiveSupport::MessageEncryptor::NullSerializer

module ActionDispatch::Cookies::SerializedCookieJars
  extend ::T::Sig
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
  include ::ActionDispatch::Cookies::SerializedCookieJars
end

class ActionDispatch::Cookies::SignedKeyRotatingCookieJar
end

class ActionDispatch::Cookies
end

class ActionDispatch::DebugExceptions
  include ::Raven::Rails::Overrides::DebugExceptionsCatcher
  def call(env); end

  def initialize(app, routes_app=T.unsafe(nil), response_format=T.unsafe(nil)); end
  RESCUES_TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::DebugExceptions::DebugView
  def debug_hash(object); end

  def debug_headers(headers); end

  def debug_params(params); end

  def render(*_); end
end

class ActionDispatch::DebugExceptions::DebugView
end

class ActionDispatch::DebugExceptions
end

class ActionDispatch::DebugLocks
  def call(env); end

  def initialize(app, path=T.unsafe(nil)); end
end

class ActionDispatch::DebugLocks
end

class ActionDispatch::ExceptionWrapper
  def application_trace(); end

  def backtrace_cleaner(); end

  def exception(); end

  def file(); end

  def framework_trace(); end

  def full_trace(); end

  def initialize(backtrace_cleaner, exception); end

  def line_number(); end

  def rescue_responses(); end

  def rescue_responses=(obj); end

  def rescue_template(); end

  def rescue_templates(); end

  def rescue_templates=(obj); end

  def source_extracts(); end

  def status_code(); end

  def traces(); end
end

class ActionDispatch::ExceptionWrapper
  def self.rescue_responses(); end

  def self.rescue_responses=(obj); end

  def self.rescue_templates(); end

  def self.rescue_templates=(obj); end

  def self.status_code_for_exception(class_name); end
end

class ActionDispatch::Executor
  def call(env); end

  def initialize(app, executor); end
end

class ActionDispatch::Executor
end

class ActionDispatch::FileHandler
  def call(env); end

  def initialize(root, index: T.unsafe(nil), headers: T.unsafe(nil)); end

  def match?(path); end

  def serve(request); end
end

class ActionDispatch::FileHandler
end

class ActionDispatch::Flash
  KEY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Flash::FlashHash
  include ::Enumerable
  def [](k); end

  def []=(k, v); end

  def alert(); end

  def alert=(message); end

  def clear(); end

  def delete(key); end

  def discard(k=T.unsafe(nil)); end

  def each(&block); end

  def empty?(); end

  def initialize(flashes=T.unsafe(nil), discard=T.unsafe(nil)); end

  def keep(k=T.unsafe(nil)); end

  def key?(name); end

  def keys(); end

  def merge!(h); end

  def notice(); end

  def notice=(message); end

  def now(); end

  def now_is_loaded?(); end

  def replace(h); end

  def sweep(); end

  def to_hash(); end

  def to_session_value(); end

  def update(h); end
end

class ActionDispatch::Flash::FlashHash
  def self.from_session_value(value); end
end

class ActionDispatch::Flash::FlashNow
  def [](k); end

  def []=(k, v); end

  def alert=(message); end

  def flash(); end

  def flash=(flash); end

  def initialize(flash); end

  def notice=(message); end
end

class ActionDispatch::Flash::FlashNow
end

module ActionDispatch::Flash::RequestMethods
  def commit_flash(); end

  def flash(); end

  def flash=(flash); end

  def flash_hash(); end

  def reset_session(); end
end

module ActionDispatch::Flash::RequestMethods
  extend ::T::Sig
end

class ActionDispatch::Flash
  def self.new(app); end
end

module ActionDispatch::Http
end

module ActionDispatch::Http::Cache
end

module ActionDispatch::Http::Cache::Request
  def etag_matches?(etag); end

  def fresh?(response); end

  def if_modified_since(); end

  def if_none_match(); end

  def if_none_match_etags(); end

  def not_modified?(modified_at); end
  HTTP_IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  HTTP_IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Request
  extend ::T::Sig
end

module ActionDispatch::Http::Cache::Response
  def cache_control(); end

  def date(); end

  def date=(utc_time); end

  def date?(); end

  def etag=(weak_validators); end

  def etag?(); end

  def last_modified(); end

  def last_modified=(utc_time); end

  def last_modified?(); end

  def strong_etag=(strong_validators); end

  def strong_etag?(); end

  def weak_etag=(weak_validators); end

  def weak_etag?(); end
  DATE = ::T.let(nil, ::T.untyped)
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  MUST_REVALIDATE = ::T.let(nil, ::T.untyped)
  NO_CACHE = ::T.let(nil, ::T.untyped)
  PRIVATE = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Cache::Response
  extend ::T::Sig
end

module ActionDispatch::Http::Cache
  extend ::T::Sig
end

module ActionDispatch::Http::FilterParameters
  def filtered_env(); end

  def filtered_parameters(); end

  def filtered_path(); end

  def initialize(); end
  ENV_MATCH = ::T.let(nil, ::T.untyped)
  KV_RE = ::T.let(nil, ::T.untyped)
  NULL_ENV_FILTER = ::T.let(nil, ::T.untyped)
  NULL_PARAM_FILTER = ::T.let(nil, ::T.untyped)
  PAIR_RE = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterParameters
  extend ::T::Sig
end

module ActionDispatch::Http::FilterRedirect
  def filtered_location(); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::FilterRedirect
  extend ::T::Sig
end

class ActionDispatch::Http::Headers
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def add(key, value); end

  def each(&block); end

  def env(); end

  def fetch(key, default=T.unsafe(nil)); end

  def include?(key); end

  def initialize(request); end

  def key?(key); end

  def merge(headers_or_env); end

  def merge!(headers_or_env); end
  CGI_VARIABLES = ::T.let(nil, ::T.untyped)
  DEFAULT = ::T.let(nil, ::T.untyped)
  HTTP_HEADER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::Headers
  def self.from_hash(hash); end
end

module ActionDispatch::Http::MimeNegotiation
  def accepts(); end

  def content_mime_type(); end

  def content_type(); end

  def format(view_path=T.unsafe(nil)); end

  def format=(extension); end

  def formats(); end

  def formats=(extensions); end

  def has_content_type?(); end

  def negotiate_mime(order); end

  def variant(); end

  def variant=(variant); end
  BROWSER_LIKE_ACCEPTS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::MimeNegotiation
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionDispatch::Http::ParameterFilter
  def filter(params); end

  def initialize(filters=T.unsafe(nil)); end
  FILTERED = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Http::ParameterFilter::CompiledFilter
  def blocks(); end

  def call(original_params, parents=T.unsafe(nil)); end

  def deep_regexps(); end

  def initialize(regexps, deep_regexps, blocks); end

  def regexps(); end
end

class ActionDispatch::Http::ParameterFilter::CompiledFilter
  def self.compile(filters); end
end

class ActionDispatch::Http::ParameterFilter
end

module ActionDispatch::Http::Parameters
  def parameters(); end

  def params(); end

  def path_parameters(); end

  def path_parameters=(parameters); end
  DEFAULT_PARSERS = ::T.let(nil, ::T.untyped)
  PARAMETERS_KEY = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::Parameters::ClassMethods
  def parameter_parsers=(parsers); end
end

module ActionDispatch::Http::Parameters::ClassMethods
  extend ::T::Sig
end

class ActionDispatch::Http::Parameters::ParseError
  def initialize(); end
end

class ActionDispatch::Http::Parameters::ParseError
end

module ActionDispatch::Http::Parameters
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionDispatch::Http::URL
  def domain(tld_length=T.unsafe(nil)); end

  def host(); end

  def host_with_port(); end

  def initialize(); end

  def optional_port(); end

  def port(); end

  def port_string(); end

  def protocol(); end

  def raw_host_with_port(); end

  def server_port(); end

  def standard_port(); end

  def standard_port?(); end

  def subdomain(tld_length=T.unsafe(nil)); end

  def subdomains(tld_length=T.unsafe(nil)); end

  def tld_length(); end

  def tld_length=(obj); end

  def url(); end
  HOST_REGEXP = ::T.let(nil, ::T.untyped)
  IP_HOST_REGEXP = ::T.let(nil, ::T.untyped)
  PROTOCOL_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Http::URL
  extend ::T::Sig
  def self.extract_domain(host, tld_length); end

  def self.extract_subdomain(host, tld_length); end

  def self.extract_subdomains(host, tld_length); end

  def self.full_url_for(options); end

  def self.path_for(options); end

  def self.tld_length(); end

  def self.tld_length=(obj); end

  def self.url_for(options); end
end

class ActionDispatch::Http::UploadedFile
  def close(unlink_now=T.unsafe(nil)); end

  def content_type(); end

  def content_type=(content_type); end

  def eof?(); end

  def headers(); end

  def headers=(headers); end

  def initialize(hash); end

  def open(); end

  def original_filename(); end

  def original_filename=(original_filename); end

  def path(); end

  def read(length=T.unsafe(nil), buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def tempfile(); end

  def tempfile=(tempfile); end

  def to_io(); end
end

class ActionDispatch::Http::UploadedFile
end

module ActionDispatch::Http
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

class ActionDispatch::IllegalStateError
end

class ActionDispatch::IllegalStateError
end

module ActionDispatch::Integration
end

module ActionDispatch::Integration::RequestHelpers
  def delete(path, **args); end

  def follow_redirect!(); end

  def get(path, **args); end

  def head(path, *args); end

  def patch(path, **args); end

  def post(path, **args); end

  def put(path, **args); end
end

module ActionDispatch::Integration::RequestHelpers
  extend ::T::Sig
end

module ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  def app(); end

  def assigns(*args); end

  def before_setup(); end

  def cookies(*args); end

  def copy_session_variables!(); end

  def create_session(app); end

  def default_url_options(); end

  def default_url_options=(options); end

  def delete(*args); end

  def follow_redirect!(*args); end

  def get(*args); end

  def head(*args); end

  def initialize(*args, &blk); end

  def integration_session(); end

  def open_session(); end

  def patch(*args); end

  def post(*args); end

  def put(*args); end

  def remove!(); end

  def reset!(); end
  APP_SESSIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Integration::Runner
  extend ::T::Sig
end

class ActionDispatch::Integration::Session
  include ::Minitest::Assertions
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionDispatch::Integration::RequestHelpers
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def accept(); end

  def accept=(accept); end

  def body(*args, &block); end

  def controller(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def headers(*args, &block); end

  def host(); end

  def host!(_); end

  def host=(host); end

  def https!(flag=T.unsafe(nil)); end

  def https?(); end

  def initialize(app); end

  def path(*args, &block); end

  def process(method, path, params: T.unsafe(nil), headers: T.unsafe(nil), env: T.unsafe(nil), xhr: T.unsafe(nil), as: T.unsafe(nil)); end

  def redirect?(*args, &block); end

  def remote_addr(); end

  def remote_addr=(remote_addr); end

  def request(); end

  def request_count(); end

  def request_count=(request_count); end

  def reset!(); end

  def response(); end

  def status(*args, &block); end

  def status_message(*args, &block); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Integration::Session
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Integration
  extend ::T::Sig
end

class ActionDispatch::IntegrationTest
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionController::TemplateAssertions
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::ActionDispatch::IntegrationTest::UrlOptions
  include ::ActionMailer::TestCase::ClearTestDeliveries
end

module ActionDispatch::IntegrationTest::Behavior
  include ::ActionDispatch::Integration::Runner
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::ActionController::TemplateAssertions
  def app(); end

  def document_root_element(); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  def app(); end

  def app=(app); end

  def register_encoder(*args); end
end

module ActionDispatch::IntegrationTest::Behavior::ClassMethods
  extend ::T::Sig
end

module ActionDispatch::IntegrationTest::Behavior
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionDispatch::IntegrationTest::UrlOptions
  def url_options(); end
end

module ActionDispatch::IntegrationTest::UrlOptions
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionDispatch::IntegrationTest
  extend ::ActionDispatch::IntegrationTest::Behavior::ClassMethods
end

module ActionDispatch::Journey
end

class ActionDispatch::Journey::Format
  def evaluate(hash); end

  def initialize(parts); end
  ESCAPE_PATH = ::T.let(nil, ::T.untyped)
  ESCAPE_SEGMENT = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Format::Parameter
  def escape(value); end

  def escaper(); end

  def escaper=(_); end

  def name(); end

  def name=(_); end
end

class ActionDispatch::Journey::Format::Parameter
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Journey::Format
  def self.required_path(symbol); end

  def self.required_segment(symbol); end
end

class ActionDispatch::Journey::Formatter
  def clear(); end

  def generate(name, options, path_parameters, parameterize=T.unsafe(nil)); end

  def initialize(routes); end

  def routes(); end
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  DEFAULT_INPUT = ::T.let(nil, ::T.untyped)
  DEFAULT_REGEX = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Journey::Formatter::RegexCaseComparator
  extend ::T::Sig
  def self.===(regex); end
end

class ActionDispatch::Journey::Formatter
end

module ActionDispatch::Journey::GTG
end

class ActionDispatch::Journey::GTG::Builder
  def ast(); end

  def endpoints(); end

  def firstpos(node); end

  def followpos(node); end

  def initialize(root); end

  def lastpos(node); end

  def nullable?(node); end

  def root(); end

  def transition_table(); end
  DUMMY = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::GTG::Builder
end

class ActionDispatch::Journey::GTG::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::GTG::MatchData
end

class ActionDispatch::Journey::GTG::Simulator
  def initialize(transition_table); end

  def memos(string); end

  def tt(); end
end

class ActionDispatch::Journey::GTG::Simulator
end

class ActionDispatch::Journey::GTG::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(from, to, sym); end

  def accepting?(state); end

  def accepting_states(); end

  def add_accepting(state); end

  def add_memo(idx, memo); end

  def eclosure(t); end

  def memo(idx); end

  def memos(); end

  def move(t, a); end

  def states(); end

  def to_svg(); end

  def transitions(); end

  def visualizer(paths, title=T.unsafe(nil)); end
end

class ActionDispatch::Journey::GTG::TransitionTable
end

module ActionDispatch::Journey::GTG
  extend ::T::Sig
end

module ActionDispatch::Journey::NFA
end

class ActionDispatch::Journey::NFA::Builder
  def initialize(ast); end

  def transition_table(); end
end

class ActionDispatch::Journey::NFA::Builder
end

module ActionDispatch::Journey::NFA::Dot
  def to_dot(); end
end

module ActionDispatch::Journey::NFA::Dot
  extend ::T::Sig
end

class ActionDispatch::Journey::NFA::MatchData
  def initialize(memos); end

  def memos(); end
end

class ActionDispatch::Journey::NFA::MatchData
end

class ActionDispatch::Journey::NFA::Simulator
  def =~(string); end

  def initialize(transition_table); end

  def match(string); end

  def simulate(string); end

  def tt(); end
end

class ActionDispatch::Journey::NFA::Simulator
end

class ActionDispatch::Journey::NFA::TransitionTable
  include ::ActionDispatch::Journey::NFA::Dot
  def []=(i, f, s); end

  def accepting(); end

  def accepting=(accepting); end

  def accepting?(state); end

  def accepting_states(); end

  def add_memo(idx, memo); end

  def alphabet(); end

  def eclosure(t); end

  def following_states(t, a); end

  def memo(idx); end

  def memos(); end

  def merge(left, right); end

  def move(t, a); end

  def states(); end

  def transitions(); end
end

class ActionDispatch::Journey::NFA::TransitionTable
end

class ActionDispatch::Journey::NFA::Visitor
  def initialize(tt); end

  def visit_CAT(node); end

  def visit_GROUP(node); end

  def visit_OR(node); end
end

class ActionDispatch::Journey::NFA::Visitor
end

module ActionDispatch::Journey::NFA
  extend ::T::Sig
end

module ActionDispatch::Journey::Nodes
end

class ActionDispatch::Journey::Nodes::Binary
  def children(); end

  def initialize(left, right); end

  def right(); end

  def right=(right); end
end

class ActionDispatch::Journey::Nodes::Binary
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Cat
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dot
end

class ActionDispatch::Journey::Nodes::Dummy
  def initialize(x=T.unsafe(nil)); end
end

class ActionDispatch::Journey::Nodes::Dummy
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Group
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Literal
end

class ActionDispatch::Journey::Nodes::Node
  include ::Enumerable
  def cat?(); end

  def each(&block); end

  def group?(); end

  def initialize(left); end

  def left(); end

  def left=(left); end

  def literal?(); end

  def memo(); end

  def memo=(memo); end

  def name(); end

  def star?(); end

  def symbol?(); end

  def terminal?(); end

  def to_dot(); end

  def to_sym(); end

  def type(); end
end

class ActionDispatch::Journey::Nodes::Node
end

class ActionDispatch::Journey::Nodes::Or
  def children(); end

  def initialize(children); end
end

class ActionDispatch::Journey::Nodes::Or
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Slash
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Star
end

class ActionDispatch::Journey::Nodes::Symbol
  def default_regexp?(); end

  def regexp(); end

  def regexp=(regexp); end
  DEFAULT_EXP = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Nodes::Symbol
end

class ActionDispatch::Journey::Nodes::Terminal
  def symbol(); end
end

class ActionDispatch::Journey::Nodes::Terminal
end

class ActionDispatch::Journey::Nodes::Unary
  def children(); end
end

class ActionDispatch::Journey::Nodes::Unary
end

module ActionDispatch::Journey::Nodes
  extend ::T::Sig
end

class ActionDispatch::Journey::Parser
  include ::ActionDispatch::Journey::Nodes
  def _reduce_1(val, _values); end

  def _reduce_10(val, _values); end

  def _reduce_15(val, _values); end

  def _reduce_16(val, _values); end

  def _reduce_17(val, _values); end

  def _reduce_18(val, _values); end

  def _reduce_2(val, _values); end

  def _reduce_7(val, _values); end

  def _reduce_8(val, _values); end

  def _reduce_9(val, _values); end

  def _reduce_none(val, _values); end

  def parse(string); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Parser
  def self.parse(string); end
end

module ActionDispatch::Journey::Path
end

class ActionDispatch::Journey::Path::Pattern
  def =~(other); end

  def anchored(); end

  def ast(); end

  def build_formatter(); end

  def eager_load!(); end

  def initialize(ast, requirements, separators, anchored); end

  def match(other); end

  def names(); end

  def optional_names(); end

  def required_names(); end

  def requirements(); end

  def source(); end

  def spec(); end

  def to_regexp(); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
  def initialize(separator, matchers); end

  def visit_CAT(node); end

  def visit_DOT(node); end

  def visit_GROUP(node); end

  def visit_LITERAL(node); end

  def visit_OR(node); end

  def visit_SLASH(node); end

  def visit_STAR(node); end

  def visit_SYMBOL(node); end
end

class ActionDispatch::Journey::Path::Pattern::AnchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::MatchData
  def [](x); end

  def captures(); end

  def initialize(names, offsets, match); end

  def length(); end

  def names(); end

  def post_match(); end
end

class ActionDispatch::Journey::Path::Pattern::MatchData
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern::UnanchoredRegexp
end

class ActionDispatch::Journey::Path::Pattern
  def self.build(path, requirements, separators, anchored); end

  def self.from_string(string); end
end

module ActionDispatch::Journey::Path
  extend ::T::Sig
end

class ActionDispatch::Journey::Route
  def app(); end

  def ast(); end

  def conditions(); end

  def constraints(); end

  def defaults(); end

  def dispatcher?(); end

  def eager_load!(); end

  def format(path_options); end

  def glob?(); end

  def initialize(name, app, path, constraints, required_defaults, defaults, request_method_match, precedence, internal=T.unsafe(nil)); end

  def internal(); end

  def ip(); end

  def matches?(request); end

  def name(); end

  def parts(); end

  def path(); end

  def precedence(); end

  def required_default?(key); end

  def required_defaults(); end

  def required_keys(); end

  def required_parts(); end

  def requirements(); end

  def requires_matching_verb?(); end

  def score(supplied_keys); end

  def segment_keys(); end

  def segments(); end

  def verb(); end
end

module ActionDispatch::Journey::Route::VerbMatchers
  VERBS = ::T.let(nil, ::T.untyped)
  VERB_TO_CLASS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Route::VerbMatchers::All
end

class ActionDispatch::Journey::Route::VerbMatchers::All
  def self.call(_); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
end

class ActionDispatch::Journey::Route::VerbMatchers::DELETE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
end

class ActionDispatch::Journey::Route::VerbMatchers::GET
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
end

class ActionDispatch::Journey::Route::VerbMatchers::HEAD
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
end

class ActionDispatch::Journey::Route::VerbMatchers::LINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
end

class ActionDispatch::Journey::Route::VerbMatchers::OPTIONS
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
end

class ActionDispatch::Journey::Route::VerbMatchers::PATCH
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
end

class ActionDispatch::Journey::Route::VerbMatchers::POST
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
end

class ActionDispatch::Journey::Route::VerbMatchers::PUT
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
end

class ActionDispatch::Journey::Route::VerbMatchers::TRACE
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
end

class ActionDispatch::Journey::Route::VerbMatchers::UNLINK
  def self.call(req); end

  def self.verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
  def call(request); end

  def initialize(verb); end

  def verb(); end
end

class ActionDispatch::Journey::Route::VerbMatchers::Unknown
end

module ActionDispatch::Journey::Route::VerbMatchers
  extend ::T::Sig
end

class ActionDispatch::Journey::Route
  def self.build(name, app, path, constraints, required_defaults, defaults); end

  def self.verb_matcher(verb); end
end

class ActionDispatch::Journey::Router
  def eager_load!(); end

  def initialize(routes); end

  def recognize(rails_req); end

  def routes(); end

  def routes=(routes); end

  def serve(req); end

  def visualizer(); end
end

class ActionDispatch::Journey::Router::RoutingError
end

class ActionDispatch::Journey::Router::RoutingError
end

class ActionDispatch::Journey::Router::Utils
  ENCODER = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
  def escape_fragment(fragment); end

  def escape_path(path); end

  def escape_segment(segment); end

  def unescape_uri(uri); end
  ALPHA = ::T.let(nil, ::T.untyped)
  DEC2HEX = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODE = ::T.let(nil, ::T.untyped)
  ESCAPED = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  SEGMENT = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Router::Utils::UriEncoder
end

class ActionDispatch::Journey::Router::Utils
  def self.escape_fragment(fragment); end

  def self.escape_path(path); end

  def self.escape_segment(segment); end

  def self.normalize_path(path); end

  def self.unescape_uri(uri); end
end

class ActionDispatch::Journey::Router
end

class ActionDispatch::Journey::Routes
  include ::Enumerable
  def add_route(name, mapping); end

  def anchored_routes(); end

  def ast(); end

  def clear(); end

  def custom_routes(); end

  def each(&block); end

  def empty?(); end

  def last(); end

  def length(); end

  def partition_route(route); end

  def routes(); end

  def simulator(); end

  def size(); end
end

class ActionDispatch::Journey::Routes
end

class ActionDispatch::Journey::Scanner
  def eos?(); end

  def next_token(); end

  def pos(); end

  def pre_match(); end

  def scan_setup(str); end
end

class ActionDispatch::Journey::Scanner
end

module ActionDispatch::Journey::Visitors
end

class ActionDispatch::Journey::Visitors::Dot
  def accept(node, seed=T.unsafe(nil)); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Dot
end

class ActionDispatch::Journey::Visitors::Each
  def visit(node, block); end
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Each
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FormatBuilder
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
  def accept(node, seed); end

  def binary(node, seed); end

  def nary(node, seed); end

  def terminal(node, seed); end

  def unary(node, seed); end

  def visit(node, seed); end

  def visit_CAT(n, seed); end

  def visit_DOT(n, seed); end

  def visit_GROUP(n, seed); end

  def visit_LITERAL(n, seed); end

  def visit_OR(n, seed); end

  def visit_SLASH(n, seed); end

  def visit_STAR(n, seed); end

  def visit_SYMBOL(n, seed); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::FunctionalVisitor
end

class ActionDispatch::Journey::Visitors::String
  INSTANCE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::String
end

class ActionDispatch::Journey::Visitors::Visitor
  def accept(node); end
  DISPATCH_CACHE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Journey::Visitors::Visitor
end

module ActionDispatch::Journey::Visitors
  extend ::T::Sig
end

module ActionDispatch::Journey
  extend ::T::Sig
end

class ActionDispatch::MiddlewareStack
  include ::Enumerable
  def [](i); end

  def build(app=T.unsafe(nil)); end

  def delete(target); end

  def each(); end

  def initialize(*args); end

  def insert(index, klass, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, klass, *args, &block); end

  def last(); end

  def middlewares(); end

  def middlewares=(middlewares); end

  def size(); end

  def swap(target, *args, &block); end

  def unshift(klass, *args, &block); end

  def use(klass, *args, &block); end
end

class ActionDispatch::MiddlewareStack::Middleware
  def ==(middleware); end

  def args(); end

  def block(); end

  def build(app); end

  def initialize(klass, args, block); end

  def klass(); end

  def name(); end
end

class ActionDispatch::MiddlewareStack::Middleware
end

class ActionDispatch::MiddlewareStack
end

class ActionDispatch::PublicExceptions
  def call(env); end

  def initialize(public_path); end

  def public_path(); end

  def public_path=(public_path); end
end

class ActionDispatch::PublicExceptions
end

class ActionDispatch::Railtie
end

class ActionDispatch::Railtie
end

class ActionDispatch::Reloader
end

class ActionDispatch::Reloader
end

class ActionDispatch::RemoteIp
  def call(env); end

  def check_ip(); end

  def initialize(app, ip_spoofing_check=T.unsafe(nil), custom_proxies=T.unsafe(nil)); end

  def proxies(); end
  TRUSTED_PROXIES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RemoteIp::GetIp
  def calculate_ip(); end

  def initialize(req, check_ip, proxies); end
end

class ActionDispatch::RemoteIp::GetIp
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp::IpSpoofAttackError
end

class ActionDispatch::RemoteIp
end

class ActionDispatch::Request
  include ::Rack::Request::Helpers
  include ::ActionDispatch::Http::Cache::Request
  include ::ActionDispatch::Http::MimeNegotiation
  include ::ActionDispatch::Http::Parameters
  include ::ActionDispatch::Http::FilterParameters
  include ::ActionDispatch::Http::URL
  include ::ActionDispatch::ContentSecurityPolicy::Request
  include ::Rack::Request::Env
  include ::ActionDispatch::Flash::RequestMethods
  def accept(); end

  def accept_charset(); end

  def auth_type(); end

  def authenticated_encrypted_cookie_salt(); end

  def authorization(); end

  def body_stream(); end

  def cache_control(); end

  def client_ip(); end

  def controller_class(); end

  def controller_class_for(name); end

  def controller_instance(); end

  def controller_instance=(controller); end

  def cookie_jar(); end

  def cookie_jar=(jar); end

  def cookies_digest(); end

  def cookies_rotations(); end

  def cookies_serializer(); end

  def encrypted_cookie_cipher(); end

  def encrypted_cookie_salt(); end

  def encrypted_signed_cookie_salt(); end

  def engine_script_name(_routes); end

  def engine_script_name=(name); end

  def from(); end

  def gateway_interface(); end

  def have_cookie_jar?(); end

  def headers(); end

  def http_auth_salt(); end

  def ignore_accept_header(); end

  def ignore_accept_header=(obj); end

  def key?(key); end

  def key_generator(); end

  def local?(); end

  def method(); end

  def method_symbol(); end

  def negotiate(); end

  def origin(); end

  def original_fullpath(); end

  def original_script_name(); end

  def original_url(); end

  def path_translated(); end

  def pragma(); end

  def query_parameters(); end

  def raw_post(); end

  def remote_addr(); end

  def remote_host(); end

  def remote_ident(); end

  def remote_ip(); end

  def remote_ip=(remote_ip); end

  def remote_user(); end

  def request_id(); end

  def request_id=(id); end

  def request_method=(request_method); end

  def request_method_symbol(); end

  def request_parameters(); end

  def request_parameters=(params); end

  def routes(); end

  def routes=(routes); end

  def secret_key_base(); end

  def secret_token(); end

  def send_early_hints(links); end

  def server_addr(); end

  def server_name(); end

  def server_protocol(); end

  def server_software(); end

  def session=(session); end

  def session_options=(options); end

  def show_exceptions?(); end

  def signed_cookie_digest(); end

  def signed_cookie_salt(); end

  def use_authenticated_cookie_encryption(); end

  def uuid(); end

  def version(); end

  def x_csrf_token(); end

  def x_forwarded_for(); end

  def x_forwarded_host(); end

  def x_request_id(); end

  def xml_http_request?(); end
  ACTION_DISPATCH_REQUEST_ID = ::T.let(nil, ::T.untyped)
  ENV_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_LOOKUP = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  RFC2518 = ::T.let(nil, ::T.untyped)
  RFC2616 = ::T.let(nil, ::T.untyped)
  RFC3253 = ::T.let(nil, ::T.untyped)
  RFC3648 = ::T.let(nil, ::T.untyped)
  RFC3744 = ::T.let(nil, ::T.untyped)
  RFC4791 = ::T.let(nil, ::T.untyped)
  RFC5323 = ::T.let(nil, ::T.untyped)
  RFC5789 = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request::PASS_NOT_FOUND
end

class ActionDispatch::Request::PASS_NOT_FOUND
  def self.action(_); end

  def self.binary_params_for?(action); end

  def self.call(_); end
end

class ActionDispatch::Request::Session
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def include?(key); end

  def initialize(by, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(other); end

  def options(); end

  def to_h(); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  ENV_SESSION_KEY = ::T.let(nil, ::T.untyped)
  ENV_SESSION_OPTIONS_KEY = ::T.let(nil, ::T.untyped)
  Unspecified = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Request::Session::Options
  def [](key); end

  def []=(k, v); end

  def id(req); end

  def initialize(by, default_options); end

  def to_hash(); end

  def values_at(*args); end
end

class ActionDispatch::Request::Session::Options
  def self.find(req); end

  def self.set(req, options); end
end

class ActionDispatch::Request::Session
  def self.create(store, req, default_options); end

  def self.find(req); end

  def self.set(req, session); end
end

class ActionDispatch::Request::Utils
  def perform_deep_munge(); end

  def perform_deep_munge=(obj); end
end

class ActionDispatch::Request::Utils::NoNilParamEncoder
end

class ActionDispatch::Request::Utils::NoNilParamEncoder
end

class ActionDispatch::Request::Utils::ParamEncoder
end

class ActionDispatch::Request::Utils::ParamEncoder
  def self.handle_array(params); end

  def self.normalize_encode_params(params); end
end

class ActionDispatch::Request::Utils
  def self.check_param_encoding(params); end

  def self.each_param_value(params, &block); end

  def self.normalize_encode_params(params); end

  def self.perform_deep_munge(); end

  def self.perform_deep_munge=(obj); end
end

class ActionDispatch::Request
  extend ::ActionDispatch::Http::Parameters::ClassMethods
  def self.empty(); end

  def self.ignore_accept_header(); end

  def self.ignore_accept_header=(obj); end

  def self.parameter_parsers(); end
end

class ActionDispatch::RequestId
  def call(env); end

  def initialize(app); end
  X_REQUEST_ID = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::RequestId
end

class ActionDispatch::Response
  include ::Rack::Response::Helpers
  include ::ActionDispatch::Http::FilterRedirect
  include ::ActionDispatch::Http::Cache::Response
  include ::MonitorMixin
  def [](*args, &block); end

  def []=(*args, &block); end

  def _cache_control(); end

  def _cache_control=(v); end

  def abort(); end

  def await_commit(); end

  def await_sent(); end

  def body(); end

  def body=(body); end

  def body_parts(); end

  def charset(); end

  def charset=(charset); end

  def close(); end

  def code(); end

  def commit!(); end

  def committed?(); end

  def content_type=(content_type); end

  def cookies(); end

  def default_charset(); end

  def default_charset=(obj); end

  def default_headers(); end

  def default_headers=(obj); end

  def delete_header(key); end

  def each(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil)); end

  def message(); end

  def prepare!(); end

  def redirect_url(); end

  def request(); end

  def request=(request); end

  def reset_body!(); end

  def response_code(); end

  def send_file(path); end

  def sending!(); end

  def sending?(); end

  def sending_file=(v); end

  def sent!(); end

  def sent?(); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def status_message(); end

  def stream(); end

  def to_a(); end

  def write(string); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  NO_CONTENT_CODES = ::T.let(nil, ::T.untyped)
  NullContentTypeHeader = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Response::Buffer
  def abort(); end

  def body(); end

  def close(); end

  def closed?(); end

  def each(&block); end

  def initialize(response, buf); end

  def write(string); end
end

class ActionDispatch::Response::Buffer
end

class ActionDispatch::Response
  def self.create(status=T.unsafe(nil), header=T.unsafe(nil), body=T.unsafe(nil), default_headers: T.unsafe(nil)); end

  def self.default_charset(); end

  def self.default_charset=(obj); end

  def self.default_headers(); end

  def self.default_headers=(obj); end

  def self.merge_default_headers(original, default); end
end

module ActionDispatch::Routing
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  SEPARATORS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::ConsoleFormatter
  def header(routes); end

  def no_routes(routes); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::ConsoleFormatter
end

class ActionDispatch::Routing::Endpoint
  def app(); end

  def dispatcher?(); end

  def engine?(); end

  def matches?(req); end

  def rack_app(); end

  def redirect?(); end
end

class ActionDispatch::Routing::Endpoint
end

class ActionDispatch::Routing::HtmlTableFormatter
  def header(routes); end

  def initialize(view); end

  def no_routes(*_); end

  def result(); end

  def section(routes); end

  def section_title(title); end
end

class ActionDispatch::Routing::HtmlTableFormatter
end

class ActionDispatch::Routing::Mapper
  include ::ActionDispatch::Routing::Mapper::Base
  include ::ActionDispatch::Routing::Mapper::HttpHelpers
  include ::ActionDispatch::Routing::Redirection
  include ::ActionDispatch::Routing::Mapper::Scoping
  include ::ActionDispatch::Routing::Mapper::Concerns
  include ::ActionDispatch::Routing::Mapper::Resources
  include ::ActionDispatch::Routing::Mapper::CustomUrls
  def as(scope); end

  def authenticate(scope=T.unsafe(nil), block=T.unsafe(nil)); end

  def authenticated(scope=T.unsafe(nil), block=T.unsafe(nil)); end

  def constraints_for(method_to_apply, scope=T.unsafe(nil), block=T.unsafe(nil)); end

  def devise_confirmation(mapping, controllers); end

  def devise_for(*resources); end

  def devise_omniauth_callback(mapping, controllers); end

  def devise_password(mapping, controllers); end

  def devise_registration(mapping, controllers); end

  def devise_scope(scope); end

  def devise_session(mapping, controllers); end

  def devise_unlock(mapping, controllers); end

  def initialize(set); end

  def raise_no_devise_method_error!(klass); end

  def raise_no_secret_key(); end

  def set_omniauth_path_prefix!(path_prefix); end

  def unauthenticated(scope=T.unsafe(nil)); end

  def with_devise_exclusive_scope(new_path, new_as, options); end
  URL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Base
  def default_url_options(options); end

  def default_url_options=(options); end

  def has_named_route?(name); end

  def match(path, options=T.unsafe(nil)); end

  def mount(app, options=T.unsafe(nil)); end

  def with_default_scope(scope, &block); end
end

module ActionDispatch::Routing::Mapper::Base
  extend ::T::Sig
end

module ActionDispatch::Routing::Mapper::Concerns
  def concern(name, callable=T.unsafe(nil), &block); end

  def concerns(*args); end
end

module ActionDispatch::Routing::Mapper::Concerns
  extend ::T::Sig
end

class ActionDispatch::Routing::Mapper::Constraints
  def constraints(); end

  def initialize(app, constraints, strategy); end

  def serve(req); end
  CALL = ::T.let(nil, ::T.untyped)
  SERVE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Constraints
end

module ActionDispatch::Routing::Mapper::CustomUrls
  def direct(name, options=T.unsafe(nil), &block); end

  def resolve(*args, &block); end
end

module ActionDispatch::Routing::Mapper::CustomUrls
  extend ::T::Sig
end

module ActionDispatch::Routing::Mapper::HttpHelpers
  def delete(*args, &block); end

  def get(*args, &block); end

  def patch(*args, &block); end

  def post(*args, &block); end

  def put(*args, &block); end
end

module ActionDispatch::Routing::Mapper::HttpHelpers
  extend ::T::Sig
end

class ActionDispatch::Routing::Mapper::Mapping
  def application(); end

  def ast(); end

  def conditions(); end

  def default_action(); end

  def default_controller(); end

  def defaults(); end

  def initialize(set, ast, defaults, controller, default_action, modyoule, to, formatted, scope_constraints, blocks, via, options_constraints, anchor, options); end

  def make_route(name, precedence); end

  def path(); end

  def required_defaults(); end

  def requirements(); end

  def to(); end
  ANCHOR_CHARACTERS_REGEX = ::T.let(nil, ::T.untyped)
  JOINED_SEPARATORS = ::T.let(nil, ::T.untyped)
  OPTIONAL_FORMAT_REGEX = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Mapping
  def self.build(scope, set, ast, controller, default_action, to, via, formatted, options_constraints, anchor, options); end

  def self.check_via(via); end

  def self.normalize_path(path, format); end

  def self.optional_format?(path, format); end
end

module ActionDispatch::Routing::Mapper::Resources
  def collection(); end

  def match(path, *rest, &block); end

  def member(); end

  def namespace(path, options=T.unsafe(nil)); end

  def nested(); end

  def new(); end

  def resource(*resources, &block); end

  def resources(*resources, &block); end

  def resources_path_names(options); end

  def root(path, options=T.unsafe(nil)); end

  def shallow(); end

  def shallow?(); end
  CANONICAL_ACTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_OPTIONS = ::T.let(nil, ::T.untyped)
  VALID_ON_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Resources::Resource
  def actions(); end

  def collection_name(); end

  def collection_scope(); end

  def controller(); end

  def default_actions(); end

  def initialize(entities, api_only, shallow, options=T.unsafe(nil)); end

  def member_name(); end

  def member_scope(); end

  def name(); end

  def nested_param(); end

  def nested_scope(); end

  def new_scope(new_path); end

  def param(); end

  def path(); end

  def plural(); end

  def resource_scope(); end

  def shallow?(); end

  def shallow_scope(); end

  def singleton?(); end

  def singular(); end
end

class ActionDispatch::Routing::Mapper::Resources::Resource
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
  def initialize(entities, api_only, shallow, options); end
end

class ActionDispatch::Routing::Mapper::Resources::SingletonResource
end

module ActionDispatch::Routing::Mapper::Resources
  extend ::T::Sig
end

class ActionDispatch::Routing::Mapper::Scope
  include ::Enumerable
  def [](key); end

  def action_name(name_prefix, prefix, collection_name, member_name); end

  def each(); end

  def frame(); end

  def initialize(hash, parent=T.unsafe(nil), scope_level=T.unsafe(nil)); end

  def nested?(); end

  def new(hash); end

  def new_level(level); end

  def null?(); end

  def options(); end

  def parent(); end

  def resource_method_scope?(); end

  def resource_scope?(); end

  def resources?(); end

  def root?(); end

  def scope_level(); end
  NULL = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  RESOURCE_METHOD_SCOPES = ::T.let(nil, ::T.untyped)
  RESOURCE_SCOPES = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::Mapper::Scope
end

module ActionDispatch::Routing::Mapper::Scoping
  def constraints(constraints=T.unsafe(nil)); end

  def controller(controller); end

  def defaults(defaults=T.unsafe(nil)); end

  def namespace(path, options=T.unsafe(nil)); end

  def scope(*args); end
  POISON = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::Routing::Mapper::Scoping
  extend ::T::Sig
end

class ActionDispatch::Routing::Mapper
  def self.normalize_name(name); end

  def self.normalize_path(path); end
end

class ActionDispatch::Routing::OptionRedirect
  def options(); end
end

class ActionDispatch::Routing::OptionRedirect
end

class ActionDispatch::Routing::PathRedirect
  URL_PARTS = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::PathRedirect
end

module ActionDispatch::Routing::PolymorphicRoutes
  def edit_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def edit_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_path(record_or_hash, options=T.unsafe(nil)); end

  def new_polymorphic_url(record_or_hash, options=T.unsafe(nil)); end

  def polymorphic_path(record_or_hash_or_array, options=T.unsafe(nil)); end

  def polymorphic_url(record_or_hash_or_array, options=T.unsafe(nil)); end
end

module ActionDispatch::Routing::PolymorphicRoutes
  extend ::T::Sig
end

class ActionDispatch::Routing::Redirect
  def block(); end

  def call(env); end

  def initialize(status, block); end

  def path(params, request); end

  def serve(req); end

  def status(); end
end

class ActionDispatch::Routing::Redirect
end

module ActionDispatch::Routing::Redirection
  def redirect(*args, &block); end
end

module ActionDispatch::Routing::Redirection
  extend ::T::Sig
end

class ActionDispatch::Routing::RouteSet
  include ::Devise::RouteSet
  def add_polymorphic_mapping(klass, options, &block); end

  def add_route(mapping, name); end

  def add_url_helper(name, options, &block); end

  def api_only?(); end

  def append(&block); end

  def call(env); end

  def clear!(); end

  def default_scope(); end

  def default_scope=(default_scope); end

  def default_url_options(); end

  def default_url_options=(default_url_options); end

  def define_mounted_helper(name, script_namer=T.unsafe(nil)); end

  def disable_clear_and_finalize(); end

  def disable_clear_and_finalize=(disable_clear_and_finalize); end

  def eager_load!(); end

  def empty?(); end

  def env_key(); end

  def extra_keys(options, recall=T.unsafe(nil)); end

  def find_relative_url_root(options); end

  def find_script_name(options); end

  def formatter(); end

  def formatter=(formatter); end

  def generate_extras(options, recall=T.unsafe(nil)); end

  def initialize(config=T.unsafe(nil)); end

  def mounted_helpers(); end

  def named_routes(); end

  def named_routes=(named_routes); end

  def optimize_routes_generation?(); end

  def path_for(options, route_name=T.unsafe(nil)); end

  def polymorphic_mappings(); end

  def prepend(&block); end

  def recognize_path(path, environment=T.unsafe(nil)); end

  def recognize_path_with_request(req, path, extras, raise_on_missing: T.unsafe(nil)); end

  def relative_url_root(); end

  def request_class(); end

  def resources_path_names(); end

  def resources_path_names=(resources_path_names); end

  def router(); end

  def router=(router); end

  def routes(); end

  def set(); end

  def set=(set); end

  def url_for(options, route_name=T.unsafe(nil), url_strategy=T.unsafe(nil)); end

  def url_helpers(supports_path=T.unsafe(nil)); end
  DEFAULT_CONFIG = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RESERVED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Config
  def api_only(); end

  def api_only=(_); end

  def relative_url_root(); end

  def relative_url_root=(_); end
end

class ActionDispatch::Routing::RouteSet::Config
  def self.[](*_); end

  def self.members(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
  def block(); end

  def call(t, args, only_path=T.unsafe(nil)); end

  def defaults(); end

  def initialize(name, defaults, &block); end

  def name(); end
end

class ActionDispatch::Routing::RouteSet::CustomUrlHelper
end

class ActionDispatch::Routing::RouteSet::Dispatcher
  def initialize(raise_on_name_error); end

  def serve(req); end
end

class ActionDispatch::Routing::RouteSet::Dispatcher
end

class ActionDispatch::Routing::RouteSet::Generator
  def controller(); end

  def current_controller(); end

  def different_controller?(); end

  def generate(); end

  def initialize(named_route, options, recall, set); end

  def named_route(); end

  def normalize_controller!(); end

  def normalize_controller_action_id!(); end

  def normalize_options!(); end

  def options(); end

  def recall(); end

  def set(); end

  def use_recall_for(key); end

  def use_relative_controller!(); end
  PARAMETERIZE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::Routing::RouteSet::Generator
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  def _artsy_auth(); end

  def _main_app(); end

  def artsy_auth(); end

  def main_app(); end
end

module ActionDispatch::Routing::RouteSet::MountedHelpers
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
  include ::Enumerable
  def [](name); end

  def []=(name, route); end

  def add(name, route); end

  def add_url_helper(name, defaults, &block); end

  def clear(); end

  def clear!(); end

  def each(); end

  def get(name); end

  def helper_names(); end

  def key?(name); end

  def length(); end

  def names(); end

  def path_helpers_module(); end

  def route_defined?(name); end

  def url_helpers_module(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def call(t, args, inner_options); end

  def handle_positional_args(controller_options, inner_options, args, result, path_params); end

  def initialize(route, options, route_name, url_strategy); end

  def route_name(); end

  def url_strategy(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
  def arg_size(); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper::OptimizedUrlHelper
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection::UrlHelper
  def self.create(route, options, route_name, url_strategy); end

  def self.optimize_helper?(route); end
end

class ActionDispatch::Routing::RouteSet::NamedRouteCollection
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
  def initialize(controller_class); end
end

class ActionDispatch::Routing::RouteSet::StaticDispatcher
end

class ActionDispatch::Routing::RouteSet
  def self.default_resources_path_names(); end

  def self.new_with_config(config); end
end

class ActionDispatch::Routing::RouteWrapper
  include ::Sprockets::Rails::RouteWrapper
  def action(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def constraints(); end

  def controller(); end

  def endpoint(); end

  def engine?(); end

  def name(); end

  def path(); end

  def rack_app(); end

  def reqs(); end
end

class ActionDispatch::Routing::RouteWrapper
  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end
end

class ActionDispatch::Routing::RoutesInspector
  def format(formatter, filter=T.unsafe(nil)); end

  def initialize(routes); end
end

class ActionDispatch::Routing::RoutesInspector
end

class ActionDispatch::Routing::RoutesProxy
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def initialize(routes, scope, helpers, script_namer=T.unsafe(nil)); end

  def routes(); end

  def routes=(routes); end

  def scope(); end

  def scope=(scope); end
end

class ActionDispatch::Routing::RoutesProxy
  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end
end

module ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def full_url_for(options=T.unsafe(nil)); end

  def initialize(*_); end

  def optimize_routes_generation?(); end

  def route_for(name, *args); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionDispatch::Routing::UrlFor
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionDispatch::Routing
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

class ActionDispatch::SSL
  def call(env); end

  def initialize(app, redirect: T.unsafe(nil), hsts: T.unsafe(nil), secure_cookies: T.unsafe(nil)); end
  HSTS_EXPIRES_IN = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::SSL
  def self.default_hsts_options(); end
end

module ActionDispatch::Session
end

class ActionDispatch::Session::AbstractStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::AbstractStore
end

class ActionDispatch::Session::CacheStore
  def delete_session(env, sid, options); end

  def write_session(env, sid, session, options); end
end

class ActionDispatch::Session::CacheStore
end

module ActionDispatch::Session::Compatibility
  def generate_sid(); end

  def initialize(app, options=T.unsafe(nil)); end
end

module ActionDispatch::Session::Compatibility
  extend ::T::Sig
end

class ActionDispatch::Session::CookieStore
  def delete_session(req, session_id, options); end

  def load_session(req); end
end

class ActionDispatch::Session::CookieStore
end

class ActionDispatch::Session::MemCacheStore
  include ::ActionDispatch::Session::Compatibility
  include ::ActionDispatch::Session::StaleSessionCheck
  include ::ActionDispatch::Session::SessionObject
end

class ActionDispatch::Session::MemCacheStore
end

module ActionDispatch::Session::SessionObject
  def loaded_session?(session); end

  def prepare_session(req); end
end

module ActionDispatch::Session::SessionObject
  extend ::T::Sig
end

class ActionDispatch::Session::SessionRestoreError
  def initialize(); end
end

class ActionDispatch::Session::SessionRestoreError
end

module ActionDispatch::Session::StaleSessionCheck
  def extract_session_id(env); end

  def load_session(env); end

  def stale_session_check!(); end
end

module ActionDispatch::Session::StaleSessionCheck
  extend ::T::Sig
end

module ActionDispatch::Session
  extend ::T::Sig
end

class ActionDispatch::ShowExceptions
  def call(env); end

  def initialize(app, exceptions_app); end
  FAILSAFE_RESPONSE = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::ShowExceptions
end

class ActionDispatch::Static
  def call(env); end

  def initialize(app, path, index: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class ActionDispatch::Static
end

class ActionDispatch::SystemTestCase
  include ::Capybara::DSL
  include ::Capybara::Minitest::Assertions
  include ::ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  include ::ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  include ::ActionDispatch::SystemTesting::TestHelpers::UndefMethods
end

class ActionDispatch::SystemTestCase
  def self.driven_by(driver, using: T.unsafe(nil), screen_size: T.unsafe(nil), options: T.unsafe(nil)); end

  def self.driver(); end

  def self.driver=(val); end

  def self.driver?(); end

  def self.start_application(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  def take_failed_screenshot(); end

  def take_screenshot(); end
end

module ActionDispatch::SystemTesting::TestHelpers::ScreenshotHelper
  extend ::T::Sig
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end

  def host!(host); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::SystemTesting::TestHelpers::SetupAndTeardown
  extend ::T::Sig
end

module ActionDispatch::SystemTesting::TestHelpers::UndefMethods
  METHODS = ::T.let(nil, ::T.untyped)
end

module ActionDispatch::SystemTesting::TestHelpers::UndefMethods
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def assigns(key=T.unsafe(nil)); end

  def cookies(); end

  def flash(); end

  def redirect_to_url(); end

  def session(); end
end

module ActionDispatch::TestProcess::FixtureFile
  def fixture_file_upload(path, mime_type=T.unsafe(nil), binary=T.unsafe(nil)); end
end

module ActionDispatch::TestProcess::FixtureFile
  extend ::T::Sig
end

module ActionDispatch::TestProcess
  extend ::T::Sig
end

class ActionDispatch::TestRequest
  def accept=(mime_types); end

  def action=(action_name); end

  def host=(host); end

  def if_modified_since=(last_modified); end

  def if_none_match=(etag); end

  def path=(path); end

  def port=(number); end

  def remote_addr=(addr); end

  def request_method=(method); end

  def request_uri=(uri); end

  def user_agent=(user_agent); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class ActionDispatch::TestRequest
  def self.create(env=T.unsafe(nil)); end
end

class ActionDispatch::TestResponse
  def error?(); end

  def initialize(*_); end

  def missing?(); end

  def parsed_body(); end

  def success?(); end
end

class ActionDispatch::TestResponse
  def self.from_response(response); end
end

module ActionDispatch
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.test_app(); end

  def self.test_app=(obj); end
end

class ActionMailer::Base
  include ::ActionMailer::DeliveryMethods
  include ::ActiveSupport::Rescuable
  include ::ActionMailer::Rescuable
  include ::ActionMailer::Parameterized
  include ::ActionMailer::Previews
  include ::ActionView::ViewPaths
  include ::AbstractController::Rendering
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::AbstractController::Helpers
  include ::AbstractController::Translation
  include ::AbstractController::AssetPaths
  include ::ActiveSupport::Callbacks
  include ::AbstractController::Callbacks
  include ::AbstractController::Caching::Fragments
  include ::AbstractController::Caching
  include ::AbstractController::Caching::ConfigMethods
  include ::ActionView::Rendering
  include ::ActionView::Layouts
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  def __callbacks(); end

  def __callbacks?(); end

  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def _process_action_callbacks(); end

  def _run_process_action_callbacks(&block); end

  def _view_cache_dependencies(); end

  def _view_cache_dependencies=(val); end

  def _view_cache_dependencies?(); end

  def _view_paths(); end

  def _view_paths=(val); end

  def _view_paths?(); end

  def asset_host(); end

  def asset_host=(value); end

  def assets_dir(); end

  def assets_dir=(value); end

  def attachments(); end

  def default_asset_host_protocol(); end

  def default_asset_host_protocol=(value); end

  def default_params(); end

  def default_params=(val); end

  def default_params?(); end

  def default_static_extension(); end

  def default_static_extension=(value); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def deliver_later_queue_name(); end

  def deliver_later_queue_name=(obj); end

  def delivery_job(); end

  def delivery_job=(val); end

  def delivery_job?(); end

  def delivery_method(); end

  def delivery_method=(val); end

  def delivery_method?(); end

  def delivery_methods(); end

  def delivery_methods=(val); end

  def delivery_methods?(); end

  def enable_fragment_cache_logging(); end

  def enable_fragment_cache_logging=(value); end

  def file_settings(); end

  def file_settings=(val); end

  def file_settings?(); end

  def fragment_cache_keys(); end

  def fragment_cache_keys=(val); end

  def fragment_cache_keys?(); end

  def headers(args=T.unsafe(nil)); end

  def initialize(); end

  def javascripts_dir(); end

  def javascripts_dir=(value); end

  def logger(); end

  def logger=(value); end

  def mailer_name(); end

  def message(); end

  def message=(message); end

  def params(); end

  def params=(params); end

  def perform_caching(); end

  def perform_caching=(value); end

  def perform_deliveries(); end

  def perform_deliveries=(obj); end

  def preview_interceptors(); end

  def preview_path(); end

  def process(method_name, *args); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(obj); end

  def relative_url_root(); end

  def relative_url_root=(value); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def sendmail_settings(); end

  def sendmail_settings=(val); end

  def sendmail_settings?(); end

  def show_previews(); end

  def smtp_settings(); end

  def smtp_settings=(val); end

  def smtp_settings?(); end

  def stylesheets_dir(); end

  def stylesheets_dir=(value); end

  def test_settings(); end

  def test_settings=(val); end

  def test_settings?(); end
  PROTECTED_IVARS = ::T.let(nil, ::T.untyped)
end

class ActionMailer::Base::LateAttachmentsProxy
  def []=(_name, _content); end

  def inline(); end
end

class ActionMailer::Base::LateAttachmentsProxy
end

class ActionMailer::Base::NullMail
  def body(); end

  def header(); end

  def method_missing(*args); end

  def respond_to?(string, include_all=T.unsafe(nil)); end
end

class ActionMailer::Base::NullMail
end

class ActionMailer::Base
  extend ::ActionMailer::DeliveryMethods::ClassMethods
  extend ::ActionMailer::Rescuable::ClassMethods
  extend ::ActionMailer::Parameterized::ClassMethods
  extend ::ActionMailer::Previews::ClassMethods
  extend ::AbstractController::Helpers::ClassMethods
  extend ::AbstractController::Callbacks::ClassMethods
  extend ::AbstractController::Caching::Fragments::ClassMethods
  extend ::AbstractController::Caching::ClassMethods
  extend ::AbstractController::Caching::ConfigMethods
  extend ::AbstractController::UrlFor::ClassMethods
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self._layout(); end

  def self._layout=(val); end

  def self._layout?(); end

  def self._layout_conditions(); end

  def self._layout_conditions=(val); end

  def self._layout_conditions?(); end

  def self._process_action_callbacks(); end

  def self._process_action_callbacks=(value); end

  def self._view_cache_dependencies(); end

  def self._view_cache_dependencies=(val); end

  def self._view_cache_dependencies?(); end

  def self._view_paths(); end

  def self._view_paths=(val); end

  def self._view_paths?(); end

  def self.asset_host(); end

  def self.asset_host=(value); end

  def self.assets_dir(); end

  def self.assets_dir=(value); end

  def self.default(value=T.unsafe(nil)); end

  def self.default_asset_host_protocol(); end

  def self.default_asset_host_protocol=(value); end

  def self.default_options=(value=T.unsafe(nil)); end

  def self.default_params(); end

  def self.default_params=(val); end

  def self.default_params?(); end

  def self.default_static_extension(); end

  def self.default_static_extension=(value); end

  def self.default_url_options(); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.deliver_later_queue_name(); end

  def self.deliver_later_queue_name=(obj); end

  def self.deliver_mail(mail); end

  def self.delivery_job(); end

  def self.delivery_job=(val); end

  def self.delivery_job?(); end

  def self.delivery_method(); end

  def self.delivery_method=(val); end

  def self.delivery_method?(); end

  def self.delivery_methods(); end

  def self.delivery_methods=(val); end

  def self.delivery_methods?(); end

  def self.enable_fragment_cache_logging(); end

  def self.enable_fragment_cache_logging=(value); end

  def self.file_settings(); end

  def self.file_settings=(val); end

  def self.file_settings?(); end

  def self.fragment_cache_keys(); end

  def self.fragment_cache_keys=(val); end

  def self.fragment_cache_keys?(); end

  def self.javascripts_dir(); end

  def self.javascripts_dir=(value); end

  def self.logger(); end

  def self.logger=(value); end

  def self.mailer_name(); end

  def self.mailer_name=(mailer_name); end

  def self.perform_caching(); end

  def self.perform_caching=(value); end

  def self.perform_deliveries(); end

  def self.perform_deliveries=(obj); end

  def self.preview_interceptors(); end

  def self.preview_interceptors=(obj); end

  def self.preview_path(); end

  def self.preview_path=(obj); end

  def self.raise_delivery_errors(); end

  def self.raise_delivery_errors=(obj); end

  def self.receive(raw_mail); end

  def self.register_interceptor(interceptor); end

  def self.register_interceptors(*interceptors); end

  def self.register_observer(observer); end

  def self.register_observers(*observers); end

  def self.relative_url_root(); end

  def self.relative_url_root=(value); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end

  def self.sendmail_settings(); end

  def self.sendmail_settings=(val); end

  def self.sendmail_settings?(); end

  def self.show_previews(); end

  def self.show_previews=(obj); end

  def self.smtp_settings(); end

  def self.smtp_settings=(val); end

  def self.smtp_settings?(); end

  def self.stylesheets_dir(); end

  def self.stylesheets_dir=(value); end

  def self.test_settings(); end

  def self.test_settings=(val); end

  def self.test_settings?(); end
end

class ActionMailer::Collector
  include ::AbstractController::Collector
  def all(*args, &block); end

  def any(*args, &block); end

  def custom(mime, options=T.unsafe(nil)); end

  def initialize(context, &block); end

  def responses(); end
end

class ActionMailer::Collector
end

class ActionMailer::DeliveryJob
  def perform(mailer, mail_method, delivery_method, *args); end
end

class ActionMailer::DeliveryJob
end

module ActionMailer::DeliveryMethods
  def wrap_delivery_behavior!(*args); end
end

module ActionMailer::DeliveryMethods::ClassMethods
  def add_delivery_method(symbol, klass, default_options=T.unsafe(nil)); end

  def deliveries(*args, &block); end

  def deliveries=(arg); end

  def wrap_delivery_behavior(mail, method=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionMailer::DeliveryMethods::ClassMethods
  extend ::T::Sig
end

module ActionMailer::DeliveryMethods
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionMailer::InlinePreviewInterceptor
  include ::Base64
  def initialize(message); end

  def transform!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionMailer::InlinePreviewInterceptor
  def self.previewing_email(message); end
end

class ActionMailer::LogSubscriber
  def deliver(event); end

  def process(event); end

  def receive(event); end
end

class ActionMailer::LogSubscriber
end

module ActionMailer::MailHelper
  def attachments(); end

  def block_format(text); end

  def format_paragraph(text, len=T.unsafe(nil), indent=T.unsafe(nil)); end

  def mailer(); end

  def message(); end
end

module ActionMailer::MailHelper
  extend ::T::Sig
end

class ActionMailer::MessageDelivery
  def __setobj__(mail_message); end

  def deliver_later(options=T.unsafe(nil)); end

  def deliver_later!(options=T.unsafe(nil)); end

  def deliver_now(); end

  def deliver_now!(); end

  def initialize(mailer_class, action, *args); end

  def message(); end

  def processed?(); end
end

class ActionMailer::MessageDelivery
end

class ActionMailer::NonInferrableMailerError
  def initialize(name); end
end

class ActionMailer::NonInferrableMailerError
end

module ActionMailer::Parameterized
end

module ActionMailer::Parameterized::ClassMethods
  def with(params); end
end

module ActionMailer::Parameterized::ClassMethods
  extend ::T::Sig
end

class ActionMailer::Parameterized::DeliveryJob
  def perform(mailer, mail_method, delivery_method, params, *args); end
end

class ActionMailer::Parameterized::DeliveryJob
end

class ActionMailer::Parameterized::Mailer
  def initialize(mailer, params); end
end

class ActionMailer::Parameterized::Mailer
end

class ActionMailer::Parameterized::MessageDelivery
  def initialize(mailer_class, action, params, *args); end
end

class ActionMailer::Parameterized::MessageDelivery
end

module ActionMailer::Parameterized
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionMailer::Preview
  def initialize(params=T.unsafe(nil)); end

  def params(); end
end

class ActionMailer::Preview
  extend ::ActiveSupport::DescendantsTracker
  def self.all(); end

  def self.call(email, params=T.unsafe(nil)); end

  def self.email_exists?(email); end

  def self.emails(); end

  def self.exists?(preview); end

  def self.find(preview); end

  def self.preview_name(); end
end

module ActionMailer::Previews
end

module ActionMailer::Previews::ClassMethods
  def register_preview_interceptor(interceptor); end

  def register_preview_interceptors(*interceptors); end
end

module ActionMailer::Previews::ClassMethods
  extend ::T::Sig
end

module ActionMailer::Previews
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionMailer::Railtie
end

class ActionMailer::Railtie
end

module ActionMailer::Rescuable
  def handle_exceptions(); end
end

module ActionMailer::Rescuable::ClassMethods
  def handle_exception(exception); end
end

module ActionMailer::Rescuable::ClassMethods
  extend ::T::Sig
end

module ActionMailer::Rescuable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionMailer::TestCase
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  def _mailer_class(); end

  def _mailer_class=(val); end

  def _mailer_class?(); end
end

module ActionMailer::TestCase::Behavior
  include ::ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::Rails::Dom::Testing::Assertions::DomAssertions
end

module ActionMailer::TestCase::Behavior::ClassMethods
  def determine_default_mailer(name); end

  def mailer_class(); end

  def tests(mailer); end
end

module ActionMailer::TestCase::Behavior::ClassMethods
  extend ::T::Sig
end

module ActionMailer::TestCase::Behavior
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionMailer::TestCase::ClearTestDeliveries
end

module ActionMailer::TestCase::ClearTestDeliveries
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionMailer::TestCase
  extend ::ActionMailer::TestCase::Behavior::ClassMethods
  def self._mailer_class(); end

  def self._mailer_class=(val); end

  def self._mailer_class?(); end
end

module ActionMailer::TestHelper
  include ::ActiveJob::TestHelper
  def assert_emails(number); end

  def assert_enqueued_email_with(mailer, method, args: T.unsafe(nil), queue: T.unsafe(nil), &block); end

  def assert_enqueued_emails(number, &block); end

  def assert_no_emails(&block); end

  def assert_no_enqueued_emails(&block); end
end

module ActionMailer::TestHelper
  extend ::T::Sig
end

module ActionMailer::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionMailer::VERSION
  extend ::T::Sig
end

module ActionMailer
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.gem_version(); end

  def self.version(); end
end

module ActionPack
end

module ActionPack::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionPack::VERSION
  extend ::T::Sig
end

module ActionPack
  extend ::T::Sig
  def self.gem_version(); end

  def self.version(); end
end

module ActionView
  ENCODING_FLAG = ::T.let(nil, ::T.untyped)
end

class ActionView::AbstractRenderer
  def any_templates?(*args, &block); end

  def find_file(*args, &block); end

  def find_template(*args, &block); end

  def formats(*args, &block); end

  def initialize(lookup_context); end

  def render(); end

  def template_exists?(*args, &block); end

  def with_fallbacks(*args, &block); end

  def with_layout_format(*args, &block); end
end

class ActionView::AbstractRenderer
end

class ActionView::ActionViewError
end

class ActionView::ActionViewError
end

class ActionView::Base
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ERB::Util
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::Kaminari::Helpers::HelperMethods
  include ::ActionCable::Helpers::ActionCableHelper
  include ::Formtastic::Helpers::FormHelper
  include ::Devise::Controllers::UrlHelpers
  include ::Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RecordTagHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::Sprockets::Rails::Utils
  def _routes(); end

  def _routes=(val); end

  def _routes?(); end

  def assets_environment(); end

  def assets_environment=(val); end

  def assets_environment?(); end

  def assets_manifest(); end

  def assets_manifest=(val); end

  def assets_manifest?(); end

  def assets_precompile(); end

  def assets_precompile=(val); end

  def assets_precompile?(); end

  def assets_prefix(); end

  def assets_prefix=(val); end

  def assets_prefix?(); end

  def assign(new_assigns); end

  def assigns(); end

  def assigns=(assigns); end

  def automatically_disable_submit_tag(); end

  def automatically_disable_submit_tag=(obj); end

  def check_precompiled_asset(); end

  def check_precompiled_asset=(val); end

  def check_precompiled_asset?(); end

  def config(); end

  def config=(config); end

  def debug_assets(); end

  def debug_assets=(val); end

  def debug_assets?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end

  def default_formats(); end

  def default_formats=(obj); end

  def digest_assets(); end

  def digest_assets=(val); end

  def digest_assets?(); end

  def field_error_proc(); end

  def field_error_proc=(obj); end

  def formats(*args, &block); end

  def formats=(arg); end

  def initialize(context=T.unsafe(nil), assigns=T.unsafe(nil), controller=T.unsafe(nil), formats=T.unsafe(nil)); end

  def locale(*args, &block); end

  def locale=(arg); end

  def logger=(val); end

  def logger?(); end

  def lookup_context(*args, &block); end

  def precompiled_asset_checker(); end

  def precompiled_asset_checker=(val); end

  def precompiled_asset_checker?(); end

  def prefix_partial_path_with_controller_namespace(); end

  def prefix_partial_path_with_controller_namespace=(obj); end

  def raise_on_missing_translations(); end

  def raise_on_missing_translations=(obj); end

  def resolve_assets_with(); end

  def resolve_assets_with=(val); end

  def resolve_assets_with?(); end

  def streaming_completion_on_exception(); end

  def streaming_completion_on_exception=(obj); end

  def unknown_asset_fallback(); end

  def unknown_asset_fallback=(val); end

  def unknown_asset_fallback?(); end

  def view_paths(*args, &block); end

  def view_paths=(arg); end

  def view_renderer(); end

  def view_renderer=(view_renderer); end
end

class ActionView::Base
  def self._routes(); end

  def self._routes=(val); end

  def self._routes?(); end

  def self.assets_environment(); end

  def self.assets_environment=(val); end

  def self.assets_environment?(); end

  def self.assets_manifest(); end

  def self.assets_manifest=(val); end

  def self.assets_manifest?(); end

  def self.assets_precompile(); end

  def self.assets_precompile=(val); end

  def self.assets_precompile?(); end

  def self.assets_prefix(); end

  def self.assets_prefix=(val); end

  def self.assets_prefix?(); end

  def self.automatically_disable_submit_tag(); end

  def self.automatically_disable_submit_tag=(obj); end

  def self.cache_template_loading(); end

  def self.cache_template_loading=(value); end

  def self.check_precompiled_asset(); end

  def self.check_precompiled_asset=(val); end

  def self.check_precompiled_asset?(); end

  def self.debug_assets(); end

  def self.debug_assets=(val); end

  def self.debug_assets?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end

  def self.default_form_builder(); end

  def self.default_form_builder=(obj); end

  def self.default_formats(); end

  def self.default_formats=(obj); end

  def self.digest_assets(); end

  def self.digest_assets=(val); end

  def self.digest_assets?(); end

  def self.erb_trim_mode=(arg); end

  def self.field_error_proc(); end

  def self.field_error_proc=(obj); end

  def self.logger(); end

  def self.logger=(val); end

  def self.logger?(); end

  def self.precompiled_asset_checker(); end

  def self.precompiled_asset_checker=(val); end

  def self.precompiled_asset_checker?(); end

  def self.prefix_partial_path_with_controller_namespace(); end

  def self.prefix_partial_path_with_controller_namespace=(obj); end

  def self.raise_on_missing_translations(); end

  def self.raise_on_missing_translations=(obj); end

  def self.resolve_assets_with(); end

  def self.resolve_assets_with=(val); end

  def self.resolve_assets_with?(); end

  def self.streaming_completion_on_exception(); end

  def self.streaming_completion_on_exception=(obj); end

  def self.unknown_asset_fallback(); end

  def self.unknown_asset_fallback=(val); end

  def self.unknown_asset_fallback?(); end

  def self.xss_safe?(); end
end

module ActionView::CollectionCaching
end

module ActionView::CollectionCaching
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionView::CompiledTemplates
end

module ActionView::CompiledTemplates
  extend ::T::Sig
end

module ActionView::Context
  include ::ActionView::CompiledTemplates
  def _layout_for(name=T.unsafe(nil)); end

  def _prepare_context(); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def view_flow(); end

  def view_flow=(view_flow); end
end

module ActionView::Context
  extend ::T::Sig
end

class ActionView::DependencyTracker
end

class ActionView::DependencyTracker::ERBTracker
  def dependencies(); end

  def initialize(name, template, view_paths=T.unsafe(nil)); end
  EXPLICIT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  IDENTIFIER = ::T.let(nil, ::T.untyped)
  LAYOUT_DEPENDENCY = ::T.let(nil, ::T.untyped)
  LAYOUT_HASH_KEY = ::T.let(nil, ::T.untyped)
  PARTIAL_HASH_KEY = ::T.let(nil, ::T.untyped)
  RENDER_ARGUMENTS = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  VARIABLE_OR_METHOD_CHAIN = ::T.let(nil, ::T.untyped)
end

class ActionView::DependencyTracker::ERBTracker
  def self.call(name, template, view_paths=T.unsafe(nil)); end

  def self.supports_view_paths?(); end
end

class ActionView::DependencyTracker
  def self.find_dependencies(name, template, view_paths=T.unsafe(nil)); end

  def self.register_tracker(extension, tracker); end

  def self.remove_tracker(handler); end
end

class ActionView::Digestor
end

class ActionView::Digestor::Injected
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Injected
end

class ActionView::Digestor::Missing
  def digest(finder, _=T.unsafe(nil)); end
end

class ActionView::Digestor::Missing
end

class ActionView::Digestor::Node
  def children(); end

  def dependency_digest(finder, stack); end

  def digest(finder, stack=T.unsafe(nil)); end

  def initialize(name, logical_name, template, children=T.unsafe(nil)); end

  def logical_name(); end

  def name(); end

  def template(); end

  def to_dep_map(); end
end

class ActionView::Digestor::Node
  def self.create(name, logical_name, template, partial); end
end

class ActionView::Digestor::NullLogger
end

class ActionView::Digestor::NullLogger
  def self.debug(_); end

  def self.error(_); end
end

class ActionView::Digestor::Partial
end

class ActionView::Digestor::Partial
end

module ActionView::Digestor::PerExecutionDigestCacheExpiry
end

module ActionView::Digestor::PerExecutionDigestCacheExpiry
  extend ::T::Sig
  def self.before(target); end
end

class ActionView::Digestor
  def self.digest(name:, finder:, dependencies: T.unsafe(nil)); end

  def self.logger(); end

  def self.tree(name, finder, partial=T.unsafe(nil), seen=T.unsafe(nil)); end
end

class ActionView::EncodingError
end

class ActionView::EncodingError
end

class ActionView::FallbackFileSystemResolver
  def decorate(*_); end
end

class ActionView::FallbackFileSystemResolver
  def self.instances(); end
end

class ActionView::FileSystemResolver
  def ==(resolver); end

  def eql?(resolver); end

  def initialize(path, pattern=T.unsafe(nil)); end

  def to_path(); end
end

class ActionView::FileSystemResolver
end

module ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RecordTagHelper
  include ::ActionView::Helpers::RenderingHelper
end

module ActionView::Helpers::ActiveModelHelper
end

module ActionView::Helpers::ActiveModelHelper
  extend ::T::Sig
end

module ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def audio_tag(*sources); end

  def auto_discovery_link_tag(type=T.unsafe(nil), url_options=T.unsafe(nil), tag_options=T.unsafe(nil)); end

  def favicon_link_tag(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_alt(src); end

  def image_tag(source, options=T.unsafe(nil)); end

  def javascript_include_tag(*sources); end

  def preload_link_tag(source, options=T.unsafe(nil)); end

  def stylesheet_link_tag(*sources); end

  def video_tag(*sources); end
end

module ActionView::Helpers::AssetTagHelper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionView::Helpers::AssetUrlHelper
  def asset_path(source, options=T.unsafe(nil)); end

  def asset_url(source, options=T.unsafe(nil)); end

  def audio_path(source, options=T.unsafe(nil)); end

  def audio_url(source, options=T.unsafe(nil)); end

  def compute_asset_extname(source, options=T.unsafe(nil)); end

  def compute_asset_host(source=T.unsafe(nil), options=T.unsafe(nil)); end

  def compute_asset_path(source, options=T.unsafe(nil)); end

  def font_path(source, options=T.unsafe(nil)); end

  def font_url(source, options=T.unsafe(nil)); end

  def image_path(source, options=T.unsafe(nil)); end

  def image_url(source, options=T.unsafe(nil)); end

  def javascript_path(source, options=T.unsafe(nil)); end

  def javascript_url(source, options=T.unsafe(nil)); end

  def path_to_asset(source, options=T.unsafe(nil)); end

  def path_to_audio(source, options=T.unsafe(nil)); end

  def path_to_font(source, options=T.unsafe(nil)); end

  def path_to_image(source, options=T.unsafe(nil)); end

  def path_to_javascript(source, options=T.unsafe(nil)); end

  def path_to_stylesheet(source, options=T.unsafe(nil)); end

  def path_to_video(source, options=T.unsafe(nil)); end

  def public_compute_asset_path(source, options=T.unsafe(nil)); end

  def stylesheet_path(source, options=T.unsafe(nil)); end

  def stylesheet_url(source, options=T.unsafe(nil)); end

  def url_to_asset(source, options=T.unsafe(nil)); end

  def url_to_audio(source, options=T.unsafe(nil)); end

  def url_to_font(source, options=T.unsafe(nil)); end

  def url_to_image(source, options=T.unsafe(nil)); end

  def url_to_javascript(source, options=T.unsafe(nil)); end

  def url_to_stylesheet(source, options=T.unsafe(nil)); end

  def url_to_video(source, options=T.unsafe(nil)); end

  def video_path(source, options=T.unsafe(nil)); end

  def video_url(source, options=T.unsafe(nil)); end
  ASSET_EXTENSIONS = ::T.let(nil, ::T.untyped)
  ASSET_PUBLIC_DIRECTORIES = ::T.let(nil, ::T.untyped)
  URI_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::AssetUrlHelper
  extend ::T::Sig
end

module ActionView::Helpers::AtomFeedHelper
  def atom_feed(options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::AtomFeedHelper
  extend ::T::Sig
end

module ActionView::Helpers::CacheHelper
  def cache(name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_fragment_name(name=T.unsafe(nil), skip_digest: T.unsafe(nil), virtual_path: T.unsafe(nil)); end

  def cache_if(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cache_unless(condition, name=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module ActionView::Helpers::CacheHelper
  extend ::T::Sig
end

module ActionView::Helpers::CaptureHelper
  def capture(*args); end

  def content_for(name, content=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def content_for?(name); end

  def provide(name, content=T.unsafe(nil), &block); end

  def with_output_buffer(buf=T.unsafe(nil)); end
end

module ActionView::Helpers::CaptureHelper
  extend ::T::Sig
end

module ActionView::Helpers::ControllerHelper
  def action_name(*args, &block); end

  def assign_controller(controller); end

  def controller(); end

  def controller=(controller); end

  def controller_name(*args, &block); end

  def controller_path(*args, &block); end

  def cookies(*args, &block); end

  def flash(*args, &block); end

  def headers(*args, &block); end

  def logger(); end

  def params(*args, &block); end

  def request(); end

  def request=(request); end

  def request_forgery_protection_token(*args, &block); end

  def respond_to?(method_name, include_private=T.unsafe(nil)); end

  def response(*args, &block); end

  def session(*args, &block); end
  CONTROLLER_DELEGATES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::ControllerHelper
  extend ::T::Sig
end

module ActionView::Helpers::CspHelper
  def csp_meta_tag(); end
end

module ActionView::Helpers::CspHelper
  extend ::T::Sig
end

module ActionView::Helpers::CsrfHelper
  def csrf_meta_tag(); end

  def csrf_meta_tags(); end
end

module ActionView::Helpers::CsrfHelper
  extend ::T::Sig
end

module ActionView::Helpers::DateHelper
  def date_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def distance_of_time_in_words(from_time, to_time=T.unsafe(nil), options=T.unsafe(nil)); end

  def distance_of_time_in_words_to_now(from_time, options=T.unsafe(nil)); end

  def select_date(date=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_datetime(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_day(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_hour(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_minute(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_month(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_second(datetime, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_time(datetime=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def select_year(date, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_ago_in_words(from_time, options=T.unsafe(nil)); end

  def time_select(object_name, method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_tag(date_or_time, *args, &block); end
  MINUTES_IN_QUARTER_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_THREE_QUARTERS_YEAR = ::T.let(nil, ::T.untyped)
  MINUTES_IN_YEAR = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::DateHelper
  extend ::T::Sig
end

module ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def debug(object); end
end

module ActionView::Helpers::DebugHelper
  extend ::T::Sig
end

class ActionView::Helpers::FormBuilder
  include ::ActionView::ModelNaming
  def button(value=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box(method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def collection_check_boxes(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def color_field(method, options=T.unsafe(nil)); end

  def date_field(method, options=T.unsafe(nil)); end

  def date_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def datetime_field(method, options=T.unsafe(nil)); end

  def datetime_local_field(method, options=T.unsafe(nil)); end

  def datetime_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def email_field(method, options=T.unsafe(nil)); end

  def emitted_hidden_id?(); end

  def field_helpers(); end

  def field_helpers=(val); end

  def field_helpers?(); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), fields_options=T.unsafe(nil), &block); end

  def file_field(method, options=T.unsafe(nil)); end

  def grouped_collection_select(method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def hidden_field(method, options=T.unsafe(nil)); end

  def index(); end

  def initialize(object_name, object, template, options); end

  def label(method, text=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(method, options=T.unsafe(nil)); end

  def multipart(); end

  def multipart=(multipart); end

  def multipart?(); end

  def number_field(method, options=T.unsafe(nil)); end

  def object(); end

  def object=(object); end

  def object_name(); end

  def object_name=(object_name); end

  def options(); end

  def options=(options); end

  def password_field(method, options=T.unsafe(nil)); end

  def phone_field(method, options=T.unsafe(nil)); end

  def radio_button(method, tag_value, options=T.unsafe(nil)); end

  def range_field(method, options=T.unsafe(nil)); end

  def search_field(method, options=T.unsafe(nil)); end

  def select(method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def submit(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field(method, options=T.unsafe(nil)); end

  def text_area(method, options=T.unsafe(nil)); end

  def text_field(method, options=T.unsafe(nil)); end

  def time_field(method, options=T.unsafe(nil)); end

  def time_select(method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def time_zone_select(method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def to_model(); end

  def to_partial_path(); end

  def url_field(method, options=T.unsafe(nil)); end

  def week_field(method, options=T.unsafe(nil)); end
end

class ActionView::Helpers::FormBuilder
  def self._to_partial_path(); end

  def self.field_helpers(); end

  def self.field_helpers=(val); end

  def self.field_helpers?(); end
end

module ActionView::Helpers::FormHelper
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def check_box(object_name, method, options=T.unsafe(nil), checked_value=T.unsafe(nil), unchecked_value=T.unsafe(nil)); end

  def color_field(object_name, method, options=T.unsafe(nil)); end

  def date_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_field(object_name, method, options=T.unsafe(nil)); end

  def datetime_local_field(object_name, method, options=T.unsafe(nil)); end

  def default_form_builder(); end

  def default_form_builder=(default_form_builder); end

  def email_field(object_name, method, options=T.unsafe(nil)); end

  def fields(scope=T.unsafe(nil), model: T.unsafe(nil), **options, &block); end

  def fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field(object_name, method, options=T.unsafe(nil)); end

  def form_for(record, options=T.unsafe(nil), &block); end

  def form_with(model: T.unsafe(nil), scope: T.unsafe(nil), url: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def form_with_generates_ids(); end

  def form_with_generates_ids=(obj); end

  def form_with_generates_remote_forms(); end

  def form_with_generates_remote_forms=(obj); end

  def hidden_field(object_name, method, options=T.unsafe(nil)); end

  def label(object_name, method, content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field(object_name, method, options=T.unsafe(nil)); end

  def number_field(object_name, method, options=T.unsafe(nil)); end

  def password_field(object_name, method, options=T.unsafe(nil)); end

  def phone_field(object_name, method, options=T.unsafe(nil)); end

  def radio_button(object_name, method, tag_value, options=T.unsafe(nil)); end

  def range_field(object_name, method, options=T.unsafe(nil)); end

  def search_field(object_name, method, options=T.unsafe(nil)); end

  def telephone_field(object_name, method, options=T.unsafe(nil)); end

  def text_area(object_name, method, options=T.unsafe(nil)); end

  def text_field(object_name, method, options=T.unsafe(nil)); end

  def time_field(object_name, method, options=T.unsafe(nil)); end

  def url_field(object_name, method, options=T.unsafe(nil)); end

  def week_field(object_name, method, options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormHelper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.form_with_generates_ids(); end

  def self.form_with_generates_ids=(obj); end

  def self.form_with_generates_remote_forms(); end

  def self.form_with_generates_remote_forms=(obj); end
end

module ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def collection_check_boxes(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_radio_buttons(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def collection_select(object, method, collection, value_method, text_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_collection_select(object, method, collection, group_method, group_label_method, option_key_method, option_value_method, options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def grouped_options_for_select(grouped_options, selected_key=T.unsafe(nil), options=T.unsafe(nil)); end

  def option_groups_from_collection_for_select(collection, group_method, group_label_method, option_key_method, option_value_method, selected_key=T.unsafe(nil)); end

  def options_for_select(container, selected=T.unsafe(nil)); end

  def options_from_collection_for_select(collection, value_method, text_method, selected=T.unsafe(nil)); end

  def select(object, method, choices=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def time_zone_options_for_select(selected=T.unsafe(nil), priority_zones=T.unsafe(nil), model=T.unsafe(nil)); end

  def time_zone_select(object, method, priority_zones=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormOptionsHelper
  extend ::T::Sig
end

module ActionView::Helpers::FormTagHelper
  def button_tag(content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def check_box_tag(name, value=T.unsafe(nil), checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def color_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def date_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def datetime_local_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def email_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def embed_authenticity_token_in_remote_forms(); end

  def embed_authenticity_token_in_remote_forms=(obj); end

  def field_set_tag(legend=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def file_field_tag(name, options=T.unsafe(nil)); end

  def form_tag(url_for_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def hidden_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def image_submit_tag(source, options=T.unsafe(nil)); end

  def label_tag(name=T.unsafe(nil), content_or_options=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def month_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def number_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def password_field_tag(name=T.unsafe(nil), value=T.unsafe(nil), options=T.unsafe(nil)); end

  def phone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def radio_button_tag(name, value, checked=T.unsafe(nil), options=T.unsafe(nil)); end

  def range_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def search_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def select_tag(name, option_tags=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_tag(value=T.unsafe(nil), options=T.unsafe(nil)); end

  def telephone_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_area_tag(name, content=T.unsafe(nil), options=T.unsafe(nil)); end

  def text_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def time_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def url_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end

  def utf8_enforcer_tag(); end

  def week_field_tag(name, value=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActionView::Helpers::FormTagHelper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.embed_authenticity_token_in_remote_forms(); end

  def self.embed_authenticity_token_in_remote_forms=(obj); end
end

module ActionView::Helpers::JavaScriptHelper
  def escape_javascript(javascript); end

  def j(javascript); end

  def javascript_cdata_section(content); end

  def javascript_tag(content_or_options_with_block=T.unsafe(nil), html_options=T.unsafe(nil), &block); end
  JS_ESCAPE_MAP = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::JavaScriptHelper
  extend ::T::Sig
end

module ActionView::Helpers::NumberHelper
  def number_to_currency(number, options=T.unsafe(nil)); end

  def number_to_human(number, options=T.unsafe(nil)); end

  def number_to_human_size(number, options=T.unsafe(nil)); end

  def number_to_percentage(number, options=T.unsafe(nil)); end

  def number_to_phone(number, options=T.unsafe(nil)); end

  def number_with_delimiter(number, options=T.unsafe(nil)); end

  def number_with_precision(number, options=T.unsafe(nil)); end
end

module ActionView::Helpers::NumberHelper
  extend ::T::Sig
end

module ActionView::Helpers::OutputSafetyHelper
  def raw(stringish); end

  def safe_join(array, sep=T.unsafe(nil)); end

  def to_sentence(array, options=T.unsafe(nil)); end
end

module ActionView::Helpers::OutputSafetyHelper
  extend ::T::Sig
end

module ActionView::Helpers::RecordTagHelper
  def content_tag_for(*_); end

  def div_for(*_); end
end

module ActionView::Helpers::RecordTagHelper
  extend ::T::Sig
end

module ActionView::Helpers::RenderingHelper
  def _layout_for(*args, &block); end

  def render(options=T.unsafe(nil), locals=T.unsafe(nil), &block); end
end

module ActionView::Helpers::RenderingHelper
  extend ::T::Sig
end

module ActionView::Helpers::SanitizeHelper
  def sanitize(html, options=T.unsafe(nil)); end

  def sanitize_css(style); end

  def strip_links(html); end

  def strip_tags(html); end
end

module ActionView::Helpers::SanitizeHelper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def cdata_section(content); end

  def content_tag(name, content_or_options_with_block=T.unsafe(nil), options=T.unsafe(nil), escape=T.unsafe(nil), &block); end

  def escape_once(html); end

  def tag(name=T.unsafe(nil), options=T.unsafe(nil), open=T.unsafe(nil), escape=T.unsafe(nil)); end
  BOOLEAN_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  PRE_CONTENT_STRINGS = ::T.let(nil, ::T.untyped)
  TAG_PREFIXES = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::TagHelper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  def concat(string); end

  def current_cycle(name=T.unsafe(nil)); end

  def cycle(first_value, *values); end

  def excerpt(text, phrase, options=T.unsafe(nil)); end

  def highlight(text, phrases, options=T.unsafe(nil)); end

  def pluralize(count, singular, plural_arg=T.unsafe(nil), plural: T.unsafe(nil), locale: T.unsafe(nil)); end

  def reset_cycle(name=T.unsafe(nil)); end

  def safe_concat(string); end

  def simple_format(text, html_options=T.unsafe(nil), options=T.unsafe(nil)); end

  def truncate(text, options=T.unsafe(nil), &block); end

  def word_wrap(text, line_width: T.unsafe(nil), break_sequence: T.unsafe(nil)); end
end

module ActionView::Helpers::TextHelper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionView::Helpers::TranslationHelper
  def l(*args); end

  def localize(*args); end

  def t(key, options=T.unsafe(nil)); end

  def translate(key, options=T.unsafe(nil)); end
end

module ActionView::Helpers::TranslationHelper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionView::Helpers::UrlHelper
  def _back_url(); end

  def _filtered_referrer(); end

  def button_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def current_page?(options, check_parameters: T.unsafe(nil)); end

  def link_to(name=T.unsafe(nil), options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_if(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless(condition, name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def link_to_unless_current(name, options=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def mail_to(email_address, name=T.unsafe(nil), html_options=T.unsafe(nil), &block); end

  def url_for(options=T.unsafe(nil)); end
  BUTTON_TAG_METHOD_VERBS = ::T.let(nil, ::T.untyped)
  STRINGIFIED_COMMON_METHODS = ::T.let(nil, ::T.untyped)
end

module ActionView::Helpers::UrlHelper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActionView::Helpers
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionView::I18nProxy
  def initialize(original_config, lookup_context); end

  def locale=(value); end

  def lookup_context(); end

  def original_config(); end
end

class ActionView::I18nProxy
end

module ActionView::Layouts
  def _layout_conditions(*args, &block); end

  def _normalize_options(options); end

  def action_has_layout=(action_has_layout); end

  def action_has_layout?(); end

  def initialize(*_); end
end

module ActionView::Layouts
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionView::LogSubscriber
  include ::Kaminari::ActionViewExtension::LogSubscriberSilencer
  def render_collection(event); end

  def render_template(event); end
  EMPTY = ::T.let(nil, ::T.untyped)
  VIEWS_PATTERN = ::T.let(nil, ::T.untyped)
end

class ActionView::LogSubscriber
end

class ActionView::LookupContext
  include ::ActionView::LookupContext::Accessors
  include ::ActionView::LookupContext::DetailsCache
  include ::ActionView::LookupContext::ViewPaths
  def digest_cache(); end

  def fallbacks(); end

  def fallbacks=(obj); end

  def formats=(values); end

  def initialize(view_paths, details=T.unsafe(nil), prefixes=T.unsafe(nil)); end

  def prefixes(); end

  def prefixes=(prefixes); end

  def registered_details(); end

  def registered_details=(obj); end

  def rendered_format(); end

  def rendered_format=(rendered_format); end
end

module ActionView::LookupContext::Accessors
  def default_formats(); end

  def default_handlers(); end

  def default_locale(); end

  def default_variants(); end

  def formats(); end

  def formats=(value); end

  def handlers(); end

  def handlers=(value); end

  def locale(); end

  def locale=(value); end

  def variants(); end

  def variants=(value); end
  DEFAULT_PROCS = ::T.let(nil, ::T.untyped)
end

module ActionView::LookupContext::Accessors
  extend ::T::Sig
end

module ActionView::LookupContext::DetailsCache
  def cache(); end

  def cache=(cache); end

  def details_key(); end

  def disable_cache(); end
end

module ActionView::LookupContext::DetailsCache
  extend ::T::Sig
end

class ActionView::LookupContext::DetailsKey
end

class ActionView::LookupContext::DetailsKey
  def self.clear(); end

  def self.digest_caches(); end

  def self.get(details); end
end

module ActionView::LookupContext::ViewPaths
  def any?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def any_templates?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil)); end

  def exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def find(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_all(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_file(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def find_template(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), options=T.unsafe(nil)); end

  def html_fallback_for_js(); end

  def template_exists?(name, prefixes=T.unsafe(nil), partial=T.unsafe(nil), keys=T.unsafe(nil), **options); end

  def view_paths(); end

  def view_paths=(paths); end

  def with_fallbacks(); end
end

module ActionView::LookupContext::ViewPaths
  extend ::T::Sig
end

class ActionView::LookupContext
  def self.fallbacks(); end

  def self.fallbacks=(obj); end

  def self.register_detail(name, &block); end

  def self.registered_details(); end

  def self.registered_details=(obj); end
end

class ActionView::MissingTemplate
  def initialize(paths, path, prefixes, partial, details, *_); end

  def path(); end
end

class ActionView::MissingTemplate
end

module ActionView::ModelNaming
  def convert_to_model(object); end

  def model_name_from_record_or_class(record_or_class); end
end

module ActionView::ModelNaming
  extend ::T::Sig
end

class ActionView::OptimizedFileSystemResolver
end

class ActionView::OptimizedFileSystemResolver
end

class ActionView::OutputBuffer
  def append=(value); end

  def initialize(*_); end

  def safe_append=(value); end

  def safe_expr_append=(val); end
end

class ActionView::OutputBuffer
end

class ActionView::OutputFlow
  def append(key, value); end

  def append!(key, value); end

  def content(); end

  def get(key); end

  def set(key, value); end
end

class ActionView::OutputFlow
end

class ActionView::PartialIteration
  def first?(); end

  def index(); end

  def initialize(size); end

  def iterate!(); end

  def last?(); end

  def size(); end
end

class ActionView::PartialIteration
end

class ActionView::PartialRenderer
  include ::ActionView::CollectionCaching
  def collection_cache(); end

  def collection_cache=(obj); end

  def initialize(*_); end

  def render(*args, &block); end

  def render_partial(*args); end

  def render_partial_with_datadog(*args); end

  def render_with_datadog(*args, &block); end

  def render_without_datadog(context, options, block); end
  IDENTIFIER_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  OPTION_AS_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
  PREFIXED_PARTIAL_NAMES = ::T.let(nil, ::T.untyped)
end

class ActionView::PartialRenderer
  def self.collection_cache(); end

  def self.collection_cache=(obj); end
end

class ActionView::PathResolver
  def initialize(pattern=T.unsafe(nil)); end
  DEFAULT_PATTERN = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class ActionView::PathResolver
end

class ActionView::PathSet
  include ::Enumerable
  def +(array); end

  def <<(*args); end

  def [](*args, &block); end

  def compact(); end

  def concat(*args); end

  def each(*args, &block); end

  def exists?(path, prefixes, *args); end

  def find(*args); end

  def find_all(path, prefixes=T.unsafe(nil), *args); end

  def find_all_with_query(query); end

  def find_file(path, prefixes=T.unsafe(nil), *args); end

  def include?(*args, &block); end

  def initialize(paths=T.unsafe(nil)); end

  def insert(*args); end

  def paths(); end

  def pop(*args, &block); end

  def push(*args); end

  def size(*args, &block); end

  def to_ary(); end

  def unshift(*args); end
end

class ActionView::PathSet
end

class ActionView::Railtie
end

class ActionView::Railtie
end

module ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  def dom_class(record_or_class, prefix=T.unsafe(nil)); end

  def dom_id(record, prefix=T.unsafe(nil)); end
  JOIN = ::T.let(nil, ::T.untyped)
  NEW = ::T.let(nil, ::T.untyped)
end

module ActionView::RecordIdentifier
  extend ::ActionView::RecordIdentifier
  extend ::ActionView::ModelNaming
  extend ::T::Sig
end

class ActionView::Renderer
  def cache_hits(); end

  def initialize(lookup_context); end

  def lookup_context(); end

  def lookup_context=(lookup_context); end

  def render(context, options); end

  def render_body(context, options); end

  def render_partial(context, options, &block); end

  def render_template(context, options); end
end

class ActionView::Renderer
end

module ActionView::Rendering
  def process(*_); end

  def render_to_body(options=T.unsafe(nil)); end

  def rendered_format(); end

  def view_context(); end

  def view_context_class(); end

  def view_context_class=(view_context_class); end

  def view_renderer(); end
end

module ActionView::Rendering
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionView::Resolver
  def caching(); end

  def caching=(obj); end

  def caching?(*args, &block); end

  def clear_cache(); end

  def find_all(name, prefix=T.unsafe(nil), partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end

  def find_all_anywhere(name, prefix, partial=T.unsafe(nil), details=T.unsafe(nil), key=T.unsafe(nil), locals=T.unsafe(nil)); end

  def find_all_with_query(query); end
end

class ActionView::Resolver::Cache
  def cache(key, name, prefix, partial, locals); end

  def cache_query(query); end

  def clear(); end

  def size(); end
  KEY_BLOCK = ::T.let(nil, ::T.untyped)
  NAME_BLOCK = ::T.let(nil, ::T.untyped)
  NO_TEMPLATES = ::T.let(nil, ::T.untyped)
  PARTIAL_BLOCK = ::T.let(nil, ::T.untyped)
  PREFIX_BLOCK = ::T.let(nil, ::T.untyped)
end

class ActionView::Resolver::Cache::SmallCache
  def initialize(options=T.unsafe(nil)); end
end

class ActionView::Resolver::Cache::SmallCache
end

class ActionView::Resolver::Cache
end

class ActionView::Resolver::Path
  def initialize(name, prefix, partial, virtual); end

  def name(); end

  def partial(); end

  def partial?(); end

  def prefix(); end

  def to_str(); end

  def virtual(); end
end

class ActionView::Resolver::Path
  def self.build(name, prefix, partial); end
end

class ActionView::Resolver
  def self.caching(); end

  def self.caching=(obj); end

  def self.caching?(); end
end

module ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def default_url_options=(obj); end

  def url_for(options=T.unsafe(nil)); end

  def url_options(); end
end

module ActionView::RoutingUrlFor
  extend ::T::Sig
  def self.default_url_options=(obj); end
end

class ActionView::StreamingBuffer
  def <<(value); end

  def append=(value); end

  def concat(value); end

  def html_safe(); end

  def initialize(block); end

  def safe_append=(value); end

  def safe_concat(value); end
end

class ActionView::StreamingBuffer
end

class ActionView::StreamingFlow
  def initialize(view, fiber); end
end

class ActionView::StreamingFlow
end

class ActionView::StreamingTemplateRenderer
  def render_template(template, layout_name=T.unsafe(nil), locals=T.unsafe(nil)); end
end

class ActionView::StreamingTemplateRenderer::Body
  include ::Raven::Rails::Overrides::StreamingReporter
  def each(&block); end

  def initialize(&start); end
end

class ActionView::StreamingTemplateRenderer::Body
end

class ActionView::StreamingTemplateRenderer
end

class ActionView::Template
  def encode!(); end

  def formats(); end

  def formats=(formats); end

  def handler(); end

  def identifier(); end

  def initialize(source, identifier, handler, details); end

  def locals(); end

  def locals=(locals); end

  def original_encoding(); end

  def refresh(view); end

  def render(view, locals, buffer=T.unsafe(nil), &block); end

  def source(); end

  def supports_streaming?(); end

  def type(); end

  def updated_at(); end

  def variants(); end

  def variants=(variants); end

  def virtual_path(); end

  def virtual_path=(virtual_path); end
  Finalizer = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Error
  def annoted_source_code(); end

  def file_name(); end

  def initialize(template); end

  def line_number(); end

  def source_extract(indentation=T.unsafe(nil), output=T.unsafe(nil)); end

  def sub_template_message(); end

  def sub_template_of(template_path); end
  SOURCE_CODE_RADIUS = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Error
end

class ActionView::Template::HTML
  def formats(); end

  def identifier(); end

  def initialize(string, type=T.unsafe(nil)); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::HTML
end

module ActionView::Template::Handlers
  def handler_for_extension(extension); end

  def register_default_template_handler(extension, klass); end

  def register_template_handler(*extensions, handler); end

  def registered_template_handler(extension); end

  def template_handler_extensions(); end

  def unregister_template_handler(*extensions); end
end

class ActionView::Template::Handlers::Builder
  def call(template); end

  def default_format(); end

  def default_format=(val); end

  def default_format?(); end
end

class ActionView::Template::Handlers::Builder
  def self.default_format(); end

  def self.default_format=(val); end

  def self.default_format?(); end
end

class ActionView::Template::Handlers::ERB
  def call(template); end

  def erb_implementation(); end

  def erb_implementation=(val); end

  def erb_implementation?(); end

  def erb_trim_mode(); end

  def erb_trim_mode=(val); end

  def erb_trim_mode?(); end

  def escape_whitelist(); end

  def escape_whitelist=(val); end

  def escape_whitelist?(); end

  def handles_encoding?(); end

  def supports_streaming?(); end
  ENCODING_TAG = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
  def evaluate(action_view_erb_handler_context); end
  BLOCK_EXPR = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Handlers::ERB::Erubi
end

class ActionView::Template::Handlers::ERB
  def self.call(template); end

  def self.erb_implementation(); end

  def self.erb_implementation=(val); end

  def self.erb_implementation?(); end

  def self.erb_trim_mode(); end

  def self.erb_trim_mode=(val); end

  def self.erb_trim_mode?(); end

  def self.escape_whitelist(); end

  def self.escape_whitelist=(val); end

  def self.escape_whitelist?(); end
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::Html
end

class ActionView::Template::Handlers::Raw
  def call(template); end
end

class ActionView::Template::Handlers::Raw
end

module ActionView::Template::Handlers
  extend ::T::Sig
  def self.extended(base); end

  def self.extensions(); end
end

class ActionView::Template::Text
  def formats(); end

  def identifier(); end

  def initialize(string); end

  def render(*args); end

  def to_str(); end

  def type(); end

  def type=(type); end
end

class ActionView::Template::Text
end

class ActionView::Template::Types
  def type_klass(); end

  def type_klass=(obj); end
end

class ActionView::Template::Types::Type
  def ==(type); end

  def initialize(symbol); end

  def ref(); end

  def symbol(); end

  def to_str(); end

  def to_sym(); end
  SET = ::T.let(nil, ::T.untyped)
end

class ActionView::Template::Types::Type
  def self.[](type); end
end

class ActionView::Template::Types
  def self.[](type); end

  def self.delegate_to(klass); end

  def self.symbols(); end

  def self.type_klass(); end

  def self.type_klass=(obj); end
end

class ActionView::Template
  extend ::ActiveSupport::Autoload
  extend ::ActionView::Template::Handlers
end

ActionView::TemplateError = ActionView::Template::Error

class ActionView::TemplateRenderer
  def render(*args, &block); end

  def render_template(*args); end

  def render_template_with_datadog(*args); end

  def render_with_datadog(*args, &block); end

  def render_without_datadog(context, options); end
end

class ActionView::TemplateRenderer
end

class ActionView::TestCase
  include ::Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  include ::ActionDispatch::Assertions
  include ::ActionDispatch::Assertions::ResponseAssertions
  include ::ActionDispatch::Assertions::RoutingAssertions
  include ::AbstractController::Helpers
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::UrlHelper
  include ::ActionView::Helpers::FormTagHelper
  include ::ActionView::Helpers::FormHelper
  include ::ActionView::Helpers::TranslationHelper
  include ::ActionView::Helpers
  include ::ActiveSupport::Benchmarkable
  include ::ActionView::Helpers::ActiveModelHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::ActionView::Helpers::AtomFeedHelper
  include ::ActionView::Helpers::CacheHelper
  include ::ActionView::Helpers::ControllerHelper
  include ::ActionView::Helpers::CspHelper
  include ::ActionView::Helpers::CsrfHelper
  include ::ActionView::Helpers::DateHelper
  include ::ActionView::Helpers::DebugHelper
  include ::ActionView::Helpers::FormOptionsHelper
  include ::ActionView::Helpers::SanitizeHelper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::TextHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::JavaScriptHelper
  include ::ActionView::Helpers::NumberHelper
  include ::ActionView::Helpers::RecordTagHelper
  include ::ActionView::Helpers::RenderingHelper
  include ::ActiveSupport::Testing::ConstantLookup
  include ::ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _helper_methods(); end

  def _helper_methods=(val); end

  def _helper_methods?(); end

  def _helpers(); end

  def _helpers=(val); end

  def _helpers?(); end

  def debug_missing_translation(); end

  def debug_missing_translation=(obj); end
end

module ActionView::TestCase::Behavior
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  include ::ActionController::TemplateAssertions
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  include ::ActionView::RecordIdentifier
  include ::ActionView::ModelNaming
  include ::ActionView::RoutingUrlFor
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def config(); end

  def controller(); end

  def controller=(controller); end

  def lookup_context(*args, &block); end

  def output_buffer(); end

  def output_buffer=(output_buffer); end

  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil), &block); end

  def rendered(); end

  def rendered=(rendered); end

  def rendered_views(); end

  def setup_with_controller(); end
  INTERNAL_IVARS = ::T.let(nil, ::T.untyped)
end

module ActionView::TestCase::Behavior::ClassMethods
  def determine_default_helper_class(name); end

  def helper_class(); end

  def helper_class=(helper_class); end

  def helper_method(*methods); end

  def new(*_); end

  def tests(helper_class); end
end

module ActionView::TestCase::Behavior::ClassMethods
  extend ::T::Sig
end

module ActionView::TestCase::Behavior::Locals
  def render(options=T.unsafe(nil), local_assigns=T.unsafe(nil)); end

  def rendered_views(); end

  def rendered_views=(rendered_views); end
end

module ActionView::TestCase::Behavior::Locals
  extend ::T::Sig
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
  def add(view, locals); end

  def locals_for(view); end

  def rendered_views(); end

  def view_rendered?(view, expected_locals); end
end

class ActionView::TestCase::Behavior::RenderedViewsCollection
end

module ActionView::TestCase::Behavior
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionView::TestCase::TestController
  include ::ActionDispatch::TestProcess
  include ::ActionDispatch::TestProcess::FixtureFile
  def controller_path=(path); end

  def initialize(); end

  def params=(params); end
end

class ActionView::TestCase::TestController
  def self.controller_path=(controller_path); end
end

class ActionView::TestCase
  extend ::AbstractController::Helpers::ClassMethods
  extend ::ActionView::TestCase::Behavior::ClassMethods
  def self._helper_methods(); end

  def self._helper_methods=(val); end

  def self._helper_methods?(); end

  def self._helpers(); end

  def self._helpers=(val); end

  def self._helpers?(); end

  def self.debug_missing_translation(); end

  def self.debug_missing_translation=(obj); end
end

module ActionView::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActionView::VERSION
  extend ::T::Sig
end

module ActionView::ViewPaths
  def _prefixes(); end

  def any_templates?(*args, &block); end

  def append_view_path(path); end

  def details_for_lookup(); end

  def formats(*args, &block); end

  def formats=(arg); end

  def locale(*args, &block); end

  def locale=(arg); end

  def lookup_context(); end

  def prepend_view_path(path); end

  def template_exists?(*args, &block); end

  def view_paths(*args, &block); end
end

module ActionView::ViewPaths
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActionView::WrongEncodingError
  def initialize(string, encoding); end
end

class ActionView::WrongEncodingError
end

module ActionView
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.gem_version(); end

  def self.version(); end
end

module ActiveAdmin
  DEFAULT_MENU = ::T.let(nil, ::T.untyped)
  Event = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ActiveAdmin::AbstractViewFactory
  def [](key); end

  def []=(key, value); end

  def default_for(key); end

  def has_key?(key); end

  def register(view_hash); end
end

class ActiveAdmin::AbstractViewFactory
  def self.register(view_hash); end
end

class ActiveAdmin::AccessDenied
  def action(); end

  def initialize(user, action, subject=T.unsafe(nil)); end

  def subject(); end

  def user(); end
end

class ActiveAdmin::AccessDenied
end

class ActiveAdmin::ActionItem
  include ::ActiveAdmin::OptionalDisplay
  def block(); end

  def block=(block); end

  def html_class(); end

  def initialize(name, options=T.unsafe(nil), &block); end

  def name(); end

  def name=(name); end
end

class ActiveAdmin::ActionItem
end

class ActiveAdmin::Application
  include ::ActiveAdmin::Settings
  include ::ActiveAdmin::Settings::Inheritance
  include ::ActiveAdmin::AssetRegistration
  def after_action(*args, &block); end

  def allow_comments=(*allow_comments); end

  def append_after_action(*args, &block); end

  def append_around_action(*args, &block); end

  def append_before_action(*args, &block); end

  def around_action(*args, &block); end

  def authentication_method(); end

  def authentication_method=(authentication_method); end

  def authentication_method?(); end

  def authorization_adapter(); end

  def authorization_adapter=(authorization_adapter); end

  def authorization_adapter?(); end

  def batch_actions(); end

  def batch_actions=(batch_actions); end

  def batch_actions?(); end

  def before_action(*args, &block); end

  def breadcrumb(); end

  def breadcrumb=(breadcrumb); end

  def breadcrumb?(); end

  def cancan_ability_class(); end

  def cancan_ability_class=(cancan_ability_class); end

  def cancan_ability_class?(); end

  def comments(); end

  def comments=(comments); end

  def comments?(); end

  def comments_menu(); end

  def comments_menu=(comments_menu); end

  def comments_menu?(); end

  def comments_order(); end

  def comments_order=(comments_order); end

  def comments_order?(); end

  def comments_registration_name(); end

  def comments_registration_name=(comments_registration_name); end

  def comments_registration_name?(); end

  def controllers_for_filters(); end

  def create_another(); end

  def create_another=(create_another); end

  def create_another?(); end

  def csv_options(); end

  def csv_options=(csv_options); end

  def csv_options?(); end

  def current_filters(); end

  def current_filters=(current_filters); end

  def current_filters?(); end

  def current_user_method(); end

  def current_user_method=(current_user_method); end

  def current_user_method?(); end

  def default_namespace(); end

  def default_namespace=(default_namespace); end

  def default_namespace?(); end

  def default_per_page(); end

  def default_per_page=(default_per_page); end

  def default_per_page?(); end

  def disable_streaming_in(); end

  def disable_streaming_in=(disable_streaming_in); end

  def disable_streaming_in?(); end

  def display_name_methods(); end

  def display_name_methods=(display_name_methods); end

  def display_name_methods?(); end

  def download_links(); end

  def download_links=(download_links); end

  def download_links?(); end

  def favicon(); end

  def favicon=(favicon); end

  def favicon?(); end

  def files(); end

  def filters(); end

  def filters=(filters); end

  def filters?(); end

  def flash_keys_to_except(); end

  def flash_keys_to_except=(flash_keys_to_except); end

  def flash_keys_to_except?(); end

  def footer(); end

  def footer=(footer); end

  def footer?(); end

  def include_default_association_filters(); end

  def include_default_association_filters=(include_default_association_filters); end

  def include_default_association_filters?(); end

  def load(file); end

  def load!(); end

  def load_paths(); end

  def load_paths=(load_paths); end

  def load_paths?(); end

  def loaded?(); end

  def localize_format(); end

  def localize_format=(localize_format); end

  def localize_format?(); end

  def logout_link_method(); end

  def logout_link_method=(logout_link_method); end

  def logout_link_method?(); end

  def logout_link_path(); end

  def logout_link_path=(logout_link_path); end

  def logout_link_path?(); end

  def max_per_page(); end

  def max_per_page=(max_per_page); end

  def max_per_page?(); end

  def meta_tags(); end

  def meta_tags=(meta_tags); end

  def meta_tags?(); end

  def meta_tags_for_logged_out_pages(); end

  def meta_tags_for_logged_out_pages=(meta_tags_for_logged_out_pages); end

  def meta_tags_for_logged_out_pages?(); end

  def namespace(name); end

  def namespaces(); end

  def on_unauthorized_access(); end

  def on_unauthorized_access=(on_unauthorized_access); end

  def on_unauthorized_access?(); end

  def order_clause(); end

  def order_clause=(order_clause); end

  def order_clause?(); end

  def permitted_params(); end

  def permitted_params=(permitted_params); end

  def permitted_params?(); end

  def prepare!(); end

  def prepend_after_action(*args, &block); end

  def prepend_around_action(*args, &block); end

  def prepend_before_action(*args, &block); end

  def pundit_default_policy(); end

  def pundit_default_policy=(pundit_default_policy); end

  def pundit_default_policy?(); end

  def register(resource, options=T.unsafe(nil), &block); end

  def register_page(name, options=T.unsafe(nil), &block); end

  def root_to(); end

  def root_to=(root_to); end

  def root_to?(); end

  def root_to_options(); end

  def root_to_options=(root_to_options); end

  def root_to_options?(); end

  def route_options(); end

  def route_options=(route_options); end

  def route_options?(); end

  def router(); end

  def routes(rails_router); end

  def scopes_show_count(); end

  def scopes_show_count=(scopes_show_count); end

  def scopes_show_count?(); end

  def setup!(); end

  def site_title(); end

  def site_title=(site_title); end

  def site_title?(); end

  def site_title_image(); end

  def site_title_image=(site_title_image); end

  def site_title_image?(); end

  def site_title_link(); end

  def site_title_link=(site_title_link); end

  def site_title_link?(); end

  def skip_after_action(*args, &block); end

  def skip_around_action(*args, &block); end

  def skip_before_action(*args, &block); end

  def unload!(); end

  def unsupported_browser_matcher(); end

  def unsupported_browser_matcher=(unsupported_browser_matcher); end

  def unsupported_browser_matcher?(); end

  def view_factory(); end

  def view_factory=(view_factory); end

  def view_factory?(); end
  AfterLoadEvent = ::T.let(nil, ::T.untyped)
  BeforeLoadEvent = ::T.let(nil, ::T.untyped)
end

class ActiveAdmin::Application
  extend ::ActiveAdmin::Settings::ClassMethods
end

module ActiveAdmin::AssetRegistration
  def clear_javascripts!(); end

  def clear_stylesheets!(); end

  def javascripts(); end

  def register_javascript(name); end

  def register_stylesheet(path, options=T.unsafe(nil)); end

  def stylesheets(); end
end

module ActiveAdmin::AssetRegistration
  extend ::T::Sig
end

ActiveAdmin::Auth = ActiveAdmin::Authorization

module ActiveAdmin::Authorization
  CREATE = ::T.let(nil, ::T.untyped)
  DESTROY = ::T.let(nil, ::T.untyped)
  READ = ::T.let(nil, ::T.untyped)
  UPDATE = ::T.let(nil, ::T.untyped)
end

module ActiveAdmin::Authorization
  extend ::T::Sig
end

class ActiveAdmin::AuthorizationAdapter
  def authorized?(action, subject=T.unsafe(nil)); end

  def initialize(resource, user); end

  def resource(); end

  def scope_collection(collection, action=T.unsafe(nil)); end

  def user(); end
end

class ActiveAdmin::AuthorizationAdapter::NormalizedMatcher
  def ===(other); end

  def initialize(klass); end
end

class ActiveAdmin::AuthorizationAdapter::NormalizedMatcher
end

class ActiveAdmin::AuthorizationAdapter
end

class ActiveAdmin::BaseController
  include ::ActiveAdmin::BaseController::Authorization
  include ::MethodOrProcHelper
  include ::ActiveAdmin::BaseController::Menu
  def collection_path(*given_args); end

  def collection_url(*given_args); end

  def edit_resource_path(*given_args); end

  def edit_resource_url(*given_args); end

  def new_resource_path(*given_args); end

  def new_resource_url(*given_args); end

  def only_render_implemented_actions(); end

  def resource_path(*given_args); end

  def resource_url(*given_args); end
  ACTIVE_ADMIN_ACTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveAdmin::BaseController::Authorization
  include ::MethodOrProcHelper
  def action_to_permission(action); end

  def active_admin_authorization(); end

  def active_admin_authorization_adapter(); end

  def authorize!(action, subject=T.unsafe(nil)); end

  def authorize_resource!(resource); end

  def authorized?(action, subject=T.unsafe(nil)); end

  def dispatch_active_admin_access_denied(exception); end

  def redirect_backwards_or_to_root(); end

  def rescue_active_admin_access_denied(exception); end
  ACTIONS_DICTIONARY = ::T.let(nil, ::T.untyped)
end

module ActiveAdmin::BaseController::Authorization
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveAdmin::BaseController::Menu
  def current_menu(); end

  def set_current_tab(); end
end

module ActiveAdmin::BaseController::Menu
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveAdmin::BaseController
  def self.active_admin_config(); end

  def self.active_admin_config=(active_admin_config); end
end

class ActiveAdmin::BatchAction
  include ::Comparable
  def block(); end

  def confirm(); end

  def display_if_block(); end

  def initialize(sym, title, options=T.unsafe(nil), &block); end

  def inputs(); end

  def priority(); end

  def sym(); end

  def title(); end
  DEFAULT_CONFIRM_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveAdmin::BatchAction
end

module ActiveAdmin::BatchActions
end

class ActiveAdmin::BatchActions::BatchActionForm
  def build(options=T.unsafe(nil), &block); end

  def prefix_html(); end
end

class ActiveAdmin::BatchActions::BatchActionForm
end

class ActiveAdmin::BatchActions::BatchActionSelector
  def build(batch_actions); end
end

class ActiveAdmin::BatchActions::BatchActionSelector
end

module ActiveAdmin::BatchActions::Controller
  def action_present?(); end

  def batch_action(); end

  def batch_action_collection(only=T.unsafe(nil)); end

  def current_batch_action(); end
  COLLECTION_APPLIES = ::T.let(nil, ::T.untyped)
end

module ActiveAdmin::BatchActions::Controller
  extend ::T::Sig
end

module ActiveAdmin::BatchActions::ResourceExtension
  def add_batch_action(sym, title, options=T.unsafe(nil), &block); end

  def batch_actions(); end

  def batch_actions=(bool); end

  def batch_actions_enabled?(); end

  def clear_batch_actions!(); end

  def initialize(*_); end

  def remove_batch_action(sym); end
end

module ActiveAdmin::BatchActions::ResourceExtension
  extend ::T::Sig
end

class ActiveAdmin::BatchActions::ResourceSelectionCell
  def build(resource); end
end

class ActiveAdmin::BatchActions::ResourceSelectionCell
end

class ActiveAdmin::BatchActions::ResourceSelectionToggleCell
  def build(label_text=T.unsafe(nil)); end
end

class ActiveAdmin::BatchActions::ResourceSelectionToggleCell
end

class ActiveAdmin::BatchActions::ResourceSelectionTogglePanel
  def build(); end
end

class ActiveAdmin::BatchActions::ResourceSelectionTogglePanel
end

module ActiveAdmin::BatchActions
  extend ::T::Sig
end

class ActiveAdmin::CSVBuilder
  def build(controller, csv); end

  def build_row(resource, columns, options); end

  def column(name, options=T.unsafe(nil), &block); end

  def columns(); end

  def encode(content, options); end

  def exec_columns(view_context=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def method_missing(method, *args, &block); end

  def options(); end

  def view_context(); end
  COLUMN_TRANSITIVE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveAdmin::CSVBuilder::Column
  def data(); end

  def humanize_name(name, resource, humanize_name_option); end

  def initialize(name, resource=T.unsafe(nil), options=T.unsafe(nil), block=T.unsafe(nil)); end

  def name(); end

  def options(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveAdmin::CSVBuilder::Column
end

class ActiveAdmin::CSVBuilder
  def self.default_for_resource(resource); end
end

module ActiveAdmin::Callbacks
end

module ActiveAdmin::Callbacks::ClassMethods
end

module ActiveAdmin::Callbacks::ClassMethods
  extend ::T::Sig
end

module ActiveAdmin::Callbacks
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveAdmin::CanCanAdapter
  def cancan_ability(); end
end

class ActiveAdmin::CanCanAdapter
end

class ActiveAdmin::Comment
  include ::ActiveAdmin::Comment::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  def autosave_associated_records_for_author(*args); end

  def autosave_associated_records_for_resource(*args); end

  def belongs_to_counter_cache_after_update(reflection); end

  def set_resource_type(); end
end

module ActiveAdmin::Comment::GeneratedAssociationMethods
  def author(); end

  def author=(value); end

  def reload_author(); end

  def reload_resource(); end

  def resource(); end

  def resource=(value); end
end

module ActiveAdmin::Comment::GeneratedAssociationMethods
  extend ::T::Sig
end

class ActiveAdmin::Comment
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.find_for_resource_in_namespace(resource, namespace); end

  def self.page(num=T.unsafe(nil)); end

  def self.resource_type(resource); end
end

module ActiveAdmin::Comments
end

module ActiveAdmin::Comments::NamespaceHelper
  def comments?(); end
end

module ActiveAdmin::Comments::NamespaceHelper
  extend ::T::Sig
end

module ActiveAdmin::Comments::ResourceHelper
  def comments?(); end
end

module ActiveAdmin::Comments::ResourceHelper
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveAdmin::Comments::ShowPageHelper
  def active_admin_comments(*args, &block); end

  def default_main_content(); end
end

module ActiveAdmin::Comments::ShowPageHelper
  extend ::T::Sig
end

module ActiveAdmin::Comments::Views
end

class ActiveAdmin::Comments::Views::Comments
  def build(resource); end

  def build_comment(comment); end

  def build_comment_form(); end

  def build_comments(); end

  def build_empty_message(); end

  def comment_form_url(); end

  def comments_url(*args); end

  def resource(); end

  def resource=(resource); end

  def title(); end
end

class ActiveAdmin::Comments::Views::Comments
end

module ActiveAdmin::Comments::Views
  extend ::T::Sig
end

module ActiveAdmin::Comments
  extend ::T::Sig
end

class ActiveAdmin::Component
end

class ActiveAdmin::Component
end

class ActiveAdmin::ControllerAction
  def http_verb(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end
end

class ActiveAdmin::ControllerAction
end

class ActiveAdmin::DSL
  def action_item(name=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def batch_action(title, options=T.unsafe(nil), &block); end

  def breadcrumb(&block); end

  def config(); end

  def controller(&block); end

  def include(mod); end

  def initialize(config); end

  def menu(options=T.unsafe(nil)); end

  def navigation_menu(menu_name=T.unsafe(nil), &block); end

  def run_registration_block(&block); end

  def sidebar(name, options=T.unsafe(nil), &block); end
end

class ActiveAdmin::DSL
end

class ActiveAdmin::DatabaseHitDuringLoad
  def initialize(exception); end
end

class ActiveAdmin::DatabaseHitDuringLoad
  def self.capture(); end

  def self.database_error_classes(); end
end

module ActiveAdmin::Dependency
end

module ActiveAdmin::Dependency::Adapter
end

class ActiveAdmin::Dependency::Adapter::Base
  def initialize(version); end
end

class ActiveAdmin::Dependency::Adapter::Base
end

class ActiveAdmin::Dependency::Adapter::Rails
  def parameterize(string); end

  def redirect_back(controller, fallback_location); end

  def render_key(); end
end

class ActiveAdmin::Dependency::Adapter::Rails
end

module ActiveAdmin::Dependency::Adapter
  extend ::T::Sig
end

class ActiveAdmin::Dependency::Matcher
  include ::Comparable
  def adapter(); end

  def initialize(name); end

  def match!(*reqs); end

  def match?(*reqs); end

  def method_missing(method, *args, &block); end

  def name(); end

  def spec(); end

  def spec!(); end
end

class ActiveAdmin::Dependency::Matcher
end

module ActiveAdmin::Dependency::Requirements
  DEVISE = ::T.let(nil, ::T.untyped)
end

module ActiveAdmin::Dependency::Requirements
  extend ::T::Sig
end

module ActiveAdmin::Dependency
  extend ::T::Sig
  def self.[](name); end

  def self.method_missing(name, *args); end

  def self.rails5?(); end
end

class ActiveAdmin::DependencyError
end

class ActiveAdmin::DependencyError
end

module ActiveAdmin::Deprecation
end

module ActiveAdmin::Deprecation
  extend ::T::Sig
  def self.deprecate(klass, method, message); end

  def self.warn(message, callstack=T.unsafe(nil)); end
end

module ActiveAdmin::Devise
end

class ActiveAdmin::Devise::ConfirmationsController
  include ::ActiveAdmin::Devise::Controller
end

class ActiveAdmin::Devise::ConfirmationsController
end

module ActiveAdmin::Devise::Controller
  def root_path(); end
end

module ActiveAdmin::Devise::Controller
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveAdmin::Devise::PasswordsController
  include ::ActiveAdmin::Devise::Controller
end

class ActiveAdmin::Devise::PasswordsController
end

class ActiveAdmin::Devise::RegistrationsController
  include ::ActiveAdmin::Devise::Controller
end

class ActiveAdmin::Devise::RegistrationsController
end

class ActiveAdmin::Devise::SessionsController
  include ::ActiveAdmin::Devise::Controller
end

class ActiveAdmin::Devise::SessionsController
end

class ActiveAdmin::Devise::UnlocksController
  include ::ActiveAdmin::Devise::Controller
end

class ActiveAdmin::Devise::UnlocksController
end

module ActiveAdmin::Devise
  extend ::T::Sig
  def self.config(); end

  def self.controllers(); end

  def self.controllers_for_filters(); end
end

class ActiveAdmin::Engine
end

class ActiveAdmin::Engine
end

class ActiveAdmin::Error
end

class ActiveAdmin::Error
end

class ActiveAdmin::ErrorLoading
  def find_cause(folder, backtrace); end
end

class ActiveAdmin::ErrorLoading
end

class ActiveAdmin::EventDispatcher
  def dispatch(event, *args); end

  def subscribe(*event_names, &block); end

  def wrap_block_for_active_support_notifications(block); end
end

class ActiveAdmin::EventDispatcher
end

module ActiveAdmin::Filters
end

class ActiveAdmin::Filters::Active
  def filters(); end

  def filters=(filters); end

  def initialize(resource, search); end

  def resource(); end

  def resource=(resource); end
end

class ActiveAdmin::Filters::Active
end

class ActiveAdmin::Filters::ActiveFilter
  include ::ActiveAdmin::ViewHelpers
  include ::ActiveAdmin::ViewHelpers::ActiveAdminApplicationHelper
  include ::ActiveAdmin::ViewHelpers::AutoLinkHelper
  include ::ActiveAdmin::ViewHelpers::BreadcrumbHelper
  include ::ActiveAdmin::ViewHelpers::DisplayHelper
  include ::MethodOrProcHelper
  include ::ActiveAdmin::ViewHelpers::SidebarHelper
  include ::ActiveAdmin::ViewHelpers::FormHelper
  include ::ActiveAdmin::ViewHelpers::TitleHelper
  include ::ActiveAdmin::ViewHelpers::ViewFactoryHelper
  include ::ActiveAdmin::ViewHelpers::FlashHelper
  include ::ActiveAdmin::ViewHelpers::ScopeNameHelper
  include ::ActiveAdmin::Filters::ViewHelper
  include ::UrlHelper
  include ::AdminHelper
  def condition(); end

  def html_options(); end

  def initialize(resource, condition); end

  def label(); end

  def predicate_name(); end

  def related_class(); end

  def resource(); end

  def values(); end
end

class ActiveAdmin::Filters::ActiveFilter
end

class ActiveAdmin::Filters::ActiveSidebar
  def initialize(); end

  def sidebar_options(); end
end

class ActiveAdmin::Filters::ActiveSidebar
end

module ActiveAdmin::Filters::DSL
  def filter(attribute, options=T.unsafe(nil)); end

  def preserve_default_filters!(); end

  def remove_filter(*attributes); end
end

module ActiveAdmin::Filters::DSL
  extend ::T::Sig
end

class ActiveAdmin::Filters::Disabled
  def initialize(); end
end

class ActiveAdmin::Filters::Disabled
end

class ActiveAdmin::Filters::FormBuilder
  include ::ActiveAdmin::Filters::FormtasticAddons
  def filter(method, options=T.unsafe(nil)); end
end

class ActiveAdmin::Filters::FormBuilder
end

module ActiveAdmin::Filters::FormtasticAddons
  def column(); end

  def column_for(method); end

  def has_predicate?(); end

  def humanized_method_name(); end

  def klass(); end

  def polymorphic_foreign_type?(method); end

  def ransacker?(); end

  def reflection_for(method); end

  def scope?(); end

  def searchable_has_many_through?(); end

  def seems_searchable?(); end
end

module ActiveAdmin::Filters::FormtasticAddons
  extend ::T::Sig
end

module ActiveAdmin::Filters::ResourceExtension
  def add_filter(attribute, options=T.unsafe(nil)); end

  def current_filters=(bool); end

  def current_filters_enabled?(); end

  def filters(); end

  def filters=(bool); end

  def filters_enabled?(); end

  def initialize(*_); end

  def preserve_default_filters!(); end

  def preserve_default_filters?(); end

  def remove_filter(*attributes); end

  def reset_filters!(); end
end

module ActiveAdmin::Filters::ResourceExtension
  extend ::T::Sig
end

module ActiveAdmin::Filters::ViewHelper
  def active_admin_filters_form_for(search, filters, options=T.unsafe(nil)); end
end

module ActiveAdmin::Filters::ViewHelper
  extend ::T::Sig
end

module ActiveAdmin::Filters
  extend ::T::Sig
end

class ActiveAdmin::FormBuilder
  include ::MethodOrProcHelper
  def already_in_an_inputs_block(); end

  def already_in_an_inputs_block=(already_in_an_inputs_block); end

  def assoc_heading(assoc); end

  def cancel_link(url=T.unsafe(nil), html_options=T.unsafe(nil), li_attrs=T.unsafe(nil)); end

  def has_many(assoc, options=T.unsafe(nil), &block); end

  def has_many_actions(has_many_form, builder_options, contents); end

  def sorted_children(assoc, column); end
end

class ActiveAdmin::FormBuilder
end

class ActiveAdmin::GeneratorError
end

class ActiveAdmin::GeneratorError
end

module ActiveAdmin::Helpers
end

module ActiveAdmin::Helpers::Collection
  def collection_is_empty?(c=T.unsafe(nil)); end

  def collection_size(c=T.unsafe(nil)); end
end

module ActiveAdmin::Helpers::Collection
  extend ::T::Sig
end

module ActiveAdmin::Helpers::I18n
  PLURAL_MANY_COUNT = ::T.let(nil, ::T.untyped)
end

module ActiveAdmin::Helpers::I18n
  extend ::T::Sig
end

module ActiveAdmin::Helpers::Routes
end

module ActiveAdmin::Helpers::Routes::UrlHelpers
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  def _routes(); end

  def accept_offer_admin_order_path(*args); end

  def accept_offer_admin_order_url(*args); end

  def admin_comment_path(*args); end

  def admin_comment_url(*args); end

  def admin_comments_path(*args); end

  def admin_comments_url(*args); end

  def admin_note_path(*args); end

  def admin_note_url(*args); end

  def admin_notes_path(*args); end

  def admin_notes_url(*args); end

  def admin_order_admin_note_path(*args); end

  def admin_order_admin_note_url(*args); end

  def admin_order_admin_notes_path(*args); end

  def admin_order_admin_notes_url(*args); end

  def admin_order_path(*args); end

  def admin_order_url(*args); end

  def admin_orders_path(*args); end

  def admin_orders_url(*args); end

  def admin_root_path(*args); end

  def admin_root_url(*args); end

  def api_graphql_path(*args); end

  def api_graphql_url(*args); end

  def api_health_path(*args); end

  def api_health_url(*args); end

  def api_webhooks_stripe_path(*args); end

  def api_webhooks_stripe_url(*args); end

  def approve_order_admin_order_path(*args); end

  def approve_order_admin_order_url(*args); end

  def artsy_auth_path(*args); end

  def artsy_auth_url(*args); end

  def batch_action_admin_order_admin_notes_path(*args); end

  def batch_action_admin_order_admin_notes_url(*args); end

  def batch_action_admin_orders_path(*args); end

  def batch_action_admin_orders_url(*args); end

  def buyer_reject_admin_order_path(*args); end

  def buyer_reject_admin_order_url(*args); end

  def confirm_fulfillment_admin_order_path(*args); end

  def confirm_fulfillment_admin_order_url(*args); end

  def confirm_pickup_admin_order_path(*args); end

  def confirm_pickup_admin_order_url(*args); end

  def default_url_options=(obj); end

  def edit_admin_note_path(*args); end

  def edit_admin_note_url(*args); end

  def edit_admin_order_admin_note_path(*args); end

  def edit_admin_order_admin_note_url(*args); end

  def new_admin_note_path(*args); end

  def new_admin_note_url(*args); end

  def new_admin_order_admin_note_path(*args); end

  def new_admin_order_admin_note_url(*args); end

  def rails_info_path(*args); end

  def rails_info_properties_path(*args); end

  def rails_info_properties_url(*args); end

  def rails_info_routes_path(*args); end

  def rails_info_routes_url(*args); end

  def rails_info_url(*args); end

  def rails_mailers_path(*args); end

  def rails_mailers_url(*args); end

  def refund_admin_order_path(*args); end

  def refund_admin_order_url(*args); end

  def root_path(*args); end

  def root_url(*args); end

  def sidekiq_web_path(*args); end

  def sidekiq_web_url(*args); end

  def toggle_assisted_admin_order_path(*args); end

  def toggle_assisted_admin_order_url(*args); end
end

module ActiveAdmin::Helpers::Routes::UrlHelpers
  extend ::T::Sig
  def self._routes(); end

  def self.default_url_options=(obj); end
end

module ActiveAdmin::Helpers::Routes
  extend ::ActiveAdmin::Helpers::Routes::UrlHelpers
  extend ::ActionDispatch::Routing::UrlFor
  extend ::ActionDispatch::Routing::PolymorphicRoutes
  extend ::T::Sig
  def self.default_url_options(); end
end

module ActiveAdmin::Helpers
  extend ::T::Sig
end

module ActiveAdmin::Inputs
end

class ActiveAdmin::Inputs::DatepickerInput
end

class ActiveAdmin::Inputs::DatepickerInput
end

module ActiveAdmin::Inputs::Filters
end

module ActiveAdmin::Inputs::Filters::Base
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::ActiveAdmin::Filters::FormtasticAddons
  def collection_from_options(); end

  def input_wrapping(&block); end

  def label_from_options(); end

  def required?(); end

  def wrapper_html_options(); end
end

module ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect
  def current_filter(); end

  def filter_options(); end

  def filters(); end

  def input_html(); end

  def select_html(); end

  def to_html(); end

  def wrapper_html_options(); end
end

module ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods
  def filter(*filters); end

  def filters(); end
end

module ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods
  extend ::T::Sig
end

module ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect
  extend ::T::Sig
  def self.included(base); end
end

module ActiveAdmin::Inputs::Filters::Base
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

class ActiveAdmin::Inputs::Filters::BooleanInput
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Filters::FormtasticAddons
end

class ActiveAdmin::Inputs::Filters::BooleanInput
end

class ActiveAdmin::Inputs::Filters::CheckBoxesInput
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Filters::FormtasticAddons
  def searchable_method_name(); end
end

class ActiveAdmin::Inputs::Filters::CheckBoxesInput
end

class ActiveAdmin::Inputs::Filters::DatePickerInput
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Filters::FormtasticAddons
end

class ActiveAdmin::Inputs::Filters::DatePickerInput
end

class ActiveAdmin::Inputs::Filters::DateRangeInput
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Filters::FormtasticAddons
  def gt_input_name(); end

  def gt_input_placeholder(); end

  def input_html_options(input_name=T.unsafe(nil), placeholder=T.unsafe(nil)); end

  def lt_input_name(); end

  def lt_input_placeholder(); end
end

class ActiveAdmin::Inputs::Filters::DateRangeInput
end

class ActiveAdmin::Inputs::Filters::NumericInput
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect
end

class ActiveAdmin::Inputs::Filters::NumericInput
  extend ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods
end

class ActiveAdmin::Inputs::Filters::SelectInput
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Filters::FormtasticAddons
  def pluck_column(); end

  def reflection_searchable?(); end

  def searchable_method_name(); end
end

class ActiveAdmin::Inputs::Filters::SelectInput
end

class ActiveAdmin::Inputs::Filters::StringInput
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect
end

class ActiveAdmin::Inputs::Filters::StringInput
  extend ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods
end

class ActiveAdmin::Inputs::Filters::TextInput
  include ::ActiveAdmin::Inputs::Filters::Base
  include ::ActiveAdmin::Filters::FormtasticAddons
  include ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect
end

class ActiveAdmin::Inputs::Filters::TextInput
  extend ::ActiveAdmin::Inputs::Filters::Base::SearchMethodSelect::ClassMethods
end

module ActiveAdmin::Inputs::Filters
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActiveAdmin::Inputs
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActiveAdmin::Localizers
end

class ActiveAdmin::Localizers::ResourceLocalizer
  def array_to_key(*arr); end

  def initialize(model_name, model=T.unsafe(nil)); end

  def t(key, options=T.unsafe(nil)); end

  def translate(key, options=T.unsafe(nil)); end
end

class ActiveAdmin::Localizers::ResourceLocalizer
  def self.from_resource(resource_config); end

  def self.t(key, options); end

  def self.translate(key, options); end
end

module ActiveAdmin::Localizers
  extend ::T::Sig
  def self.resource(active_admin_config); end
end

class ActiveAdmin::Menu
  include ::ActiveAdmin::Menu::MenuNode
end

module ActiveAdmin::Menu::MenuNode
  def [](id); end

  def []=(id, child); end

  def add(options); end

  def children(); end

  def current?(item); end

  def include?(item); end

  def initialize(); end

  def items(context=T.unsafe(nil)); end
end

module ActiveAdmin::Menu::MenuNode
  extend ::T::Sig
end

class ActiveAdmin::Menu
end

class ActiveAdmin::MenuCollection
  def add(menu_name, menu_item_options=T.unsafe(nil)); end

  def before_build(&block); end

  def clear!(); end

  def exists?(menu_name); end

  def fetch(menu_name); end

  def menu(menu_name); end

  def on_build(&block); end
end

class ActiveAdmin::MenuCollection
end

class ActiveAdmin::MenuItem
  include ::ActiveAdmin::Menu::MenuNode
  include ::MethodOrProcHelper
  def ancestors(); end

  def display?(context=T.unsafe(nil)); end

  def html_options(); end

  def id(); end

  def initialize(options=T.unsafe(nil)); end

  def label(context=T.unsafe(nil)); end

  def parent(); end

  def priority(); end

  def url(context=T.unsafe(nil)); end
end

class ActiveAdmin::MenuItem
end

class ActiveAdmin::Namespace
  include ::ActiveAdmin::Settings
  include ::ActiveAdmin::Comments::NamespaceHelper
  def add_current_user_to_menu(menu, priority=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def add_logout_button_to_menu(menu, priority=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def application(); end

  def authentication_method(); end

  def authentication_method=(authentication_method); end

  def authentication_method?(); end

  def authorization_adapter(); end

  def authorization_adapter=(authorization_adapter); end

  def authorization_adapter?(); end

  def batch_actions(); end

  def batch_actions=(batch_actions); end

  def batch_actions?(); end

  def breadcrumb(); end

  def breadcrumb=(breadcrumb); end

  def breadcrumb?(); end

  def build_default_utility_nav(); end

  def build_menu(name=T.unsafe(nil)); end

  def build_menu_collection(); end

  def build_page(name, options); end

  def cancan_ability_class(); end

  def cancan_ability_class=(cancan_ability_class); end

  def cancan_ability_class?(); end

  def comments(); end

  def comments=(comments); end

  def comments_menu(); end

  def comments_menu=(comments_menu); end

  def comments_menu?(); end

  def comments_order(); end

  def comments_order=(comments_order); end

  def comments_order?(); end

  def comments_registration_name(); end

  def comments_registration_name=(comments_registration_name); end

  def comments_registration_name?(); end

  def create_another(); end

  def create_another=(create_another); end

  def create_another?(); end

  def csv_options(); end

  def csv_options=(csv_options); end

  def csv_options?(); end

  def current_filters(); end

  def current_filters=(current_filters); end

  def current_filters?(); end

  def current_user_method(); end

  def current_user_method=(current_user_method); end

  def current_user_method?(); end

  def default_per_page(); end

  def default_per_page=(default_per_page); end

  def default_per_page?(); end

  def download_links(); end

  def download_links=(download_links); end

  def download_links?(); end

  def favicon(); end

  def favicon=(favicon); end

  def favicon?(); end

  def fetch_menu(name); end

  def filters(); end

  def filters=(filters); end

  def filters?(); end

  def find_or_build_resource(resource_class, options); end

  def flash_keys_to_except(); end

  def flash_keys_to_except=(flash_keys_to_except); end

  def flash_keys_to_except?(); end

  def footer(); end

  def footer=(footer); end

  def footer?(); end

  def include_default_association_filters(); end

  def include_default_association_filters=(include_default_association_filters); end

  def include_default_association_filters?(); end

  def initialize(application, name); end

  def logout_link_method(); end

  def logout_link_method=(logout_link_method); end

  def logout_link_method?(); end

  def logout_link_path(); end

  def logout_link_path=(logout_link_path); end

  def logout_link_path?(); end

  def max_per_page(); end

  def max_per_page=(max_per_page); end

  def max_per_page?(); end

  def menus(); end

  def meta_tags(); end

  def meta_tags=(meta_tags); end

  def meta_tags?(); end

  def meta_tags_for_logged_out_pages(); end

  def meta_tags_for_logged_out_pages=(meta_tags_for_logged_out_pages); end

  def meta_tags_for_logged_out_pages?(); end

  def module_name(); end

  def name(); end

  def on_unauthorized_access(); end

  def on_unauthorized_access=(on_unauthorized_access); end

  def on_unauthorized_access?(); end

  def order_clause(); end

  def order_clause=(order_clause); end

  def order_clause?(); end

  def parse_page_registration_block(config, &block); end

  def parse_registration_block(config, &block); end

  def permitted_params(); end

  def permitted_params=(permitted_params); end

  def permitted_params?(); end

  def pundit_default_policy(); end

  def pundit_default_policy=(pundit_default_policy); end

  def pundit_default_policy?(); end

  def register(resource_class, options=T.unsafe(nil), &block); end

  def register_module(); end

  def register_page(name, options=T.unsafe(nil), &block); end

  def register_page_controller(config); end

  def register_resource_controller(config); end

  def reset_menu!(); end

  def resource_for(klass); end

  def resources(); end

  def root?(); end

  def root_to(); end

  def root_to=(root_to); end

  def root_to?(); end

  def root_to_options(); end

  def root_to_options=(root_to_options); end

  def root_to_options?(); end

  def route_options(); end

  def route_options=(route_options); end

  def route_options?(); end

  def route_prefix(); end

  def scopes_show_count(); end

  def scopes_show_count=(scopes_show_count); end

  def scopes_show_count?(); end

  def site_title(); end

  def site_title=(site_title); end

  def site_title?(); end

  def site_title_image(); end

  def site_title_image=(site_title_image); end

  def site_title_image?(); end

  def site_title_link(); end

  def site_title_link=(site_title_link); end

  def site_title_link?(); end

  def unload!(); end

  def unload_resources!(); end

  def unsupported_browser_matcher(); end

  def unsupported_browser_matcher=(unsupported_browser_matcher); end

  def unsupported_browser_matcher?(); end

  def view_factory(); end

  def view_factory=(view_factory); end

  def view_factory?(); end
  RegisterEvent = ::T.let(nil, ::T.untyped)
end

class ActiveAdmin::Namespace::Store
  include ::Enumerable
  def [](*args, &block); end

  def []=(*args, &block); end

  def each(&block); end

  def empty?(*args, &block); end

  def names(); end
end

class ActiveAdmin::Namespace::Store
end

class ActiveAdmin::Namespace
  extend ::ActiveAdmin::Settings::ClassMethods
end

class ActiveAdmin::NoMenuError
end

class ActiveAdmin::NoMenuError
end

module ActiveAdmin::OptionalDisplay
  def display_on?(action, render_context=T.unsafe(nil)); end
end

module ActiveAdmin::OptionalDisplay
  extend ::T::Sig
end

class ActiveAdmin::OrderClause
  def active_admin_config(); end

  def apply(chain); end

  def custom_sql(); end

  def field(); end

  def initialize(active_admin_config, clause); end

  def order(); end

  def sql(); end

  def table(); end

  def table_column(); end

  def to_sql(); end

  def valid?(); end
end

class ActiveAdmin::OrderClause
end

module ActiveAdmin::OutputSafetyHelper
  def to_sentence(array, options=T.unsafe(nil)); end
end

module ActiveAdmin::OutputSafetyHelper
  extend ::T::Sig
end

class ActiveAdmin::Page
  include ::ActiveAdmin::Page::Base
  include ::ActiveAdmin::Resource::Controllers
  include ::ActiveAdmin::Resource::PagePresenters
  include ::ActiveAdmin::Resource::Sidebars
  include ::ActiveAdmin::Resource::ActionItems
  include ::ActiveAdmin::Resource::Menu
  include ::ActiveAdmin::Resource::Naming
  include ::ActiveAdmin::Resource::Routes
  def add_default_sidebar_sections(); end

  def belongs_to(target, options=T.unsafe(nil)); end

  def belongs_to?(); end

  def belongs_to_config(); end

  def breadcrumb(); end

  def breadcrumb=(breadcrumb); end

  def camelized_resource_name(); end

  def clear_page_actions!(); end

  def name(); end

  def namespace(); end

  def namespace_name(); end

  def order_clause(); end

  def page_actions(); end

  def plural_resource_label(); end

  def underscored_resource_name(); end
end

module ActiveAdmin::Page::Base
  def initialize(namespace, name, options); end
end

module ActiveAdmin::Page::Base
  extend ::T::Sig
end

class ActiveAdmin::Page
end

class ActiveAdmin::PageController
  def clear_page_actions!(); end
  ACTIVE_ADMIN_ACTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveAdmin::PageController
end

class ActiveAdmin::PageDSL
  def belongs_to(target, options=T.unsafe(nil)); end

  def content(options=T.unsafe(nil), &block); end

  def page_action(name, options=T.unsafe(nil), &block); end
end

class ActiveAdmin::PageDSL
end

class ActiveAdmin::PagePresenter
  def [](key); end

  def block(); end

  def fetch(*args, &block); end

  def has_key?(*args, &block); end

  def initialize(options=T.unsafe(nil), &block); end

  def options(); end
end

class ActiveAdmin::PagePresenter
end

class ActiveAdmin::PunditAdapter
  def format_action(action, subject); end

  def retrieve_policy(subject); end
end

class ActiveAdmin::PunditAdapter
end

module ActiveAdmin::Reloader
end

module ActiveAdmin::Reloader
  extend ::T::Sig
  def self.to_complete(*args, &block); end

  def self.to_prepare(*args, &block); end
end

class ActiveAdmin::Resource
  include ::MethodOrProcHelper
  include ::ActiveAdmin::Resource::Base
  include ::ActiveAdmin::Resource::ActionItems
  include ::ActiveAdmin::Authorization
  include ::ActiveAdmin::Resource::Controllers
  include ::ActiveAdmin::Resource::Menu
  include ::ActiveAdmin::Resource::Naming
  include ::ActiveAdmin::Resource::PagePresenters
  include ::ActiveAdmin::Resource::Pagination
  include ::ActiveAdmin::Resource::Scopes
  include ::ActiveAdmin::Resource::Includes
  include ::ActiveAdmin::Resource::ScopeTo
  include ::ActiveAdmin::Resource::Sidebars
  include ::ActiveAdmin::Resource::Routes
  include ::ActiveAdmin::Resource::Ordering
  include ::ActiveAdmin::Resource::Attributes
  include ::ActiveAdmin::Filters::ResourceExtension
  include ::ActiveAdmin::Comments::ResourceHelper
  include ::ActiveAdmin::BatchActions::ResourceExtension
  def association_columns(); end

  def belongs_to(target, options=T.unsafe(nil)); end

  def belongs_to?(); end

  def belongs_to_config(); end

  def belongs_to_param(); end

  def breadcrumb(); end

  def breadcrumb=(breadcrumb); end

  def clear_collection_actions!(); end

  def clear_member_actions!(); end

  def collection_actions(); end

  def comments(); end

  def comments=(comments); end

  def content_columns(); end

  def create_another(); end

  def create_another=(create_another); end

  def csv_builder(); end

  def csv_builder=(csv_builder); end

  def decorator_class(); end

  def decorator_class_name(); end

  def decorator_class_name=(decorator_class_name); end

  def defined_actions(); end

  def dsl(); end

  def dsl=(dsl); end

  def find_resource(id); end

  def member_actions(); end

  def namespace(); end

  def order_clause(); end

  def order_clause=(order_clause); end

  def resource_attributes(); end

  def resource_class(); end

  def resource_class_name(); end

  def resource_column_names(); end

  def resource_columns(); end

  def resource_quoted_column_name(column); end

  def resource_table_name(); end

  def sort_order(); end

  def sort_order=(sort_order); end
  RegisterEvent = ::T.let(nil, ::T.untyped)
end

module ActiveAdmin::Resource::ActionItems
  def action_items(); end

  def action_items?(); end

  def action_items_for(action, render_context=T.unsafe(nil)); end

  def add_action_item(name, options=T.unsafe(nil), &block); end

  def clear_action_items!(); end

  def initialize(*args); end

  def remove_action_item(name); end
end

module ActiveAdmin::Resource::ActionItems
  extend ::T::Sig
end

module ActiveAdmin::Resource::Attributes
  def counter_cache_col?(c); end

  def default_attributes(); end

  def foreign_methods(); end

  def method_for_column(c); end

  def primary_col?(c); end

  def reject_col?(c); end

  def sti_col?(c); end
end

module ActiveAdmin::Resource::Attributes
  extend ::T::Sig
end

module ActiveAdmin::Resource::Base
  def initialize(namespace, resource_class, options=T.unsafe(nil)); end
end

module ActiveAdmin::Resource::Base
  extend ::T::Sig
end

class ActiveAdmin::Resource::BelongsTo
  def initialize(owner, target_name, options=T.unsafe(nil)); end

  def namespace(); end

  def optional?(); end

  def owner(); end

  def required?(); end

  def resource(); end

  def target(); end
end

class ActiveAdmin::Resource::BelongsTo::TargetNotFound
  def initialize(key, namespace); end
end

class ActiveAdmin::Resource::BelongsTo::TargetNotFound
end

class ActiveAdmin::Resource::BelongsTo
end

module ActiveAdmin::Resource::Controllers
  def controller(); end

  def controller_name(); end

  def resources_configuration(*args, &block); end
end

module ActiveAdmin::Resource::Controllers
  extend ::T::Sig
end

module ActiveAdmin::Resource::Includes
  def includes(); end
end

module ActiveAdmin::Resource::Includes
  extend ::T::Sig
end

module ActiveAdmin::Resource::Menu
  def add_to_menu(menu_collection); end

  def default_menu_options(); end

  def include_in_menu?(); end

  def menu_item(); end

  def menu_item_options(); end

  def menu_item_options=(options); end

  def navigation_menu(); end

  def navigation_menu_name(); end

  def navigation_menu_name=(menu_name); end
end

module ActiveAdmin::Resource::Menu
  extend ::T::Sig
end

class ActiveAdmin::Resource::Name
  def eql?(other); end

  def hash(*args, &block); end

  def initialize(klass, name=T.unsafe(nil)); end

  def translate(options=T.unsafe(nil)); end
end

class ActiveAdmin::Resource::Name
end

module ActiveAdmin::Resource::Naming
  def param_key(); end

  def plural_resource_label(options=T.unsafe(nil)); end

  def resource_label(); end

  def resource_name(); end
end

module ActiveAdmin::Resource::Naming
  extend ::T::Sig
end

module ActiveAdmin::Resource::Ordering
  def ordering(); end
end

module ActiveAdmin::Resource::Ordering
  extend ::T::Sig
end

module ActiveAdmin::Resource::PagePresenters
  def default_index_class(); end

  def find_index_class(symbol_or_class); end

  def get_page_presenter(action, type=T.unsafe(nil)); end

  def page_presenters(); end

  def set_index_presenter(index_as, page_presenter); end

  def set_page_presenter(action, page_presenter); end
end

module ActiveAdmin::Resource::PagePresenters
  extend ::T::Sig
end

module ActiveAdmin::Resource::Pagination
  def initialize(*args); end

  def max_per_page(); end

  def max_per_page=(max_per_page); end

  def paginate(); end

  def paginate=(paginate); end

  def per_page(); end

  def per_page=(per_page); end
end

module ActiveAdmin::Resource::Pagination
  extend ::T::Sig
end

module ActiveAdmin::Resource::Routes
  def route_batch_action_path(params=T.unsafe(nil), additional_params=T.unsafe(nil)); end

  def route_builder(); end

  def route_collection_path(params=T.unsafe(nil), additional_params=T.unsafe(nil)); end

  def route_edit_instance_path(resource, additional_params=T.unsafe(nil)); end

  def route_instance_path(resource, additional_params=T.unsafe(nil)); end

  def route_prefix(); end

  def route_uncountable?(); end
end

module ActiveAdmin::Resource::Routes
  extend ::T::Sig
end

module ActiveAdmin::Resource::ScopeTo
  def scope_to(*args, &block); end

  def scope_to?(context=T.unsafe(nil)); end

  def scope_to_association_method(); end

  def scope_to_config(); end

  def scope_to_method(); end
end

module ActiveAdmin::Resource::ScopeTo
  extend ::T::Sig
end

module ActiveAdmin::Resource::Scopes
  def default_scope(context=T.unsafe(nil)); end

  def get_scope_by_id(id); end

  def scope(*args, &block); end

  def scopes(); end
end

module ActiveAdmin::Resource::Scopes
  extend ::T::Sig
end

module ActiveAdmin::Resource::Sidebars
  def clear_sidebar_sections!(); end

  def sidebar_sections(); end

  def sidebar_sections?(); end

  def sidebar_sections_for(action, render_context=T.unsafe(nil)); end
end

module ActiveAdmin::Resource::Sidebars
  extend ::T::Sig
end

class ActiveAdmin::Resource
end

class ActiveAdmin::ResourceCollection
  include ::Enumerable
  def [](obj); end

  def add(resource); end

  def each(&block); end

  def empty?(*args, &block); end

  def has_key?(*args, &block); end

  def keys(*args, &block); end

  def size(*args, &block); end

  def values(*args, &block); end
end

class ActiveAdmin::ResourceCollection::ConfigMismatch
  def initialize(existing, given); end
end

class ActiveAdmin::ResourceCollection::ConfigMismatch
end

class ActiveAdmin::ResourceCollection::IncorrectClass
  def initialize(existing, given); end
end

class ActiveAdmin::ResourceCollection::IncorrectClass
end

class ActiveAdmin::ResourceCollection
  extend ::Forwardable
end

class ActiveAdmin::ResourceController
  include ::ActiveAdmin::ResourceController::ActionBuilder
  include ::ActiveAdmin::ResourceController::Decorators
  include ::ActiveAdmin::ResourceController::DataAccess
  include ::ActiveAdmin::Callbacks
  include ::ActiveAdmin::ScopeChain
  include ::ActiveAdmin::ResourceController::Scoping
  include ::ActiveAdmin::ResourceController::Streaming
  include ::ActiveAdmin::ResourceController::Sidebars
  include ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
  include ::ActiveAdmin::BatchActions::Controller
end

module ActiveAdmin::ResourceController::ActionBuilder
end

module ActiveAdmin::ResourceController::ActionBuilder::ClassMethods
  def clear_collection_actions!(); end

  def clear_member_actions!(); end
end

module ActiveAdmin::ResourceController::ActionBuilder::ClassMethods
  extend ::T::Sig
end

module ActiveAdmin::ResourceController::ActionBuilder
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveAdmin::ResourceController::DataAccess
  def apply_authorization_scope(collection); end

  def apply_decorations(resource); end

  def apply_filtering(chain); end

  def apply_includes(chain); end

  def apply_pagination(chain); end

  def apply_scoping(chain); end

  def apply_sorting(chain); end

  def assign_attributes(resource, attributes); end

  def build_new_resource(); end

  def build_resource(); end

  def collection(); end

  def collection_applies(options=T.unsafe(nil)); end

  def collection_before_scope(); end

  def configured_per_page(); end

  def create_resource(object); end

  def current_scope(); end

  def destroy_resource(object); end

  def dynamic_per_page(); end

  def find_collection(options=T.unsafe(nil)); end

  def find_resource(); end

  def per_page(); end

  def resource(); end

  def save_resource(object); end

  def scoped_collection(); end

  def smart_resource_url(); end

  def update_resource(object, attributes); end
  COLLECTION_APPLIES = ::T.let(nil, ::T.untyped)
end

module ActiveAdmin::ResourceController::DataAccess
  extend ::T::Sig
  def self.included(base); end
end

module ActiveAdmin::ResourceController::Decorators
  def apply_collection_decorator(collection); end

  def apply_decorator(resource); end
end

class ActiveAdmin::ResourceController::Decorators::Wrapper
end

class ActiveAdmin::ResourceController::Decorators::Wrapper
  def self.draper_collection_decorator(); end

  def self.draper_collection_decorator?(decorator); end

  def self.find_collection_decorator(decorator); end

  def self.wrap(decorator); end

  def self.wrap!(parent, name); end
end

module ActiveAdmin::ResourceController::Decorators
  extend ::T::Sig
  def self.undecorate(resource); end
end

module ActiveAdmin::ResourceController::ResourceClassMethods
  def override_resource_class_methods!(); end
end

module ActiveAdmin::ResourceController::ResourceClassMethods
  extend ::T::Sig
end

module ActiveAdmin::ResourceController::Scoping
  def begin_of_association_chain(); end

  def method_for_association_chain(); end
end

module ActiveAdmin::ResourceController::Scoping
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveAdmin::ResourceController::Sidebars
  def skip_sidebar!(); end

  def skip_sidebar?(); end
end

module ActiveAdmin::ResourceController::Sidebars
  extend ::T::Sig
end

module ActiveAdmin::ResourceController::Streaming
  def csv_filename(); end

  def index(); end

  def stream_csv(); end

  def stream_resource(&block); end
end

module ActiveAdmin::ResourceController::Streaming
  extend ::T::Sig
end

class ActiveAdmin::ResourceController
  extend ::ActiveAdmin::ResourceController::ActionBuilder::ClassMethods
  extend ::ActiveAdmin::Callbacks::ClassMethods
  extend ::ActiveAdmin::ResourceController::ResourceClassMethods
  def self.active_admin_config=(config); end

  def self.after_build(method=T.unsafe(nil), &block); end

  def self.after_create(method=T.unsafe(nil), &block); end

  def self.after_destroy(method=T.unsafe(nil), &block); end

  def self.after_save(method=T.unsafe(nil), &block); end

  def self.after_update(method=T.unsafe(nil), &block); end

  def self.before_build(method=T.unsafe(nil), &block); end

  def self.before_create(method=T.unsafe(nil), &block); end

  def self.before_destroy(method=T.unsafe(nil), &block); end

  def self.before_save(method=T.unsafe(nil), &block); end

  def self.before_update(method=T.unsafe(nil), &block); end
end

class ActiveAdmin::ResourceDSL
  include ::ActiveAdmin::Filters::DSL
  def actions(*args, &block); end

  def after_build(*args, &block); end

  def after_create(*args, &block); end

  def after_destroy(*args, &block); end

  def after_save(*args, &block); end

  def after_update(*args, &block); end

  def before_build(*args, &block); end

  def before_create(*args, &block); end

  def before_destroy(*args, &block); end

  def before_save(*args, &block); end

  def before_update(*args, &block); end
end

class ActiveAdmin::ResourceDSL
end

class ActiveAdmin::Router
  def apply(router); end

  def define_resource_routes(router); end

  def define_root_routes(router); end

  def initialize(application); end

  def resource_routes(config); end
end

class ActiveAdmin::Router
end

class ActiveAdmin::Scope
  def default_block(); end

  def display_if_block(); end

  def id(); end

  def initialize(name, method=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def name(); end

  def scope_block(); end

  def scope_method(); end

  def show_count(); end
end

class ActiveAdmin::Scope
end

module ActiveAdmin::ScopeChain
  def scope_chain(scope, chain); end
end

module ActiveAdmin::ScopeChain
  extend ::T::Sig
end

module ActiveAdmin::Settings
  def read_default_setting(name); end
end

module ActiveAdmin::Settings::ClassMethods
  def default_settings(); end

  def deprecated_setting(name, default, message=T.unsafe(nil)); end

  def setting(name, default); end
end

module ActiveAdmin::Settings::ClassMethods
  extend ::T::Sig
end

module ActiveAdmin::Settings::Inheritance
end

module ActiveAdmin::Settings::Inheritance
  extend ::T::Sig
  def self.included(base); end
end

module ActiveAdmin::Settings
  extend ::T::Sig
  def self.included(base); end
end

class ActiveAdmin::SidebarSection
  include ::ActiveAdmin::OptionalDisplay
  def block(); end

  def block=(block); end

  def custom_class(); end

  def id(); end

  def initialize(name, options=T.unsafe(nil), &block); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def partial_name(); end

  def priority(); end

  def title(); end
end

class ActiveAdmin::SidebarSection
end

class ActiveAdmin::ViewFactory
end

class ActiveAdmin::ViewFactory
end

module ActiveAdmin::ViewHelpers
  include ::ActiveAdmin::ViewHelpers::ActiveAdminApplicationHelper
  include ::ActiveAdmin::ViewHelpers::AutoLinkHelper
  include ::ActiveAdmin::ViewHelpers::BreadcrumbHelper
  include ::ActiveAdmin::ViewHelpers::DisplayHelper
  include ::MethodOrProcHelper
  include ::ActiveAdmin::ViewHelpers::SidebarHelper
  include ::ActiveAdmin::ViewHelpers::FormHelper
  include ::ActiveAdmin::ViewHelpers::TitleHelper
  include ::ActiveAdmin::ViewHelpers::ViewFactoryHelper
  include ::ActiveAdmin::ViewHelpers::FlashHelper
  include ::ActiveAdmin::ViewHelpers::ScopeNameHelper
  include ::ActiveAdmin::Filters::ViewHelper
  include ::UrlHelper
  include ::AdminHelper
end

module ActiveAdmin::ViewHelpers::ActiveAdminApplicationHelper
  def active_admin_application(); end
end

module ActiveAdmin::ViewHelpers::ActiveAdminApplicationHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers::AutoLinkHelper
  def active_admin_resource_for(klass); end

  def auto_link(resource, content=T.unsafe(nil)); end

  def auto_url_for(resource); end
end

module ActiveAdmin::ViewHelpers::AutoLinkHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers::BreadcrumbHelper
  def breadcrumb_links(path=T.unsafe(nil)); end
end

module ActiveAdmin::ViewHelpers::BreadcrumbHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers::DisplayHelper
  def association_methods_for(resource); end

  def boolean_attr?(resource, attr, value); end

  def display_name(resource); end

  def display_name_method_for(resource); end

  def find_value(resource, attr); end

  def format_attribute(resource, attr); end

  def pretty_format(object); end
  DISPLAY_NAME_FALLBACK = ::T.let(nil, ::T.untyped)
end

module ActiveAdmin::ViewHelpers::DisplayHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
  def build_download_format_links(formats=T.unsafe(nil)); end

  def build_download_formats(download_links); end
end

module ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
  extend ::T::Sig
  def self.included(base); end
end

module ActiveAdmin::ViewHelpers::FlashHelper
  def flash_messages(); end
end

module ActiveAdmin::ViewHelpers::FlashHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers::FormHelper
  def active_admin_form_for(resource, options=T.unsafe(nil), &block); end

  def fields_for_params(params, options=T.unsafe(nil)); end

  def hidden_field_tags_for(params, options=T.unsafe(nil)); end
end

module ActiveAdmin::ViewHelpers::FormHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers::ScopeNameHelper
  def scope_name(scope); end
end

module ActiveAdmin::ViewHelpers::ScopeNameHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers::SidebarHelper
  def skip_sidebar!(); end

  def skip_sidebar?(); end
end

module ActiveAdmin::ViewHelpers::SidebarHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers::TitleHelper
  def title(_title); end
end

module ActiveAdmin::ViewHelpers::TitleHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers::ViewFactoryHelper
  def view_factory(); end
end

module ActiveAdmin::ViewHelpers::ViewFactoryHelper
  extend ::T::Sig
end

module ActiveAdmin::ViewHelpers
  extend ::T::Sig
end

module ActiveAdmin::Views
end

class ActiveAdmin::Views::ActionItems
  def build(action_items); end
end

class ActiveAdmin::Views::ActionItems
end

class ActiveAdmin::Views::ActiveAdminForm
  def actions(*args, &block); end

  def add_create_another_checkbox(); end

  def build(resource, options=T.unsafe(nil), &block); end

  def commit_action_with_cancel_link(); end

  def form_buffers(); end

  def has_many(*args, &block); end

  def input(*args); end

  def inputs(*args, &block); end

  def multipart?(); end

  def object(); end
end

class ActiveAdmin::Views::ActiveAdminForm
end

class ActiveAdmin::Views::AttributesTable
  def build(obj, *attrs); end

  def build_colgroups(); end

  def content_for(record, attr); end

  def empty_value(); end

  def header_content_for(attr); end

  def row(*args, &block); end

  def rows(*attrs); end

  def single_record?(); end
end

class ActiveAdmin::Views::AttributesTable
end

class ActiveAdmin::Views::BlankSlate
  def build(content); end
end

class ActiveAdmin::Views::BlankSlate
end

class ActiveAdmin::Views::Column
  def build(options=T.unsafe(nil)); end

  def max_width(); end

  def max_width=(max_width); end

  def min_width(); end

  def min_width=(min_width); end

  def set_column_styles(column_width, margin_width, is_last_column=T.unsafe(nil)); end

  def span_size(); end

  def span_size=(span_size); end
end

class ActiveAdmin::Views::Column
end

class ActiveAdmin::Views::Columns
  def add_child(*_); end

  def calculate_columns!(); end

  def column(*args, &block); end

  def columns(); end

  def columns_span_count(); end

  def margin_size(); end
end

class ActiveAdmin::Views::Columns
end

class ActiveAdmin::Views::DropdownMenu
  def build(name, options=T.unsafe(nil)); end

  def item(*args); end
end

class ActiveAdmin::Views::DropdownMenu
end

class ActiveAdmin::Views::Footer
  def build(namespace); end

  def footer?(); end
end

class ActiveAdmin::Views::Footer
end

class ActiveAdmin::Views::FormtasticProxy
  def split_string_on(string, match); end
end

class ActiveAdmin::Views::FormtasticProxy
end

class ActiveAdmin::Views::HasManyProxy
  def build(form_builder, *args, &block); end
end

class ActiveAdmin::Views::HasManyProxy
end

class ActiveAdmin::Views::Header
  def build(namespace, menu); end

  def build_global_navigation(); end

  def build_site_title(); end

  def build_utility_navigation(); end
end

class ActiveAdmin::Views::Header
end

class ActiveAdmin::Views::IndexAsBlock
  def build(page_presenter, collection); end
end

class ActiveAdmin::Views::IndexAsBlock
  def self.index_name(); end
end

class ActiveAdmin::Views::IndexAsBlog
  def body(method=T.unsafe(nil), &block); end

  def build(page_presenter, collection); end

  def title(method=T.unsafe(nil), &block); end
end

class ActiveAdmin::Views::IndexAsBlog
  def self.index_name(); end
end

class ActiveAdmin::Views::IndexAsGrid
  def build(page_presenter, collection); end

  def build_empty_cell(); end

  def build_item(item); end

  def build_row(group); end

  def build_table(); end

  def default_number_of_columns(); end

  def number_of_columns(); end
end

class ActiveAdmin::Views::IndexAsGrid
  def self.index_name(); end
end

class ActiveAdmin::Views::IndexAsTable
  def build(page_presenter, collection); end

  def default_table(); end
end

class ActiveAdmin::Views::IndexAsTable::IndexTableFor
  def actions(options=T.unsafe(nil), &block); end

  def default_actions(); end

  def id_column(); end

  def index_column(start_value=T.unsafe(nil)); end

  def selectable_column(); end
end

class ActiveAdmin::Views::IndexAsTable::IndexTableFor::TableActions
  def item(*args); end
end

class ActiveAdmin::Views::IndexAsTable::IndexTableFor::TableActions
end

class ActiveAdmin::Views::IndexAsTable::IndexTableFor
end

class ActiveAdmin::Views::IndexAsTable
  def self.index_name(); end
end

class ActiveAdmin::Views::IndexList
  include ::ActiveAdmin::Helpers::Collection
  def build(index_classes); end

  def build_index_list(index_class); end

  def classes_for_index(index_class); end

  def current_filter_search_empty?(); end

  def current_index?(index_class); end
end

class ActiveAdmin::Views::IndexList
end

module ActiveAdmin::Views::Pages
end

class ActiveAdmin::Views::Pages::Base
  def active_admin_config(*args, &block); end

  def controller(*args, &block); end

  def params(*args, &block); end
end

class ActiveAdmin::Views::Pages::Base
end

class ActiveAdmin::Views::Pages::Form
  def form_presenter(); end
end

class ActiveAdmin::Views::Pages::Form
end

class ActiveAdmin::Views::Pages::Index
  include ::ActiveAdmin::Helpers::Collection
  include ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
  def any_table_tools?(); end

  def build_batch_actions_selector(); end

  def build_collection(); end

  def build_index_list(); end

  def build_scopes(); end

  def build_table_tools(); end

  def config(); end

  def find_index_renderer_class(klass); end

  def items_in_collection?(); end

  def render_blank_slate(); end

  def render_empty_results(); end

  def render_index(); end

  def wrap_with_batch_action_form(&block); end
end

class ActiveAdmin::Views::Pages::Index
end

class ActiveAdmin::Views::Pages::Layout
end

class ActiveAdmin::Views::Pages::Layout
end

class ActiveAdmin::Views::Pages::Page
  def page_presenter(); end
end

class ActiveAdmin::Views::Pages::Page
end

class ActiveAdmin::Views::Pages::Show
  include ::ActiveAdmin::Views::Pages::Show::DefaultMainContent
  include ::ActiveAdmin::Comments::ShowPageHelper
  def attributes_table(*args, &block); end

  def config(); end

  def default_title(); end
end

module ActiveAdmin::Views::Pages::Show::DefaultMainContent
  def default_attribute_table_rows(); end

  def default_main_content(&block); end
end

module ActiveAdmin::Views::Pages::Show::DefaultMainContent
  extend ::T::Sig
end

class ActiveAdmin::Views::Pages::Show
end

module ActiveAdmin::Views::Pages
  extend ::T::Sig
end

class ActiveAdmin::Views::PaginatedCollection
  include ::ActiveAdmin::Helpers::Collection
  include ::ActiveAdmin::ViewHelpers::DownloadFormatLinksHelper
  def add_child(*args, &block); end

  def build(collection, options=T.unsafe(nil)); end

  def build_pagination(); end

  def build_pagination_with_formats(options); end

  def build_per_page_select(); end

  def collection(); end

  def page_entries_info(options=T.unsafe(nil)); end
end

class ActiveAdmin::Views::PaginatedCollection
end

class ActiveAdmin::Views::Panel
  def build(title, attributes=T.unsafe(nil)); end

  def header_action(*args); end
end

class ActiveAdmin::Views::Panel
end

class ActiveAdmin::Views::Scopes
  include ::ActiveAdmin::ScopeChain
  include ::ActiveAdmin::Helpers::Collection
  def build(scopes, options=T.unsafe(nil)); end

  def build_scope(scope, options); end

  def classes_for_scope(scope); end

  def current_scope?(scope); end

  def get_scope_count(scope); end
end

class ActiveAdmin::Views::Scopes
end

class ActiveAdmin::Views::SemanticActionsProxy
  def build(form_builder, *args, &block); end
end

class ActiveAdmin::Views::SemanticActionsProxy
end

class ActiveAdmin::Views::SemanticInputsProxy
  def build(form_builder, *args, &block); end
end

class ActiveAdmin::Views::SemanticInputsProxy
end

class ActiveAdmin::Views::SidebarSection
  include ::ActiveAdmin::OutputSafetyHelper
  def attributes_table(*args, &block); end

  def build(section); end

  def build_sidebar_content(); end
end

class ActiveAdmin::Views::SidebarSection
end

class ActiveAdmin::Views::SiteTitle
  def build(namespace); end

  def site_title_image?(); end

  def site_title_link?(); end
end

class ActiveAdmin::Views::SiteTitle
end

class ActiveAdmin::Views::StatusTag
  def convert_to_boolean_status(status); end

  def status_to_class(status); end
end

class ActiveAdmin::Views::StatusTag
end

class ActiveAdmin::Views::TabbedNavigation
  def build(menu, options=T.unsafe(nil)); end

  def menu(); end

  def menu_items(); end
end

class ActiveAdmin::Views::TabbedNavigation
end

class ActiveAdmin::Views::TableFor
  def build(obj, *attrs); end

  def build_table(); end

  def build_table_body(); end

  def build_table_cell(col, resource); end

  def build_table_head(); end

  def build_table_header(col); end

  def column(*args, &block); end

  def columns(*attrs); end

  def current_sort(); end

  def default_options(); end

  def order_for_sort_key(sort_key); end

  def sortable?(); end
end

class ActiveAdmin::Views::TableFor::Column
  def data(); end

  def data=(data); end

  def html_class(); end

  def html_class=(html_class); end

  def initialize(*args, &block); end

  def pretty_title(); end

  def sort_key(); end

  def sortable?(); end

  def title(); end

  def title=(title); end
end

class ActiveAdmin::Views::TableFor::Column
end

class ActiveAdmin::Views::TableFor
end

class ActiveAdmin::Views::Tabs
  def build(&block); end

  def build_content_item(title, options, &block); end

  def build_menu_item(title, options, &block); end

  def tab(title, options=T.unsafe(nil), &block); end
end

class ActiveAdmin::Views::Tabs
end

class ActiveAdmin::Views::TitleBar
  def build(title, action_items); end
end

class ActiveAdmin::Views::TitleBar
end

class ActiveAdmin::Views::UnsupportedBrowser
  def build(); end
end

class ActiveAdmin::Views::UnsupportedBrowser
end

module ActiveAdmin::Views
  extend ::T::Sig
end

module ActiveAdmin
  extend ::T::Sig
  def self.after_load(&block); end

  def self.application(); end

  def self.application=(application); end

  def self.before_load(&block); end

  def self.load!(*args, &block); end

  def self.register(*args, &block); end

  def self.register_page(*args, &block); end

  def self.routes(*args, &block); end

  def self.setup(); end

  def self.unload!(*args, &block); end
end

module ActiveJob
end

module ActiveJob::Arguments
  def deserialize(arguments); end

  def serialize(arguments); end
  TYPE_WHITELIST = ::T.let(nil, ::T.untyped)
end

module ActiveJob::Arguments
  extend ::ActiveJob::Arguments
  extend ::T::Sig
end

class ActiveJob::Base
  include ::ActiveJob::Core
  include ::ActiveJob::QueueAdapter
  include ::ActiveJob::QueueName
  include ::ActiveJob::QueuePriority
  include ::ActiveJob::Enqueuing
  include ::ActiveSupport::Rescuable
  include ::ActiveJob::Execution
  include ::ActiveSupport::Callbacks
  include ::ActiveJob::Callbacks
  include ::ActiveJob::Exceptions
  include ::ActiveJob::Logging
  include ::ActiveJob::Translation
  include ::Raven::Rails::ActiveJobExtensions
  include ::ActiveJob::TestHelper::TestQueueAdapter
  def __callbacks(); end

  def __callbacks?(); end

  def _enqueue_callbacks(); end

  def _perform_callbacks(); end

  def _run_enqueue_callbacks(&block); end

  def _run_perform_callbacks(&block); end

  def arguments(); end

  def arguments=(arguments); end

  def executions(); end

  def executions=(executions); end

  def job_id(); end

  def job_id=(job_id); end

  def locale(); end

  def locale=(locale); end

  def logger(); end

  def logger=(obj); end

  def priority=(priority); end

  def provider_job_id(); end

  def provider_job_id=(provider_job_id); end

  def queue_name=(queue_name); end

  def rescue_handlers(); end

  def rescue_handlers=(val); end

  def rescue_handlers?(); end

  def scheduled_at(); end

  def scheduled_at=(scheduled_at); end

  def serialized_arguments=(serialized_arguments); end
end

class ActiveJob::Base
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._enqueue_callbacks(); end

  def self._enqueue_callbacks=(value); end

  def self._perform_callbacks(); end

  def self._perform_callbacks=(value); end

  def self._queue_adapter(); end

  def self._queue_adapter=(val); end

  def self._queue_adapter_name(); end

  def self._queue_adapter_name=(val); end

  def self._test_adapter(); end

  def self._test_adapter=(val); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.priority(); end

  def self.priority=(val); end

  def self.priority?(); end

  def self.queue_name(); end

  def self.queue_name=(val); end

  def self.queue_name?(); end

  def self.queue_name_delimiter(); end

  def self.queue_name_delimiter=(val); end

  def self.queue_name_delimiter?(); end

  def self.rescue_handlers(); end

  def self.rescue_handlers=(val); end

  def self.rescue_handlers?(); end
end

module ActiveJob::Callbacks
end

module ActiveJob::Callbacks
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Callbacks
  extend ::T::Sig
  def self.__callbacks(); end

  def self.__callbacks?(); end

  def self._execute_callbacks(); end

  def self._run_execute_callbacks(&block); end
end

class ActiveJob::ConfiguredJob
  def initialize(job_class, options=T.unsafe(nil)); end

  def perform_later(*args); end

  def perform_now(*args); end
end

class ActiveJob::ConfiguredJob
end

module ActiveJob::Core
  def deserialize(job_data); end

  def initialize(*arguments); end

  def serialize(); end
end

module ActiveJob::Core
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveJob::DeserializationError
  def initialize(); end
end

class ActiveJob::DeserializationError
end

module ActiveJob::Enqueuing
  def enqueue(options=T.unsafe(nil)); end
end

module ActiveJob::Enqueuing
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveJob::Exceptions
  def retry_job(options=T.unsafe(nil)); end
end

module ActiveJob::Exceptions
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveJob::Execution
  def perform(*_); end

  def perform_now(); end
end

module ActiveJob::Execution
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveJob::Logging
end

module ActiveJob::Logging
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveJob::QueueAdapter
end

module ActiveJob::QueueAdapter
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveJob::QueueAdapters
end

class ActiveJob::QueueAdapters::AsyncAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def immediate=(immediate); end

  def initialize(**executor_options); end

  def shutdown(wait: T.unsafe(nil)); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
  def initialize(job); end

  def perform(); end
end

class ActiveJob::QueueAdapters::AsyncAdapter::JobWrapper
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
  def enqueue(job, queue_name:); end

  def enqueue_at(job, timestamp, queue_name:); end

  def executor(); end

  def immediate(); end

  def immediate=(immediate); end

  def initialize(**options); end

  def shutdown(wait: T.unsafe(nil)); end
  DEFAULT_EXECUTOR_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveJob::QueueAdapters::AsyncAdapter::Scheduler
end

class ActiveJob::QueueAdapters::AsyncAdapter
end

class ActiveJob::QueueAdapters::InlineAdapter
  def enqueue(job); end

  def enqueue_at(*_); end
end

class ActiveJob::QueueAdapters::InlineAdapter
end

class ActiveJob::QueueAdapters::SidekiqAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end
end

class ActiveJob::QueueAdapters::SidekiqAdapter::JobWrapper
  include ::Sidekiq::Worker
  def perform(job_data); end

  def sidekiq_options_hash(); end

  def sidekiq_options_hash=(sidekiq_options_hash); end

  def sidekiq_retries_exhausted_block(); end

  def sidekiq_retries_exhausted_block=(sidekiq_retries_exhausted_block); end

  def sidekiq_retry_in_block(); end

  def sidekiq_retry_in_block=(sidekiq_retry_in_block); end
end

class ActiveJob::QueueAdapters::SidekiqAdapter::JobWrapper
  def self.sidekiq_options_hash(); end

  def self.sidekiq_options_hash=(val); end

  def self.sidekiq_retries_exhausted_block(); end

  def self.sidekiq_retries_exhausted_block=(val); end

  def self.sidekiq_retry_in_block(); end

  def self.sidekiq_retry_in_block=(val); end
end

class ActiveJob::QueueAdapters::SidekiqAdapter
end

class ActiveJob::QueueAdapters::TestAdapter
  def enqueue(job); end

  def enqueue_at(job, timestamp); end

  def enqueued_jobs(); end

  def enqueued_jobs=(enqueued_jobs); end

  def filter(); end

  def filter=(filter); end

  def perform_enqueued_at_jobs(); end

  def perform_enqueued_at_jobs=(perform_enqueued_at_jobs); end

  def perform_enqueued_jobs(); end

  def perform_enqueued_jobs=(perform_enqueued_jobs); end

  def performed_jobs(); end

  def performed_jobs=(performed_jobs); end

  def reject(); end

  def reject=(reject); end
end

class ActiveJob::QueueAdapters::TestAdapter
end

module ActiveJob::QueueAdapters
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.lookup(name); end
end

module ActiveJob::QueueName
  def queue_name(); end
end

module ActiveJob::QueueName
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveJob::QueuePriority
  def priority(); end
end

module ActiveJob::QueuePriority
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveJob::Railtie
end

class ActiveJob::Railtie
end

class ActiveJob::SerializationError
end

class ActiveJob::SerializationError
end

class ActiveJob::TestCase
  include ::ActiveJob::TestHelper
end

class ActiveJob::TestCase
end

module ActiveJob::TestHelper
  def after_teardown(); end

  def assert_enqueued_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil), queue: T.unsafe(nil)); end

  def assert_enqueued_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil)); end

  def assert_no_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil), &block); end

  def assert_no_performed_jobs(only: T.unsafe(nil), except: T.unsafe(nil), &block); end

  def assert_performed_jobs(number, only: T.unsafe(nil), except: T.unsafe(nil)); end

  def assert_performed_with(job: T.unsafe(nil), args: T.unsafe(nil), at: T.unsafe(nil), queue: T.unsafe(nil)); end

  def before_setup(); end

  def enqueued_jobs(*args, &block); end

  def enqueued_jobs=(arg); end

  def perform_enqueued_jobs(only: T.unsafe(nil), except: T.unsafe(nil)); end

  def performed_jobs(*args, &block); end

  def performed_jobs=(arg); end

  def queue_adapter(); end

  def queue_adapter_for_test(); end
end

module ActiveJob::TestHelper::TestQueueAdapter
end

module ActiveJob::TestHelper::TestQueueAdapter
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveJob::TestHelper
  extend ::T::Sig
end

module ActiveJob::Translation
end

module ActiveJob::Translation
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveJob::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveJob::VERSION
  extend ::T::Sig
end

module ActiveJob
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.gem_version(); end

  def self.version(); end
end

module ActiveModel
end

class ActiveModel::Attribute
  def ==(other); end

  def assigned?(); end

  def came_from_user?(); end

  def changed?(); end

  def changed_in_place?(); end

  def encode_with(coder); end

  def eql?(other); end

  def forgetting_assignment(); end

  def has_been_read?(); end

  def init_with(coder); end

  def initialize(name, value_before_type_cast, type, original_attribute=T.unsafe(nil)); end

  def initialized?(); end

  def name(); end

  def original_attribute(); end

  def original_value(); end

  def original_value_for_database(); end

  def type(); end

  def type_cast(*_); end

  def value(); end

  def value_before_type_cast(); end

  def value_for_database(); end

  def with_cast_value(value); end

  def with_type(type); end

  def with_value_from_database(value); end

  def with_value_from_user(value); end
end

class ActiveModel::Attribute::FromUser
  def type_cast(value); end
end

class ActiveModel::Attribute::FromUser
end

class ActiveModel::Attribute::UserProvidedDefault
  def initialize(name, value, type, database_default); end

  def marshal_dump(); end

  def marshal_load(values); end

  def user_provided_value(); end
end

class ActiveModel::Attribute::UserProvidedDefault
end

class ActiveModel::Attribute
  def self.from_database(name, value, type); end

  def self.from_user(name, value, type, original_attribute=T.unsafe(nil)); end

  def self.null(name); end

  def self.uninitialized(name, type); end

  def self.with_cast_value(name, value, type); end
end

module ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def assign_attributes(new_attributes); end

  def attributes=(new_attributes); end
end

module ActiveModel::AttributeAssignment
  extend ::T::Sig
end

module ActiveModel::AttributeMethods
  def attribute_missing(match, *args, &block); end

  def method_missing(method, *args, &block); end

  def respond_to?(method, include_private_methods=T.unsafe(nil)); end

  def respond_to_without_attributes?(*_); end
  CALL_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
  NAME_COMPILABLE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ActiveModel::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveModel::AttributeMutationTracker
  def any_changes?(); end

  def attributes(); end

  def change_to_attribute(attr_name); end

  def changed?(attr_name, from: T.unsafe(nil), to: T.unsafe(nil)); end

  def changed_attribute_names(); end

  def changed_in_place?(attr_name); end

  def changed_values(); end

  def changes(); end

  def force_change(attr_name); end

  def forced_changes(); end

  def forget_change(attr_name); end

  def initialize(attributes); end

  def original_value(attr_name); end
  OPTION_NOT_GIVEN = ::T.let(nil, ::T.untyped)
end

class ActiveModel::AttributeMutationTracker
end

class ActiveModel::AttributeSet
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def accessed(); end

  def attributes(); end

  def each_value(*args, &block); end

  def except(*args, &block); end

  def fetch(*args, &block); end

  def fetch_value(name); end

  def initialize(attributes); end

  def key?(name); end

  def keys(); end

  def map(&block); end

  def reset(key); end

  def to_h(); end

  def to_hash(); end

  def values_before_type_cast(); end

  def write_cast_value(name, value); end

  def write_from_database(name, value); end

  def write_from_user(name, value); end
end

class ActiveModel::AttributeSet::Builder
  def build_from_database(values=T.unsafe(nil), additional_types=T.unsafe(nil)); end

  def default_attributes(); end

  def initialize(types, default_attributes=T.unsafe(nil)); end

  def types(); end
end

class ActiveModel::AttributeSet::Builder
end

class ActiveModel::AttributeSet::YAMLEncoder
  def decode(coder); end

  def default_types(); end

  def encode(attribute_set, coder); end

  def initialize(default_types); end
end

class ActiveModel::AttributeSet::YAMLEncoder
end

class ActiveModel::AttributeSet
end

module ActiveModel::Attributes
  def attributes(); end

  def initialize(*_); end
end

module ActiveModel::Attributes::ClassMethods
  def attribute(name, type=T.unsafe(nil), **options); end
end

module ActiveModel::Attributes::ClassMethods
  extend ::T::Sig
end

module ActiveModel::Attributes
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveModel::BlockValidator
  def initialize(options, &block); end
end

class ActiveModel::BlockValidator
end

module ActiveModel::Callbacks
  def define_model_callbacks(*callbacks); end
end

module ActiveModel::Callbacks
  extend ::T::Sig
  def self.extended(base); end
end

module ActiveModel::Conversion
  def to_key(); end

  def to_model(); end

  def to_param(); end

  def to_partial_path(); end
end

module ActiveModel::Conversion
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveModel::Dirty
  def attribute_changed?(attr, from: T.unsafe(nil), to: T.unsafe(nil)); end

  def attribute_changed_in_place?(attr_name); end

  def attribute_previously_changed?(attr); end

  def attribute_was(attr); end

  def changed(); end

  def changed?(); end

  def changed_attributes(); end

  def changes(); end

  def changes_applied(); end

  def clear_attribute_changes(attr_names); end

  def clear_changes_information(); end

  def previous_changes(); end

  def restore_attributes(attributes=T.unsafe(nil)); end
end

module ActiveModel::Dirty
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveModel::EachValidator
  def attributes(); end

  def check_validity!(); end

  def initialize(options); end

  def validate_each(record, attribute, value); end
end

class ActiveModel::EachValidator
end

class ActiveModel::Errors
  include ::Enumerable
  def [](attribute); end

  def add(attribute, message=T.unsafe(nil), options=T.unsafe(nil)); end

  def added?(attribute, message=T.unsafe(nil), options=T.unsafe(nil)); end

  def clear(); end

  def copy!(other); end

  def count(); end

  def delete(key); end

  def details(); end

  def each(); end

  def empty?(); end

  def full_message(attribute, message); end

  def full_messages(); end

  def full_messages_for(attribute); end

  def generate_message(attribute, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def has_key?(attribute); end

  def include?(attribute); end

  def init_with(coder); end

  def initialize(base); end

  def key?(attribute); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(array); end

  def merge!(other); end

  def messages(); end

  def size(); end

  def to_a(); end

  def to_hash(full_messages=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def values(); end
  CALLBACKS_OPTIONS = ::T.let(nil, ::T.untyped)
  MESSAGE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Errors
end

class ActiveModel::ForbiddenAttributesError
end

class ActiveModel::ForbiddenAttributesError
end

module ActiveModel::ForbiddenAttributesProtection
end

module ActiveModel::ForbiddenAttributesProtection
  extend ::T::Sig
end

class ActiveModel::LazyAttributeHash
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def additional_types(); end

  def default_attributes(); end

  def delegate_hash(); end

  def each_key(*args, &block); end

  def each_value(*args, &block); end

  def except(*args, &block); end

  def fetch(*args, &block); end

  def initialize(types, values, additional_types, default_attributes, delegate_hash=T.unsafe(nil)); end

  def key?(key); end

  def marshal_dump(); end

  def marshal_load(values); end

  def materialize(); end

  def select(); end

  def transform_values(*args, &block); end

  def types(); end

  def values(); end
end

class ActiveModel::LazyAttributeHash
end

module ActiveModel::Lint
end

module ActiveModel::Lint::Tests
  def test_errors_aref(); end

  def test_model_naming(); end

  def test_persisted?(); end

  def test_to_key(); end

  def test_to_param(); end

  def test_to_partial_path(); end
end

module ActiveModel::Lint::Tests
  extend ::T::Sig
end

module ActiveModel::Lint
  extend ::T::Sig
end

class ActiveModel::MissingAttributeError
end

class ActiveModel::MissingAttributeError
end

module ActiveModel::Model
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(attributes=T.unsafe(nil)); end

  def persisted?(); end
end

module ActiveModel::Model
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveModel::Name
  include ::Comparable
  def !~(*args, &block); end

  def ==(arg); end

  def ===(arg); end

  def =~(*args, &block); end

  def as_json(*args, &block); end

  def cache_key(); end

  def collection(); end

  def element(); end

  def eql?(*args, &block); end

  def human(options=T.unsafe(nil)); end

  def i18n_key(); end

  def initialize(klass, namespace=T.unsafe(nil), name=T.unsafe(nil)); end

  def name(); end

  def param_key(); end

  def plural(); end

  def route_key(); end

  def singular(); end

  def singular_route_key(); end

  def to_s(*args, &block); end

  def to_str(*args, &block); end
end

class ActiveModel::Name
end

module ActiveModel::Naming
  def model_name(); end
end

module ActiveModel::Naming
  extend ::T::Sig
  def self.extended(base); end

  def self.param_key(record_or_class); end

  def self.plural(record_or_class); end

  def self.route_key(record_or_class); end

  def self.singular(record_or_class); end

  def self.singular_route_key(record_or_class); end

  def self.uncountable?(record_or_class); end
end

class ActiveModel::NullMutationTracker
  include ::Singleton
  def any_changes?(*_); end

  def change_to_attribute(attr_name); end

  def changed?(*_); end

  def changed_attribute_names(*_); end

  def changed_in_place?(*_); end

  def changed_values(*_); end

  def changes(*_); end

  def force_change(*_); end

  def forget_change(*_); end

  def original_value(*_); end
end

class ActiveModel::NullMutationTracker
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class ActiveModel::Railtie
end

class ActiveModel::Railtie
end

class ActiveModel::RangeError
end

class ActiveModel::RangeError
end

module ActiveModel::SecurePassword
  MAX_PASSWORD_LENGTH_ALLOWED = ::T.let(nil, ::T.untyped)
end

module ActiveModel::SecurePassword
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.min_cost(); end

  def self.min_cost=(min_cost); end
end

module ActiveModel::Serialization
  def read_attribute_for_serialization(*_); end

  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveModel::Serialization
  extend ::T::Sig
end

module ActiveModel::Serializers
end

module ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  def as_json(options=T.unsafe(nil)); end

  def from_json(json, include_root=T.unsafe(nil)); end
end

module ActiveModel::Serializers::JSON
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveModel::Serializers
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

class ActiveModel::StrictValidationFailed
end

class ActiveModel::StrictValidationFailed
end

module ActiveModel::Translation
  include ::ActiveModel::Naming
  def human_attribute_name(attribute, options=T.unsafe(nil)); end

  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveModel::Translation
  extend ::T::Sig
end

module ActiveModel::Type
end

class ActiveModel::Type::BigInteger
end

class ActiveModel::Type::BigInteger
end

class ActiveModel::Type::Binary
  def changed_in_place?(raw_old_value, value); end
end

class ActiveModel::Type::Binary::Data
  def ==(other); end

  def hex(); end

  def initialize(value); end

  def to_str(); end
end

class ActiveModel::Type::Binary::Data
end

class ActiveModel::Type::Binary
end

class ActiveModel::Type::Boolean
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Boolean
end

class ActiveModel::Type::Date
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Date
end

class ActiveModel::Type::DateTime
  include ::ActiveModel::Type::Helpers::TimeValue
end

class ActiveModel::Type::DateTime
end

class ActiveModel::Type::Decimal
  include ::ActiveModel::Type::Helpers::Numeric
  BIGDECIMAL_PRECISION = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Decimal
end

class ActiveModel::Type::Float
  include ::ActiveModel::Type::Helpers::Numeric
end

class ActiveModel::Type::Float
end

module ActiveModel::Type::Helpers
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
  def initialize(defaults: T.unsafe(nil)); end
end

class ActiveModel::Type::Helpers::AcceptsMultiparameterTime
end

module ActiveModel::Type::Helpers::Mutable
  def cast(value); end

  def changed_in_place?(raw_old_value, new_value); end
end

module ActiveModel::Type::Helpers::Mutable
  extend ::T::Sig
end

module ActiveModel::Type::Helpers::Numeric
  def cast(value); end

  def changed?(old_value, _new_value, new_value_before_type_cast); end
end

module ActiveModel::Type::Helpers::Numeric
  extend ::T::Sig
end

module ActiveModel::Type::Helpers::TimeValue
  def apply_seconds_precision(value); end

  def default_timezone(); end

  def is_utc?(); end

  def serialize(value); end

  def type_cast_for_schema(value); end

  def user_input_in_time_zone(value); end
  ISO_DATETIME = ::T.let(nil, ::T.untyped)
end

module ActiveModel::Type::Helpers::TimeValue
  extend ::T::Sig
end

module ActiveModel::Type::Helpers
  extend ::T::Sig
end

class ActiveModel::Type::ImmutableString
end

class ActiveModel::Type::ImmutableString
end

class ActiveModel::Type::Integer
  include ::ActiveModel::Type::Helpers::Numeric
  def initialize(*_); end

  def range(); end
  DEFAULT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveModel::Type::Integer
end

class ActiveModel::Type::Registration
  def block(); end

  def call(_registry, *args, **kwargs); end

  def initialize(name, block, **_); end

  def matches?(type_name, *args, **kwargs); end

  def name(); end
end

class ActiveModel::Type::Registration
end

class ActiveModel::Type::Registry
  def lookup(symbol, *args); end

  def register(type_name, klass=T.unsafe(nil), **options, &block); end

  def registrations(); end
end

class ActiveModel::Type::Registry
end

class ActiveModel::Type::String
end

class ActiveModel::Type::String
end

class ActiveModel::Type::Time
  include ::ActiveModel::Type::Helpers::TimeValue
end

class ActiveModel::Type::Time
end

class ActiveModel::Type::Value
  def ==(other); end

  def assert_valid_value(*_); end

  def binary?(); end

  def cast(value); end

  def changed?(old_value, new_value, _new_value_before_type_cast); end

  def changed_in_place?(raw_old_value, new_value); end

  def deserialize(value); end

  def eql?(other); end

  def force_equality?(_value); end

  def initialize(precision: T.unsafe(nil), limit: T.unsafe(nil), scale: T.unsafe(nil)); end

  def limit(); end

  def map(value); end

  def precision(); end

  def scale(); end

  def serialize(value); end

  def type(); end

  def type_cast_for_schema(value); end

  def value_constructed_by_mass_assignment?(_value); end
end

class ActiveModel::Type::Value
end

module ActiveModel::Type
  extend ::T::Sig
  def self.default_value(); end

  def self.lookup(*args, **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

class ActiveModel::UnknownAttributeError
  def attribute(); end

  def initialize(record, attribute); end

  def record(); end
end

class ActiveModel::UnknownAttributeError
end

module ActiveModel::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveModel::VERSION
  extend ::T::Sig
end

class ActiveModel::ValidationError
  def initialize(model); end

  def model(); end
end

class ActiveModel::ValidationError
end

module ActiveModel::Validations
  def errors(); end

  def invalid?(context=T.unsafe(nil)); end

  def read_attribute_for_validation(*_); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end

  def validate!(context=T.unsafe(nil)); end

  def validates_with(*args, &block); end
end

module ActiveModel::Validations::Callbacks
end

module ActiveModel::Validations::Callbacks
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveModel::Validations::HelperMethods
  def validates_absence_of(*attr_names); end

  def validates_acceptance_of(*attr_names); end

  def validates_confirmation_of(*attr_names); end

  def validates_exclusion_of(*attr_names); end

  def validates_format_of(*attr_names); end

  def validates_inclusion_of(*attr_names); end

  def validates_length_of(*attr_names); end

  def validates_numericality_of(*attr_names); end

  def validates_presence_of(*attr_names); end

  def validates_size_of(*attr_names); end
end

module ActiveModel::Validations::HelperMethods
  extend ::T::Sig
end

module ActiveModel::Validations
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveModel::Validator
  def initialize(options=T.unsafe(nil)); end

  def kind(); end

  def options(); end

  def validate(record); end
end

class ActiveModel::Validator
  def self.kind(); end
end

module ActiveModel
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.gem_version(); end

  def self.version(); end
end

class ActiveRecord::ActiveRecordError
end

class ActiveRecord::ActiveRecordError
end

class ActiveRecord::AdapterNotFound
end

class ActiveRecord::AdapterNotFound
end

class ActiveRecord::AdapterNotSpecified
end

class ActiveRecord::AdapterNotSpecified
end

module ActiveRecord::Aggregations
  def reload(*_); end
end

module ActiveRecord::Aggregations
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::AmbiguousSourceReflectionForThroughAssociation
  def initialize(klass, macro, association_name, options, possible_sources); end
end

class ActiveRecord::AmbiguousSourceReflectionForThroughAssociation
end

class ActiveRecord::AssociationNotFoundError
  def initialize(record=T.unsafe(nil), association_name=T.unsafe(nil)); end
end

class ActiveRecord::AssociationNotFoundError
end

class ActiveRecord::AssociationRelation
  def build(*args, &block); end

  def create(*args, &block); end

  def create!(*args, &block); end

  def initialize(klass, association); end

  def new(*args, &block); end

  def proxy_association(); end
end

class ActiveRecord::AssociationRelation
end

class ActiveRecord::AssociationTypeMismatch
end

class ActiveRecord::AssociationTypeMismatch
end

module ActiveRecord::Associations
  def association(name); end

  def association_cached?(name); end

  def reload(*_); end
end

class ActiveRecord::Associations::JoinDependency
  include ::Polyamorous::JoinDependencyExtensions
  def alias_tracker(); end

  def apply_column_aliases(relation); end

  def initialize(base, table, associations); end

  def instantiate(result_set, &block); end

  def join_constraints(joins_to_add, join_type, alias_tracker); end

  def join_root(); end

  def reflections(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases
  def column_alias(node, column); end

  def column_aliases(node); end

  def columns(); end

  def initialize(tables); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column
  def alias(); end

  def alias=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Column
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table
  def column_aliases(); end

  def columns(); end

  def columns=(_); end

  def node(); end

  def node=(_); end
end

class ActiveRecord::Associations::JoinDependency::Aliases::Table
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Associations::JoinDependency::Aliases
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation
  include ::Polyamorous::JoinAssociationExtensions
  include ::Polyamorous::SwappingReflectionClass
  def join_constraints(foreign_table, foreign_klass, join_type, alias_tracker); end

  def join_type(); end

  def reflection(); end

  def table=(table); end

  def tables(); end

  def tables=(tables); end
end

class ActiveRecord::Associations::JoinDependency::JoinAssociation
end

class ActiveRecord::Associations::JoinDependency::JoinBase
  def initialize(base_klass, table, children); end
end

class ActiveRecord::Associations::JoinDependency::JoinBase
end

class ActiveRecord::Associations::JoinDependency::JoinPart
  include ::Enumerable
  def base_klass(); end

  def children(); end

  def column_names(*args, &block); end

  def each(&block); end

  def each_children(&block); end

  def extract_record(row, column_names_with_alias); end

  def initialize(base_klass, children); end

  def instantiate(row, aliases, &block); end

  def match?(other); end

  def primary_key(*args, &block); end

  def table(); end

  def table_name(*args, &block); end
end

class ActiveRecord::Associations::JoinDependency::JoinPart
end

class ActiveRecord::Associations::JoinDependency
  extend ::Polyamorous::JoinDependencyExtensions::ClassMethods
  def self.make_tree(associations); end
end

module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
end

module ActiveRecord::AttributeAssignment
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::AttributeAssignmentError
  def attribute(); end

  def exception(); end

  def initialize(message=T.unsafe(nil), exception=T.unsafe(nil), attribute=T.unsafe(nil)); end
end

class ActiveRecord::AttributeAssignmentError
end

module ActiveRecord::AttributeDecorators
end

module ActiveRecord::AttributeDecorators
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods
  def [](attr_name); end

  def []=(attr_name, value); end

  def accessed_fields(); end

  def attribute_for_inspect(attr_name); end

  def attribute_method?(attr_name); end

  def attribute_names(); end

  def attribute_present?(attribute); end

  def attributes(); end

  def has_attribute?(attr_name); end

  def respond_to?(name, include_private=T.unsafe(nil)); end
  BLACKLISTED_CLASS_METHODS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  def attributes_before_type_cast(); end

  def read_attribute_before_type_cast(attr_name); end
end

module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Dirty
  def attribute_before_last_save(attr_name); end

  def attribute_change_to_be_saved(attr_name); end

  def attribute_in_database(attr_name); end

  def attributes_in_database(); end

  def changed_attribute_names_to_save(); end

  def changes_to_save(); end

  def has_changes_to_save?(); end

  def reload(*_); end

  def saved_change_to_attribute(attr_name); end

  def saved_change_to_attribute?(attr_name, **options); end

  def saved_changes(); end

  def saved_changes?(); end

  def will_save_change_to_attribute?(attr_name, **options); end
end

module ActiveRecord::AttributeMethods::Dirty
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::PrimaryKey
  def id(); end

  def id=(value); end

  def id?(); end

  def id_before_type_cast(); end

  def id_in_database(); end

  def id_was(); end

  def to_key(); end
end

module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Query
  def query_attribute(attr_name); end
end

module ActiveRecord::AttributeMethods::Query
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Read
  def _read_attribute(attr_name); end

  def read_attribute(attr_name, &block); end
end

module ActiveRecord::AttributeMethods::Read
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Serialization
end

module ActiveRecord::AttributeMethods::Serialization
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
end

module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods::Write
  def _write_attribute(attr_name, value); end

  def write_attribute(attr_name, value); end
end

module ActiveRecord::AttributeMethods::Write
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActiveRecord::Attributes
end

module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::AutosaveAssociation
  def changed_for_autosave?(); end

  def destroyed_by_association(); end

  def destroyed_by_association=(reflection); end

  def mark_for_destruction(); end

  def marked_for_destruction?(); end

  def reload(options=T.unsafe(nil)); end
end

module ActiveRecord::AutosaveAssociation
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::Base
  include ::ActiveRecord::Core
  include ::ActiveRecord::Persistence
  include ::ActiveRecord::ReadonlyAttributes
  include ::ActiveRecord::ModelSchema
  include ::ActiveRecord::Inheritance
  include ::ActiveRecord::Scoping
  include ::ActiveRecord::Scoping::Default
  include ::ActiveRecord::Scoping::Named
  include ::ActiveRecord::Sanitization
  include ::ActiveRecord::AttributeAssignment
  include ::ActiveModel::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::Conversion
  include ::ActiveRecord::Integration
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveRecord::Validations
  include ::ActiveRecord::CounterCache
  include ::ActiveRecord::Attributes
  include ::ActiveRecord::AttributeDecorators
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveRecord::Locking::Pessimistic
  include ::ActiveRecord::DefineCallbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::AttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::AttributeMethods::Dirty
  include ::ActiveRecord::AttributeMethods::Serialization
  include ::ActiveRecord::Callbacks
  include ::ActiveRecord::Timestamp
  include ::ActiveRecord::Associations
  include ::ActiveModel::SecurePassword
  include ::ActiveRecord::AutosaveAssociation
  include ::ActiveRecord::NestedAttributes
  include ::ActiveRecord::Aggregations
  include ::ActiveRecord::Transactions
  include ::ActiveRecord::TouchLater
  include ::ActiveRecord::NoTouching
  include ::ActiveRecord::Reflection
  include ::ActiveModel::Serializers::JSON
  include ::ActiveModel::Serialization
  include ::ActiveRecord::Serialization
  include ::ActiveRecord::Store
  include ::ActiveRecord::SecureToken
  include ::ActiveRecord::Suppressor
  include ::Kaminari::ActiveRecordExtension
  include ::PaperTrail::Model
  include ::CanCan::ModelAdditions
  include ::GlobalID::Identification
  def __callbacks(); end

  def __callbacks?(); end

  def _before_commit_callbacks(); end

  def _before_commit_without_transaction_enrollment_callbacks(); end

  def _commit_callbacks(); end

  def _commit_without_transaction_enrollment_callbacks(); end

  def _create_callbacks(); end

  def _destroy_callbacks(); end

  def _find_callbacks(); end

  def _initialize_callbacks(); end

  def _ransack_aliases(); end

  def _ransack_aliases=(val); end

  def _ransack_aliases?(); end

  def _ransackers(); end

  def _ransackers=(val); end

  def _ransackers?(); end

  def _reflections(); end

  def _reflections?(); end

  def _rollback_callbacks(); end

  def _rollback_without_transaction_enrollment_callbacks(); end

  def _run_before_commit_callbacks(&block); end

  def _run_before_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_commit_callbacks(&block); end

  def _run_commit_without_transaction_enrollment_callbacks(&block); end

  def _run_create_callbacks(&block); end

  def _run_destroy_callbacks(&block); end

  def _run_find_callbacks(&block); end

  def _run_initialize_callbacks(&block); end

  def _run_rollback_callbacks(&block); end

  def _run_rollback_without_transaction_enrollment_callbacks(&block); end

  def _run_save_callbacks(&block); end

  def _run_touch_callbacks(&block); end

  def _run_update_callbacks(&block); end

  def _run_validate_callbacks(&block); end

  def _run_validation_callbacks(&block); end

  def _save_callbacks(); end

  def _touch_callbacks(); end

  def _update_callbacks(); end

  def _validate_callbacks(); end

  def _validation_callbacks(); end

  def _validators(); end

  def _validators?(); end

  def aggregate_reflections(); end

  def aggregate_reflections?(); end

  def allow_unsafe_raw_sql(); end

  def attribute_aliases(); end

  def attribute_aliases?(); end

  def attribute_method_matchers(); end

  def attribute_method_matchers?(); end

  def cache_timestamp_format(); end

  def cache_timestamp_format?(); end

  def cache_versioning(); end

  def cache_versioning?(); end

  def column_for_attribute(*args, &block); end

  def default_connection_handler(); end

  def default_connection_handler?(); end

  def default_scope_override(); end

  def default_scopes(); end

  def default_timezone(); end

  def defined_enums(); end

  def defined_enums?(); end

  def dump_schema_after_migration(); end

  def dump_schemas(); end

  def error_on_ignored_order(); end

  def include_root_in_json(); end

  def include_root_in_json?(); end

  def index_nested_attribute_errors(); end

  def lock_optimistically(); end

  def lock_optimistically?(); end

  def logger(); end

  def model_name(*args, &block); end

  def nested_attributes_options(); end

  def nested_attributes_options?(); end

  def partial_writes(); end

  def partial_writes?(); end

  def pluralize_table_names(); end

  def pluralize_table_names?(); end

  def primary_key_prefix_type(); end

  def record_timestamps(); end

  def record_timestamps=(val); end

  def record_timestamps?(); end

  def schema_format(); end

  def skip_time_zone_conversion_for_attributes(); end

  def skip_time_zone_conversion_for_attributes?(); end

  def store_full_sti_class(); end

  def store_full_sti_class?(); end

  def table_name_prefix(); end

  def table_name_prefix?(); end

  def table_name_suffix(); end

  def table_name_suffix?(); end

  def time_zone_aware_attributes(); end

  def time_zone_aware_types(); end

  def time_zone_aware_types?(); end

  def timestamped_migrations(); end

  def type_for_attribute(*args, &block); end

  def validation_context(); end

  def verbose_query_logs(); end

  def warn_on_records_fetched_greater_than(); end
end

module ActiveRecord::Base::GeneratedAssociationMethods
end

module ActiveRecord::Base::GeneratedAssociationMethods
  extend ::T::Sig
end

class ActiveRecord::Base
  extend ::ActiveSupport::Benchmarkable
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::ConnectionHandling
  extend ::ActiveRecord::QueryCache::ClassMethods
  extend ::ActiveRecord::Querying
  extend ::ActiveRecord::Translation
  extend ::ActiveModel::Translation
  extend ::ActiveModel::Naming
  extend ::ActiveRecord::DynamicMatchers
  extend ::ActiveRecord::Explain
  extend ::ActiveRecord::Enum
  extend ::ActiveRecord::Delegation::DelegateCache
  extend ::ActiveRecord::CollectionCacheKey
  extend ::ActiveModel::Callbacks
  extend ::ActiveModel::Validations::HelperMethods
  extend ::Ransack::Adapters::ActiveRecord::Base
  extend ::OrmAdapter::ToAdapter
  extend ::ActiveStorage::Attached::Macros
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._attr_readonly(); end

  def self._attr_readonly=(val); end

  def self._attr_readonly?(); end

  def self._before_commit_callbacks(); end

  def self._before_commit_callbacks=(value); end

  def self._before_commit_without_transaction_enrollment_callbacks(); end

  def self._before_commit_without_transaction_enrollment_callbacks=(value); end

  def self._commit_callbacks(); end

  def self._commit_callbacks=(value); end

  def self._commit_without_transaction_enrollment_callbacks(); end

  def self._commit_without_transaction_enrollment_callbacks=(value); end

  def self._create_callbacks(); end

  def self._create_callbacks=(value); end

  def self._destroy_callbacks(); end

  def self._destroy_callbacks=(value); end

  def self._find_callbacks(); end

  def self._find_callbacks=(value); end

  def self._initialize_callbacks(); end

  def self._initialize_callbacks=(value); end

  def self._ransack_aliases(); end

  def self._ransack_aliases=(val); end

  def self._ransack_aliases?(); end

  def self._ransackers(); end

  def self._ransackers=(val); end

  def self._ransackers?(); end

  def self._reflections(); end

  def self._reflections=(val); end

  def self._reflections?(); end

  def self._rollback_callbacks(); end

  def self._rollback_callbacks=(value); end

  def self._rollback_without_transaction_enrollment_callbacks(); end

  def self._rollback_without_transaction_enrollment_callbacks=(value); end

  def self._save_callbacks(); end

  def self._save_callbacks=(value); end

  def self._touch_callbacks(); end

  def self._touch_callbacks=(value); end

  def self._update_callbacks(); end

  def self._update_callbacks=(value); end

  def self._validate_callbacks(); end

  def self._validate_callbacks=(value); end

  def self._validation_callbacks(); end

  def self._validation_callbacks=(value); end

  def self._validators(); end

  def self._validators=(val); end

  def self._validators?(); end

  def self.after_create(*args, &block); end

  def self.after_destroy(*args, &block); end

  def self.after_find(*args, &block); end

  def self.after_initialize(*args, &block); end

  def self.after_save(*args, &block); end

  def self.after_touch(*args, &block); end

  def self.after_update(*args, &block); end

  def self.aggregate_reflections(); end

  def self.aggregate_reflections=(val); end

  def self.aggregate_reflections?(); end

  def self.allow_unsafe_raw_sql(); end

  def self.allow_unsafe_raw_sql=(obj); end

  def self.around_create(*args, &block); end

  def self.around_destroy(*args, &block); end

  def self.around_save(*args, &block); end

  def self.around_update(*args, &block); end

  def self.attribute_aliases(); end

  def self.attribute_aliases=(val); end

  def self.attribute_aliases?(); end

  def self.attribute_method_matchers(); end

  def self.attribute_method_matchers=(val); end

  def self.attribute_method_matchers?(); end

  def self.attribute_type_decorations(); end

  def self.attribute_type_decorations=(val); end

  def self.attribute_type_decorations?(); end

  def self.attributes_to_define_after_schema_loads(); end

  def self.attributes_to_define_after_schema_loads=(val); end

  def self.attributes_to_define_after_schema_loads?(); end

  def self.before_create(*args, &block); end

  def self.before_destroy(*args, &block); end

  def self.before_save(*args, &block); end

  def self.before_update(*args, &block); end

  def self.belongs_to_required_by_default(); end

  def self.belongs_to_required_by_default=(obj); end

  def self.cache_timestamp_format(); end

  def self.cache_timestamp_format=(val); end

  def self.cache_timestamp_format?(); end

  def self.cache_versioning(); end

  def self.cache_versioning=(val); end

  def self.cache_versioning?(); end

  def self.configurations(); end

  def self.configurations=(config); end

  def self.connection_handler(); end

  def self.connection_handler=(handler); end

  def self.default_connection_handler(); end

  def self.default_connection_handler=(val); end

  def self.default_connection_handler?(); end

  def self.default_scope_override(); end

  def self.default_scope_override=(val); end

  def self.default_scopes(); end

  def self.default_scopes=(val); end

  def self.default_timezone(); end

  def self.default_timezone=(obj); end

  def self.defined_enums(); end

  def self.defined_enums=(val); end

  def self.defined_enums?(); end

  def self.dump_schema_after_migration(); end

  def self.dump_schema_after_migration=(obj); end

  def self.dump_schemas(); end

  def self.dump_schemas=(obj); end

  def self.error_on_ignored_order(); end

  def self.error_on_ignored_order=(obj); end

  def self.include_root_in_json(); end

  def self.include_root_in_json=(val); end

  def self.include_root_in_json?(); end

  def self.index_nested_attribute_errors(); end

  def self.index_nested_attribute_errors=(obj); end

  def self.internal_metadata_table_name(); end

  def self.internal_metadata_table_name=(val); end

  def self.internal_metadata_table_name?(); end

  def self.local_stored_attributes(); end

  def self.local_stored_attributes=(local_stored_attributes); end

  def self.lock_optimistically(); end

  def self.lock_optimistically=(val); end

  def self.lock_optimistically?(); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.maintain_test_schema(); end

  def self.maintain_test_schema=(obj); end

  def self.nested_attributes_options(); end

  def self.nested_attributes_options=(val); end

  def self.nested_attributes_options?(); end

  def self.partial_writes(); end

  def self.partial_writes=(val); end

  def self.partial_writes?(); end

  def self.pluralize_table_names(); end

  def self.pluralize_table_names=(val); end

  def self.pluralize_table_names?(); end

  def self.primary_key_prefix_type(); end

  def self.primary_key_prefix_type=(obj); end

  def self.record_timestamps(); end

  def self.record_timestamps=(val); end

  def self.record_timestamps?(); end

  def self.schema_format(); end

  def self.schema_format=(obj); end

  def self.schema_migrations_table_name(); end

  def self.schema_migrations_table_name=(val); end

  def self.schema_migrations_table_name?(); end

  def self.skip_time_zone_conversion_for_attributes(); end

  def self.skip_time_zone_conversion_for_attributes=(val); end

  def self.skip_time_zone_conversion_for_attributes?(); end

  def self.store_full_sti_class(); end

  def self.store_full_sti_class=(val); end

  def self.store_full_sti_class?(); end

  def self.table_name_prefix(); end

  def self.table_name_prefix=(val); end

  def self.table_name_prefix?(); end

  def self.table_name_suffix(); end

  def self.table_name_suffix=(val); end

  def self.table_name_suffix?(); end

  def self.time_zone_aware_attributes(); end

  def self.time_zone_aware_attributes=(obj); end

  def self.time_zone_aware_types(); end

  def self.time_zone_aware_types=(val); end

  def self.time_zone_aware_types?(); end

  def self.timestamped_migrations(); end

  def self.timestamped_migrations=(obj); end

  def self.verbose_query_logs(); end

  def self.verbose_query_logs=(obj); end

  def self.warn_on_records_fetched_greater_than(); end

  def self.warn_on_records_fetched_greater_than=(obj); end
end

module ActiveRecord::Batches
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end

  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil)); end
  ORDER_IGNORE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Batches::BatchEnumerator
  include ::Enumerable
  def delete_all(*args, &block); end

  def destroy_all(*args, &block); end

  def each(); end

  def each_record(); end

  def initialize(relation:, of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil)); end

  def update_all(*args, &block); end
end

class ActiveRecord::Batches::BatchEnumerator
end

module ActiveRecord::Batches
  extend ::T::Sig
end

module ActiveRecord::Calculations
  def average(column_name); end

  def calculate(operation, column_name); end

  def count(column_name=T.unsafe(nil)); end

  def ids(); end

  def maximum(column_name); end

  def minimum(column_name); end

  def pluck(*column_names); end

  def sum(column_name=T.unsafe(nil)); end
end

module ActiveRecord::Calculations
  extend ::T::Sig
end

module ActiveRecord::Callbacks
  def destroy(); end

  def increment!(*_, touch: T.unsafe(nil)); end

  def touch(*_); end
  CALLBACKS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Coders
end

class ActiveRecord::Coders::JSON
end

class ActiveRecord::Coders::JSON
  def self.dump(obj); end

  def self.load(json); end
end

class ActiveRecord::Coders::YAMLColumn
  def assert_valid_value(obj, action:); end

  def dump(obj); end

  def initialize(attr_name, object_class=T.unsafe(nil)); end

  def load(yaml); end

  def object_class(); end

  def object_class=(object_class); end
end

class ActiveRecord::Coders::YAMLColumn
end

module ActiveRecord::Coders
  extend ::T::Sig
end

module ActiveRecord::CollectionCacheKey
  def collection_cache_key(collection=T.unsafe(nil), timestamp_column=T.unsafe(nil)); end
end

module ActiveRecord::CollectionCacheKey
  extend ::T::Sig
end

class ActiveRecord::ConcurrentMigrationError
  DEFAULT_MESSAGE = ::T.let(nil, ::T.untyped)
  RELEASE_LOCK_FAILED_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConcurrentMigrationError
end

class ActiveRecord::ConfigurationError
end

class ActiveRecord::ConfigurationError
end

module ActiveRecord::ConnectionAdapters
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  def __callbacks(); end

  def __callbacks?(); end

  def _checkin_callbacks(); end

  def _checkout_callbacks(); end

  def _run_checkin_callbacks(&block); end

  def _run_checkout_callbacks(&block); end

  def active?(); end

  def adapter_name(); end

  def case_insensitive_comparison(table, attribute, column, value); end

  def case_sensitive_comparison(table, attribute, column, value); end

  def clear_cache!(); end

  def close(); end

  def column_name_for_operation(operation, node); end

  def column_name_from_arel_node(node); end

  def default_index_type?(index); end

  def delete(*_); end

  def disable_extension(name); end

  def disable_referential_integrity(); end

  def discard!(); end

  def disconnect!(); end

  def enable_extension(name); end

  def expire(); end

  def extensions(); end

  def get_advisory_lock(lock_id); end

  def in_use?(); end

  def index_algorithms(); end

  def initialize(connection, logger=T.unsafe(nil), config=T.unsafe(nil)); end

  def insert(*_); end

  def lease(); end

  def lock(); end

  def logger(); end

  def migration_context(); end

  def migrations_paths(); end

  def owner(); end

  def pool(); end

  def pool=(pool); end

  def prefetch_primary_key?(table_name=T.unsafe(nil)); end

  def prepared_statements(); end

  def raw_connection(); end

  def reconnect!(); end

  def release_advisory_lock(lock_id); end

  def requires_reloading?(); end

  def reset!(); end

  def rollback_db_transaction(*_); end

  def rollback_to_savepoint(*_); end

  def schema_cache(); end

  def schema_cache=(cache); end

  def seconds_idle(); end

  def steal!(); end

  def supports_advisory_locks?(); end

  def supports_bulk_alter?(); end

  def supports_comments?(); end

  def supports_comments_in_create?(); end

  def supports_datetime_with_precision?(); end

  def supports_ddl_transactions?(); end

  def supports_explain?(); end

  def supports_expression_index?(); end

  def supports_extensions?(); end

  def supports_foreign_keys?(); end

  def supports_foreign_keys_in_create?(); end

  def supports_foreign_tables?(); end

  def supports_index_sort_order?(); end

  def supports_indexes_in_create?(); end

  def supports_json?(); end

  def supports_multi_insert?(); end

  def supports_partial_index?(); end

  def supports_savepoints?(); end

  def supports_transaction_isolation?(); end

  def supports_validate_constraints?(); end

  def supports_views?(); end

  def supports_virtual_columns?(); end

  def unprepared_statement(); end

  def update(*_); end

  def valid_type?(type); end

  def verify!(); end

  def visitor(); end

  def visitor=(visitor); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  SIMPLE_INT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
  def accept(o); end

  def initialize(conn); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable
  def initialize(version_string); end
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
end

class ActiveRecord::ConnectionAdapters::AbstractAdapter
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._checkin_callbacks(); end

  def self._checkin_callbacks=(value); end

  def self._checkout_callbacks(); end

  def self._checkout_callbacks=(value); end

  def self.type_cast_config_to_boolean(config); end

  def self.type_cast_config_to_integer(config); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def column(); end

  def column=(_); end
end

class ActiveRecord::ConnectionAdapters::AddColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
  def add_column(name, type, options); end

  def add_foreign_key(to_table, options); end

  def adds(); end

  def drop_foreign_key(name); end

  def foreign_key_adds(); end

  def foreign_key_drops(); end

  def initialize(td); end

  def name(); end
end

class ActiveRecord::ConnectionAdapters::AlterTable
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def column(); end

  def column=(_); end

  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::Column
  def ==(other); end

  def attributes_for_hash(); end

  def bigint?(); end

  def collation(); end

  def comment(); end

  def default(); end

  def default_function(); end

  def encode_with(coder); end

  def eql?(other); end

  def has_default?(); end

  def human_name(); end

  def init_with(coder); end

  def initialize(name, default, sql_type_metadata=T.unsafe(nil), null=T.unsafe(nil), table_name=T.unsafe(nil), default_function=T.unsafe(nil), collation=T.unsafe(nil), comment: T.unsafe(nil), **_); end

  def limit(*args, &block); end

  def name(); end

  def null(); end

  def precision(*args, &block); end

  def scale(*args, &block); end

  def sql_type(*args, &block); end

  def sql_type_metadata(); end

  def table_name(); end

  def type(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::Column
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def collation(); end

  def collation=(value); end

  def comment(); end

  def comment=(value); end

  def default(); end

  def default=(value); end

  def limit(); end

  def limit=(value); end

  def name(); end

  def name=(_); end

  def null(); end

  def null=(value); end

  def options(); end

  def options=(_); end

  def precision(); end

  def precision=(value); end

  def primary_key?(); end

  def scale(); end

  def scale=(value); end

  def sql_type(); end

  def sql_type=(_); end

  def type(); end

  def type=(_); end
end

class ActiveRecord::ConnectionAdapters::ColumnDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  def bigint(*args, **options); end

  def binary(*args, **options); end

  def boolean(*args, **options); end

  def date(*args, **options); end

  def datetime(*args, **options); end

  def decimal(*args, **options); end

  def float(*args, **options); end

  def integer(*args, **options); end

  def json(*args, **options); end

  def numeric(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def string(*args, **options); end

  def text(*args, **options); end

  def time(*args, **options); end

  def timestamp(*args, **options); end

  def virtual(*args, **options); end
end

module ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def active_connections?(); end

  def clear_active_connections!(); end

  def clear_all_connections!(); end

  def clear_reloadable_connections!(); end

  def connected?(spec_name); end

  def connection_pool_list(); end

  def connection_pools(); end

  def establish_connection(config); end

  def flush_idle_connections!(); end

  def remove_connection(spec_name); end

  def retrieve_connection(spec_name); end

  def retrieve_connection_pool(spec_name); end
end

class ActiveRecord::ConnectionAdapters::ConnectionHandler
  def self.discard_unowned_pools(pid_map); end

  def self.unowned_pool_finalizer(pid_map); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def active_connection?(); end

  def automatic_reconnect(); end

  def automatic_reconnect=(automatic_reconnect); end

  def checkin(conn); end

  def checkout(checkout_timeout=T.unsafe(nil)); end

  def checkout_timeout(); end

  def checkout_timeout=(checkout_timeout); end

  def clear_reloadable_connections(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def clear_reloadable_connections!(); end

  def connected?(); end

  def connection(); end

  def connections(); end

  def discard!(); end

  def disconnect(raise_on_acquisition_timeout=T.unsafe(nil)); end

  def disconnect!(); end

  def flush(minimum_idle=T.unsafe(nil)); end

  def flush!(); end

  def initialize(spec); end

  def lock_thread=(lock_thread); end

  def num_waiting_in_queue(); end

  def reap(); end

  def reaper(); end

  def release_connection(owner_thread=T.unsafe(nil)); end

  def remove(conn); end

  def schema_cache(); end

  def schema_cache=(schema_cache); end

  def size(); end

  def spec(); end

  def stat(); end

  def with_connection(); end
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  def with_a_bias_for(thread); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  def broadcast(); end

  def broadcast_on_biased(); end

  def initialize(lock, other_cond, preferred_thread); end

  def signal(); end

  def wait(timeout); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
end

module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
  include ::ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  def add(element); end

  def any_waiting?(); end

  def clear(); end

  def delete(element); end

  def initialize(lock=T.unsafe(nil)); end

  def num_waiting(); end

  def poll(timeout=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  def frequency(); end

  def initialize(pool, frequency); end

  def pool(); end

  def run(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
end

class ActiveRecord::ConnectionAdapters::ConnectionPool
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
  def adapter_method(); end

  def config(); end

  def initialize(name, config, adapter_method); end

  def name(); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  def initialize(url); end

  def to_hash(); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
  def configurations(); end

  def initialize(configurations); end

  def resolve(config); end

  def resolve_all(); end

  def spec(config); end
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
end

class ActiveRecord::ConnectionAdapters::ConnectionSpecification
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  def allowed_index_name_length(); end

  def column_name_length(); end

  def columns_per_multicolumn_index(); end

  def columns_per_table(); end

  def in_clause_length(); end

  def index_name_length(); end

  def indexes_per_table(); end

  def joins_per_query(); end

  def sql_query_length(); end

  def table_alias_length(); end

  def table_name_length(); end
end

module ActiveRecord::ConnectionAdapters::DatabaseLimits
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  def add_transaction_record(record); end

  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def begin_transaction(*args, &block); end

  def cacheable_query(klass, arel); end

  def commit_db_transaction(); end

  def commit_transaction(*args, &block); end

  def create(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def current_transaction(*args, &block); end

  def default_sequence_name(table, column); end

  def delete(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def empty_insert_statement_value(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def initialize(); end

  def insert(arel, name=T.unsafe(nil), pk=T.unsafe(nil), id_value=T.unsafe(nil), sequence_name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def insert_fixture(fixture, table_name); end

  def insert_fixtures(fixtures, table_name); end

  def insert_fixtures_set(fixture_set, tables_to_delete=T.unsafe(nil)); end

  def join_to_delete(update, select, key); end

  def join_to_update(update, select, key); end

  def open_transactions(*args, &block); end

  def query(sql, name=T.unsafe(nil)); end

  def query_value(sql, name=T.unsafe(nil)); end

  def query_values(sql, name=T.unsafe(nil)); end

  def reset_sequence!(table, column, sequence=T.unsafe(nil)); end

  def reset_transaction(); end

  def rollback_db_transaction(); end

  def rollback_to_savepoint(name=T.unsafe(nil)); end

  def rollback_transaction(*args, &block); end

  def sanitize_limit(limit); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def select_one(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_rows(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_value(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def select_values(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def supports_statement_cache?(*args, &block); end

  def to_sql(arel_or_sql_string, binds=T.unsafe(nil)); end

  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  def transaction_isolation_levels(); end

  def transaction_manager(); end

  def transaction_open?(); end

  def transaction_state(); end

  def truncate(table_name, name=T.unsafe(nil)); end

  def update(arel, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def within_new_transaction(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::DatabaseStatements::PartialQueryCollector
  def <<(str); end

  def add_bind(obj); end

  def value(); end
end

class ActiveRecord::ConnectionAdapters::DatabaseStatements::PartialQueryCollector
end

module ActiveRecord::ConnectionAdapters::DatabaseStatements
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
  def accept(*_); end

  def preparable(); end

  def visit_Arel_Nodes_In(*_); end

  def visit_Arel_Nodes_SqlLiteral(*_); end
end

module ActiveRecord::ConnectionAdapters::DetermineIfPreparableVisitor
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def column(); end

  def custom_primary_key?(); end

  def defined_for?(to_table_ord=T.unsafe(nil), to_table: T.unsafe(nil), **options); end

  def from_table(); end

  def from_table=(_); end

  def name(); end

  def on_delete(); end

  def on_update(); end

  def options(); end

  def options=(_); end

  def primary_key(); end

  def to_table(); end

  def to_table=(_); end

  def validate?(); end

  def validated?(); end
end

class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
  def columns(); end

  def comment(); end

  def initialize(table, name, unique=T.unsafe(nil), columns=T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), comment: T.unsafe(nil)); end

  def lengths(); end

  def name(); end

  def opclasses(); end

  def orders(); end

  def table(); end

  def type(); end

  def unique(); end

  def using(); end

  def where(); end
end

class ActiveRecord::ConnectionAdapters::IndexDefinition
end

class ActiveRecord::ConnectionAdapters::NullColumn
  def initialize(name); end
end

class ActiveRecord::ConnectionAdapters::NullColumn
end

class ActiveRecord::ConnectionAdapters::NullTransaction
  def add_record(record); end

  def closed?(); end

  def joinable?(); end

  def open?(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::NullTransaction
end

module ActiveRecord::ConnectionAdapters::PostgreSQL
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
  def constraint_validations(); end

  def validate_constraint(name); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::AlterTable
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  def bigserial(*args, **options); end

  def bit(*args, **options); end

  def bit_varying(*args, **options); end

  def box(*args, **options); end

  def cidr(*args, **options); end

  def circle(*args, **options); end

  def citext(*args, **options); end

  def daterange(*args, **options); end

  def hstore(*args, **options); end

  def inet(*args, **options); end

  def int4range(*args, **options); end

  def int8range(*args, **options); end

  def interval(*args, **options); end

  def jsonb(*args, **options); end

  def line(*args, **options); end

  def lseg(*args, **options); end

  def ltree(*args, **options); end

  def macaddr(*args, **options); end

  def money(*args, **options); end

  def numrange(*args, **options); end

  def oid(*args, **options); end

  def path(*args, **options); end

  def point(*args, **options); end

  def polygon(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def serial(*args, **options); end

  def tsrange(*args, **options); end

  def tstzrange(*args, **options); end

  def tsvector(*args, **options); end

  def uuid(*args, **options); end

  def xml(*args, **options); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def begin_db_transaction(); end

  def begin_isolated_db_transaction(isolation); end

  def commit_db_transaction(); end

  def exec_delete(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def exec_insert(sql, name=T.unsafe(nil), binds=T.unsafe(nil), pk=T.unsafe(nil), sequence_name=T.unsafe(nil)); end

  def exec_query(sql, name=T.unsafe(nil), binds=T.unsafe(nil), prepare: T.unsafe(nil)); end

  def exec_rollback_db_transaction(); end

  def exec_update(sql, name=T.unsafe(nil), binds=T.unsafe(nil)); end

  def execute(sql, name=T.unsafe(nil)); end

  def explain(arel, binds=T.unsafe(nil)); end

  def query(sql, name=T.unsafe(nil)); end

  def result_as_array(res); end
  BYTEA_COLUMN_TYPE_OID = ::T.let(nil, ::T.untyped)
  MONEY_COLUMN_TYPE_OID = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
  def pp(result); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::ExplainPrettyPrinter
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
  def ==(o); end

  def eql?(o); end

  def identifier(); end

  def initialize(schema, identifier); end

  def parts(); end

  def quoted(); end

  def schema(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Name
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::OID
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
  include ::ActiveModel::Type::Helpers::Mutable
  def delimiter(); end

  def force_equality?(value); end

  def initialize(subtype, delimiter=T.unsafe(nil)); end

  def limit(*args, &block); end

  def map(value, &block); end

  def precision(*args, &block); end

  def scale(*args, &block); end

  def subtype(); end

  def type(*args, &block); end

  def user_input_in_time_zone(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def encoder(); end

  def encoder=(_); end

  def values=(_); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array::Data
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Array
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
  def binary?(); end

  def hex?(); end

  def initialize(value); end

  def value(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit::Data
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bit
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::BitVarying
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::BitVarying
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bytea
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Bytea
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Cidr
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Date
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Date
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::DateTime
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
  def infinity(options=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Decimal
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Enum
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Enum
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
  HstorePair = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Hstore
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Inet
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Inet
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Jsonb
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Jsonb
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::LegacyPoint
  include ::ActiveModel::Type::Helpers::Mutable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::LegacyPoint
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Money
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Oid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Oid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Point
  include ::ActiveModel::Type::Helpers::Mutable
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Point
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
  def force_equality?(value); end

  def initialize(subtype, type=T.unsafe(nil)); end

  def subtype(); end

  def user_input_in_time_zone(*args, &block); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Range
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
  def initialize(type, **options); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::SpecializedString
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
  def initialize(store); end

  def query_conditions_for_initial_load(); end

  def run(records); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::TypeMapInitializer
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
  ACCEPTABLE_UUID = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Uuid
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
  def delim(); end

  def initialize(delim, subtype); end

  def subtype(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Vector
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
  def initialize(value); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml::Data
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::OID::Xml
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::OID
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  def escape_bytea(value); end

  def lookup_cast_type_from_column(column); end

  def quote_column_name(name); end

  def quote_default_expression(value, column); end

  def quote_schema_name(name); end

  def quote_string(s); end

  def quote_table_name(name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def unescape_bytea(value); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  def disable_referential_integrity(); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaCreation
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaDumper
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def add_index(table_name, column_name, options=T.unsafe(nil)); end

  def bulk_change_table(table_name, operations); end

  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def change_column_comment(table_name, column_name, comment); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table_comment(table_name, comment); end

  def client_min_messages(); end

  def client_min_messages=(level); end

  def collation(); end

  def columns_for_distinct(columns, orders); end

  def create_database(name, options=T.unsafe(nil)); end

  def create_schema(schema_name); end

  def create_schema_dumper(options); end

  def ctype(); end

  def current_database(); end

  def current_schema(); end

  def default_sequence_name(table_name, pk=T.unsafe(nil)); end

  def drop_database(name); end

  def drop_schema(schema_name, options=T.unsafe(nil)); end

  def drop_table(table_name, options=T.unsafe(nil)); end

  def encoding(); end

  def foreign_keys(table_name); end

  def foreign_table_exists?(table_name); end

  def foreign_tables(); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def pk_and_sequence_for(table); end

  def primary_keys(table_name); end

  def recreate_database(name, options=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def reset_pk_sequence!(table, pk=T.unsafe(nil), sequence=T.unsafe(nil)); end

  def schema_exists?(name); end

  def schema_names(); end

  def schema_search_path(); end

  def schema_search_path=(schema_csv); end

  def serial_sequence(table, column); end

  def set_pk_sequence!(table, value); end

  def table_comment(table_name); end

  def table_options(table_name); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), array: T.unsafe(nil), **_); end

  def update_table_definition(table_name, base); end

  def validate_constraint(table_name, constraint_name); end

  def validate_foreign_key(from_table, options_or_to_table=T.unsafe(nil)); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::Table
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ColumnMethods
end

class ActiveRecord::ConnectionAdapters::PostgreSQL::TableDefinition
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  def extract_schema_qualified_name(string); end
end

module ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  extend ::ActiveRecord::ConnectionAdapters::PostgreSQL::Utils
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::PostgreSQL
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::Quoting
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::ReferentialIntegrity
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::PostgreSQL::DatabaseStatements
  def extension_enabled?(name); end

  def initialize(connection, logger, connection_parameters, config); end

  def max_identifier_length(); end

  def postgresql_version(); end

  def session_auth=(user); end

  def set_standard_conforming_strings(); end

  def supports_materialized_views?(); end

  def supports_pgcrypto_uuid?(); end

  def supports_ranges?(); end

  def use_insert_returning?(); end
  ADAPTER_NAME = ::T.let(nil, ::T.untyped)
  CACHED_PLAN_HEURISTIC = ::T.let(nil, ::T.untyped)
  DEADLOCK_DETECTED = ::T.let(nil, ::T.untyped)
  FEATURE_NOT_SUPPORTED = ::T.let(nil, ::T.untyped)
  FOREIGN_KEY_VIOLATION = ::T.let(nil, ::T.untyped)
  LOCK_NOT_AVAILABLE = ::T.let(nil, ::T.untyped)
  NATIVE_DATABASE_TYPES = ::T.let(nil, ::T.untyped)
  NOT_NULL_VIOLATION = ::T.let(nil, ::T.untyped)
  NUMERIC_VALUE_OUT_OF_RANGE = ::T.let(nil, ::T.untyped)
  OPERATION_ALIASES = ::T.let(nil, ::T.untyped)
  QUERY_CANCELED = ::T.let(nil, ::T.untyped)
  SERIALIZATION_FAILURE = ::T.let(nil, ::T.untyped)
  UNIQUE_VIOLATION = ::T.let(nil, ::T.untyped)
  VALUE_LIMIT_VIOLATION = ::T.let(nil, ::T.untyped)
end

ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::OID = ActiveRecord::ConnectionAdapters::PostgreSQL::OID

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
  def []=(sql, key); end

  def initialize(connection, max); end

  def next_key(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter::StatementPool
end

class ActiveRecord::ConnectionAdapters::PostgreSQLAdapter
end

class ActiveRecord::ConnectionAdapters::PostgreSQLColumn
  def array(*args, &block); end

  def array?(*args, &block); end

  def fmod(*args, &block); end

  def initialize(*_, max_identifier_length: T.unsafe(nil), **_1); end

  def max_identifier_length(); end

  def oid(*args, &block); end

  def serial?(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLColumn
end

class ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata
  def ==(other); end

  def array(); end

  def attributes_for_hash(); end

  def eql?(other); end

  def fmod(); end

  def hash(); end

  def initialize(type_metadata, oid: T.unsafe(nil), fmod: T.unsafe(nil)); end

  def oid(); end

  def sql_type(); end
end

class ActiveRecord::ConnectionAdapters::PostgreSQLTypeMetadata
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def name(); end

  def name=(_); end
end

class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition
  def self.[](*_); end

  def self.members(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache
  def cache(); end

  def clear_query_cache(); end

  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache(); end

  def query_cache_enabled(); end

  def select_all(arel, name=T.unsafe(nil), binds=T.unsafe(nil), preparable: T.unsafe(nil)); end

  def uncached(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  def disable_query_cache!(); end

  def enable_query_cache!(); end

  def initialize(*_); end

  def query_cache_enabled(); end
end

module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  extend ::T::Sig
end

module ActiveRecord::ConnectionAdapters::QueryCache
  extend ::T::Sig
  def self.dirties_query_cache(base, *method_names); end

  def self.included(base); end
end

module ActiveRecord::ConnectionAdapters::Quoting
  def lookup_cast_type_from_column(column); end

  def quote(value); end

  def quote_column_name(column_name); end

  def quote_default_expression(value, column); end

  def quote_string(s); end

  def quote_table_name(table_name); end

  def quote_table_name_for_assignment(table, attr); end

  def quoted_binary(value); end

  def quoted_date(value); end

  def quoted_false(); end

  def quoted_time(value); end

  def quoted_true(); end

  def type_cast(value, column=T.unsafe(nil)); end

  def type_cast_from_column(column, value); end

  def type_casted_binds(binds); end

  def unquoted_false(); end

  def unquoted_true(); end
end

module ActiveRecord::ConnectionAdapters::Quoting
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::RealTransaction
  def commit(); end

  def initialize(connection, options, *args); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::RealTransaction
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  def add_to(table); end

  def foreign_key(); end

  def index(); end

  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end

  def name(); end

  def options(); end

  def polymorphic(); end

  def type(); end
end

class ActiveRecord::ConnectionAdapters::ReferenceDefinition
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
  def commit(); end

  def initialize(connection, savepoint_name, parent_transaction, options, *args); end

  def rollback(); end
end

class ActiveRecord::ConnectionAdapters::SavepointTransaction
end

module ActiveRecord::ConnectionAdapters::Savepoints
  def create_savepoint(name=T.unsafe(nil)); end

  def current_savepoint_name(); end

  def exec_rollback_to_savepoint(name=T.unsafe(nil)); end

  def release_savepoint(name=T.unsafe(nil)); end
end

module ActiveRecord::ConnectionAdapters::Savepoints
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::SchemaCache
  def add(table_name); end

  def clear!(); end

  def clear_data_source_cache!(name); end

  def columns(table_name); end

  def columns_hash(table_name); end

  def connection(); end

  def connection=(connection); end

  def data_source_exists?(name); end

  def data_sources(name); end

  def encode_with(coder); end

  def init_with(coder); end

  def initialize(conn); end

  def marshal_dump(); end

  def marshal_load(array); end

  def primary_keys(table_name); end

  def size(); end

  def version(); end
end

class ActiveRecord::ConnectionAdapters::SchemaCache
end

ActiveRecord::ConnectionAdapters::SchemaCreation = ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation

class ActiveRecord::ConnectionAdapters::SchemaDumper
end

class ActiveRecord::ConnectionAdapters::SchemaDumper
  def self.create(connection, options); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def add_foreign_key(from_table, to_table, options=T.unsafe(nil)); end

  def add_index(table_name, column_name, options=T.unsafe(nil)); end

  def add_index_options(table_name, column_name, comment: T.unsafe(nil), **options); end

  def add_reference(table_name, ref_name, **options); end

  def add_timestamps(table_name, options=T.unsafe(nil)); end

  def assume_migrated_upto_version(version, migrations_paths); end

  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def change_column_comment(table_name, column_name, comment); end

  def change_column_default(table_name, column_name, default_or_changes); end

  def change_column_null(table_name, column_name, null, default=T.unsafe(nil)); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def change_table_comment(table_name, comment); end

  def column_exists?(table_name, column_name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def columns(table_name); end

  def columns_for_distinct(columns, orders); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  def create_schema_dumper(options); end

  def create_table(table_name, comment: T.unsafe(nil), **options); end

  def data_source_exists?(name); end

  def data_sources(); end

  def drop_join_table(table_1, table_2, options=T.unsafe(nil)); end

  def drop_table(table_name, options=T.unsafe(nil)); end

  def dump_schema_information(); end

  def foreign_key_column_for(table_name); end

  def foreign_key_exists?(from_table, options_or_to_table=T.unsafe(nil)); end

  def foreign_key_options(from_table, to_table, options); end

  def foreign_keys(table_name); end

  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def index_name(table_name, options); end

  def index_name_exists?(table_name, index_name); end

  def indexes(table_name); end

  def internal_string_options_for_primary_key(); end

  def native_database_types(); end

  def options_include_default?(options); end

  def primary_key(table_name); end

  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_column(table_name, column_name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def remove_columns(table_name, *column_names); end

  def remove_foreign_key(from_table, options_or_to_table=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end

  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  def remove_timestamps(table_name, options=T.unsafe(nil)); end

  def rename_column(table_name, column_name, new_column_name); end

  def rename_index(table_name, old_name, new_name); end

  def rename_table(table_name, new_name); end

  def table_alias_for(table_name); end

  def table_comment(table_name); end

  def table_exists?(table_name); end

  def table_options(table_name); end

  def tables(); end

  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), **_); end

  def update_table_definition(table_name, base); end

  def view_exists?(view_name); end

  def views(); end
end

module ActiveRecord::ConnectionAdapters::SchemaStatements
  extend ::T::Sig
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  def ==(other); end

  def attributes_for_hash(); end

  def eql?(other); end

  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  def limit(); end

  def precision(); end

  def scale(); end

  def sql_type(); end

  def type(); end
end

class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
end

class ActiveRecord::ConnectionAdapters::StatementPool
  include ::Enumerable
  def [](key); end

  def []=(sql, stmt); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def initialize(statement_limit=T.unsafe(nil)); end

  def key?(key); end

  def length(); end
  DEFAULT_STATEMENT_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::StatementPool
end

class ActiveRecord::ConnectionAdapters::Table
  include ::ActiveRecord::ConnectionAdapters::ColumnMethods
  def belongs_to(*args, **options); end

  def change(column_name, type, options=T.unsafe(nil)); end

  def change_default(column_name, default_or_changes); end

  def column(column_name, type, options=T.unsafe(nil)); end

  def column_exists?(column_name, type=T.unsafe(nil), options=T.unsafe(nil)); end

  def foreign_key(*args); end

  def foreign_key_exists?(*args); end

  def index(column_name, options=T.unsafe(nil)); end

  def index_exists?(column_name, options=T.unsafe(nil)); end

  def initialize(table_name, base); end

  def name(); end

  def references(*args, **options); end

  def remove(*column_names); end

  def remove_belongs_to(*args, **options); end

  def remove_index(options=T.unsafe(nil)); end

  def remove_references(*args, **options); end

  def remove_timestamps(options=T.unsafe(nil)); end

  def rename(column_name, new_column_name); end

  def rename_index(index_name, new_index_name); end

  def timestamps(options=T.unsafe(nil)); end
end

class ActiveRecord::ConnectionAdapters::Table
end

class ActiveRecord::ConnectionAdapters::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::ColumnMethods
  def [](name); end

  def as(); end

  def belongs_to(*args, **options); end

  def column(name, type, options=T.unsafe(nil)); end

  def columns(); end

  def comment(); end

  def foreign_key(table_name, options=T.unsafe(nil)); end

  def foreign_keys(); end

  def index(column_name, options=T.unsafe(nil)); end

  def indexes(); end

  def indexes=(indexes); end

  def initialize(name, temporary=T.unsafe(nil), options=T.unsafe(nil), as=T.unsafe(nil), comment: T.unsafe(nil)); end

  def name(); end

  def new_column_definition(name, type, **options); end

  def options(); end

  def primary_keys(name=T.unsafe(nil)); end

  def references(*args, **options); end

  def remove_column(name); end

  def temporary(); end

  def timestamps(**options); end
end

class ActiveRecord::ConnectionAdapters::TableDefinition
end

class ActiveRecord::ConnectionAdapters::Transaction
  def add_record(record); end

  def before_commit_records(); end

  def closed?(); end

  def commit_records(); end

  def connection(); end

  def full_rollback?(); end

  def initialize(connection, options, run_commit_callbacks: T.unsafe(nil)); end

  def joinable=(joinable); end

  def joinable?(); end

  def open?(); end

  def records(); end

  def rollback_records(); end

  def savepoint_name(); end

  def state(); end
end

class ActiveRecord::ConnectionAdapters::Transaction
end

class ActiveRecord::ConnectionAdapters::TransactionManager
  def begin_transaction(options=T.unsafe(nil)); end

  def commit_transaction(); end

  def current_transaction(); end

  def initialize(connection); end

  def open_transactions(); end

  def rollback_transaction(transaction=T.unsafe(nil)); end

  def within_new_transaction(options=T.unsafe(nil)); end
  NULL_TRANSACTION = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionAdapters::TransactionManager
end

class ActiveRecord::ConnectionAdapters::TransactionState
  def add_child(state); end

  def commit!(); end

  def committed?(); end

  def completed?(); end

  def finalized?(); end

  def full_commit!(); end

  def full_rollback!(); end

  def fully_committed?(); end

  def fully_completed?(); end

  def fully_rolledback?(); end

  def initialize(state=T.unsafe(nil)); end

  def nullify!(); end

  def rollback!(); end

  def rolledback?(); end

  def set_state(state); end
end

class ActiveRecord::ConnectionAdapters::TransactionState
end

module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActiveRecord::ConnectionHandling
  def clear_active_connections!(*args, &block); end

  def clear_all_connections!(*args, &block); end

  def clear_cache!(); end

  def clear_reloadable_connections!(*args, &block); end

  def connected?(); end

  def connection(); end

  def connection_config(); end

  def connection_pool(); end

  def connection_specification_name(); end

  def connection_specification_name=(connection_specification_name); end

  def establish_connection(config=T.unsafe(nil)); end

  def flush_idle_connections!(*args, &block); end

  def postgresql_connection(config); end

  def remove_connection(name=T.unsafe(nil)); end

  def retrieve_connection(); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ConnectionHandling::MergeAndResolveDefaultUrlConfig
  def initialize(raw_configurations); end

  def resolve(); end
end

class ActiveRecord::ConnectionHandling::MergeAndResolveDefaultUrlConfig
end

module ActiveRecord::ConnectionHandling
  extend ::T::Sig
end

class ActiveRecord::ConnectionNotEstablished
end

class ActiveRecord::ConnectionNotEstablished
end

class ActiveRecord::ConnectionTimeoutError
end

class ActiveRecord::ConnectionTimeoutError
end

module ActiveRecord::Core
  def ==(comparison_object); end

  def connection_handler(); end

  def encode_with(coder); end

  def eql?(comparison_object); end

  def freeze(); end

  def frozen?(); end

  def hash(); end

  def init_with(coder); end

  def initialize(attributes=T.unsafe(nil)); end

  def inspect(); end

  def pretty_print(pp); end

  def readonly!(); end

  def readonly?(); end

  def slice(*methods); end
end

module ActiveRecord::Core
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::CounterCache
end

module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::DangerousAttributeError
end

class ActiveRecord::DangerousAttributeError
end

class ActiveRecord::Deadlocked
end

class ActiveRecord::Deadlocked
end

module ActiveRecord::DefineCallbacks
end

module ActiveRecord::DefineCallbacks
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Delegation
  def &(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def [](*args, &block); end

  def as_json(*args, &block); end

  def compact(*args, &block); end

  def connection(*args, &block); end

  def each(*args, &block); end

  def encode_with(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def index(*args, &block); end

  def join(*args, &block); end

  def length(*args, &block); end

  def primary_key(*args, &block); end

  def reverse(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def sample(*args, &block); end

  def shuffle(*args, &block); end

  def slice(*args, &block); end

  def split(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_sentence(*args, &block); end

  def to_xml(*args, &block); end

  def uniq(*args, &block); end

  def |(*args, &block); end
end

module ActiveRecord::Delegation::ClassMethods
  def create(klass, *args); end
end

module ActiveRecord::Delegation::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Delegation::ClassSpecificRelation
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  def delegate_to_scoped_klass(method); end

  def name(); end
end

module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Delegation::DelegateCache
  def inherited(child_class); end

  def initialize_relation_delegate_cache(); end

  def relation_delegate_class(klass); end
end

module ActiveRecord::Delegation::DelegateCache
  extend ::T::Sig
end

module ActiveRecord::Delegation
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::DeleteRestrictionError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DeleteRestrictionError
end

class ActiveRecord::DuplicateMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationNameError
end

class ActiveRecord::DuplicateMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::DuplicateMigrationVersionError
end

module ActiveRecord::DynamicMatchers
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindBy
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::FindByBang
end

class ActiveRecord::DynamicMatchers::Method
  def attribute_names(); end

  def define(); end

  def initialize(model, name); end

  def model(); end

  def name(); end

  def valid?(); end
end

class ActiveRecord::DynamicMatchers::Method
  def self.match(model, name); end

  def self.matchers(); end

  def self.pattern(); end

  def self.prefix(); end

  def self.suffix(); end
end

module ActiveRecord::DynamicMatchers
  extend ::T::Sig
end

class ActiveRecord::EagerLoadPolymorphicError
  def initialize(reflection=T.unsafe(nil)); end
end

class ActiveRecord::EagerLoadPolymorphicError
end

module ActiveRecord::Enum
  def enum(definitions); end

  def inherited(base); end
  ENUM_CONFLICT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Enum::EnumType
  def assert_valid_value(value); end

  def initialize(name, mapping, subtype); end

  def mapping(); end

  def name(); end

  def subtype(); end

  def type(*args, &block); end
end

class ActiveRecord::Enum::EnumType
end

module ActiveRecord::Enum
  extend ::T::Sig
  def self.extended(base); end
end

class ActiveRecord::EnvironmentMismatchError
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

class ActiveRecord::EnvironmentMismatchError
end

class ActiveRecord::ExclusiveConnectionTimeoutError
end

class ActiveRecord::ExclusiveConnectionTimeoutError
end

module ActiveRecord::Explain
  def collecting_queries_for_explain(); end

  def exec_explain(queries); end
end

module ActiveRecord::Explain
  extend ::T::Sig
end

class ActiveRecord::ExplainRegistry
  def collect(); end

  def collect=(collect); end

  def collect?(); end

  def queries(); end

  def queries=(queries); end

  def reset(); end
end

class ActiveRecord::ExplainRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveRecord::ExplainSubscriber
  def finish(name, id, payload); end

  def ignore_payload?(payload); end

  def start(name, id, payload); end
  EXPLAINED_SQLS = ::T.let(nil, ::T.untyped)
  IGNORED_PAYLOADS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::ExplainSubscriber
end

module ActiveRecord::FinderMethods
  def exists?(conditions=T.unsafe(nil)); end

  def fifth(); end

  def fifth!(); end

  def find(*args); end

  def find_by(arg, *args); end

  def find_by!(arg, *args); end

  def first(limit=T.unsafe(nil)); end

  def first!(); end

  def forty_two(); end

  def forty_two!(); end

  def fourth(); end

  def fourth!(); end

  def last(limit=T.unsafe(nil)); end

  def last!(); end

  def raise_record_not_found_exception!(ids=T.unsafe(nil), result_size=T.unsafe(nil), expected_size=T.unsafe(nil), key=T.unsafe(nil), not_found_ids=T.unsafe(nil)); end

  def second(); end

  def second!(); end

  def second_to_last(); end

  def second_to_last!(); end

  def take(limit=T.unsafe(nil)); end

  def take!(); end

  def third(); end

  def third!(); end

  def third_to_last(); end

  def third_to_last!(); end
  ONE_AS_ONE = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::FinderMethods
  extend ::T::Sig
end

class ActiveRecord::HasManyThroughAssociationNotFoundError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationNotFoundError
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), source_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError
end

class ActiveRecord::HasManyThroughCantAssociateThroughHasOneOrManyReflection
end

class ActiveRecord::HasManyThroughCantAssociateThroughHasOneOrManyReflection
end

class ActiveRecord::HasManyThroughNestedAssociationsAreReadonly
end

class ActiveRecord::HasManyThroughNestedAssociationsAreReadonly
end

class ActiveRecord::HasManyThroughOrderError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughOrderError
end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasManyThroughSourceAssociationNotFoundError
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneAssociationPolymorphicThroughError
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection
  def initialize(owner_class_name=T.unsafe(nil), reflection=T.unsafe(nil), through_reflection=T.unsafe(nil)); end
end

class ActiveRecord::HasOneThroughCantAssociateThroughCollection
end

class ActiveRecord::HasOneThroughCantAssociateThroughHasOneOrManyReflection
end

class ActiveRecord::HasOneThroughCantAssociateThroughHasOneOrManyReflection
end

class ActiveRecord::HasOneThroughNestedAssociationsAreReadonly
end

class ActiveRecord::HasOneThroughNestedAssociationsAreReadonly
end

class ActiveRecord::IllegalMigrationNameError
  def initialize(name=T.unsafe(nil)); end
end

class ActiveRecord::IllegalMigrationNameError
end

class ActiveRecord::ImmutableRelation
end

class ActiveRecord::ImmutableRelation
end

module ActiveRecord::Inheritance
end

module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Integration
  def cache_key(*timestamp_names); end

  def cache_key_with_version(); end

  def cache_version(); end

  def to_param(); end
end

module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::InternalMetadata
  include ::ActiveRecord::InternalMetadata::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
end

module ActiveRecord::InternalMetadata::GeneratedAssociationMethods
  extend ::T::Sig
end

class ActiveRecord::InternalMetadata
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.[](key); end

  def self.[]=(key, value); end

  def self.create_table(); end

  def self.page(num=T.unsafe(nil)); end
end

class ActiveRecord::InvalidForeignKey
end

class ActiveRecord::InvalidForeignKey
end

class ActiveRecord::InverseOfAssociationNotFoundError
  def initialize(reflection=T.unsafe(nil), associated_class=T.unsafe(nil)); end
end

class ActiveRecord::InverseOfAssociationNotFoundError
end

class ActiveRecord::IrreversibleMigration
end

class ActiveRecord::IrreversibleMigration
end

class ActiveRecord::IrreversibleOrderError
end

class ActiveRecord::IrreversibleOrderError
end

module ActiveRecord::LegacyYamlAdapter
end

module ActiveRecord::LegacyYamlAdapter::Rails41
end

module ActiveRecord::LegacyYamlAdapter::Rails41
  extend ::T::Sig
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter::Rails420
end

module ActiveRecord::LegacyYamlAdapter::Rails420
  extend ::T::Sig
  def self.convert(klass, coder); end
end

module ActiveRecord::LegacyYamlAdapter
  extend ::T::Sig
  def self.convert(klass, coder); end
end

class ActiveRecord::LockWaitTimeout
end

class ActiveRecord::LockWaitTimeout
end

module ActiveRecord::Locking
end

class ActiveRecord::Locking::LockingType
  def deserialize(value); end

  def encode_with(coder); end

  def init_with(coder); end

  def serialize(value); end
end

class ActiveRecord::Locking::LockingType
end

module ActiveRecord::Locking::Optimistic
  def locking_enabled?(); end
end

module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Locking::Pessimistic
  def lock!(lock=T.unsafe(nil)); end

  def with_lock(lock=T.unsafe(nil)); end
end

module ActiveRecord::Locking::Pessimistic
  extend ::T::Sig
end

module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

class ActiveRecord::LogSubscriber
  def sql(event); end
  IGNORE_PAYLOAD_NAMES = ::T.let(nil, ::T.untyped)
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::LogSubscriber
  def self.reset_runtime(); end

  def self.runtime(); end

  def self.runtime=(value); end
end

class ActiveRecord::Migration
  def announce(message); end

  def connection(); end

  def copy(destination, sources, options=T.unsafe(nil)); end

  def disable_ddl_transaction(); end

  def down(); end

  def exec_migration(conn, direction); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def method_missing(method, *arguments, &block); end

  def migrate(direction); end

  def name(); end

  def name=(name); end

  def next_migration_number(number); end

  def proper_table_name(name, options=T.unsafe(nil)); end

  def reversible(); end

  def revert(*migration_classes); end

  def reverting?(); end

  def run(*migration_classes); end

  def say(message, subitem=T.unsafe(nil)); end

  def say_with_time(message); end

  def suppress_messages(); end

  def table_name_options(config=T.unsafe(nil)); end

  def up(); end

  def up_only(); end

  def verbose(); end

  def verbose=(obj); end

  def version(); end

  def version=(version); end

  def write(text=T.unsafe(nil)); end
  MigrationFilenameRegexp = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migration::CheckPending
  def call(env); end

  def initialize(app); end
end

class ActiveRecord::Migration::CheckPending
end

class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions
  def add_belongs_to(*args, &block); end

  def add_column(*args, &block); end

  def add_foreign_key(*args, &block); end

  def add_index(*args, &block); end

  def add_reference(*args, &block); end

  def add_timestamps(*args, &block); end

  def change_column(*args, &block); end

  def change_column_default(*args, &block); end

  def change_column_null(*args, &block); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def commands(); end

  def commands=(commands); end

  def create_join_table(*args, &block); end

  def create_table(*args, &block); end

  def delegate(); end

  def delegate=(delegate); end

  def disable_extension(*args, &block); end

  def drop_join_table(*args, &block); end

  def drop_table(*args, &block); end

  def enable_extension(*args, &block); end

  def execute(*args, &block); end

  def execute_block(*args, &block); end

  def initialize(delegate=T.unsafe(nil)); end

  def inverse_of(command, args, &block); end

  def invert_add_belongs_to(args, &block); end

  def invert_remove_belongs_to(args, &block); end

  def record(*command, &block); end

  def remove_belongs_to(*args, &block); end

  def remove_column(*args, &block); end

  def remove_columns(*args, &block); end

  def remove_foreign_key(*args, &block); end

  def remove_index(*args, &block); end

  def remove_reference(*args, &block); end

  def remove_timestamps(*args, &block); end

  def rename_column(*args, &block); end

  def rename_index(*args, &block); end

  def rename_table(*args, &block); end

  def revert(); end

  def reverting(); end

  def reverting=(reverting); end

  def transaction(*args, &block); end
  ReversibleAndIrreversibleMethods = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  def invert_add_column(args, &block); end

  def invert_add_reference(args, &block); end

  def invert_add_timestamps(args, &block); end

  def invert_create_join_table(args, &block); end

  def invert_create_table(args, &block); end

  def invert_disable_extension(args, &block); end

  def invert_drop_join_table(args, &block); end

  def invert_drop_table(args, &block); end

  def invert_enable_extension(args, &block); end

  def invert_execute_block(args, &block); end

  def invert_remove_column(args, &block); end

  def invert_remove_reference(args, &block); end

  def invert_remove_timestamps(args, &block); end

  def invert_transaction(args, &block); end
end

module ActiveRecord::Migration::CommandRecorder::StraightReversions
  extend ::T::Sig
end

class ActiveRecord::Migration::CommandRecorder
end

class ActiveRecord::Migration::Compatibility::V4_2
  def add_belongs_to(*_, **options); end

  def add_reference(*_, **options); end

  def add_timestamps(_, **options); end

  def index_exists?(table_name, column_name, options=T.unsafe(nil)); end

  def remove_index(table_name, options=T.unsafe(nil)); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  def belongs_to(*_, **options); end

  def references(*_, **options); end

  def timestamps(**options); end
end

module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  extend ::T::Sig
end

class ActiveRecord::Migration::Compatibility::V4_2
end

class ActiveRecord::Migration::Compatibility::V5_0
  def add_belongs_to(table_name, ref_name, **options); end

  def add_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def add_reference(table_name, ref_name, **options); end

  def change_table(table_name, options=T.unsafe(nil)); end

  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  def belongs_to(*args, **options); end

  def primary_key(name, type=T.unsafe(nil), **options); end

  def references(*args, **options); end
end

module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  extend ::T::Sig
end

class ActiveRecord::Migration::Compatibility::V5_0
end

class ActiveRecord::Migration::Compatibility::V5_1
  def change_column(table_name, column_name, type, options=T.unsafe(nil)); end

  def create_table(table_name, options=T.unsafe(nil)); end
end

class ActiveRecord::Migration::Compatibility::V5_1
end

module ActiveRecord::Migration::Compatibility
  extend ::T::Sig
  def self.find(version); end
end

module ActiveRecord::Migration::JoinTable
end

module ActiveRecord::Migration::JoinTable
  extend ::T::Sig
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def down(); end

  def reverting(); end

  def reverting=(_); end

  def up(); end
end

class ActiveRecord::Migration::ReversibleBlockHelper
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migration
  def self.[](version); end

  def self.check_pending!(connection=T.unsafe(nil)); end

  def self.current_version(); end

  def self.delegate(); end

  def self.delegate=(delegate); end

  def self.disable_ddl_transaction(); end

  def self.disable_ddl_transaction!(); end

  def self.disable_ddl_transaction=(disable_ddl_transaction); end

  def self.inherited(subclass); end

  def self.load_schema_if_pending!(); end

  def self.maintain_test_schema!(); end

  def self.method_missing(name, *args, &block); end

  def self.migrate(direction); end

  def self.nearest_delegate(); end

  def self.verbose(); end

  def self.verbose=(obj); end
end

class ActiveRecord::MigrationContext
  def any_migrations?(); end

  def current_environment(); end

  def current_version(); end

  def down(target_version=T.unsafe(nil)); end

  def forward(steps=T.unsafe(nil)); end

  def get_all_versions(); end

  def initialize(migrations_paths); end

  def last_migration(); end

  def last_stored_environment(); end

  def migrate(target_version=T.unsafe(nil), &block); end

  def migration_files(); end

  def migrations(); end

  def migrations_paths(); end

  def migrations_status(); end

  def needs_migration?(); end

  def open(); end

  def parse_migration_filename(filename); end

  def protected_environment?(); end

  def rollback(steps=T.unsafe(nil)); end

  def run(direction, target_version); end

  def up(target_version=T.unsafe(nil)); end
end

class ActiveRecord::MigrationContext
end

class ActiveRecord::MigrationError
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::MigrationError
end

class ActiveRecord::MigrationProxy
  def announce(*args, &block); end

  def basename(); end

  def disable_ddl_transaction(*args, &block); end

  def filename(); end

  def filename=(_); end

  def initialize(name, version, filename, scope); end

  def migrate(*args, &block); end

  def mtime(); end

  def name(); end

  def name=(_); end

  def scope(); end

  def scope=(_); end

  def version(); end

  def version=(_); end

  def write(*args, &block); end
end

class ActiveRecord::MigrationProxy
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::Migrator
  def current(); end

  def current_migration(); end

  def current_version(); end

  def initialize(direction, migrations, target_version=T.unsafe(nil)); end

  def load_migrated(); end

  def migrate(); end

  def migrated(); end

  def migrations(); end

  def pending_migrations(); end

  def run(); end

  def runnable(); end
  MIGRATOR_SALT = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Migrator
  def self.current_version(); end

  def self.migrations_path=(path); end

  def self.migrations_paths(); end

  def self.migrations_paths=(migrations_paths); end
end

class ActiveRecord::MismatchedForeignKey
  def initialize(adapter=T.unsafe(nil), message: T.unsafe(nil), table: T.unsafe(nil), foreign_key: T.unsafe(nil), target_table: T.unsafe(nil), primary_key: T.unsafe(nil)); end
end

class ActiveRecord::MismatchedForeignKey
end

module ActiveRecord::ModelSchema
end

module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.derive_join_table_name(first_table, second_table); end
end

class ActiveRecord::MultiparameterAssignmentErrors
  def errors(); end

  def initialize(errors=T.unsafe(nil)); end
end

class ActiveRecord::MultiparameterAssignmentErrors
end

module ActiveRecord::NestedAttributes
  def _destroy(); end
  UNASSIGNABLE_KEYS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::NoDatabaseError
end

class ActiveRecord::NoDatabaseError
end

class ActiveRecord::NoEnvironmentInSchemaError
  def initialize(); end
end

class ActiveRecord::NoEnvironmentInSchemaError
end

module ActiveRecord::NoTouching
  def no_touching?(); end

  def touch(*_); end

  def touch_later(*_); end
end

module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.applied_to?(klass); end

  def self.apply_to(klass); end
end

class ActiveRecord::NotNullViolation
end

class ActiveRecord::NotNullViolation
end

class ActiveRecord::NullMigration
  def initialize(); end
end

class ActiveRecord::NullMigration
end

module ActiveRecord::NullRelation
  def any?(); end

  def calculate(operation, _column_name); end

  def delete(_id_or_array); end

  def delete_all(); end

  def empty?(); end

  def exists?(_conditions=T.unsafe(nil)); end

  def many?(); end

  def none?(); end

  def one?(); end

  def or(other); end

  def pluck(*column_names); end

  def to_sql(); end

  def update_all(_updates); end
end

module ActiveRecord::NullRelation
  extend ::T::Sig
end

class ActiveRecord::PendingMigrationError
end

class ActiveRecord::PendingMigrationError
end

module ActiveRecord::Persistence
  def becomes(klass); end

  def becomes!(klass); end

  def decrement(attribute, by=T.unsafe(nil)); end

  def decrement!(attribute, by=T.unsafe(nil), touch: T.unsafe(nil)); end

  def delete(); end

  def destroy(); end

  def destroy!(); end

  def destroyed?(); end

  def increment(attribute, by=T.unsafe(nil)); end

  def increment!(attribute, by=T.unsafe(nil), touch: T.unsafe(nil)); end

  def new_record?(); end

  def persisted?(); end

  def reload(options=T.unsafe(nil)); end

  def save(*args, &block); end

  def save!(*args, &block); end

  def toggle(attribute); end

  def toggle!(attribute); end

  def touch(*names, time: T.unsafe(nil)); end

  def update(attributes); end

  def update!(attributes); end

  def update_attribute(name, value); end

  def update_attributes(attributes); end

  def update_attributes!(attributes); end

  def update_column(name, value); end

  def update_columns(attributes); end
end

module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class ActiveRecord::Point
  def self.[](*_); end

  def self.members(); end
end

class ActiveRecord::PredicateBuilder
  def build(attribute, value); end

  def build_bind_attribute(column_name, value); end

  def build_from_hash(attributes); end

  def expand_from_hash(attributes); end

  def initialize(table); end

  def register_handler(klass, handler); end

  def resolve_column_aliases(*args, &block); end

  def table(); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end

  def predicate_builder(); end
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
end

module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  extend ::T::Sig
  def self.or(other); end
end

class ActiveRecord::PredicateBuilder::ArrayHandler
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
  def associated_table(); end

  def initialize(associated_table, value); end

  def queries(); end

  def value(); end
end

class ActiveRecord::PredicateBuilder::AssociationQueryValue
end

class ActiveRecord::PredicateBuilder::BaseHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end

  def predicate_builder(); end
end

class ActiveRecord::PredicateBuilder::BaseHandler
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end

  def predicate_builder(); end
end

class ActiveRecord::PredicateBuilder::BasicObjectHandler
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  def associated_table(); end

  def initialize(associated_table, values); end

  def queries(); end

  def values(); end
end

class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
end

class ActiveRecord::PredicateBuilder::RangeHandler
  def call(attribute, value); end

  def initialize(predicate_builder); end

  def predicate_builder(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
  def exclude_end?(); end
end

class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds
end

class ActiveRecord::PredicateBuilder::RangeHandler
end

class ActiveRecord::PredicateBuilder::RelationHandler
  def call(attribute, value); end
end

class ActiveRecord::PredicateBuilder::RelationHandler
end

class ActiveRecord::PredicateBuilder
  def self.references(attributes); end
end

class ActiveRecord::PreparedStatementCacheExpired
end

class ActiveRecord::PreparedStatementCacheExpired
end

class ActiveRecord::PreparedStatementInvalid
end

class ActiveRecord::PreparedStatementInvalid
end

class ActiveRecord::ProtectedEnvironmentError
  def initialize(env=T.unsafe(nil)); end
end

class ActiveRecord::ProtectedEnvironmentError
end

class ActiveRecord::QueryCache
end

module ActiveRecord::QueryCache::ClassMethods
  def cache(&block); end

  def uncached(&block); end
end

module ActiveRecord::QueryCache::ClassMethods
  extend ::T::Sig
end

class ActiveRecord::QueryCache
  def self.complete(pools); end

  def self.install_executor_hooks(executor=T.unsafe(nil)); end

  def self.run(); end
end

class ActiveRecord::QueryCanceled
end

class ActiveRecord::QueryCanceled
end

module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  def _select!(*fields); end

  def arel(aliases=T.unsafe(nil)); end

  def create_with(value); end

  def create_with!(value); end

  def create_with_value(); end

  def create_with_value=(value); end

  def distinct(value=T.unsafe(nil)); end

  def distinct!(value=T.unsafe(nil)); end

  def distinct_value(); end

  def distinct_value=(value); end

  def eager_load(*args); end

  def eager_load!(*args); end

  def eager_load_values(); end

  def eager_load_values=(value); end

  def extending(*modules, &block); end

  def extending!(*modules, &block); end

  def extending_values(); end

  def extending_values=(value); end

  def extensions(); end

  def from(value, subquery_name=T.unsafe(nil)); end

  def from!(value, subquery_name=T.unsafe(nil)); end

  def from_clause(); end

  def from_clause=(value); end

  def get_value(name); end

  def group(*args); end

  def group!(*args); end

  def group_values(); end

  def group_values=(value); end

  def having(opts, *rest); end

  def having!(opts, *rest); end

  def having_clause(); end

  def having_clause=(value); end

  def includes(*args); end

  def includes!(*args); end

  def includes_values(); end

  def includes_values=(value); end

  def joins(*args); end

  def joins!(*args); end

  def joins_values(); end

  def joins_values=(value); end

  def left_joins(*args); end

  def left_outer_joins(*args); end

  def left_outer_joins!(*args); end

  def left_outer_joins_values(); end

  def left_outer_joins_values=(value); end

  def limit(value); end

  def limit!(value); end

  def limit_value(); end

  def limit_value=(value); end

  def lock(locks=T.unsafe(nil)); end

  def lock!(locks=T.unsafe(nil)); end

  def lock_value(); end

  def lock_value=(value); end

  def none(); end

  def none!(); end

  def offset(value); end

  def offset!(value); end

  def offset_value(); end

  def offset_value=(value); end

  def or(other); end

  def or!(other); end

  def order(*args); end

  def order!(*args); end

  def order_values(); end

  def order_values=(value); end

  def preload(*args); end

  def preload!(*args); end

  def preload_values(); end

  def preload_values=(value); end

  def readonly(value=T.unsafe(nil)); end

  def readonly!(value=T.unsafe(nil)); end

  def readonly_value(); end

  def readonly_value=(value); end

  def references(*table_names); end

  def references!(*table_names); end

  def references_values(); end

  def references_values=(value); end

  def reorder(*args); end

  def reorder!(*args); end

  def reordering_value(); end

  def reordering_value=(value); end

  def reverse_order(); end

  def reverse_order!(); end

  def reverse_order_value(); end

  def reverse_order_value=(value); end

  def rewhere(conditions); end

  def select(*fields); end

  def select_values(); end

  def select_values=(value); end

  def set_value(name, value); end

  def skip_query_cache!(value=T.unsafe(nil)); end

  def skip_query_cache_value(); end

  def skip_query_cache_value=(value); end

  def unscope(*args); end

  def unscope!(*args); end

  def unscope_values(); end

  def unscope_values=(value); end

  def where(opts=T.unsafe(nil), *rest); end

  def where!(opts, *rest); end

  def where_clause(); end

  def where_clause=(value); end
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_ARRAY = ::T.let(nil, ::T.untyped)
  FROZEN_EMPTY_HASH = ::T.let(nil, ::T.untyped)
  STRUCTURAL_OR_METHODS = ::T.let(nil, ::T.untyped)
  VALID_DIRECTIONS = ::T.let(nil, ::T.untyped)
  VALID_UNSCOPING_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::QueryMethods::WhereChain
  include ::ActiveModel::ForbiddenAttributesProtection
  def initialize(scope); end

  def not(opts, *rest); end
end

class ActiveRecord::QueryMethods::WhereChain
end

module ActiveRecord::QueryMethods
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Querying
  def any?(*args, &block); end

  def average(*args, &block); end

  def calculate(*args, &block); end

  def count(*args, &block); end

  def count_by_sql(sql); end

  def create_with(*args, &block); end

  def delete_all(*args, &block); end

  def destroy_all(*args, &block); end

  def distinct(*args, &block); end

  def eager_load(*args, &block); end

  def except(*args, &block); end

  def exists?(*args, &block); end

  def extending(*args, &block); end

  def fifth(*args, &block); end

  def fifth!(*args, &block); end

  def find(*args, &block); end

  def find_by(*args, &block); end

  def find_by!(*args, &block); end

  def find_by_sql(sql, binds=T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  def find_each(*args, &block); end

  def find_in_batches(*args, &block); end

  def find_or_create_by(*args, &block); end

  def find_or_create_by!(*args, &block); end

  def find_or_initialize_by(*args, &block); end

  def first(*args, &block); end

  def first!(*args, &block); end

  def first_or_create(*args, &block); end

  def first_or_create!(*args, &block); end

  def first_or_initialize(*args, &block); end

  def forty_two(*args, &block); end

  def forty_two!(*args, &block); end

  def fourth(*args, &block); end

  def fourth!(*args, &block); end

  def from(*args, &block); end

  def group(*args, &block); end

  def having(*args, &block); end

  def ids(*args, &block); end

  def in_batches(*args, &block); end

  def includes(*args, &block); end

  def joins(*args, &block); end

  def last(*args, &block); end

  def last!(*args, &block); end

  def left_joins(*args, &block); end

  def left_outer_joins(*args, &block); end

  def limit(*args, &block); end

  def lock(*args, &block); end

  def many?(*args, &block); end

  def maximum(*args, &block); end

  def merge(*args, &block); end

  def minimum(*args, &block); end

  def none(*args, &block); end

  def none?(*args, &block); end

  def offset(*args, &block); end

  def one?(*args, &block); end

  def or(*args, &block); end

  def order(*args, &block); end

  def pluck(*args, &block); end

  def preload(*args, &block); end

  def readonly(*args, &block); end

  def references(*args, &block); end

  def reorder(*args, &block); end

  def rewhere(*args, &block); end

  def second(*args, &block); end

  def second!(*args, &block); end

  def second_to_last(*args, &block); end

  def second_to_last!(*args, &block); end

  def select(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take!(*args, &block); end

  def third(*args, &block); end

  def third!(*args, &block); end

  def third_to_last(*args, &block); end

  def third_to_last!(*args, &block); end

  def unscope(*args, &block); end

  def update_all(*args, &block); end

  def where(*args, &block); end
end

module ActiveRecord::Querying
  extend ::T::Sig
end

class ActiveRecord::Railtie
end

class ActiveRecord::Railtie
end

module ActiveRecord::Railties
end

module ActiveRecord::Railties::ControllerRuntime
  def db_runtime(); end

  def db_runtime=(db_runtime); end
end

module ActiveRecord::Railties::ControllerRuntime
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Railties
  extend ::T::Sig
end

class ActiveRecord::RangeError
end

class ActiveRecord::RangeError
end

class ActiveRecord::ReadOnlyRecord
end

class ActiveRecord::ReadOnlyRecord
end

module ActiveRecord::ReadonlyAttributes
end

module ActiveRecord::ReadonlyAttributes
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::RecordInvalid
  def initialize(record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordInvalid
end

class ActiveRecord::RecordNotDestroyed
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotDestroyed
end

class ActiveRecord::RecordNotFound
  def id(); end

  def initialize(message=T.unsafe(nil), model=T.unsafe(nil), primary_key=T.unsafe(nil), id=T.unsafe(nil)); end

  def model(); end

  def primary_key(); end
end

class ActiveRecord::RecordNotFound
end

class ActiveRecord::RecordNotSaved
  def initialize(message=T.unsafe(nil), record=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::RecordNotSaved
end

class ActiveRecord::RecordNotUnique
end

class ActiveRecord::RecordNotUnique
end

module ActiveRecord::Reflection
end

module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.add_aggregate_reflection(ar, name, reflection); end

  def self.add_reflection(ar, name, reflection); end

  def self.create(macro, name, scope, options, ar); end
end

class ActiveRecord::Relation
  include ::Enumerable
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  def ==(other); end

  def _exec_scope(*args, &block); end

  def alias_tracker(joins=T.unsafe(nil), aliases=T.unsafe(nil)); end

  def any?(); end

  def arel_attribute(name); end

  def build(attributes=T.unsafe(nil), &block); end

  def cache_key(timestamp_column=T.unsafe(nil)); end

  def create(attributes=T.unsafe(nil), &block); end

  def create!(attributes=T.unsafe(nil), &block); end

  def delete_all(); end

  def destroy_all(); end

  def eager_loading?(); end

  def empty?(); end

  def empty_scope?(); end

  def encode_with(coder); end

  def explain(); end

  def find_or_create_by(attributes, &block); end

  def find_or_create_by!(attributes, &block); end

  def find_or_initialize_by(attributes, &block); end

  def first_or_create(attributes=T.unsafe(nil), &block); end

  def first_or_create!(attributes=T.unsafe(nil), &block); end

  def first_or_initialize(attributes=T.unsafe(nil), &block); end

  def has_limit_or_offset?(); end

  def initialize(klass, table: T.unsafe(nil), predicate_builder: T.unsafe(nil), values: T.unsafe(nil)); end

  def joined_includes_values(); end

  def klass(); end

  def load(&block); end

  def load_records(records); end

  def loaded(); end

  def loaded?(); end

  def locked?(); end

  def model(); end

  def new(attributes=T.unsafe(nil), &block); end

  def none?(); end

  def one?(); end

  def predicate_builder(); end

  def records(); end

  def reload(); end

  def reset(); end

  def scope_for_create(attributes=T.unsafe(nil)); end

  def scoping(); end

  def size(); end

  def table(); end

  def to_a(); end

  def to_ary(); end

  def to_sql(); end

  def update_all(updates); end

  def values(); end

  def where_values_hash(relation_table_name=T.unsafe(nil)); end
  CLAUSE_METHODS = ::T.let(nil, ::T.untyped)
  INVALID_METHODS_FOR_DELETE_ALL = ::T.let(nil, ::T.untyped)
  MULTI_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  SINGLE_VALUE_METHODS = ::T.let(nil, ::T.untyped)
  VALUE_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::FromClause
  def empty?(); end

  def initialize(value, name); end

  def merge(other); end

  def name(); end

  def value(); end
end

class ActiveRecord::Relation::FromClause
  def self.empty(); end
end

class ActiveRecord::Relation::HashMerger
  def initialize(relation, hash); end

  def merge(); end

  def other(); end

  def relation(); end
end

class ActiveRecord::Relation::HashMerger
end

class ActiveRecord::Relation::Merger
  def initialize(relation, other); end

  def merge(); end

  def normal_values(); end

  def other(); end

  def relation(); end

  def values(); end
  NORMAL_VALUES = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::Merger
end

class ActiveRecord::Relation::QueryAttribute
  def boundable?(); end

  def infinity?(); end

  def type_cast(value); end
end

class ActiveRecord::Relation::QueryAttribute
end

class ActiveRecord::Relation::WhereClause
  def +(other); end

  def -(other); end

  def ==(other); end

  def any?(*args, &block); end

  def ast(); end

  def empty?(*args, &block); end

  def except(*columns); end

  def initialize(predicates); end

  def invert(); end

  def merge(other); end

  def or(other); end

  def predicates(); end

  def referenced_columns(); end

  def to_h(table_name=T.unsafe(nil)); end
  ARRAY_WITH_EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Relation::WhereClause
  def self.empty(); end
end

class ActiveRecord::Relation::WhereClauseFactory
  def build(opts, other); end

  def initialize(klass, predicate_builder); end

  def klass(); end

  def predicate_builder(); end
end

class ActiveRecord::Relation::WhereClauseFactory
end

class ActiveRecord::Relation
  extend ::ActiveRecord::Delegation::ClassMethods
end

class ActiveRecord::Result
  include ::Enumerable
  def [](idx); end

  def cast_values(type_overrides=T.unsafe(nil)); end

  def collect!(); end

  def column_types(); end

  def columns(); end

  def each(); end

  def empty?(); end

  def first(); end

  def initialize(columns, rows, column_types=T.unsafe(nil)); end

  def last(); end

  def length(); end

  def map!(); end

  def rows(); end

  def to_ary(); end

  def to_hash(); end
end

class ActiveRecord::Result
end

class ActiveRecord::Rollback
end

class ActiveRecord::Rollback
end

class ActiveRecord::RuntimeRegistry
  def connection_handler(); end

  def connection_handler=(connection_handler); end

  def sql_runtime(); end

  def sql_runtime=(sql_runtime); end
end

class ActiveRecord::RuntimeRegistry
  extend ::ActiveSupport::PerThreadRegistry
  def self.connection_handler(); end

  def self.connection_handler=(x); end

  def self.sql_runtime(); end

  def self.sql_runtime=(x); end
end

module ActiveRecord::Sanitization
end

module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::Schema
  def define(info, &block); end
end

class ActiveRecord::SchemaDumper
  def dump(stream); end

  def ignore_tables(); end

  def ignore_tables=(obj); end

  def initialize(connection, options=T.unsafe(nil)); end
end

class ActiveRecord::SchemaDumper
  def self.dump(connection=T.unsafe(nil), stream=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.ignore_tables(); end

  def self.ignore_tables=(obj); end
end

class ActiveRecord::SchemaMigration
  include ::ActiveRecord::SchemaMigration::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  def version(); end
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
end

module ActiveRecord::SchemaMigration::GeneratedAssociationMethods
  extend ::T::Sig
end

class ActiveRecord::SchemaMigration
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.all_versions(); end

  def self.create_table(); end

  def self.drop_table(); end

  def self.normalize_migration_number(number); end

  def self.normalized_versions(); end

  def self.page(num=T.unsafe(nil)); end
end

module ActiveRecord::Scoping
  def initialize_internals_callback(); end

  def populate_with_current_scope_attributes(); end
end

module ActiveRecord::Scoping::Default
end

module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Scoping::Named
end

module ActiveRecord::Scoping::Named
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActiveRecord::SecureToken
end

module ActiveRecord::SecureToken
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Serialization
  def serializable_hash(options=T.unsafe(nil)); end
end

module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::SerializationFailure
end

class ActiveRecord::SerializationFailure
end

class ActiveRecord::SerializationTypeMismatch
end

class ActiveRecord::SerializationTypeMismatch
end

module ActiveRecord::SpawnMethods
  def except(*skips); end

  def merge(other); end

  def merge!(other); end

  def only(*onlies); end

  def spawn(); end
end

module ActiveRecord::SpawnMethods
  extend ::T::Sig
end

class ActiveRecord::StaleObjectError
  def attempted_action(); end

  def initialize(record=T.unsafe(nil), attempted_action=T.unsafe(nil)); end

  def record(); end
end

class ActiveRecord::StaleObjectError
end

class ActiveRecord::StatementCache
  def bind_map(); end

  def execute(params, connection, &block); end

  def initialize(query_builder, bind_map, klass); end

  def klass(); end

  def query_builder(); end
end

class ActiveRecord::StatementCache::BindMap
  def bind(values); end

  def initialize(bound_attributes); end
end

class ActiveRecord::StatementCache::BindMap
end

class ActiveRecord::StatementCache::Params
  def bind(); end
end

class ActiveRecord::StatementCache::Params
end

class ActiveRecord::StatementCache::PartialQuery
  def initialize(values); end
end

class ActiveRecord::StatementCache::PartialQuery
end

class ActiveRecord::StatementCache::Query
  def initialize(sql); end

  def sql_for(binds, connection); end
end

class ActiveRecord::StatementCache::Query
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache::Substitute
end

class ActiveRecord::StatementCache
  def self.create(connection, block=T.unsafe(nil)); end

  def self.partial_query(values); end

  def self.query(sql); end

  def self.unsupported_value?(value); end
end

class ActiveRecord::StatementInvalid
  def initialize(message=T.unsafe(nil)); end
end

class ActiveRecord::StatementInvalid
end

class ActiveRecord::StatementTimeout
end

class ActiveRecord::StatementTimeout
end

module ActiveRecord::Store
end

module ActiveRecord::Store
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::SubclassNotFound
end

class ActiveRecord::SubclassNotFound
end

module ActiveRecord::Suppressor
  def save(*_); end

  def save!(*_); end
end

module ActiveRecord::Suppressor
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::SuppressorRegistry
  def suppressed(); end
end

class ActiveRecord::SuppressorRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveRecord::TableMetadata
  def aggregated_with?(aggregation_name); end

  def arel_attribute(column_name); end

  def arel_table(); end

  def associated_table(table_name); end

  def associated_with?(association_name); end

  def association(); end

  def association_foreign_key(*args, &block); end

  def association_foreign_type(*args, &block); end

  def association_join_foreign_key(*args, &block); end

  def association_join_primary_key(*args, &block); end

  def has_column?(column_name); end

  def initialize(klass, arel_table, association=T.unsafe(nil)); end

  def klass(); end

  def polymorphic_association?(); end

  def reflect_on_aggregation(aggregation_name); end

  def resolve_column_aliases(hash); end

  def type(column_name); end
end

class ActiveRecord::TableMetadata
end

module ActiveRecord::Tasks
end

module ActiveRecord::Tasks::DatabaseTasks
  def charset(*arguments); end

  def charset_current(environment=T.unsafe(nil)); end

  def check_protected_environments!(); end

  def check_schema_file(filename); end

  def check_target_version(); end

  def collation(*arguments); end

  def collation_current(environment=T.unsafe(nil)); end

  def create(*arguments); end

  def create_all(); end

  def create_current(environment=T.unsafe(nil)); end

  def current_config(options=T.unsafe(nil)); end

  def current_config=(current_config); end

  def database_configuration(); end

  def database_configuration=(database_configuration); end

  def db_dir(); end

  def db_dir=(db_dir); end

  def drop(*arguments); end

  def drop_all(); end

  def drop_current(environment=T.unsafe(nil)); end

  def dump_schema_cache(conn, filename); end

  def env(); end

  def env=(env); end

  def fixtures_path(); end

  def fixtures_path=(fixtures_path); end

  def load_schema(configuration, format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_schema_current(format=T.unsafe(nil), file=T.unsafe(nil), environment=T.unsafe(nil)); end

  def load_seed(); end

  def migrate(); end

  def migrations_paths(); end

  def migrations_paths=(migrations_paths); end

  def purge(configuration); end

  def purge_all(); end

  def purge_current(environment=T.unsafe(nil)); end

  def register_task(pattern, task); end

  def root(); end

  def root=(root); end

  def schema_file(format=T.unsafe(nil)); end

  def seed_loader(); end

  def seed_loader=(seed_loader); end

  def structure_dump(*arguments); end

  def structure_load(*arguments); end

  def target_version(); end
  LOCAL_HOSTS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Tasks::DatabaseTasks
  extend ::ActiveRecord::Tasks::DatabaseTasks
  extend ::T::Sig
  def self.structure_dump_flags(); end

  def self.structure_dump_flags=(obj); end

  def self.structure_load_flags(); end

  def self.structure_load_flags=(obj); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
  def charset(); end

  def collation(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::MySQLDatabaseTasks
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  def charset(); end

  def clear_active_connections!(*args, &block); end

  def collation(); end

  def connection(*args, &block); end

  def create(master_established=T.unsafe(nil)); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  ON_ERROR_STOP_1 = ::T.let(nil, ::T.untyped)
  SQL_COMMENT_BEGIN = ::T.let(nil, ::T.untyped)
end

class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
  def charset(); end

  def connection(*args, &block); end

  def create(); end

  def drop(); end

  def establish_connection(*args, &block); end

  def initialize(configuration, root=T.unsafe(nil)); end

  def purge(); end

  def structure_dump(filename, extra_flags); end

  def structure_load(filename, extra_flags); end
end

class ActiveRecord::Tasks::SQLiteDatabaseTasks
end

module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module ActiveRecord::TestFixtures
  def after_teardown(); end

  def before_setup(); end

  def enlist_fixture_connections(); end

  def run_in_transaction?(); end

  def setup_fixtures(config=T.unsafe(nil)); end

  def teardown_fixtures(); end
end

module ActiveRecord::TestFixtures::ClassMethods
  def fixtures(*fixture_set_names); end

  def set_fixture_class(class_names=T.unsafe(nil)); end

  def setup_fixture_accessors(fixture_set_names=T.unsafe(nil)); end

  def uses_transaction(*methods); end

  def uses_transaction?(method); end
end

module ActiveRecord::TestFixtures::ClassMethods
  extend ::T::Sig
end

module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection
end

class ActiveRecord::ThroughNestedAssociationsAreReadonly
  def initialize(owner=T.unsafe(nil), reflection=T.unsafe(nil)); end
end

class ActiveRecord::ThroughNestedAssociationsAreReadonly
end

module ActiveRecord::Timestamp
end

module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::TouchLater
  def touch(*names, time: T.unsafe(nil)); end

  def touch_later(*names); end
end

module ActiveRecord::TouchLater
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::TransactionIsolationError
end

class ActiveRecord::TransactionIsolationError
end

class ActiveRecord::TransactionRollbackError
end

class ActiveRecord::TransactionRollbackError
end

module ActiveRecord::Transactions
  def _committed_already_called(); end

  def _trigger_destroy_callback(); end

  def _trigger_update_callback(); end

  def add_to_transaction(); end

  def before_committed!(); end

  def committed!(should_run_callbacks: T.unsafe(nil)); end

  def destroy(); end

  def rollback_active_record_state!(); end

  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  def save(*_); end

  def save!(*_); end

  def touch(*_); end

  def transaction(options=T.unsafe(nil), &block); end

  def with_transaction_returning_status(); end
  ACTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveRecord::Translation
  include ::ActiveModel::Translation
  include ::ActiveModel::Naming
  def i18n_scope(); end

  def lookup_ancestors(); end
end

module ActiveRecord::Translation
  extend ::T::Sig
end

module ActiveRecord::Type
end

class ActiveRecord::Type::AdapterSpecificRegistry
  def add_modifier(options, klass, **args); end
end

class ActiveRecord::Type::AdapterSpecificRegistry
end

ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger

ActiveRecord::Type::Binary = ActiveModel::Type::Binary

ActiveRecord::Type::Boolean = ActiveModel::Type::Boolean

class ActiveRecord::Type::Date
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Date
end

class ActiveRecord::Type::DateTime
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::DateTime
end

ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecimalWithoutScale
end

class ActiveRecord::Type::DecorationRegistration
  def call(registry, *args, **kwargs); end

  def initialize(options, klass, adapter: T.unsafe(nil)); end

  def klass(); end

  def matches?(*args, **kwargs); end

  def options(); end
end

class ActiveRecord::Type::DecorationRegistration
end

ActiveRecord::Type::Float = ActiveModel::Type::Float

class ActiveRecord::Type::HashLookupTypeMap
  def alias_type(type, alias_type); end

  def key?(key); end

  def keys(); end
end

class ActiveRecord::Type::HashLookupTypeMap
end

ActiveRecord::Type::Helpers = ActiveModel::Type::Helpers

ActiveRecord::Type::Integer = ActiveModel::Type::Integer

module ActiveRecord::Type::Internal
end

module ActiveRecord::Type::Internal::Timezone
  def default_timezone(); end

  def is_utc?(); end
end

module ActiveRecord::Type::Internal::Timezone
  extend ::T::Sig
end

module ActiveRecord::Type::Internal
  extend ::T::Sig
end

class ActiveRecord::Type::Json
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end
end

class ActiveRecord::Type::Json
end

class ActiveRecord::Type::Registration
  def adapter(); end

  def block(); end

  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  def matches?(type_name, *args, **kwargs); end

  def name(); end

  def override(); end

  def priority(); end

  def priority_except_adapter(); end
end

class ActiveRecord::Type::Registration
end

class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable
  def accessor(); end

  def assert_valid_value(value); end

  def changed_in_place?(raw_old_value, value); end

  def coder(); end

  def deserialize(value); end

  def force_equality?(value); end

  def initialize(subtype, coder); end

  def inspect(); end

  def serialize(value); end

  def subtype(); end
end

class ActiveRecord::Type::Serialized
end

ActiveRecord::Type::String = ActiveModel::Type::String

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Text
end

class ActiveRecord::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time::Value
end

class ActiveRecord::Type::Time
end

class ActiveRecord::Type::TypeMap
  def alias_type(key, target_key); end

  def clear(); end

  def fetch(lookup_key, *args, &block); end

  def lookup(lookup_key, *args); end

  def register_type(key, value=T.unsafe(nil), &block); end
end

class ActiveRecord::Type::TypeMap
end

class ActiveRecord::Type::UnsignedInteger
end

class ActiveRecord::Type::UnsignedInteger
end

ActiveRecord::Type::Value = ActiveModel::Type::Value

module ActiveRecord::Type
  extend ::T::Sig
  def self.add_modifier(*args, &block); end

  def self.default_value(); end

  def self.lookup(*args, adapter: T.unsafe(nil), **kwargs); end

  def self.register(type_name, klass=T.unsafe(nil), **options, &block); end

  def self.registry(); end

  def self.registry=(registry); end
end

module ActiveRecord::TypeCaster
end

class ActiveRecord::TypeCaster::Connection
  def connection(*args, &block); end

  def initialize(klass, table_name); end

  def table_name(); end

  def type_cast_for_database(attribute_name, value); end
end

class ActiveRecord::TypeCaster::Connection
end

class ActiveRecord::TypeCaster::Map
  def initialize(types); end

  def type_cast_for_database(attr_name, value); end

  def types(); end
end

class ActiveRecord::TypeCaster::Map
end

module ActiveRecord::TypeCaster
  extend ::T::Sig
end

class ActiveRecord::TypeConflictError
end

class ActiveRecord::TypeConflictError
end

ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError

class ActiveRecord::UnknownAttributeReference
end

class ActiveRecord::UnknownAttributeReference
end

class ActiveRecord::UnknownMigrationVersionError
  def initialize(version=T.unsafe(nil)); end
end

class ActiveRecord::UnknownMigrationVersionError
end

class ActiveRecord::UnknownPrimaryKey
  def initialize(model=T.unsafe(nil), description=T.unsafe(nil)); end

  def model(); end
end

class ActiveRecord::UnknownPrimaryKey
end

module ActiveRecord::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveRecord::VERSION
  extend ::T::Sig
end

module ActiveRecord::Validations
  def save(options=T.unsafe(nil)); end

  def save!(options=T.unsafe(nil)); end

  def valid?(context=T.unsafe(nil)); end

  def validate(context=T.unsafe(nil)); end
end

module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveRecord::ValueTooLong
end

class ActiveRecord::ValueTooLong
end

class ActiveRecord::WrappedDatabaseException
end

class ActiveRecord::WrappedDatabaseException
end

module ActiveRecord
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.gem_version(); end

  def self.version(); end
end

module ActiveStorage
  def analyzers(); end

  def analyzers=(obj); end

  def content_types_to_serve_as_binary(); end

  def content_types_to_serve_as_binary=(obj); end

  def logger(); end

  def logger=(obj); end

  def paths(); end

  def paths=(obj); end

  def previewers(); end

  def previewers=(obj); end

  def queue(); end

  def queue=(obj); end

  def variable_content_types(); end

  def variable_content_types=(obj); end

  def verifier(); end

  def verifier=(obj); end
end

class ActiveStorage::Analyzer
  include ::ActiveStorage::Downloading
  def blob(); end

  def initialize(blob); end

  def metadata(); end
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::ImageAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer::VideoAnalyzer
end

class ActiveStorage::Analyzer
  def self.accept?(blob); end
end

class ActiveStorage::Attached
  def dependent(); end

  def initialize(name, record, dependent:); end

  def name(); end

  def record(); end
end

module ActiveStorage::Attached::Macros
  def has_many_attached(name, dependent: T.unsafe(nil)); end

  def has_one_attached(name, dependent: T.unsafe(nil)); end
end

module ActiveStorage::Attached::Macros
  extend ::T::Sig
end

class ActiveStorage::Attached::Many
  def attach(*attachables); end

  def attached?(); end

  def attachments(); end

  def detach(); end

  def method_missing(method, *args, &block); end
end

class ActiveStorage::Attached::Many
end

class ActiveStorage::Attached::One
  def attach(attachable); end

  def attached?(); end

  def attachment(); end

  def detach(); end

  def method_missing(method, *args, &block); end

  def purge(); end

  def purge_later(); end

  def transaction(*args, &block); end
end

class ActiveStorage::Attached::One
end

class ActiveStorage::Attached
end

module ActiveStorage::Downloading
end

module ActiveStorage::Downloading
  extend ::T::Sig
end

class ActiveStorage::Engine
end

class ActiveStorage::Engine
end

class ActiveStorage::InvariableError
end

class ActiveStorage::InvariableError
end

class ActiveStorage::Previewer
  include ::ActiveStorage::Downloading
  def blob(); end

  def initialize(blob); end

  def preview(); end
end

class ActiveStorage::Previewer::MuPDFPreviewer
end

class ActiveStorage::Previewer::MuPDFPreviewer
  def self.mutool_exists?(); end

  def self.mutool_path(); end
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
end

class ActiveStorage::Previewer::PopplerPDFPreviewer
  def self.pdftoppm_exists?(); end

  def self.pdftoppm_path(); end
end

class ActiveStorage::Previewer::VideoPreviewer
end

class ActiveStorage::Previewer::VideoPreviewer
end

class ActiveStorage::Previewer
  def self.accept?(blob); end
end

class ActiveStorage::Service
  def delete(key); end

  def delete_prefixed(prefix); end

  def download(key); end

  def download_chunk(key, range); end

  def exist?(key); end

  def headers_for_direct_upload(key, filename:, content_type:, content_length:, checksum:); end

  def upload(key, io, checksum: T.unsafe(nil)); end

  def url(key, expires_in:, disposition:, filename:, content_type:); end

  def url_expires_in(); end

  def url_expires_in=(val); end

  def url_expires_in?(); end

  def url_for_direct_upload(key, expires_in:, content_type:, content_length:, checksum:); end
end

class ActiveStorage::Service::Configurator
  def build(service_name); end

  def configurations(); end

  def initialize(configurations); end
end

class ActiveStorage::Service::Configurator
  def self.build(service_name, configurations); end
end

class ActiveStorage::Service
  extend ::ActiveSupport::Autoload
  def self.build(configurator:, service: T.unsafe(nil), **service_config); end

  def self.configure(service_name, configurations); end

  def self.url_expires_in(); end

  def self.url_expires_in=(val); end

  def self.url_expires_in?(); end
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnpreviewableError
end

class ActiveStorage::UnrepresentableError
end

class ActiveStorage::UnrepresentableError
end

module ActiveStorage::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveStorage::VERSION
  extend ::T::Sig
end

module ActiveStorage
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.analyzers(); end

  def self.analyzers=(obj); end

  def self.content_types_to_serve_as_binary(); end

  def self.content_types_to_serve_as_binary=(obj); end

  def self.gem_version(); end

  def self.logger(); end

  def self.logger=(obj); end

  def self.paths(); end

  def self.paths=(obj); end

  def self.previewers(); end

  def self.previewers=(obj); end

  def self.queue(); end

  def self.queue=(obj); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end

  def self.variable_content_types(); end

  def self.variable_content_types=(obj); end

  def self.verifier(); end

  def self.verifier=(obj); end

  def self.version(); end
end

module ActiveSupport
  def parse_json_times(); end

  def parse_json_times=(obj); end

  def test_order(); end

  def test_order=(obj); end
end

class ActiveSupport::ArrayInquirer
  def any?(*candidates); end
end

class ActiveSupport::ArrayInquirer
end

module ActiveSupport::Autoload
  def autoload(const_name, path=T.unsafe(nil)); end

  def autoload_at(path); end

  def autoload_under(path); end

  def autoloads(); end

  def eager_autoload(); end

  def eager_load!(); end
end

module ActiveSupport::Autoload
  extend ::T::Sig
  def self.extended(base); end
end

class ActiveSupport::BacktraceCleaner
  def add_filter(&block); end

  def add_silencer(&block); end

  def clean(backtrace, kind=T.unsafe(nil)); end

  def filter(backtrace, kind=T.unsafe(nil)); end

  def remove_filters!(); end

  def remove_silencers!(); end
end

class ActiveSupport::BacktraceCleaner
end

module ActiveSupport::Benchmarkable
  def benchmark(message=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::Benchmarkable
  extend ::T::Sig
end

module ActiveSupport::BigDecimalWithDefaultFormat
  def to_s(format=T.unsafe(nil)); end
end

module ActiveSupport::BigDecimalWithDefaultFormat
  extend ::T::Sig
end

module ActiveSupport::Cache
  UNIVERSAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::ConnectionPoolLike
  def with(); end
end

module ActiveSupport::Cache::ConnectionPoolLike
  extend ::T::Sig
end

class ActiveSupport::Cache::Entry
  def dup_value!(); end

  def expired?(); end

  def expires_at(); end

  def expires_at=(value); end

  def initialize(value, compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), version: T.unsafe(nil), expires_in: T.unsafe(nil), **_); end

  def mismatched?(version); end

  def size(); end

  def value(); end

  def version(); end
  DEFAULT_COMPRESS_LIMIT = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::Entry
end

class ActiveSupport::Cache::FileStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  def cache_path(); end

  def initialize(cache_path, options=T.unsafe(nil)); end
  DIR_FORMATTER = ::T.let(nil, ::T.untyped)
  EXCLUDED_DIRS = ::T.let(nil, ::T.untyped)
  FILENAME_MAX_SIZE = ::T.let(nil, ::T.untyped)
  FILEPATH_MAX_SIZE = ::T.let(nil, ::T.untyped)
  GITKEEP_FILES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::FileStore
end

class ActiveSupport::Cache::MemCacheStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  include ::ActiveSupport::Cache::MemCacheStore::LocalCacheWithRaw
  def initialize(*addresses); end

  def stats(); end
  ESCAPE_KEY_CHARS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::MemCacheStore::LocalCacheWithRaw
end

module ActiveSupport::Cache::MemCacheStore::LocalCacheWithRaw
  extend ::T::Sig
end

class ActiveSupport::Cache::MemCacheStore
  def self.build_mem_cache(*addresses); end
end

class ActiveSupport::Cache::MemoryStore
  def prune(target_size, max_time=T.unsafe(nil)); end

  def pruning?(); end

  def synchronize(&block); end
  PER_ENTRY_OVERHEAD = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Cache::MemoryStore
end

class ActiveSupport::Cache::NullStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
end

class ActiveSupport::Cache::NullStore
end

class ActiveSupport::Cache::RedisCacheStore
  include ::ActiveSupport::Cache::Strategy::LocalCache
  include ::ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
  def initialize(namespace: T.unsafe(nil), compress: T.unsafe(nil), compress_threshold: T.unsafe(nil), expires_in: T.unsafe(nil), race_condition_ttl: T.unsafe(nil), error_handler: T.unsafe(nil), **redis_options); end

  def max_key_bytesize(); end

  def mget_capable?(); end

  def mset_capable?(); end

  def redis(); end

  def redis_options(); end
  DEFAULT_ERROR_HANDLER = ::T.let(nil, ::T.untyped)
  DEFAULT_REDIS_OPTIONS = ::T.let(nil, ::T.untyped)
  MAX_KEY_BYTESIZE = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
end

module ActiveSupport::Cache::RedisCacheStore::LocalCacheWithRaw
  extend ::T::Sig
end

class ActiveSupport::Cache::RedisCacheStore
  def self.build_redis(redis: T.unsafe(nil), url: T.unsafe(nil), **redis_options); end
end

class ActiveSupport::Cache::Store
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(*args, &block); end

  def delete_matched(matcher, options=T.unsafe(nil)); end

  def delete_without_datadog(name, options=T.unsafe(nil)); end

  def exist?(name, options=T.unsafe(nil)); end

  def fetch(*args, &block); end

  def fetch_multi(*names); end

  def fetch_without_datadog(name, options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def logger(); end

  def logger=(obj); end

  def mute(); end

  def options(); end

  def read(*args, &block); end

  def read_multi(*names); end

  def read_without_datadog(name, options=T.unsafe(nil)); end

  def silence(); end

  def silence!(); end

  def silence?(); end

  def write(*args, &block); end

  def write_multi(hash, options=T.unsafe(nil)); end

  def write_without_datadog(name, value, options=T.unsafe(nil)); end
end

class ActiveSupport::Cache::Store
  def self.logger(); end

  def self.logger=(obj); end
end

module ActiveSupport::Cache::Strategy
end

module ActiveSupport::Cache::Strategy::LocalCache
  def cleanup(options=T.unsafe(nil)); end

  def clear(options=T.unsafe(nil)); end

  def decrement(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def increment(name, amount=T.unsafe(nil), options=T.unsafe(nil)); end

  def middleware(); end

  def with_local_cache(); end
end

module ActiveSupport::Cache::Strategy::LocalCache
  extend ::T::Sig
end

module ActiveSupport::Cache::Strategy
  extend ::T::Sig
end

module ActiveSupport::Cache
  extend ::T::Sig
  def self.expand_cache_key(key, namespace=T.unsafe(nil)); end

  def self.lookup_store(*store_option); end
end

class ActiveSupport::CachingKeyGenerator
  def generate_key(*args); end

  def initialize(key_generator); end
end

class ActiveSupport::CachingKeyGenerator
end

module ActiveSupport::Callbacks
  def run_callbacks(kind); end
  CALLBACK_FILTER_TYPES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Callbacks
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveSupport::Concern
  def append_features(base); end

  def class_methods(&class_methods_module_definition); end

  def included(base=T.unsafe(nil), &block); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
  def initialize(); end
end

class ActiveSupport::Concern::MultipleIncludedBlocks
end

module ActiveSupport::Concern
  extend ::T::Sig
  def self.extended(base); end
end

module ActiveSupport::Concurrency
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

class ActiveSupport::Concurrency::LoadInterlockAwareMonitor
end

class ActiveSupport::Concurrency::ShareLock
  include ::MonitorMixin
  def exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), after_compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def initialize(); end

  def raw_state(); end

  def sharing(); end

  def start_exclusive(purpose: T.unsafe(nil), compatible: T.unsafe(nil), no_wait: T.unsafe(nil)); end

  def start_sharing(); end

  def stop_exclusive(compatible: T.unsafe(nil)); end

  def stop_sharing(); end

  def yield_shares(purpose: T.unsafe(nil), compatible: T.unsafe(nil), block_share: T.unsafe(nil)); end
end

class ActiveSupport::Concurrency::ShareLock
end

module ActiveSupport::Concurrency
  extend ::T::Sig
end

module ActiveSupport::Configurable
  def config(); end
end

module ActiveSupport::Configurable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveSupport::CurrentAttributes
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _reset_callbacks(); end

  def _run_reset_callbacks(&block); end

  def attributes(); end

  def attributes=(attributes); end

  def reset(); end

  def set(set_attributes); end
end

class ActiveSupport::CurrentAttributes
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._reset_callbacks(); end

  def self._reset_callbacks=(value); end

  def self.attribute(*names); end

  def self.clear_all(); end

  def self.instance(); end

  def self.reset(*args, &block); end

  def self.reset_all(); end

  def self.resets(&block); end

  def self.set(*args, &block); end
end

module ActiveSupport::Dependencies
  def autoload_module!(into, const_name, qualified_name, path_suffix); end

  def autoload_once_paths(); end

  def autoload_once_paths=(obj); end

  def autoload_paths(); end

  def autoload_paths=(obj); end

  def autoloadable_module?(path_suffix); end

  def autoloaded?(desc); end

  def autoloaded_constants(); end

  def autoloaded_constants=(obj); end

  def clear(); end

  def constant_watch_stack(); end

  def constant_watch_stack=(obj); end

  def constantize(name); end

  def depend_on(file_name, message=T.unsafe(nil)); end

  def explicitly_unloadable_constants(); end

  def explicitly_unloadable_constants=(obj); end

  def history(); end

  def history=(obj); end

  def hook!(); end

  def interlock(); end

  def interlock=(obj); end

  def load?(); end

  def load_file(path, const_paths=T.unsafe(nil)); end

  def load_missing_constant(from_mod, const_name); end

  def load_once_path?(path); end

  def loadable_constants_for_path(path, bases=T.unsafe(nil)); end

  def loaded(); end

  def loaded=(obj); end

  def loading(); end

  def loading=(obj); end

  def mark_for_unload(const_desc); end

  def mechanism(); end

  def mechanism=(obj); end

  def new_constants_in(*descs); end

  def qualified_const_defined?(path); end

  def qualified_name_for(mod, name); end

  def reference(klass); end

  def remove_constant(const); end

  def remove_unloadable_constants!(); end

  def require_or_load(file_name, const_path=T.unsafe(nil)); end

  def safe_constantize(name); end

  def search_for_file(path_suffix); end

  def to_constant_name(desc); end

  def unhook!(); end

  def warnings_on_first_load(); end

  def warnings_on_first_load=(obj); end

  def will_unload?(const_desc); end
  Reference = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Dependencies::Blamable
  def blame_file!(file); end

  def blamed_files(); end

  def copy_blame!(exc); end

  def describe_blame(); end
end

module ActiveSupport::Dependencies::Blamable
  extend ::T::Sig
end

class ActiveSupport::Dependencies::ClassCache
  def [](key); end

  def clear!(); end

  def empty?(); end

  def get(key); end

  def key?(key); end

  def safe_get(key); end

  def store(klass); end
end

class ActiveSupport::Dependencies::ClassCache
end

class ActiveSupport::Dependencies::Interlock
  def done_running(); end

  def done_unloading(); end

  def loading(); end

  def permit_concurrent_loads(); end

  def raw_state(&block); end

  def running(); end

  def start_running(); end

  def start_unloading(); end

  def unloading(); end
end

class ActiveSupport::Dependencies::Interlock
end

module ActiveSupport::Dependencies::Loadable
  def load_dependency(file); end

  def require_dependency(file_name, message=T.unsafe(nil)); end

  def require_or_load(file_name); end

  def unloadable(const_desc); end
end

module ActiveSupport::Dependencies::Loadable
  extend ::T::Sig
  def self.exclude_from(base); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  def const_missing(const_name); end

  def guess_for_anonymous(const_name); end

  def unloadable(const_desc=T.unsafe(nil)); end
end

module ActiveSupport::Dependencies::ModuleConstMissing
  extend ::T::Sig
  def self.append_features(base); end

  def self.exclude_from(base); end
end

class ActiveSupport::Dependencies::WatchStack
  include ::Enumerable
  def each(&block); end

  def new_constants(); end

  def watch_namespaces(namespaces); end

  def watching?(); end
end

class ActiveSupport::Dependencies::WatchStack
end

module ActiveSupport::Dependencies
  extend ::ActiveSupport::Dependencies
  extend ::T::Sig
  def self.load_interlock(); end

  def self.run_interlock(); end

  def self.unload_interlock(); end
end

class ActiveSupport::Deprecation
  include ::Singleton
  include ::ActiveSupport::Deprecation::InstanceDelegator
  include ::ActiveSupport::Deprecation::Behavior
  include ::ActiveSupport::Deprecation::Reporting
  include ::ActiveSupport::Deprecation::MethodWrapper
  def deprecation_horizon(); end

  def deprecation_horizon=(deprecation_horizon); end

  def initialize(deprecation_horizon=T.unsafe(nil), gem_name=T.unsafe(nil)); end
  DEFAULT_BEHAVIORS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Behavior
  def behavior(); end

  def behavior=(behavior); end

  def debug(); end

  def debug=(debug); end
end

module ActiveSupport::Deprecation::Behavior
  extend ::T::Sig
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
end

module ActiveSupport::Deprecation::DeprecatedConstantAccessor
  extend ::T::Sig
  def self.included(base); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
  def initialize(old_const, new_const, deprecator=T.unsafe(nil), message: T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedConstantProxy
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
  def initialize(instance, method, var=T.unsafe(nil), deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedInstanceVariableProxy
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
  def initialize(object, message, deprecator=T.unsafe(nil)); end
end

class ActiveSupport::Deprecation::DeprecatedObjectProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
end

class ActiveSupport::Deprecation::DeprecationProxy
  def self.new(*args, &block); end
end

module ActiveSupport::Deprecation::InstanceDelegator
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  def include(included_module); end

  def method_added(method_name); end
end

module ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend ::T::Sig
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
end

module ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  extend ::T::Sig
end

module ActiveSupport::Deprecation::InstanceDelegator
  extend ::T::Sig
  def self.included(base); end
end

module ActiveSupport::Deprecation::MethodWrapper
  def deprecate_methods(target_module, *method_names); end
end

module ActiveSupport::Deprecation::MethodWrapper
  extend ::T::Sig
end

module ActiveSupport::Deprecation::Reporting
  def deprecation_warning(deprecated_method_name, message=T.unsafe(nil), caller_backtrace=T.unsafe(nil)); end

  def gem_name(); end

  def gem_name=(gem_name); end

  def silence(); end

  def silenced(); end

  def silenced=(silenced); end

  def warn(message=T.unsafe(nil), callstack=T.unsafe(nil)); end
  RAILS_GEM_ROOT = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Deprecation::Reporting
  extend ::T::Sig
end

class ActiveSupport::Deprecation
  extend ::Singleton::SingletonClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::ClassMethods
  extend ::ActiveSupport::Deprecation::InstanceDelegator::OverrideDelegators
  def self.behavior(*args, &block); end

  def self.behavior=(arg); end

  def self.debug(*args, &block); end

  def self.debug=(arg); end

  def self.deprecate_methods(*args, &block); end

  def self.deprecation_horizon(*args, &block); end

  def self.deprecation_horizon=(arg); end

  def self.deprecation_warning(*args, &block); end

  def self.gem_name(*args, &block); end

  def self.gem_name=(arg); end

  def self.initialize(*args, &block); end

  def self.instance(); end

  def self.silence(*args, &block); end

  def self.silenced(*args, &block); end

  def self.silenced=(arg); end

  def self.warn(*args, &block); end
end

class ActiveSupport::DeprecationException
end

class ActiveSupport::DeprecationException
end

module ActiveSupport::DescendantsTracker
  def descendants(); end

  def direct_descendants(); end

  def inherited(base); end
end

module ActiveSupport::DescendantsTracker
  extend ::T::Sig
  def self.clear(); end

  def self.descendants(klass); end

  def self.direct_descendants(klass); end

  def self.store_inherited(klass, descendant); end
end

class ActiveSupport::Digest
end

class ActiveSupport::Digest
  def self.hash_digest_class(); end

  def self.hash_digest_class=(klass); end

  def self.hexdigest(arg); end
end

class ActiveSupport::Duration
  def %(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def -@(); end

  def /(other); end

  def ==(other); end

  def after(time=T.unsafe(nil)); end

  def ago(time=T.unsafe(nil)); end

  def before(time=T.unsafe(nil)); end

  def coerce(other); end

  def encode_with(coder); end

  def eql?(other); end

  def from_now(time=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(value, parts); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def iso8601(precision: T.unsafe(nil)); end

  def kind_of?(klass); end

  def parts(); end

  def parts=(parts); end

  def since(time=T.unsafe(nil)); end

  def to_i(); end

  def until(time=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
  PARTS = ::T.let(nil, ::T.untyped)
  PARTS_IN_SECONDS = ::T.let(nil, ::T.untyped)
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
  SECONDS_PER_HOUR = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MINUTE = ::T.let(nil, ::T.untyped)
  SECONDS_PER_MONTH = ::T.let(nil, ::T.untyped)
  SECONDS_PER_WEEK = ::T.let(nil, ::T.untyped)
  SECONDS_PER_YEAR = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser
  def initialize(string); end

  def mode(); end

  def mode=(mode); end

  def parse!(); end

  def parts(); end

  def scanner(); end

  def sign(); end

  def sign=(sign); end
  COMMA = ::T.let(nil, ::T.untyped)
  DATE_COMPONENT = ::T.let(nil, ::T.untyped)
  DATE_COMPONENTS = ::T.let(nil, ::T.untyped)
  DATE_MARKER = ::T.let(nil, ::T.untyped)
  DATE_TO_PART = ::T.let(nil, ::T.untyped)
  PERIOD = ::T.let(nil, ::T.untyped)
  PERIOD_OR_COMMA = ::T.let(nil, ::T.untyped)
  SIGN_MARKER = ::T.let(nil, ::T.untyped)
  TIME_COMPONENT = ::T.let(nil, ::T.untyped)
  TIME_COMPONENTS = ::T.let(nil, ::T.untyped)
  TIME_MARKER = ::T.let(nil, ::T.untyped)
  TIME_TO_PART = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser::ParsingError
end

class ActiveSupport::Duration::ISO8601Parser
end

class ActiveSupport::Duration::ISO8601Serializer
  def initialize(duration, precision: T.unsafe(nil)); end

  def serialize(); end
end

class ActiveSupport::Duration::ISO8601Serializer
end

class ActiveSupport::Duration::Scalar
  def %(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def coerce(other); end

  def initialize(value); end

  def to_f(*args, &block); end

  def to_i(*args, &block); end

  def to_s(*args, &block); end

  def value(); end
end

class ActiveSupport::Duration::Scalar
end

class ActiveSupport::Duration
  def self.===(other); end

  def self.build(value); end

  def self.days(value); end

  def self.hours(value); end

  def self.minutes(value); end

  def self.months(value); end

  def self.parse(iso8601duration); end

  def self.seconds(value); end

  def self.weeks(value); end

  def self.years(value); end
end

module ActiveSupport::EachTimeWithZone
  def each(&block); end

  def step(n=T.unsafe(nil), &block); end
end

module ActiveSupport::EachTimeWithZone
  extend ::T::Sig
end

class ActiveSupport::EncryptedConfiguration
  def [](*args, &block); end

  def config(); end

  def fetch(*args, &block); end

  def initialize(config_path:, key_path:, env_key:, raise_if_missing_key:); end

  def method_missing(method, *args, &block); end
end

class ActiveSupport::EncryptedConfiguration
end

class ActiveSupport::EncryptedFile
  def change(&block); end

  def content_path(); end

  def env_key(); end

  def initialize(content_path:, key_path:, env_key:, raise_if_missing_key:); end

  def key(); end

  def key_path(); end

  def raise_if_missing_key(); end

  def read(); end

  def write(contents); end
  CIPHER = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::EncryptedFile::MissingContentError
  def initialize(content_path); end
end

class ActiveSupport::EncryptedFile::MissingContentError
end

class ActiveSupport::EncryptedFile::MissingKeyError
  def initialize(key_path:, env_key:); end
end

class ActiveSupport::EncryptedFile::MissingKeyError
end

class ActiveSupport::EncryptedFile
  def self.generate_key(); end
end

class ActiveSupport::EventedFileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
  def existing_parent(dir); end

  def filter_out_descendants(dirs); end

  def longest_common_subpath(paths); end

  def normalize_extension(ext); end

  def xpath(path); end
end

class ActiveSupport::EventedFileUpdateChecker::PathHelper
end

class ActiveSupport::EventedFileUpdateChecker
end

class ActiveSupport::ExecutionWrapper
  include ::ActiveSupport::Callbacks
  def __callbacks(); end

  def __callbacks?(); end

  def _complete_callbacks(); end

  def _run_callbacks(); end

  def _run_complete_callbacks(&block); end

  def _run_run_callbacks(&block); end

  def complete!(); end

  def run!(); end
  Null = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def after(target); end

  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::CompleteHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def before(target); end

  def hook(); end

  def hook=(_); end
end

class ActiveSupport::ExecutionWrapper::RunHook
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::ExecutionWrapper
  extend ::ActiveSupport::DescendantsTracker
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._complete_callbacks(); end

  def self._complete_callbacks=(value); end

  def self._run_callbacks(); end

  def self._run_callbacks=(value); end

  def self.active(); end

  def self.active=(active); end

  def self.active?(); end

  def self.inherited(other); end

  def self.register_hook(hook, outer: T.unsafe(nil)); end

  def self.run!(); end

  def self.to_complete(*args, &block); end

  def self.to_run(*args, &block); end

  def self.wrap(); end
end

class ActiveSupport::Executor
end

class ActiveSupport::Executor
end

class ActiveSupport::FileUpdateChecker
  def execute(); end

  def execute_if_updated(); end

  def initialize(files, dirs=T.unsafe(nil), &block); end

  def updated?(); end
end

class ActiveSupport::FileUpdateChecker
end

module ActiveSupport::Gzip
end

class ActiveSupport::Gzip::Stream
end

class ActiveSupport::Gzip::Stream
end

module ActiveSupport::Gzip
  extend ::T::Sig
  def self.compress(source, level=T.unsafe(nil), strategy=T.unsafe(nil)); end

  def self.decompress(source); end
end

class ActiveSupport::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def default(*args); end

  def delete(key); end

  def dig(*args); end

  def fetch(key, *extras); end

  def fetch_values(*indices, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash, &block); end

  def merge!(other_hash); end

  def regular_update(_); end

  def regular_writer(_, _1); end

  def reject(*args, &block); end

  def replace(other_hash); end

  def select(*args, &block); end

  def slice(*keys); end

  def store(key, value); end

  def transform_keys(*args, &block); end

  def transform_values(*args, &block); end

  def update(other_hash); end

  def values_at(*indices); end
end

class ActiveSupport::HashWithIndifferentAccess
  def self.[](*args); end
end

module ActiveSupport::IncludeTimeWithZone
  def include?(value); end
end

module ActiveSupport::IncludeTimeWithZone
  extend ::T::Sig
end

module ActiveSupport::IncludeWithRange
  def include?(value); end
end

module ActiveSupport::IncludeWithRange
  extend ::T::Sig
end

module ActiveSupport::Inflector
  def camelize(term, uppercase_first_letter=T.unsafe(nil)); end

  def classify(table_name); end

  def constantize(camel_cased_word); end

  def dasherize(underscored_word); end

  def deconstantize(path); end

  def demodulize(path); end

  def foreign_key(class_name, separate_class_name_and_id_with_underscore=T.unsafe(nil)); end

  def humanize(lower_case_and_underscored_word, capitalize: T.unsafe(nil), keep_id_suffix: T.unsafe(nil)); end

  def inflections(locale=T.unsafe(nil)); end

  def ordinal(number); end

  def ordinalize(number); end

  def parameterize(string, separator: T.unsafe(nil), preserve_case: T.unsafe(nil)); end

  def pluralize(word, locale=T.unsafe(nil)); end

  def safe_constantize(camel_cased_word); end

  def singularize(word, locale=T.unsafe(nil)); end

  def tableize(class_name); end

  def titleize(word, keep_id_suffix: T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end

  def underscore(camel_cased_word); end

  def upcase_first(string); end
end

class ActiveSupport::Inflector::Inflections
  def acronym(word); end

  def acronyms(); end

  def acronyms_camelize_regex(); end

  def acronyms_underscore_regex(); end

  def clear(scope=T.unsafe(nil)); end

  def human(rule, replacement); end

  def humans(); end

  def irregular(singular, plural); end

  def plural(rule, replacement); end

  def plurals(); end

  def singular(rule, replacement); end

  def singulars(); end

  def uncountable(*words); end

  def uncountables(); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
  def <<(*word); end

  def add(words); end

  def delete(entry); end

  def initialize(); end

  def uncountable?(str); end
end

class ActiveSupport::Inflector::Inflections::Uncountables
end

class ActiveSupport::Inflector::Inflections
  def self.instance(locale=T.unsafe(nil)); end
end

module ActiveSupport::Inflector
  extend ::ActiveSupport::Inflector
  extend ::T::Sig
end

class ActiveSupport::InheritableOptions
  def inheritable_copy(); end

  def initialize(parent=T.unsafe(nil)); end
end

class ActiveSupport::InheritableOptions
end

module ActiveSupport::JSON
  DATETIME_REGEX = ::T.let(nil, ::T.untyped)
  DATE_REGEX = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::JSON::Encoding
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
  def encode(value); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end
end

class ActiveSupport::JSON::Encoding::JSONGemEncoder
end

module ActiveSupport::JSON::Encoding
  extend ::T::Sig
  def self.escape_html_entities_in_json(); end

  def self.escape_html_entities_in_json=(escape_html_entities_in_json); end

  def self.json_encoder(); end

  def self.json_encoder=(json_encoder); end

  def self.time_precision(); end

  def self.time_precision=(time_precision); end

  def self.use_standard_json_time_format(); end

  def self.use_standard_json_time_format=(use_standard_json_time_format); end
end

module ActiveSupport::JSON
  extend ::T::Sig
  def self.decode(json); end

  def self.encode(value, options=T.unsafe(nil)); end

  def self.parse_error(); end
end

class ActiveSupport::KeyGenerator
  def generate_key(salt, key_size=T.unsafe(nil)); end

  def initialize(secret, options=T.unsafe(nil)); end
end

class ActiveSupport::KeyGenerator
end

module ActiveSupport::LazyLoadHooks
  def on_load(name, options=T.unsafe(nil), &block); end

  def run_load_hooks(name, base=T.unsafe(nil)); end
end

module ActiveSupport::LazyLoadHooks
  extend ::T::Sig
  def self.extended(base); end
end

class ActiveSupport::LegacyKeyGenerator
  def generate_key(salt); end

  def initialize(secret); end
  SECRET_MIN_LENGTH = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LegacyKeyGenerator
end

class ActiveSupport::LogSubscriber
  def colorize_logging(); end

  def colorize_logging=(obj); end

  def debug(progname=T.unsafe(nil), &block); end

  def error(progname=T.unsafe(nil), &block); end

  def fatal(progname=T.unsafe(nil), &block); end

  def info(progname=T.unsafe(nil), &block); end

  def logger(); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end
  BLACK = ::T.let(nil, ::T.untyped)
  BLUE = ::T.let(nil, ::T.untyped)
  BOLD = ::T.let(nil, ::T.untyped)
  CLEAR = ::T.let(nil, ::T.untyped)
  CYAN = ::T.let(nil, ::T.untyped)
  GREEN = ::T.let(nil, ::T.untyped)
  MAGENTA = ::T.let(nil, ::T.untyped)
  RED = ::T.let(nil, ::T.untyped)
  WHITE = ::T.let(nil, ::T.untyped)
  YELLOW = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::LogSubscriber
  def self.colorize_logging(); end

  def self.colorize_logging=(obj); end

  def self.flush_all!(); end

  def self.log_subscribers(); end

  def self.logger(); end

  def self.logger=(logger); end
end

class ActiveSupport::Logger
  include ::ActiveSupport::LoggerThreadSafeLevel
  include ::LoggerSilence
  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def initialize(*args); end

  def silencer(); end

  def silencer=(obj); end

  def unknown?(); end
end

class ActiveSupport::Logger::SimpleFormatter
  def call(severity, timestamp, progname, msg); end
end

class ActiveSupport::Logger::SimpleFormatter
end

class ActiveSupport::Logger
  def self.broadcast(logger); end

  def self.logger_outputs_to?(logger, *sources); end

  def self.silencer(); end

  def self.silencer=(obj); end
end

module ActiveSupport::LoggerThreadSafeLevel
  def after_initialize(); end

  def level(); end

  def local_level(); end

  def local_level=(level); end

  def local_log_id(); end
end

module ActiveSupport::LoggerThreadSafeLevel
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveSupport::MarshalWithAutoloading
  def load(source, proc=T.unsafe(nil)); end
end

module ActiveSupport::MarshalWithAutoloading
  extend ::T::Sig
end

class ActiveSupport::MessageEncryptor
  include ::ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def encrypt_and_sign(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

class ActiveSupport::MessageEncryptor::InvalidMessage
end

module ActiveSupport::MessageEncryptor::NullSerializer
end

module ActiveSupport::MessageEncryptor::NullSerializer
  extend ::T::Sig
  def self.dump(value); end

  def self.load(value); end
end

module ActiveSupport::MessageEncryptor::NullVerifier
end

module ActiveSupport::MessageEncryptor::NullVerifier
  extend ::T::Sig
  def self.generate(value); end

  def self.verify(value); end
end

ActiveSupport::MessageEncryptor::OpenSSLCipherError = OpenSSL::Cipher::CipherError

class ActiveSupport::MessageEncryptor
  def self.default_cipher(); end

  def self.key_len(cipher=T.unsafe(nil)); end

  def self.use_authenticated_message_encryption(); end

  def self.use_authenticated_message_encryption=(obj); end
end

class ActiveSupport::MessageVerifier
  include ::ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def generate(value, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end

  def valid_message?(signed_message); end

  def verify(*args); end
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier::InvalidSignature
end

class ActiveSupport::MessageVerifier
end

module ActiveSupport::Messages
end

class ActiveSupport::Messages::Metadata
  def initialize(message, expires_at=T.unsafe(nil), purpose=T.unsafe(nil)); end

  def verify(purpose); end
end

class ActiveSupport::Messages::Metadata
  def self.verify(message, purpose); end

  def self.wrap(message, expires_at: T.unsafe(nil), expires_in: T.unsafe(nil), purpose: T.unsafe(nil)); end
end

class ActiveSupport::Messages::RotationConfiguration
  def encrypted(); end

  def rotate(kind, *args); end

  def signed(); end
end

class ActiveSupport::Messages::RotationConfiguration
end

module ActiveSupport::Messages::Rotator
  def initialize(*_, **options); end

  def rotate(*secrets, **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
  include ::ActiveSupport::Messages::Rotator
  def decrypt_and_verify(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Encryptor
  extend ::T::Sig
end

module ActiveSupport::Messages::Rotator::Verifier
  include ::ActiveSupport::Messages::Rotator
  def verified(*args, on_rotation: T.unsafe(nil), **options); end
end

module ActiveSupport::Messages::Rotator::Verifier
  extend ::T::Sig
end

module ActiveSupport::Messages::Rotator
  extend ::T::Sig
end

module ActiveSupport::Messages
  extend ::T::Sig
end

module ActiveSupport::Multibyte
end

class ActiveSupport::Multibyte::Chars
  include ::Comparable
  def =~(*args, &block); end

  def acts_like_string?(*args, &block); end

  def capitalize(); end

  def capitalize!(*args); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def grapheme_length(); end

  def initialize(string); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice!(*args); end

  def split(*args); end

  def swapcase(); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class ActiveSupport::Multibyte::Chars
  def self.consumes?(string); end
end

module ActiveSupport::Multibyte::Unicode
  def compose(codepoints); end

  def decompose(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def downcase(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def pack_graphemes(unpacked); end

  def reorder_characters(codepoints); end

  def swapcase(string); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def unpack_graphemes(string); end

  def upcase(string); end
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class ActiveSupport::Multibyte::Unicode::Codepoint
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module ActiveSupport::Multibyte::Unicode
  extend ::ActiveSupport::Multibyte::Unicode
  extend ::T::Sig
end

module ActiveSupport::Multibyte
  extend ::T::Sig
  def self.proxy_class(); end

  def self.proxy_class=(klass); end
end

module ActiveSupport::Notifications
end

class ActiveSupport::Notifications::Event
  def <<(event); end

  def children(); end

  def duration(); end

  def end(); end

  def end=(_); end

  def initialize(name, start, ending, transaction_id, payload); end

  def name(); end

  def parent_of?(event); end

  def payload(); end

  def time(); end

  def transaction_id(); end
end

class ActiveSupport::Notifications::Event
end

class ActiveSupport::Notifications::Fanout
  include ::Mutex_m
  def finish(name, id, payload, listeners=T.unsafe(nil)); end

  def initialize(); end

  def listeners_for(name); end

  def listening?(name); end

  def lock(); end

  def locked?(); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribe(pattern=T.unsafe(nil), block=T.unsafe(nil)); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end

  def unsubscribe(subscriber_or_name); end

  def wait(); end
end

module ActiveSupport::Notifications::Fanout::Subscribers
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
  def finish(name, id, payload); end

  def initialize(delegate); end

  def matches?(_); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::AllMessages
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
  def finish(name, id, payload); end

  def initialize(pattern, delegate); end

  def matches?(name); end

  def publish(name, *args); end

  def start(name, id, payload); end

  def subscribed_to?(name); end
end

class ActiveSupport::Notifications::Fanout::Subscribers::Evented
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

class ActiveSupport::Notifications::Fanout::Subscribers::Timed
end

module ActiveSupport::Notifications::Fanout::Subscribers
  extend ::T::Sig
  def self.new(pattern, listener); end
end

class ActiveSupport::Notifications::Fanout
end

class ActiveSupport::Notifications::InstrumentationRegistry
  def instrumenter_for(notifier); end
end

class ActiveSupport::Notifications::InstrumentationRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

class ActiveSupport::Notifications::Instrumenter
  def finish(name, payload); end

  def finish_with_state(listeners_state, name, payload); end

  def id(); end

  def initialize(notifier); end

  def instrument(name, payload=T.unsafe(nil)); end

  def start(name, payload); end
end

class ActiveSupport::Notifications::Instrumenter
end

module ActiveSupport::Notifications
  extend ::T::Sig
  def self.instrument(name, payload=T.unsafe(nil)); end

  def self.instrumenter(); end

  def self.notifier(); end

  def self.notifier=(notifier); end

  def self.publish(name, *args); end

  def self.subscribe(*args, &block); end

  def self.subscribed(callback, *args, &block); end

  def self.unsubscribe(subscriber_or_name); end
end

module ActiveSupport::NumberHelper
  def number_to_currency(number, options=T.unsafe(nil)); end

  def number_to_delimited(number, options=T.unsafe(nil)); end

  def number_to_human(number, options=T.unsafe(nil)); end

  def number_to_human_size(number, options=T.unsafe(nil)); end

  def number_to_percentage(number, options=T.unsafe(nil)); end

  def number_to_phone(number, options=T.unsafe(nil)); end

  def number_to_rounded(number, options=T.unsafe(nil)); end
end

class ActiveSupport::NumberHelper::NumberConverter
  def execute(); end

  def initialize(number, options); end

  def namespace(); end

  def namespace=(val); end

  def namespace?(); end

  def number(); end

  def opts(); end

  def validate_float(); end

  def validate_float=(val); end

  def validate_float?(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberConverter
  def self.convert(number, options); end

  def self.namespace(); end

  def self.namespace=(val); end

  def self.namespace?(); end

  def self.validate_float(); end

  def self.validate_float=(val); end

  def self.validate_float?(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToCurrencyConverter
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
  def convert(); end
  DEFAULT_DELIMITER_REGEX = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToDelimitedConverter
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
  def convert(); end
  DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
  INVERTED_DECIMAL_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanConverter
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
  def convert(); end
  STORAGE_UNITS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::NumberHelper::NumberToHumanSizeConverter
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPercentageConverter
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToPhoneConverter
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
  def convert(); end
end

class ActiveSupport::NumberHelper::NumberToRoundedConverter
end

class ActiveSupport::NumberHelper::RoundingHelper
  def digit_count(number); end

  def initialize(options); end

  def options(); end

  def round(number); end
end

class ActiveSupport::NumberHelper::RoundingHelper
end

module ActiveSupport::NumberHelper
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::NumberHelper
  extend ::T::Sig
end

module ActiveSupport::NumericWithFormat
  def to_s(format=T.unsafe(nil), options=T.unsafe(nil)); end
end

module ActiveSupport::NumericWithFormat
  extend ::T::Sig
end

class ActiveSupport::OptionMerger
  def initialize(context, options); end
end

class ActiveSupport::OptionMerger
end

class ActiveSupport::OrderedHash
  def encode_with(coder); end

  def reject(*args, &block); end

  def select(*args, &block); end

  def to_yaml_type(); end
end

class ActiveSupport::OrderedHash
end

class ActiveSupport::OrderedOptions
  def [](key); end

  def []=(key, value); end

  def _get(_); end

  def method_missing(name, *args); end
end

class ActiveSupport::OrderedOptions
end

module ActiveSupport::PerThreadRegistry
  def instance(); end
end

module ActiveSupport::PerThreadRegistry
  extend ::T::Sig
  def self.extended(object); end
end

class ActiveSupport::ProxyObject
  def raise(*args); end
end

class ActiveSupport::ProxyObject
end

class ActiveSupport::Railtie
end

class ActiveSupport::Railtie
end

module ActiveSupport::RangeWithFormat
  def to_default_s(format=T.unsafe(nil)); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end
  RANGE_FORMATS = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::RangeWithFormat
  extend ::T::Sig
end

class ActiveSupport::Reloader
  def _class_unload_callbacks(); end

  def _prepare_callbacks(); end

  def _run_class_unload_callbacks(&block); end

  def _run_prepare_callbacks(&block); end

  def check(); end

  def check=(val); end

  def check?(); end

  def class_unload!(&block); end

  def executor(); end

  def executor=(val); end

  def executor?(); end

  def release_unload_lock!(); end

  def require_unload_lock!(); end
end

class ActiveSupport::Reloader
  def self._class_unload_callbacks(); end

  def self._class_unload_callbacks=(value); end

  def self._prepare_callbacks(); end

  def self._prepare_callbacks=(value); end

  def self.after_class_unload(*args, &block); end

  def self.before_class_unload(*args, &block); end

  def self.check(); end

  def self.check!(); end

  def self.check=(val); end

  def self.check?(); end

  def self.executor(); end

  def self.executor=(val); end

  def self.executor?(); end

  def self.prepare!(); end

  def self.reload!(); end

  def self.reloaded!(); end

  def self.to_prepare(*args, &block); end
end

module ActiveSupport::Rescuable
  def handler_for_rescue(exception); end

  def rescue_with_handler(exception); end
end

module ActiveSupport::Rescuable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class ActiveSupport::SafeBuffer
  def %(args); end

  def +(other); end

  def <<(value); end

  def [](*args); end

  def capitalize(*args, &block); end

  def capitalize!(*args); end

  def chomp(*args, &block); end

  def chomp!(*args); end

  def chop(*args, &block); end

  def chop!(*args); end

  def clone_empty(); end

  def concat(value); end

  def delete(*args, &block); end

  def delete!(*args); end

  def downcase(*args, &block); end

  def downcase!(*args); end

  def encode_with(coder); end

  def gsub(*args, &block); end

  def gsub!(*args); end

  def initialize(str=T.unsafe(nil)); end

  def lstrip(*args, &block); end

  def lstrip!(*args); end

  def next(*args, &block); end

  def next!(*args); end

  def prepend(value); end

  def reverse(*args, &block); end

  def reverse!(*args); end

  def rstrip(*args, &block); end

  def rstrip!(*args); end

  def safe_concat(value); end

  def slice(*args, &block); end

  def slice!(*args); end

  def squeeze(*args, &block); end

  def squeeze!(*args); end

  def strip(*args, &block); end

  def strip!(*args); end

  def sub(*args, &block); end

  def sub!(*args); end

  def succ(*args, &block); end

  def succ!(*args); end

  def swapcase(*args, &block); end

  def swapcase!(*args); end

  def tr(*args, &block); end

  def tr!(*args); end

  def tr_s(*args, &block); end

  def tr_s!(*args); end

  def upcase(*args, &block); end

  def upcase!(*args); end
  UNSAFE_STRING_METHODS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::SafeBuffer
end

module ActiveSupport::SecurityUtils
end

module ActiveSupport::SecurityUtils
  extend ::T::Sig
  def self.fixed_length_secure_compare(a, b); end

  def self.secure_compare(a, b); end
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::StringInquirer
end

class ActiveSupport::Subscriber
  def finish(name, id, payload); end

  def patterns(); end

  def start(name, id, payload); end
end

class ActiveSupport::Subscriber
  def self.attach_to(namespace, subscriber=T.unsafe(nil), notifier=T.unsafe(nil)); end

  def self.method_added(event); end

  def self.namespace(); end

  def self.notifier(); end

  def self.subscriber(); end

  def self.subscribers(); end
end

class ActiveSupport::SubscriberQueueRegistry
  def get_queue(queue_key); end
end

class ActiveSupport::SubscriberQueueRegistry
  extend ::ActiveSupport::PerThreadRegistry
end

module ActiveSupport::TaggedLogging
  def clear_tags!(*args, &block); end

  def flush(); end

  def pop_tags(*args, &block); end

  def push_tags(*args, &block); end

  def tagged(*tags); end
end

module ActiveSupport::TaggedLogging::Formatter
  def call(severity, timestamp, progname, msg); end

  def clear_tags!(); end

  def current_tags(); end

  def pop_tags(size=T.unsafe(nil)); end

  def push_tags(*tags); end

  def tagged(*tags); end

  def tags_text(); end
end

module ActiveSupport::TaggedLogging::Formatter
  extend ::T::Sig
end

module ActiveSupport::TaggedLogging
  extend ::T::Sig
  def self.new(logger); end
end

class ActiveSupport::TestCase
  include ::ActiveSupport::Testing::TaggedLogging
  include ::ActiveSupport::Callbacks
  include ::ActiveSupport::Testing::Assertions
  include ::ActiveSupport::Testing::Deprecation
  include ::ActiveSupport::Testing::TimeHelpers
  include ::ActiveSupport::Testing::FileFixtures
  include ::ActiveSupport::Testing::SetupAndTeardown
  def __callbacks(); end

  def __callbacks?(); end

  def _run_setup_callbacks(&block); end

  def _run_teardown_callbacks(&block); end

  def _setup_callbacks(); end

  def _teardown_callbacks(); end

  def assert_no_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_not_empty(obj, msg=T.unsafe(nil)); end

  def assert_not_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_not_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_not_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_not_nil(obj, msg=T.unsafe(nil)); end

  def assert_not_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_not_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_not_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_not_same(exp, act, msg=T.unsafe(nil)); end

  def assert_raise(*exp); end

  def file_fixture_path(); end

  def file_fixture_path?(); end

  def method_name(); end
end

class ActiveSupport::TestCase
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveSupport::Testing::Declarative
  extend ::Rails::LineFiltering
  def self.__callbacks(); end

  def self.__callbacks=(val); end

  def self.__callbacks?(); end

  def self._setup_callbacks(); end

  def self._setup_callbacks=(value); end

  def self._teardown_callbacks(); end

  def self._teardown_callbacks=(value); end

  def self.file_fixture_path(); end

  def self.file_fixture_path=(val); end

  def self.file_fixture_path?(); end

  def self.test_order=(new_order); end
end

module ActiveSupport::Testing
end

module ActiveSupport::Testing::Assertions
  def assert_changes(expression, message=T.unsafe(nil), from: T.unsafe(nil), to: T.unsafe(nil), &block); end

  def assert_difference(expression, *args, &block); end

  def assert_no_changes(expression, message=T.unsafe(nil), &block); end

  def assert_no_difference(expression, message=T.unsafe(nil), &block); end

  def assert_not(object, message=T.unsafe(nil)); end

  def assert_nothing_raised(); end
  UNTRACKED = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Assertions
  extend ::T::Sig
end

module ActiveSupport::Testing::ConstantLookup
end

module ActiveSupport::Testing::ConstantLookup
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveSupport::Testing::Declarative
  def test(name, &block); end
end

module ActiveSupport::Testing::Declarative
  extend ::T::Sig
end

module ActiveSupport::Testing::Deprecation
  def assert_deprecated(match=T.unsafe(nil), deprecator=T.unsafe(nil), &block); end

  def assert_not_deprecated(deprecator=T.unsafe(nil), &block); end

  def collect_deprecations(deprecator=T.unsafe(nil)); end
end

module ActiveSupport::Testing::Deprecation
  extend ::T::Sig
end

module ActiveSupport::Testing::FileFixtures
  def file_fixture(fixture_name); end
end

module ActiveSupport::Testing::FileFixtures
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ActiveSupport::Testing::Isolation
  include ::ActiveSupport::Testing::Isolation::Forking
  def run(); end
end

module ActiveSupport::Testing::Isolation::Forking
  def run_in_isolation(&blk); end
end

module ActiveSupport::Testing::Isolation::Forking
  extend ::T::Sig
end

module ActiveSupport::Testing::Isolation::Subprocess
  def run_in_isolation(&blk); end
  ORIG_ARGV = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::Testing::Isolation::Subprocess
  extend ::T::Sig
end

module ActiveSupport::Testing::Isolation
  extend ::T::Sig
  def self.forking_env?(); end

  def self.included(klass); end
end

module ActiveSupport::Testing::SetupAndTeardown
  def after_teardown(); end

  def before_setup(); end
end

module ActiveSupport::Testing::SetupAndTeardown
  extend ::T::Sig
  def self.prepended(klass); end
end

class ActiveSupport::Testing::SimpleStubs
  def stub_object(object, method_name, &block); end

  def stubbing(object, method_name); end

  def unstub_all!(); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def method_name(); end

  def method_name=(_); end

  def object(); end

  def object=(_); end

  def original_method(); end

  def original_method=(_); end
end

class ActiveSupport::Testing::SimpleStubs::Stub
  def self.[](*_); end

  def self.members(); end
end

class ActiveSupport::Testing::SimpleStubs
end

module ActiveSupport::Testing::Stream
end

module ActiveSupport::Testing::Stream
  extend ::T::Sig
end

module ActiveSupport::Testing::TaggedLogging
  def before_setup(); end

  def tagged_logger=(tagged_logger); end
end

module ActiveSupport::Testing::TaggedLogging
  extend ::T::Sig
end

module ActiveSupport::Testing::TimeHelpers
  def after_teardown(); end

  def freeze_time(&block); end

  def travel(duration, &block); end

  def travel_back(); end

  def travel_to(date_or_time); end
end

module ActiveSupport::Testing::TimeHelpers
  extend ::T::Sig
end

module ActiveSupport::Testing
  extend ::T::Sig
end

class ActiveSupport::TimeWithZone
  include ::DateAndTime::Compatibility
  include ::Comparable
  def +(other); end

  def -(other); end

  def acts_like_time?(); end

  def advance(options); end

  def ago(other); end

  def between?(min, max); end

  def change(options); end

  def comparable_time(); end

  def day(); end

  def dst?(); end

  def encode_with(coder); end

  def eql?(other); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def future?(); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmt?(); end

  def gmt_offset(); end

  def gmtime(); end

  def gmtoff(); end

  def hour(); end

  def httpdate(); end

  def in(other); end

  def in_time_zone(new_zone=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(utc_time, time_zone, local_time=T.unsafe(nil), period=T.unsafe(nil)); end

  def is_a?(klass); end

  def isdst(); end

  def iso8601(fraction_digits=T.unsafe(nil)); end

  def kind_of?(klass); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(variables); end

  def mday(); end

  def method_missing(sym, *args, &block); end

  def min(); end

  def mon(); end

  def month(); end

  def nsec(); end

  def past?(); end

  def period(); end

  def respond_to?(sym, include_priv=T.unsafe(nil)); end

  def rfc2822(); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def rfc822(); end

  def sec(); end

  def since(other); end

  def strftime(format); end

  def time(); end

  def time_zone(); end

  def to_a(); end

  def to_date(); end

  def to_datetime(); end

  def to_f(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_i(); end

  def to_r(); end

  def to_s(format=T.unsafe(nil)); end

  def to_time(); end

  def today?(); end

  def tv_sec(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end

  def wday(); end

  def xmlschema(fraction_digits=T.unsafe(nil)); end

  def yday(); end

  def year(); end

  def zone(); end
  PRECISIONS = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeWithZone
end

class ActiveSupport::TimeZone
  include ::Comparable
  def =~(re); end

  def at(secs); end

  def encode_with(coder); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def init_with(coder); end

  def initialize(name, utc_offset=T.unsafe(nil), tzinfo=T.unsafe(nil)); end

  def iso8601(str); end

  def local(*args); end

  def local_to_utc(time, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def parse(str, now=T.unsafe(nil)); end

  def period_for_local(time, dst=T.unsafe(nil)); end

  def period_for_utc(time); end

  def periods_for_local(time); end

  def rfc3339(str); end

  def strptime(str, format, now=T.unsafe(nil)); end

  def today(); end

  def tomorrow(); end

  def tzinfo(); end

  def utc_offset(); end

  def utc_to_local(time); end

  def yesterday(); end
  MAPPING = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITHOUT_COLON = ::T.let(nil, ::T.untyped)
  UTC_OFFSET_WITH_COLON = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::TimeZone
  def self.[](arg); end

  def self.all(); end

  def self.clear(); end

  def self.country_zones(country_code); end

  def self.create(*_); end

  def self.find_tzinfo(name); end

  def self.new(name); end

  def self.seconds_to_utc_offset(seconds, colon=T.unsafe(nil)); end

  def self.us_zones(); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_json(options=T.unsafe(nil)); end
end

module ActiveSupport::ToJsonWithActiveSupportEncoder
  extend ::T::Sig
end

module ActiveSupport::Tryable
  def try(*a, &b); end

  def try!(*a, &b); end
end

module ActiveSupport::Tryable
  extend ::T::Sig
end

module ActiveSupport::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::VERSION
  extend ::T::Sig
end

class ActiveSupport::XMLConverter
  def initialize(xml, disallowed_types=T.unsafe(nil)); end

  def to_h(); end
  DISALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class ActiveSupport::XMLConverter::DisallowedType
  def initialize(type); end
end

class ActiveSupport::XMLConverter::DisallowedType
end

class ActiveSupport::XMLConverter
end

module ActiveSupport::XmlMini
  def backend(); end

  def backend=(name); end

  def depth(); end

  def depth=(depth); end

  def parse(*args, &block); end

  def rename_key(key, options=T.unsafe(nil)); end

  def to_tag(key, value, options); end

  def with_backend(name); end
  DEFAULT_ENCODINGS = ::T.let(nil, ::T.untyped)
  FORMATTING = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini::FileLike
  def content_type(); end

  def content_type=(content_type); end

  def original_filename(); end

  def original_filename=(original_filename); end
end

module ActiveSupport::XmlMini::FileLike
  extend ::T::Sig
end

module ActiveSupport::XmlMini
  extend ::ActiveSupport::XmlMini
  extend ::T::Sig
end

module ActiveSupport::XmlMini_REXML
  def parse(data); end
  CONTENT_KEY = ::T.let(nil, ::T.untyped)
end

module ActiveSupport::XmlMini_REXML
  extend ::ActiveSupport::XmlMini_REXML
  extend ::T::Sig
end

module ActiveSupport
  extend ::ActiveSupport::LazyLoadHooks
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.escape_html_entities_in_json(*args, &block); end

  def self.escape_html_entities_in_json=(arg); end

  def self.gem_version(); end

  def self.json_encoder(*args, &block); end

  def self.json_encoder=(arg); end

  def self.parse_json_times(); end

  def self.parse_json_times=(obj); end

  def self.test_order(); end

  def self.test_order=(obj); end

  def self.time_precision(*args, &block); end

  def self.time_precision=(arg); end

  def self.to_time_preserves_timezone(); end

  def self.to_time_preserves_timezone=(value); end

  def self.use_standard_json_time_format(*args, &block); end

  def self.use_standard_json_time_format=(arg); end

  def self.version(); end
end

module Adapters
  extend ::T::Sig
end

module Addressable
end

module Addressable::IDNA
  ACE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  ACE_PREFIX = ::T.let(nil, ::T.untyped)
  COMPOSITION_TABLE = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  PUNYCODE_BASE = ::T.let(nil, ::T.untyped)
  PUNYCODE_DAMP = ::T.let(nil, ::T.untyped)
  PUNYCODE_DELIMITER = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  PUNYCODE_INITIAL_N = ::T.let(nil, ::T.untyped)
  PUNYCODE_MAXINT = ::T.let(nil, ::T.untyped)
  PUNYCODE_PRINT_ASCII = ::T.let(nil, ::T.untyped)
  PUNYCODE_SKEW = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMAX = ::T.let(nil, ::T.untyped)
  PUNYCODE_TMIN = ::T.let(nil, ::T.untyped)
  UNICODE_DATA = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_CANONICAL = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMBINING_CLASS = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_COMPATIBILITY = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_EXCLUSION = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_LOWERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_TITLECASE = ::T.let(nil, ::T.untyped)
  UNICODE_DATA_UPPERCASE = ::T.let(nil, ::T.untyped)
  UNICODE_MAX_LENGTH = ::T.let(nil, ::T.untyped)
  UNICODE_TABLE = ::T.let(nil, ::T.untyped)
  UTF8_REGEX = ::T.let(nil, ::T.untyped)
  UTF8_REGEX_MULTIBYTE = ::T.let(nil, ::T.untyped)
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBadInput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeBigOutput
end

class Addressable::IDNA::PunycodeOverflow
end

class Addressable::IDNA::PunycodeOverflow
end

module Addressable::IDNA
  extend ::T::Sig
  def self.to_ascii(input); end

  def self.to_unicode(input); end

  def self.unicode_normalize_kc(input); end
end

class Addressable::Template
  def ==(template); end

  def eql?(template); end

  def expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def extract(uri, processor=T.unsafe(nil)); end

  def generate(params=T.unsafe(nil), recall=T.unsafe(nil), options=T.unsafe(nil)); end

  def initialize(pattern); end

  def keys(); end

  def match(uri, processor=T.unsafe(nil)); end

  def named_captures(); end

  def names(); end

  def partial_expand(mapping, processor=T.unsafe(nil), normalize_values=T.unsafe(nil)); end

  def pattern(); end

  def source(); end

  def to_regexp(); end

  def variable_defaults(); end

  def variables(); end
  EXPRESSION = ::T.let(nil, ::T.untyped)
  JOINERS = ::T.let(nil, ::T.untyped)
  LEADERS = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
  VARIABLE_LIST = ::T.let(nil, ::T.untyped)
  VARNAME = ::T.let(nil, ::T.untyped)
  VARSPEC = ::T.let(nil, ::T.untyped)
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateOperatorError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::InvalidTemplateValueError
end

class Addressable::Template::MatchData
  def [](key, len=T.unsafe(nil)); end

  def captures(); end

  def initialize(uri, template, mapping); end

  def keys(); end

  def mapping(); end

  def names(); end

  def post_match(); end

  def pre_match(); end

  def string(); end

  def template(); end

  def to_a(); end

  def uri(); end

  def values(); end

  def values_at(*indexes); end

  def variables(); end
end

class Addressable::Template::MatchData
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template::TemplateOperatorAbortedError
end

class Addressable::Template
end

class Addressable::URI
  def +(uri); end

  def ==(uri); end

  def ===(uri); end

  def absolute?(); end

  def authority(); end

  def authority=(new_authority); end

  def basename(); end

  def default_port(); end

  def defer_validation(&block); end

  def display_uri(); end

  def domain(); end

  def empty?(); end

  def eql?(uri); end

  def extname(); end

  def fragment(); end

  def fragment=(new_fragment); end

  def host(); end

  def host=(new_host); end

  def hostname(); end

  def hostname=(new_hostname); end

  def inferred_port(); end

  def initialize(options=T.unsafe(nil)); end

  def ip_based?(); end

  def join(uri); end

  def join!(uri); end

  def merge(hash); end

  def merge!(uri); end

  def normalize(); end

  def normalize!(); end

  def normalized_authority(); end

  def normalized_fragment(); end

  def normalized_host(); end

  def normalized_password(); end

  def normalized_path(); end

  def normalized_port(); end

  def normalized_query(); end

  def normalized_query_without_ordering_fix(*flags); end

  def normalized_scheme(); end

  def normalized_site(); end

  def normalized_user(); end

  def normalized_userinfo(); end

  def omit(*components); end

  def omit!(*components); end

  def origin(); end

  def origin=(new_origin); end

  def password(); end

  def password=(new_password); end

  def path(); end

  def path=(new_path); end

  def port(); end

  def port=(new_port); end

  def query(); end

  def query=(new_query); end

  def query_values(return_type=T.unsafe(nil)); end

  def query_values=(new_query_values); end

  def relative?(); end

  def remove_composite_values(); end

  def replace_self(uri); end

  def request_uri(); end

  def request_uri=(new_request_uri); end

  def route_from(uri); end

  def route_to(uri); end

  def scheme(); end

  def scheme=(new_scheme); end

  def site(); end

  def site=(new_site); end

  def split_path(path); end

  def tld(); end

  def to_hash(); end

  def to_str(); end

  def user(); end

  def user=(new_user); end

  def userinfo(); end

  def userinfo=(new_userinfo); end

  def validate(); end
  EMPTY_STR = ::T.let(nil, ::T.untyped)
  NORMPATH = ::T.let(nil, ::T.untyped)
  PARENT = ::T.let(nil, ::T.untyped)
  PORT_MAPPING = ::T.let(nil, ::T.untyped)
  RULE_2A = ::T.let(nil, ::T.untyped)
  RULE_2B_2C = ::T.let(nil, ::T.untyped)
  RULE_2D = ::T.let(nil, ::T.untyped)
  RULE_PREFIXED_PARENT = ::T.let(nil, ::T.untyped)
  SELF_REF = ::T.let(nil, ::T.untyped)
  SLASH = ::T.let(nil, ::T.untyped)
  URIREGEX = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  ALPHA = ::T.let(nil, ::T.untyped)
  AUTHORITY = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  FRAGMENT = ::T.let(nil, ::T.untyped)
  GEN_DELIMS = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  PCHAR = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  SCHEME = ::T.let(nil, ::T.untyped)
  SUB_DELIMS = ::T.let(nil, ::T.untyped)
  UNRESERVED = ::T.let(nil, ::T.untyped)
end

module Addressable::URI::CharacterClasses
  extend ::T::Sig
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI::InvalidURIError
end

class Addressable::URI
  def self.convert_path(path); end

  def self.encode(uri, return_type=T.unsafe(nil)); end

  def self.encode_component(component, character_class=T.unsafe(nil), upcase_encoded=T.unsafe(nil)); end

  def self.escape(uri, return_type=T.unsafe(nil)); end

  def self.form_encode(form_values, sort=T.unsafe(nil)); end

  def self.form_unencode(encoded_value); end

  def self.heuristic_parse(uri, hints=T.unsafe(nil)); end

  def self.ip_based_schemes(); end

  def self.join(*uris); end

  def self.normalize_component(component, character_class=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.normalize_path(path); end

  def self.normalized_encode(uri, return_type=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.port_mapping(); end

  def self.unencode(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unencode_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end

  def self.unescape_component(uri, return_type=T.unsafe(nil), leave_encoded=T.unsafe(nil)); end
end

module Addressable::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Addressable::VERSION
  extend ::T::Sig
end

module Addressable
  extend ::T::Sig
end

class Addrinfo
  extend ::T::Sig
end

module Admin
end

class Admin::AdminNotesController
  include ::InheritedResources::BelongsToHelpers
  def edit_parent_path(*given_args); end

  def edit_parent_url(*given_args); end

  def parent_path(*given_args); end

  def parent_url(*given_args); end
end

class Admin::AdminNotesController
  def self.resource_class=(klass); end
end

class Admin::CommentsController
  def create(); end
end

class Admin::CommentsController
  def self.resource_class=(klass); end
end

class Admin::OrdersController
  def accept_offer(); end

  def approve_order(); end

  def buyer_reject(); end

  def confirm_fulfillment(); end

  def confirm_pickup(); end

  def refund(); end

  def toggle_assisted(); end
end

class Admin::OrdersController
  def self.resource_class=(klass); end
end

module Admin
  extend ::T::Sig
end

module AdminHelper
  extend ::T::Sig
end

class AdminNote
  include ::AdminNote::GeneratedAssociationMethods
  def autosave_associated_records_for_order(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

module AdminNote::GeneratedAssociationMethods
  def build_order(*args, &block); end

  def create_order(*args, &block); end

  def create_order!(*args, &block); end

  def order(); end

  def order=(value); end

  def reload_order(); end
end

module AdminNote::GeneratedAssociationMethods
  extend ::T::Sig
end

module Api
  extend ::T::Sig
end

class ApplicationController
  include ::ArtsyAuth::Authenticated
  def authenticate_request!(); end

  def valid_admin?(token); end
end

class ApplicationErrorEvent
end

class ApplicationJob
end

class ApplicationRecord
  include ::ApplicationRecord::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
end

module ApplicationRecord::GeneratedAssociationMethods
  extend ::T::Sig
end

class ApplicationRecord
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

module Arbre
end

class Arbre::Component
  def default_class_name(); end
end

class Arbre::Component
end

class Arbre::Context
  def bytesize(); end

  def initialize(assigns=T.unsafe(nil), helpers=T.unsafe(nil), &block); end

  def length(); end

  def method_missing(method, *args, &block); end

  def with_current_arbre_element(tag); end

  def within(tag); end
end

class Arbre::Context
end

class Arbre::Element
  include ::Arbre::Element::BuilderMethods
  include ::Arbre::Rails::Rendering
  def +(element); end

  def <<(child); end

  def add_child(child); end

  def ancestors(); end

  def arbre_context(); end

  def assigns(); end

  def build(*args, &block); end

  def children(); end

  def children?(); end

  def content(); end

  def content=(contents); end

  def each(&block); end

  def find_by_class(class_name); end

  def find_by_tag(tag_name); end

  def find_first_ancestor(type); end

  def get_elements_by_class_name(class_name); end

  def get_elements_by_tag_name(tag_name); end

  def helpers(); end

  def html_safe(); end

  def indent_level(); end

  def initialize(arbre_context=T.unsafe(nil)); end

  def parent(); end

  def parent=(parent); end

  def parent?(); end

  def remove_child(child); end

  def tag_name(); end

  def to_a(); end

  def to_ary(); end

  def to_str(); end
end

module Arbre::Element::BuilderMethods
  def a(*args, &block); end

  def abbr(*args, &block); end

  def active_admin_comments_for(*args, &block); end

  def active_admin_form_for(*args, &block); end

  def address(*args, &block); end

  def area(*args, &block); end

  def article(*args, &block); end

  def aside(*args, &block); end

  def attributes_table_for(*args, &block); end

  def audio(*args, &block); end

  def b(*args, &block); end

  def base(*args, &block); end

  def batch_action_form(*args, &block); end

  def batch_action_selector(*args, &block); end

  def bdo(*args, &block); end

  def blank_slate(*args, &block); end

  def blockquote(*args, &block); end

  def body(*args, &block); end

  def br(*args, &block); end

  def build_tag(klass, *args, &block); end

  def button(*args, &block); end

  def canvas(*args, &block); end

  def caption(*args, &block); end

  def cite(*args, &block); end

  def code(*args, &block); end

  def col(*args, &block); end

  def colgroup(*args, &block); end

  def columns(*args, &block); end

  def command(*args, &block); end

  def current_arbre_element(); end

  def datalist(*args, &block); end

  def dd(*args, &block); end

  def del(*args, &block); end

  def details(*args, &block); end

  def dfn(*args, &block); end

  def div(*args, &block); end

  def dl(*args, &block); end

  def dropdown_menu(*args, &block); end

  def dt(*args, &block); end

  def em(*args, &block); end

  def embed(*args, &block); end

  def fieldset(*args, &block); end

  def figcaption(*args, &block); end

  def figure(*args, &block); end

  def footer(*args, &block); end

  def form(*args, &block); end

  def form_for(*args, &block); end

  def h1(*args, &block); end

  def h2(*args, &block); end

  def h3(*args, &block); end

  def h4(*args, &block); end

  def h5(*args, &block); end

  def h6(*args, &block); end

  def head(*args, &block); end

  def header(*args, &block); end

  def hgroup(*args, &block); end

  def hr(*args, &block); end

  def html(*args, &block); end

  def i(*args, &block); end

  def iframe(*args, &block); end

  def img(*args, &block); end

  def index_list_renderer(*args, &block); end

  def input(*args, &block); end

  def ins(*args, &block); end

  def insert_tag(klass, *args, &block); end

  def kbd(*args, &block); end

  def keygen(*args, &block); end

  def label(*args, &block); end

  def legend(*args, &block); end

  def li(*args, &block); end

  def link(*args, &block); end

  def map(*args, &block); end

  def mark(*args, &block); end

  def menu(*args, &block); end

  def menuitem(*args, &block); end

  def meta(*args, &block); end

  def meter(*args, &block); end

  def nav(*args, &block); end

  def noscript(*args, &block); end

  def object(*args, &block); end

  def ol(*args, &block); end

  def optgroup(*args, &block); end

  def option(*args, &block); end

  def output(*args, &block); end

  def paginated_collection(*args, &block); end

  def panel(*args, &block); end

  def para(*args, &block); end

  def param(*args, &block); end

  def pre(*args, &block); end

  def progress(*args, &block); end

  def q(*args, &block); end

  def resource_selection_cell(*args, &block); end

  def resource_selection_toggle_cell(*args, &block); end

  def resource_selection_toggle_panel(*args, &block); end

  def s(*args, &block); end

  def samp(*args, &block); end

  def scopes_renderer(*args, &block); end

  def script(*args, &block); end

  def section(*args, &block); end

  def select(*args, &block); end

  def sidebar_section(*args, &block); end

  def small(*args, &block); end

  def source(*args, &block); end

  def span(*args, &block); end

  def status_tag(*args, &block); end

  def strong(*args, &block); end

  def style(*args, &block); end

  def sub(*args, &block); end

  def summary(*args, &block); end

  def sup(*args, &block); end

  def svg(*args, &block); end

  def table(*args, &block); end

  def table_actions(*args, &block); end

  def table_for(*args, &block); end

  def tabs(*args, &block); end

  def tbody(*args, &block); end

  def td(*args, &block); end

  def text_node(*args, &block); end

  def textarea(*args, &block); end

  def tfoot(*args, &block); end

  def th(*args, &block); end

  def thead(*args, &block); end

  def time(*args, &block); end

  def title(*args, &block); end

  def tr(*args, &block); end

  def track(*args, &block); end

  def ul(*args, &block); end

  def var(*args, &block); end

  def video(*args, &block); end

  def wbr(*args, &block); end

  def with_current_arbre_element(tag, &block); end

  def within(tag, &block); end
end

module Arbre::Element::BuilderMethods
  extend ::T::Sig
  def self.included(klass); end
end

class Arbre::Element
end

class Arbre::ElementCollection
  def &(other); end

  def +(other); end

  def -(other); end

  def to_s(); end
end

class Arbre::ElementCollection
end

module Arbre::HTML
  AUTO_BUILD_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML5_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Arbre::HTML::A
end

class Arbre::HTML::A
end

class Arbre::HTML::Abbr
end

class Arbre::HTML::Abbr
end

class Arbre::HTML::Address
end

class Arbre::HTML::Address
end

class Arbre::HTML::Area
end

class Arbre::HTML::Area
end

class Arbre::HTML::Article
end

class Arbre::HTML::Article
end

class Arbre::HTML::Aside
end

class Arbre::HTML::Aside
end

class Arbre::HTML::Attributes
  def any?(); end

  def html_escape(s); end

  def value_empty?(value); end
end

class Arbre::HTML::Attributes
end

class Arbre::HTML::Audio
end

class Arbre::HTML::Audio
end

class Arbre::HTML::B
end

class Arbre::HTML::B
end

class Arbre::HTML::Base
end

class Arbre::HTML::Base
end

class Arbre::HTML::Bdo
end

class Arbre::HTML::Bdo
end

class Arbre::HTML::Blockquote
end

class Arbre::HTML::Blockquote
end

class Arbre::HTML::Body
end

class Arbre::HTML::Body
end

class Arbre::HTML::Br
end

class Arbre::HTML::Br
end

class Arbre::HTML::Button
end

class Arbre::HTML::Button
end

class Arbre::HTML::Canvas
end

class Arbre::HTML::Canvas
end

class Arbre::HTML::Caption
end

class Arbre::HTML::Caption
end

class Arbre::HTML::Cite
end

class Arbre::HTML::Cite
end

class Arbre::HTML::ClassList
  def <<(class_names); end

  def add(class_names); end
end

class Arbre::HTML::ClassList
  def self.build_from_string(class_names); end
end

class Arbre::HTML::Code
end

class Arbre::HTML::Code
end

class Arbre::HTML::Col
end

class Arbre::HTML::Col
end

class Arbre::HTML::Colgroup
end

class Arbre::HTML::Colgroup
end

class Arbre::HTML::Command
end

class Arbre::HTML::Command
end

class Arbre::HTML::Datalist
end

class Arbre::HTML::Datalist
end

class Arbre::HTML::Dd
end

class Arbre::HTML::Dd
end

class Arbre::HTML::Del
end

class Arbre::HTML::Del
end

class Arbre::HTML::Details
end

class Arbre::HTML::Details
end

class Arbre::HTML::Dfn
end

class Arbre::HTML::Dfn
end

class Arbre::HTML::Div
end

class Arbre::HTML::Div
end

class Arbre::HTML::Dl
end

class Arbre::HTML::Dl
end

class Arbre::HTML::Document
  def build_body(); end

  def build_head(); end

  def doctype(); end

  def document(); end
end

class Arbre::HTML::Document
end

class Arbre::HTML::Dt
end

class Arbre::HTML::Dt
end

class Arbre::HTML::Em
end

class Arbre::HTML::Em
end

class Arbre::HTML::Embed
end

class Arbre::HTML::Embed
end

class Arbre::HTML::Fieldset
end

class Arbre::HTML::Fieldset
end

class Arbre::HTML::Figcaption
end

class Arbre::HTML::Figcaption
end

class Arbre::HTML::Figure
end

class Arbre::HTML::Figure
end

class Arbre::HTML::Footer
end

class Arbre::HTML::Footer
end

class Arbre::HTML::Form
end

class Arbre::HTML::Form
end

class Arbre::HTML::H1
end

class Arbre::HTML::H1
end

class Arbre::HTML::H2
end

class Arbre::HTML::H2
end

class Arbre::HTML::H3
end

class Arbre::HTML::H3
end

class Arbre::HTML::H4
end

class Arbre::HTML::H4
end

class Arbre::HTML::H5
end

class Arbre::HTML::H5
end

class Arbre::HTML::H6
end

class Arbre::HTML::H6
end

class Arbre::HTML::Head
end

class Arbre::HTML::Head
end

class Arbre::HTML::Header
end

class Arbre::HTML::Header
end

class Arbre::HTML::Hgroup
end

class Arbre::HTML::Hgroup
end

class Arbre::HTML::Hr
end

class Arbre::HTML::Hr
end

class Arbre::HTML::Html
end

class Arbre::HTML::Html
end

class Arbre::HTML::I
end

class Arbre::HTML::I
end

class Arbre::HTML::Iframe
end

class Arbre::HTML::Iframe
end

class Arbre::HTML::Img
end

class Arbre::HTML::Img
end

class Arbre::HTML::Input
end

class Arbre::HTML::Input
end

class Arbre::HTML::Ins
end

class Arbre::HTML::Ins
end

class Arbre::HTML::Kbd
end

class Arbre::HTML::Kbd
end

class Arbre::HTML::Keygen
end

class Arbre::HTML::Keygen
end

class Arbre::HTML::Label
end

class Arbre::HTML::Label
end

class Arbre::HTML::Legend
end

class Arbre::HTML::Legend
end

class Arbre::HTML::Li
end

class Arbre::HTML::Li
end

class Arbre::HTML::Link
end

class Arbre::HTML::Link
end

class Arbre::HTML::Map
end

class Arbre::HTML::Map
end

class Arbre::HTML::Mark
end

class Arbre::HTML::Mark
end

class Arbre::HTML::Menu
end

class Arbre::HTML::Menu
end

class Arbre::HTML::Menuitem
end

class Arbre::HTML::Menuitem
end

class Arbre::HTML::Meta
end

class Arbre::HTML::Meta
end

class Arbre::HTML::Meter
end

class Arbre::HTML::Meter
end

class Arbre::HTML::Nav
end

class Arbre::HTML::Nav
end

class Arbre::HTML::Noscript
end

class Arbre::HTML::Noscript
end

class Arbre::HTML::Object
end

class Arbre::HTML::Object
end

class Arbre::HTML::Ol
end

class Arbre::HTML::Ol
end

class Arbre::HTML::Optgroup
end

class Arbre::HTML::Optgroup
end

class Arbre::HTML::Option
end

class Arbre::HTML::Option
end

class Arbre::HTML::Output
end

class Arbre::HTML::Output
end

class Arbre::HTML::P
end

class Arbre::HTML::P
end

class Arbre::HTML::Param
end

class Arbre::HTML::Param
end

class Arbre::HTML::Pre
end

class Arbre::HTML::Pre
end

class Arbre::HTML::Progress
end

class Arbre::HTML::Progress
end

class Arbre::HTML::Q
end

class Arbre::HTML::Q
end

class Arbre::HTML::S
end

class Arbre::HTML::S
end

class Arbre::HTML::Samp
end

class Arbre::HTML::Samp
end

class Arbre::HTML::Script
end

class Arbre::HTML::Script
end

class Arbre::HTML::Section
end

class Arbre::HTML::Section
end

class Arbre::HTML::Select
end

class Arbre::HTML::Select
end

class Arbre::HTML::Small
end

class Arbre::HTML::Small
end

class Arbre::HTML::Source
end

class Arbre::HTML::Source
end

class Arbre::HTML::Span
end

class Arbre::HTML::Span
end

class Arbre::HTML::Strong
end

class Arbre::HTML::Strong
end

class Arbre::HTML::Style
end

class Arbre::HTML::Style
end

class Arbre::HTML::Sub
end

class Arbre::HTML::Sub
end

class Arbre::HTML::Summary
end

class Arbre::HTML::Summary
end

class Arbre::HTML::Sup
end

class Arbre::HTML::Sup
end

class Arbre::HTML::Svg
end

class Arbre::HTML::Svg
end

class Arbre::HTML::Table
  def set_table_tag_defaults(); end
end

class Arbre::HTML::Table
end

class Arbre::HTML::Tag
  def add_class(class_names); end

  def attr(name); end

  def attributes(); end

  def build(*args); end

  def class_list(); end

  def class_names(); end

  def extract_arguments(args); end

  def get_attribute(name); end

  def has_attribute?(name); end

  def id(); end

  def id!(); end

  def id=(id); end

  def initialize(*_); end

  def remove_attribute(name); end

  def remove_class(class_names); end

  def set_attribute(name, value); end
  INDENT_SIZE = ::T.let(nil, ::T.untyped)
  SELF_CLOSING_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Arbre::HTML::Tag
end

class Arbre::HTML::Tbody
end

class Arbre::HTML::Tbody
end

class Arbre::HTML::Td
end

class Arbre::HTML::Td
end

class Arbre::HTML::TextNode
  def add_child(*args); end

  def build(string); end

  def class_list(); end
end

class Arbre::HTML::TextNode
  def self.from_string(string); end
end

class Arbre::HTML::Textarea
end

class Arbre::HTML::Textarea
end

class Arbre::HTML::Tfoot
end

class Arbre::HTML::Tfoot
end

class Arbre::HTML::Th
end

class Arbre::HTML::Th
end

class Arbre::HTML::Thead
end

class Arbre::HTML::Thead
end

class Arbre::HTML::Time
end

class Arbre::HTML::Time
end

class Arbre::HTML::Title
end

class Arbre::HTML::Title
end

class Arbre::HTML::Tr
end

class Arbre::HTML::Tr
end

class Arbre::HTML::Track
end

class Arbre::HTML::Track
end

class Arbre::HTML::Ul
end

class Arbre::HTML::Ul
end

class Arbre::HTML::Var
end

class Arbre::HTML::Var
end

class Arbre::HTML::Video
end

class Arbre::HTML::Video
end

class Arbre::HTML::Wbr
end

class Arbre::HTML::Wbr
end

module Arbre::HTML
  extend ::T::Sig
end

module Arbre::Rails
end

module Arbre::Rails::Forms
end

class Arbre::Rails::Forms::FieldsForProxy
  def build(form_builder, *args, &block); end
end

class Arbre::Rails::Forms::FieldsForProxy
end

class Arbre::Rails::Forms::FormBuilderProxy
  def form_builder(); end

  def label(*args); end

  def select(*args); end
end

class Arbre::Rails::Forms::FormBuilderProxy
end

class Arbre::Rails::Forms::FormForProxy
  def build(resource, form_options=T.unsafe(nil), &block); end

  def fields_for(*args, &block); end

  def split_string_on(string, match); end
end

class Arbre::Rails::Forms::FormForProxy
end

module Arbre::Rails::Forms
  extend ::T::Sig
end

module Arbre::Rails::Rendering
  def render(*args); end
end

module Arbre::Rails::Rendering
  extend ::T::Sig
end

class Arbre::Rails::TemplateHandler
  def call(template); end
end

class Arbre::Rails::TemplateHandler
end

module Arbre::Rails
  extend ::T::Sig
end

module Arbre
  extend ::T::Sig
end

module Arel
  VERSION = ::T.let(nil, ::T.untyped)
end

module Arel::AliasPredication
  def as(other); end
end

module Arel::AliasPredication
  extend ::T::Sig
end

class Arel::ArelError
end

class Arel::ArelError
end

Arel::Attribute = Arel::Attributes::Attribute

module Arel::Attributes
end

class Arel::Attributes::Attribute
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
  def able_to_type_cast?(); end

  def lower(); end

  def type_cast_for_database(value); end
end

class Arel::Attributes::Attribute
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Boolean
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Decimal
end

class Arel::Attributes::Float
end

class Arel::Attributes::Float
end

class Arel::Attributes::Integer
end

class Arel::Attributes::Integer
end

class Arel::Attributes::String
end

class Arel::Attributes::String
end

class Arel::Attributes::Time
end

class Arel::Attributes::Time
end

class Arel::Attributes::Undefined
end

class Arel::Attributes::Undefined
end

module Arel::Attributes
  extend ::T::Sig
  def self.for(column); end
end

module Arel::Collectors
end

class Arel::Collectors::Bind
  def <<(str); end

  def add_bind(bind); end

  def value(); end
end

class Arel::Collectors::Bind
end

class Arel::Collectors::Composite
  def <<(str); end

  def add_bind(bind, &block); end

  def initialize(left, right); end

  def left(); end

  def right(); end

  def value(); end
end

class Arel::Collectors::Composite
end

class Arel::Collectors::PlainString
  def <<(str); end

  def value(); end
end

class Arel::Collectors::PlainString
end

class Arel::Collectors::SQLString
  def add_bind(bind); end

  def compile(bvs); end

  def initialize(*_); end
end

class Arel::Collectors::SQLString
end

class Arel::Collectors::SubstituteBinds
  def <<(str); end

  def add_bind(bind); end

  def delegate(); end

  def initialize(quoter, delegate_collector); end

  def quoter(); end

  def value(); end
end

class Arel::Collectors::SubstituteBinds
end

module Arel::Collectors
  extend ::T::Sig
end

module Arel::Compatibility
end

class Arel::Compatibility::Wheres
  include ::Enumerable
  def each(); end

  def initialize(engine, collection); end
end

module Arel::Compatibility::Wheres::Value
  def name(); end

  def value(); end

  def visitor(); end

  def visitor=(visitor); end
end

module Arel::Compatibility::Wheres::Value
  extend ::T::Sig
end

class Arel::Compatibility::Wheres
end

module Arel::Compatibility
  extend ::T::Sig
end

module Arel::Crud
  def compile_delete(); end

  def compile_insert(values); end

  def compile_update(values, pk); end

  def create_insert(); end
end

module Arel::Crud
  extend ::T::Sig
end

class Arel::DeleteManager
  def from(relation); end

  def take(limit); end

  def wheres=(list); end
end

class Arel::DeleteManager
end

class Arel::EmptyJoinError
end

class Arel::EmptyJoinError
end

module Arel::Expressions
  def average(); end

  def count(distinct=T.unsafe(nil)); end

  def extract(field); end

  def maximum(); end

  def minimum(); end

  def sum(); end
end

module Arel::Expressions
  extend ::T::Sig
end

module Arel::FactoryMethods
  def create_and(clauses); end

  def create_false(); end

  def create_join(to, constraint=T.unsafe(nil), klass=T.unsafe(nil)); end

  def create_on(expr); end

  def create_string_join(to); end

  def create_table_alias(relation, name); end

  def create_true(); end

  def grouping(expr); end

  def lower(column); end
end

module Arel::FactoryMethods
  extend ::T::Sig
end

class Arel::InsertManager
  def columns(); end

  def create_values(values, columns); end

  def create_values_list(rows); end

  def insert(fields); end

  def into(table); end

  def select(select); end

  def values=(val); end
end

class Arel::InsertManager
end

module Arel::Math
  def &(other); end

  def *(other); end

  def +(other); end

  def -(other); end

  def /(other); end

  def <<(other); end

  def >>(other); end

  def ^(other); end

  def |(other); end

  def ~(); end
end

module Arel::Math
  extend ::T::Sig
end

Arel::Node = Arel::Nodes::Node

module Arel::Nodes
end

class Arel::Nodes::Addition
  def initialize(left, right); end
end

class Arel::Nodes::Addition
end

class Arel::Nodes::And
  def ==(other); end

  def children(); end

  def eql?(other); end

  def initialize(children); end

  def left(); end

  def right(); end
end

class Arel::Nodes::And
end

class Arel::Nodes::As
end

class Arel::Nodes::As
end

class Arel::Nodes::Ascending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Ascending
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Assignment
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Avg
end

class Arel::Nodes::Between
end

class Arel::Nodes::Between
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Bin
end

class Arel::Nodes::Binary
  def ==(other); end

  def eql?(other); end

  def initialize(left, right); end

  def left(); end

  def left=(left); end

  def right(); end

  def right=(right); end
end

class Arel::Nodes::Binary
end

class Arel::Nodes::BindParam
  def ==(other); end

  def eql?(other); end

  def initialize(value); end

  def value(); end

  def value=(value); end
end

class Arel::Nodes::BindParam
end

class Arel::Nodes::BitwiseAnd
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseAnd
end

class Arel::Nodes::BitwiseNot
  def initialize(operand); end
end

class Arel::Nodes::BitwiseNot
end

class Arel::Nodes::BitwiseOr
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseOr
end

class Arel::Nodes::BitwiseShiftLeft
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftLeft
end

class Arel::Nodes::BitwiseShiftRight
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseShiftRight
end

class Arel::Nodes::BitwiseXor
  def initialize(left, right); end
end

class Arel::Nodes::BitwiseXor
end

class Arel::Nodes::Case
  include ::Arel::OrderPredications
  include ::Arel::Predications
  include ::Arel::AliasPredication
  def ==(other); end

  def case(); end

  def case=(_); end

  def conditions(); end

  def conditions=(conditions); end

  def default(); end

  def default=(default); end

  def else(expression); end

  def eql?(other); end

  def initialize(expression=T.unsafe(nil), default=T.unsafe(nil)); end

  def then(expression); end

  def when(condition, expression=T.unsafe(nil)); end
end

class Arel::Nodes::Case
end

class Arel::Nodes::Casted
  def ==(other); end

  def attribute(); end

  def eql?(other); end

  def initialize(val, attribute); end

  def val(); end
end

class Arel::Nodes::Casted
end

class Arel::Nodes::Concat
  def initialize(left, right); end
end

class Arel::Nodes::Concat
end

class Arel::Nodes::Count
  include ::Arel::Math
  def initialize(expr, distinct=T.unsafe(nil), aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Count
end

class Arel::Nodes::Cube
end

class Arel::Nodes::Cube
end

class Arel::Nodes::CurrentRow
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::CurrentRow
end

class Arel::Nodes::DeleteStatement
  def initialize(relation=T.unsafe(nil), wheres=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def relation(); end

  def relation=(relation); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::DeleteStatement
end

class Arel::Nodes::Descending
  def ascending?(); end

  def descending?(); end

  def direction(); end

  def reverse(); end
end

class Arel::Nodes::Descending
end

class Arel::Nodes::Distinct
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::Distinct
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::DistinctOn
end

class Arel::Nodes::Division
  def initialize(left, right); end
end

class Arel::Nodes::Division
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::DoesNotMatch
end

class Arel::Nodes::Else
end

class Arel::Nodes::Else
end

class Arel::Nodes::Equality
  def operand1(); end

  def operand2(); end

  def operator(); end
end

class Arel::Nodes::Equality
end

class Arel::Nodes::Except
end

class Arel::Nodes::Except
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Exists
end

class Arel::Nodes::Extract
  include ::Arel::AliasPredication
  include ::Arel::Predications
  def field(); end

  def field=(field); end

  def initialize(expr, field); end
end

class Arel::Nodes::Extract
end

class Arel::Nodes::False
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::False
end

class Arel::Nodes::Following
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Following
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::FullOuterJoin
end

class Arel::Nodes::Function
  include ::Arel::Predications
  include ::Arel::WindowPredications
  include ::Arel::OrderPredications
  def ==(other); end

  def alias(); end

  def alias=(_); end

  def as(aliaz); end

  def distinct(); end

  def distinct=(distinct); end

  def eql?(other); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(expr, aliaz=T.unsafe(nil)); end
end

class Arel::Nodes::Function
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThan
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::GreaterThanOrEqual
end

class Arel::Nodes::Group
end

class Arel::Nodes::Group
end

class Arel::Nodes::Grouping
  include ::Arel::Predications
end

class Arel::Nodes::Grouping
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingElement
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::GroupingSet
end

class Arel::Nodes::In
end

class Arel::Nodes::In
end

class Arel::Nodes::InfixOperation
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::OrderPredications
  include ::Arel::AliasPredication
  include ::Arel::Math
  def initialize(operator, left, right); end

  def operator(); end
end

class Arel::Nodes::InfixOperation
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InnerJoin
end

class Arel::Nodes::InsertStatement
  def ==(other); end

  def columns(); end

  def columns=(columns); end

  def eql?(other); end

  def relation(); end

  def relation=(relation); end

  def select=(select); end

  def values(); end

  def values=(values); end
end

class Arel::Nodes::InsertStatement
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Intersect
end

class Arel::Nodes::Join
end

class Arel::Nodes::Join
end

class Arel::Nodes::JoinSource
  def empty?(); end

  def initialize(single_source, joinop=T.unsafe(nil)); end
end

class Arel::Nodes::JoinSource
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThan
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::LessThanOrEqual
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Limit
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Lock
end

class Arel::Nodes::Matches
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def escape(); end

  def initialize(left, right, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Matches
end

class Arel::Nodes::Max
end

class Arel::Nodes::Max
end

class Arel::Nodes::Min
end

class Arel::Nodes::Min
end

class Arel::Nodes::Multiplication
  def initialize(left, right); end
end

class Arel::Nodes::Multiplication
end

class Arel::Nodes::NamedFunction
  def initialize(name, expr, aliaz=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedFunction
end

class Arel::Nodes::NamedWindow
  def initialize(name); end

  def name(); end

  def name=(name); end
end

class Arel::Nodes::NamedWindow
end

class Arel::Nodes::Node
  include ::Arel::FactoryMethods
  include ::Enumerable
  def and(right); end

  def each(&block); end

  def not(); end

  def or(right); end

  def to_sql(engine=T.unsafe(nil)); end
end

class Arel::Nodes::Node
end

class Arel::Nodes::Not
end

class Arel::Nodes::Not
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotEqual
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotIn
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::NotRegexp
end

class Arel::Nodes::Offset
end

class Arel::Nodes::Offset
end

class Arel::Nodes::On
end

class Arel::Nodes::On
end

class Arel::Nodes::Or
end

class Arel::Nodes::Or
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::Ordering
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::OuterJoin
end

class Arel::Nodes::Over
  include ::Arel::AliasPredication
  def initialize(left, right=T.unsafe(nil)); end

  def operator(); end
end

class Arel::Nodes::Over
end

class Arel::Nodes::Preceding
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Preceding
end

class Arel::Nodes::Quoted
  def val(); end
end

class Arel::Nodes::Quoted
end

class Arel::Nodes::Range
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Range
end

class Arel::Nodes::Regexp
  def case_sensitive(); end

  def case_sensitive=(case_sensitive); end

  def initialize(left, right, case_sensitive=T.unsafe(nil)); end
end

class Arel::Nodes::Regexp
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RightOuterJoin
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::RollUp
end

class Arel::Nodes::Rows
  def initialize(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Rows
end

class Arel::Nodes::SelectCore
  def ==(other); end

  def eql?(other); end

  def from(); end

  def from=(value); end

  def froms(); end

  def froms=(value); end

  def groups(); end

  def groups=(groups); end

  def havings(); end

  def havings=(havings); end

  def projections(); end

  def projections=(projections); end

  def set_quantifier(); end

  def set_quantifier=(set_quantifier); end

  def source(); end

  def source=(source); end

  def top(); end

  def top=(top); end

  def wheres(); end

  def wheres=(wheres); end

  def windows(); end

  def windows=(windows); end
end

class Arel::Nodes::SelectCore
end

class Arel::Nodes::SelectStatement
  def ==(other); end

  def cores(); end

  def eql?(other); end

  def initialize(cores=T.unsafe(nil)); end

  def limit(); end

  def limit=(limit); end

  def lock(); end

  def lock=(lock); end

  def offset(); end

  def offset=(offset); end

  def orders(); end

  def orders=(orders); end

  def with(); end

  def with=(with); end
end

class Arel::Nodes::SelectStatement
end

class Arel::Nodes::SqlLiteral
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  def encode_with(coder); end
end

class Arel::Nodes::SqlLiteral
end

class Arel::Nodes::StringJoin
  def initialize(left, right=T.unsafe(nil)); end
end

class Arel::Nodes::StringJoin
end

class Arel::Nodes::Subtraction
  def initialize(left, right); end
end

class Arel::Nodes::Subtraction
end

class Arel::Nodes::Sum
end

class Arel::Nodes::Sum
end

class Arel::Nodes::TableAlias
  def [](name); end

  def able_to_type_cast?(); end

  def name(); end

  def relation(); end

  def table_alias(); end

  def table_name(); end

  def type_cast_for_database(*args); end
end

class Arel::Nodes::TableAlias
end

class Arel::Nodes::Top
end

class Arel::Nodes::Top
end

class Arel::Nodes::True
  def ==(other); end

  def eql?(other); end
end

class Arel::Nodes::True
end

class Arel::Nodes::Unary
  def ==(other); end

  def eql?(other); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end

  def value(); end
end

class Arel::Nodes::Unary
end

class Arel::Nodes::UnaryOperation
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::OrderPredications
  include ::Arel::AliasPredication
  include ::Arel::Math
  def initialize(operator, operand); end

  def operator(); end
end

class Arel::Nodes::UnaryOperation
end

class Arel::Nodes::Union
end

class Arel::Nodes::Union
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnionAll
end

class Arel::Nodes::UnqualifiedColumn
  def attribute(); end

  def attribute=(attribute); end

  def column(); end

  def name(); end

  def relation(); end
end

class Arel::Nodes::UnqualifiedColumn
end

class Arel::Nodes::UpdateStatement
  def ==(other); end

  def eql?(other); end

  def key(); end

  def key=(key); end

  def limit(); end

  def limit=(limit); end

  def orders(); end

  def orders=(orders); end

  def relation(); end

  def relation=(relation); end

  def values(); end

  def values=(values); end

  def wheres(); end

  def wheres=(wheres); end
end

class Arel::Nodes::UpdateStatement
end

class Arel::Nodes::Values
  def columns(); end

  def columns=(columns); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(exprs, columns=T.unsafe(nil)); end
end

class Arel::Nodes::Values
end

class Arel::Nodes::ValuesList
  def ==(other); end

  def eql?(other); end

  def initialize(rows); end

  def rows(); end
end

class Arel::Nodes::ValuesList
end

class Arel::Nodes::When
end

class Arel::Nodes::When
end

class Arel::Nodes::Window
  def ==(other); end

  def eql?(other); end

  def frame(expr); end

  def framing(); end

  def framing=(framing); end

  def order(*expr); end

  def orders(); end

  def orders=(orders); end

  def partition(*expr); end

  def partitions(); end

  def partitions=(partitions); end

  def range(expr=T.unsafe(nil)); end

  def rows(expr=T.unsafe(nil)); end
end

class Arel::Nodes::Window
end

class Arel::Nodes::With
  def children(); end
end

class Arel::Nodes::With
end

class Arel::Nodes::WithRecursive
end

class Arel::Nodes::WithRecursive
end

module Arel::Nodes
  extend ::T::Sig
  def self.build_quoted(other, attribute=T.unsafe(nil)); end
end

module Arel::OrderPredications
  def asc(); end

  def desc(); end
end

module Arel::OrderPredications
  extend ::T::Sig
end

module Arel::Predications
  def between(other); end

  def concat(other); end

  def does_not_match(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def does_not_match_all(others, escape=T.unsafe(nil)); end

  def does_not_match_any(others, escape=T.unsafe(nil)); end

  def does_not_match_regexp(other, case_sensitive=T.unsafe(nil)); end

  def eq(other); end

  def eq_all(others); end

  def eq_any(others); end

  def gt(right); end

  def gt_all(others); end

  def gt_any(others); end

  def gteq(right); end

  def gteq_all(others); end

  def gteq_any(others); end

  def in(other); end

  def in_all(others); end

  def in_any(others); end

  def lt(right); end

  def lt_all(others); end

  def lt_any(others); end

  def lteq(right); end

  def lteq_all(others); end

  def lteq_any(others); end

  def matches(other, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_all(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_any(others, escape=T.unsafe(nil), case_sensitive=T.unsafe(nil)); end

  def matches_regexp(other, case_sensitive=T.unsafe(nil)); end

  def not_between(other); end

  def not_eq(other); end

  def not_eq_all(others); end

  def not_eq_any(others); end

  def not_in(other); end

  def not_in_all(others); end

  def not_in_any(others); end

  def when(right); end
end

module Arel::Predications
  extend ::T::Sig
end

class Arel::SelectManager
  include ::Arel::Crud
  def as(other); end

  def constraints(); end

  def distinct(value=T.unsafe(nil)); end

  def distinct_on(value); end

  def except(other); end

  def exists(); end

  def from(table); end

  def froms(); end

  def group(*columns); end

  def having(expr); end

  def initialize(table=T.unsafe(nil)); end

  def intersect(other); end

  def join(relation, klass=T.unsafe(nil)); end

  def join_sources(); end

  def limit(); end

  def limit=(limit); end

  def lock(locking=T.unsafe(nil)); end

  def locked(); end

  def minus(other); end

  def offset(); end

  def offset=(amount); end

  def on(*exprs); end

  def order(*expr); end

  def orders(); end

  def outer_join(relation); end

  def project(*projections); end

  def projections(); end

  def projections=(projections); end

  def skip(amount); end

  def source(); end

  def take(limit); end

  def taken(); end

  def union(operation, other=T.unsafe(nil)); end

  def where_sql(engine=T.unsafe(nil)); end

  def window(name); end

  def with(*subqueries); end
  STRING_OR_SYMBOL_CLASS = ::T.let(nil, ::T.untyped)
end

class Arel::SelectManager::Row
  def id(); end

  def method_missing(name, *args); end
end

class Arel::SelectManager::Row
end

class Arel::SelectManager
end

class Arel::Table
  include ::Arel::Crud
  include ::Arel::FactoryMethods
  def ==(other); end

  def [](name); end

  def able_to_type_cast?(); end

  def alias(name=T.unsafe(nil)); end

  def eql?(other); end

  def from(); end

  def group(*columns); end

  def having(expr); end

  def initialize(name, as: T.unsafe(nil), type_caster: T.unsafe(nil)); end

  def join(relation, klass=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def order(*expr); end

  def outer_join(relation); end

  def project(*things); end

  def skip(amount); end

  def table_alias(); end

  def table_alias=(table_alias); end

  def table_name(); end

  def take(amount); end

  def type_cast_for_database(attribute_name, value); end

  def type_caster(); end

  def where(condition); end
end

class Arel::Table
  def self.engine(); end

  def self.engine=(engine); end
end

class Arel::TreeManager
  include ::Arel::FactoryMethods
  def ast(); end

  def to_dot(); end

  def to_sql(engine=T.unsafe(nil)); end

  def where(expr); end
end

class Arel::TreeManager
end

class Arel::UpdateManager
  def key(); end

  def key=(key); end

  def order(*expr); end

  def set(values); end

  def table(table); end

  def take(limit); end

  def wheres=(exprs); end
end

class Arel::UpdateManager
end

module Arel::Visitors
end

class Arel::Visitors::DepthFirst
  def initialize(block=T.unsafe(nil)); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::DepthFirst
end

class Arel::Visitors::Dot
  def accept(object, collector); end
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Edge
end

class Arel::Visitors::Dot::Node
  def fields(); end

  def fields=(fields); end

  def id(); end

  def id=(id); end

  def initialize(name, id, fields=T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class Arel::Visitors::Dot::Node
end

class Arel::Visitors::Dot
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::IBM_DB
end

class Arel::Visitors::Informix
end

class Arel::Visitors::Informix
end

class Arel::Visitors::MSSQL
  def initialize(*_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def children(); end

  def children=(_); end
end

class Arel::Visitors::MSSQL::RowNumber
  def self.[](*_); end

  def self.members(); end
end

class Arel::Visitors::MSSQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::MySQL
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::Oracle12
end

class Arel::Visitors::PostgreSQL
  CUBE = ::T.let(nil, ::T.untyped)
  GROUPING_SET = ::T.let(nil, ::T.untyped)
  ROLLUP = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::PostgreSQL
end

class Arel::Visitors::Reduce
  def accept(object, collector); end
end

class Arel::Visitors::Reduce
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::SQLite
end

class Arel::Visitors::ToSql
  def compile(node, &block); end

  def initialize(connection); end
  AND = ::T.let(nil, ::T.untyped)
  COMMA = ::T.let(nil, ::T.untyped)
  DISTINCT = ::T.let(nil, ::T.untyped)
  GROUP_BY = ::T.let(nil, ::T.untyped)
  ORDER_BY = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  WHERE = ::T.let(nil, ::T.untyped)
  WINDOW = ::T.let(nil, ::T.untyped)
end

class Arel::Visitors::ToSql
end

class Arel::Visitors::UnsupportedVisitError
  def initialize(object); end
end

class Arel::Visitors::UnsupportedVisitError
end

class Arel::Visitors::Visitor
  def accept(object); end
end

class Arel::Visitors::Visitor
  def self.dispatch_cache(); end
end

class Arel::Visitors::WhereSql
  def initialize(inner_visitor, *args, &block); end
end

class Arel::Visitors::WhereSql
end

module Arel::Visitors
  extend ::T::Sig
end

module Arel::WindowPredications
  def over(expr=T.unsafe(nil)); end
end

module Arel::WindowPredications
  extend ::T::Sig
end

module Arel
  extend ::T::Sig
  def self.sql(raw_sql); end

  def self.star(); end
end

class ArgumentError
  extend ::T::Sig
end

class Array
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def append(*_); end

  def bsearch(); end

  def bsearch_index(); end

  def butfirst(); end

  def collect!(); end

  def dig(*_); end

  def extract_options!(); end

  def fifth(); end

  def flatten!(*_); end

  def forty_two(); end

  def fourth(); end

  def from(position); end

  def in_groups(number, fill_with=T.unsafe(nil)); end

  def in_groups_of(number, fill_with=T.unsafe(nil)); end

  def inquiry(); end

  def pack(*_); end

  def prepend(*_); end

  def replace(_); end

  def second(); end

  def second_to_last(); end

  def shelljoin(); end

  def split(value=T.unsafe(nil)); end

  def third(); end

  def third_to_last(); end

  def to(position); end

  def to_csv(**options); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  def to_h(); end

  def to_sentence(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end
end

class Array
  extend ::T::Sig
  def self.try_convert(_); end

  def self.wrap(object); end
end

module Artsy
end

module Artsy::EventService
  VERSION = ::T.let(nil, ::T.untyped)
end

module Artsy::EventService::Config
  def app_name(); end

  def app_name=(app_name); end

  def confirms_enabled(); end

  def confirms_enabled=(confirms_enabled); end

  def event_stream_enabled(); end

  def event_stream_enabled=(event_stream_enabled); end

  def rabbitmq_url(); end

  def rabbitmq_url=(rabbitmq_url); end

  def reset(); end

  def tls(); end

  def tls=(tls); end

  def tls_ca_certificate(); end

  def tls_ca_certificate=(tls_ca_certificate); end

  def tls_cert(); end

  def tls_cert=(tls_cert); end

  def tls_key(); end

  def tls_key=(tls_key); end

  def verify_peer(); end

  def verify_peer=(verify_peer); end
end

module Artsy::EventService::Config
  extend ::Artsy::EventService::Config
  extend ::T::Sig
end

class Artsy::EventService::Publisher
  def config(); end

  def post_data(topic:, data:, routing_key: T.unsafe(nil), headers: T.unsafe(nil)); end

  def post_event(topic:, event:, routing_key: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class Artsy::EventService::Publisher
  def self.publish_data(topic:, data:, routing_key: T.unsafe(nil), headers: T.unsafe(nil)); end

  def self.publish_event(topic:, event:, routing_key: T.unsafe(nil), headers: T.unsafe(nil)); end
end

class Artsy::EventService::RabbitMQConnection
end

class Artsy::EventService::RabbitMQConnection
  def self.build_connection(); end

  def self.bunny_params(); end

  def self.config(); end

  def self.get_channel(); end

  def self.get_connection(); end

  def self.no_tls_params(); end

  def self.rabbitmq_url(); end

  def self.tls_params(); end
end

module Artsy::EventService
  extend ::T::Sig
  def self.config(); end

  def self.configure(); end

  def self.consume(**args); end

  def self.event_stream_enabled?(); end

  def self.post_data(topic:, data:, routing_key: T.unsafe(nil)); end

  def self.post_event(topic:, event:, routing_key: T.unsafe(nil)); end
end

module Artsy
  extend ::T::Sig
end

module ArtsyAuth
  VERSION = ::T.let(nil, ::T.untyped)
end

module ArtsyAuth::Authenticated
end

module ArtsyAuth::Authenticated
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module ArtsyAuth::Config
  def application_id(); end

  def application_id=(application_id); end

  def application_secret(); end

  def application_secret=(application_secret); end

  def artsy_api_url(); end

  def artsy_api_url=(artsy_api_url); end

  def callback_url(); end

  def callback_url=(callback_url); end

  def reset(); end
end

module ArtsyAuth::Config
  extend ::ArtsyAuth::Config
  extend ::T::Sig
end

class ArtsyAuth::Engine
end

class ArtsyAuth::Engine
end

class ArtsyAuth::SessionsController
  def auth_hash(); end

  def create(); end

  def destroy(); end
end

class ArtsyAuth::SessionsController
end

module ArtsyAuth
  extend ::T::Sig
  def self.config(); end

  def self.configure(); end

  def self.railtie_helpers_paths(); end

  def self.railtie_namespace(); end

  def self.railtie_routes_url_helpers(include_path_helpers=T.unsafe(nil)); end

  def self.table_name_prefix(); end

  def self.use_relative_model_naming?(); end
end

module AuthHandler
  extend ::T::Sig
end

module Base64
  extend ::T::Sig
end

module Base64Bp
end

module Base64Bp
  extend ::Base64
  extend ::T::Sig
  def self.urlsafe_encode64(bin, padding:); end
end

class BasicObject
  def should(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

BasicObject::BasicObject = BasicObject

class BasicObject
  extend ::T::Sig
end

class BasicSocket
  extend ::T::Sig
end

class Benchmark::Job
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def initialize(width); end

  def item(label=T.unsafe(nil), &blk); end

  def list(); end

  def report(label=T.unsafe(nil), &blk); end

  def width(); end
end

class Benchmark::Job
  extend ::T::Sig
end

class Benchmark::Report
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def initialize(width=T.unsafe(nil), format=T.unsafe(nil)); end

  def item(label=T.unsafe(nil), *format, &blk); end

  def list(); end

  def report(label=T.unsafe(nil), *format, &blk); end
end

class Benchmark::Report
  extend ::T::Sig
end

class Benchmark::Tms
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def *(x); end

  def +(other); end

  def -(other); end

  def /(x); end

  def add(&blk); end

  def add!(&blk); end

  def cstime(); end

  def cutime(); end

  def format(format=T.unsafe(nil), *args); end

  def initialize(utime=T.unsafe(nil), stime=T.unsafe(nil), cutime=T.unsafe(nil), cstime=T.unsafe(nil), real=T.unsafe(nil), label=T.unsafe(nil)); end

  def label(); end

  def memberwise(op, x); end

  def real(); end

  def stime(); end

  def to_a(); end

  def total(); end

  def utime(); end
end

class Benchmark::Tms
  extend ::T::Sig
end

module Benchmark
  extend ::T::Sig
  def self.ms(); end
end

class BigDecimal
  include ::ActiveSupport::NumericWithFormat
  include ::ActiveSupport::BigDecimalWithDefaultFormat
  def clone(); end

  def to_d(); end

  def to_digits(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  SIGN_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  extend ::T::Sig
  def self._load(_); end

  def self.double_fig(); end

  def self.limit(*_); end

  def self.mode(*_); end

  def self.save_exception_mode(); end

  def self.save_limit(); end

  def self.save_rounding_mode(); end

  def self.ver(); end
end

module BigMath
  extend ::T::Sig
end

class Binding
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def clone(); end

  def irb(); end

  def local_variable_defined?(_); end

  def local_variable_get(_); end

  def local_variable_set(_, _1); end

  def receiver(); end
end

class Binding
  extend ::T::Sig
end

module Bundler::BuildMetadata
  extend ::T::Sig
end

Bundler::Deprecate = Gem::Deprecate

class Bundler::Env
end

class Bundler::Env
  def self.environment(); end

  def self.report(options=T.unsafe(nil)); end

  def self.write(io); end
end

class Bundler::FeatureFlag
  def github_https?(); end
end

class Bundler::Fetcher
  def fetch_spec(spec); end

  def fetchers(); end

  def http_proxy(); end

  def initialize(remote); end

  def specs(gem_names, source); end

  def specs_with_retry(gem_names, source); end

  def uri(); end

  def use_api(); end

  def user_agent(); end
  FAIL_ERRORS = ::T.let(nil, ::T.untyped)
  FETCHERS = ::T.let(nil, ::T.untyped)
  HTTP_ERRORS = ::T.let(nil, ::T.untyped)
  NET_ERRORS = ::T.let(nil, ::T.untyped)
end

class Bundler::Fetcher::AuthenticationRequiredError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::AuthenticationRequiredError
end

class Bundler::Fetcher::BadAuthenticationError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::BadAuthenticationError
end

class Bundler::Fetcher::Base
  def api_fetcher?(); end

  def available?(); end

  def display_uri(); end

  def downloader(); end

  def fetch_uri(); end

  def initialize(downloader, remote, display_uri); end

  def remote(); end

  def remote_uri(); end
end

class Bundler::Fetcher::Base
end

class Bundler::Fetcher::CertificateFailureError
  def initialize(remote_uri); end
end

class Bundler::Fetcher::CertificateFailureError
end

class Bundler::Fetcher::CompactIndex
  def available?(*args, &blk); end

  def fetch_spec(*args, &blk); end

  def specs(*args, &blk); end

  def specs_for_names(gem_names); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def call(path, headers); end

  def fetcher(); end

  def fetcher=(_); end

  def ui(); end

  def ui=(_); end
end

class Bundler::Fetcher::CompactIndex::ClientFetcher
  def self.[](*_); end

  def self.members(); end
end

class Bundler::Fetcher::CompactIndex
  def self.compact_index_request(method_name); end
end

class Bundler::Fetcher::Dependency
  def dependency_api_uri(gem_names=T.unsafe(nil)); end

  def dependency_specs(gem_names); end

  def get_formatted_specs_and_deps(gem_list); end

  def specs(gem_names, full_dependency_list=T.unsafe(nil), last_spec_list=T.unsafe(nil)); end

  def unmarshalled_dep_gems(gem_names); end
end

class Bundler::Fetcher::Dependency
end

class Bundler::Fetcher::Downloader
  def connection(); end

  def fetch(uri, headers=T.unsafe(nil), counter=T.unsafe(nil)); end

  def initialize(connection, redirect_limit); end

  def redirect_limit(); end

  def request(uri, headers); end
end

class Bundler::Fetcher::Downloader
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::FallbackError
end

class Bundler::Fetcher::Index
  def fetch_spec(spec); end

  def specs(_gem_names); end
end

class Bundler::Fetcher::Index
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::NetworkDownError
end

class Bundler::Fetcher::SSLError
  def initialize(msg=T.unsafe(nil)); end
end

class Bundler::Fetcher::SSLError
end

class Bundler::Fetcher
  def self.api_timeout(); end

  def self.api_timeout=(api_timeout); end

  def self.disable_endpoint(); end

  def self.disable_endpoint=(disable_endpoint); end

  def self.max_retries(); end

  def self.max_retries=(max_retries); end

  def self.redirect_limit(); end

  def self.redirect_limit=(redirect_limit); end
end

module Bundler::FileUtils::DryRun
  extend ::T::Sig
end

module Bundler::FileUtils::LowMethods
  extend ::T::Sig
end

module Bundler::FileUtils::NoWrite
  extend ::T::Sig
end

module Bundler::FileUtils::StreamUtils_
  extend ::T::Sig
end

module Bundler::FileUtils::Verbose
  extend ::T::Sig
end

module Bundler::FileUtils
  extend ::T::Sig
end

class Bundler::GemHelper
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def allowed_push_host(); end

  def already_tagged?(); end

  def base(); end

  def build_gem(); end

  def built_gem_path(); end

  def clean?(); end

  def committed?(); end

  def gem_key(); end

  def gem_push?(); end

  def gem_push_host(); end

  def gemspec(); end

  def git_push(remote=T.unsafe(nil)); end

  def guard_clean(); end

  def initialize(base=T.unsafe(nil), name=T.unsafe(nil)); end

  def install(); end

  def install_gem(built_gem_path=T.unsafe(nil), local=T.unsafe(nil)); end

  def name(); end

  def perform_git_push(options=T.unsafe(nil)); end

  def rubygem_push(path); end

  def sh(cmd, &block); end

  def sh_with_code(cmd, &block); end

  def spec_path(); end

  def tag_version(); end

  def version(); end

  def version_tag(); end
end

class Bundler::GemHelper
  def self.gemspec(&block); end

  def self.install_tasks(opts=T.unsafe(nil)); end

  def self.instance(); end

  def self.instance=(instance); end
end

module Bundler::GemHelpers
  extend ::T::Sig
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemRemoteFetcher
end

class Bundler::GemVersionPromoter
  def initialize(locked_specs=T.unsafe(nil), unlock_gems=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def locked_specs(); end

  def major?(); end

  def minor?(); end

  def prerelease_specified(); end

  def prerelease_specified=(prerelease_specified); end

  def sort_versions(dep, spec_groups); end

  def strict(); end

  def strict=(strict); end

  def unlock_gems(); end
  DEBUG = ::T.let(nil, ::T.untyped)
end

class Bundler::GemVersionPromoter
end

class Bundler::Graph
  def edge_options(); end

  def groups(); end

  def initialize(env, output_file, show_version=T.unsafe(nil), show_requirements=T.unsafe(nil), output_format=T.unsafe(nil), without=T.unsafe(nil)); end

  def node_options(); end

  def output_file(); end

  def output_format(); end

  def relations(); end

  def viz(); end
  GRAPH_NAME = ::T.let(nil, ::T.untyped)
end

class Bundler::Graph::GraphVizClient
  def g(); end

  def initialize(graph_instance); end

  def run(); end
end

class Bundler::Graph::GraphVizClient
end

class Bundler::Graph
end

class Bundler::Injector
  def initialize(deps, options=T.unsafe(nil)); end

  def inject(gemfile_path, lockfile_path); end

  def remove(gemfile_path, lockfile_path); end
  INJECTED_GEMS = ::T.let(nil, ::T.untyped)
end

class Bundler::Injector
  def self.inject(new_deps, options=T.unsafe(nil)); end

  def self.remove(gems, options=T.unsafe(nil)); end
end

class Bundler::Installer
  def generate_bundler_executable_stubs(spec, options=T.unsafe(nil)); end

  def generate_standalone_bundler_executable_stubs(spec); end

  def initialize(root, definition); end

  def post_install_messages(); end

  def run(options); end
end

class Bundler::Installer
  def self.ambiguous_gems(); end

  def self.ambiguous_gems=(ambiguous_gems); end

  def self.install(root, definition, options=T.unsafe(nil)); end
end

module Bundler::MatchPlatform
  extend ::T::Sig
end

module Bundler::Molinillo::Compatibility
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::Delegates
  extend ::T::Sig
end

module Bundler::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Bundler::Molinillo::UI
  extend ::T::Sig
end

module Bundler::Molinillo
  extend ::T::Sig
end

module Bundler::Plugin::API::Source
  def ==(other); end

  def app_cache_dirname(); end

  def app_cache_path(custom_path=T.unsafe(nil)); end

  def bundler_plugin_api_source?(); end

  def cache(spec, custom_path=T.unsafe(nil)); end

  def cached!(); end

  def can_lock?(spec); end

  def dependency_names(); end

  def dependency_names=(dependency_names); end

  def double_check_for(*_); end

  def eql?(other); end

  def fetch_gemspec_files(); end

  def gem_install_dir(); end

  def hash(); end

  def include?(other); end

  def initialize(opts); end

  def install(spec, opts); end

  def install_path(); end

  def installed?(); end

  def name(); end

  def options(); end

  def options_to_lock(); end

  def post_install(spec, disable_exts=T.unsafe(nil)); end

  def remote!(); end

  def root(); end

  def specs(); end

  def to_lock(); end

  def to_s(); end

  def unlock!(); end

  def unmet_deps(); end

  def uri(); end

  def uri_hash(); end
end

module Bundler::Plugin::API::Source
  extend ::T::Sig
end

class Bundler::Plugin::DSL
  def _gem(name, *args); end

  def inferred_plugins(); end

  def plugin(name, *args); end
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL::PluginGemfileError
end

class Bundler::Plugin::DSL
end

module Bundler::Plugin::Events
  GEM_AFTER_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_AFTER_INSTALL_ALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL = ::T.let(nil, ::T.untyped)
  GEM_BEFORE_INSTALL_ALL = ::T.let(nil, ::T.untyped)
end

module Bundler::Plugin::Events
  extend ::T::Sig
  def self.defined_event?(event); end
end

class Bundler::Plugin::Index
  def command_plugin(command); end

  def commands(); end

  def global_index_file(); end

  def hook_plugins(event); end

  def index_file(); end

  def installed?(name); end

  def load_paths(name); end

  def local_index_file(); end

  def plugin_path(name); end

  def register_plugin(name, path, load_paths, commands, sources, hooks); end

  def source?(source); end

  def source_plugin(name); end
end

class Bundler::Plugin::Index::CommandConflict
  def initialize(plugin, commands); end
end

class Bundler::Plugin::Index::CommandConflict
end

class Bundler::Plugin::Index::SourceConflict
  def initialize(plugin, sources); end
end

class Bundler::Plugin::Index::SourceConflict
end

class Bundler::Plugin::Index
end

class Bundler::Plugin::Installer
  def install(names, options); end

  def install_definition(definition); end
end

class Bundler::Plugin::Installer::Git
  def generate_bin(spec, disable_extensions=T.unsafe(nil)); end
end

class Bundler::Plugin::Installer::Git
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer::Rubygems
end

class Bundler::Plugin::Installer
end

class Bundler::Plugin::SourceList
end

class Bundler::Plugin::SourceList
end

module Bundler::Plugin
  extend ::T::Sig
end

class Bundler::ProcessLock
end

class Bundler::ProcessLock
  def self.lock(bundle_path=T.unsafe(nil)); end
end

class Bundler::Retry
  def attempt(&block); end

  def attempts(&block); end

  def current_run(); end

  def current_run=(current_run); end

  def initialize(name, exceptions=T.unsafe(nil), retries=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def total_runs(); end

  def total_runs=(total_runs); end
end

class Bundler::Retry
  def self.attempts(); end

  def self.default_attempts(); end

  def self.default_retries(); end
end

module Bundler::RubyDsl
  extend ::T::Sig
end

class Bundler::RubyGemsGemInstaller
  def initialize(gem, options=T.unsafe(nil)); end
end

class Bundler::RubyGemsGemInstaller
end

class Bundler::Settings::Mirror
  def ==(other); end

  def fallback_timeout(); end

  def fallback_timeout=(timeout); end

  def initialize(uri=T.unsafe(nil), fallback_timeout=T.unsafe(nil)); end

  def uri(); end

  def uri=(uri); end

  def valid?(); end

  def validate!(probe=T.unsafe(nil)); end
  DEFAULT_FALLBACK_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bundler::Settings::Mirror
end

class Bundler::Settings::Mirrors
  def each(); end

  def for(uri); end

  def initialize(prober=T.unsafe(nil)); end

  def parse(key, value); end
end

class Bundler::Settings::Mirrors
end

class Bundler::Settings::Validator
end

class Bundler::Settings::Validator::Rule
  def description(); end

  def fail!(key, value, *reasons); end

  def initialize(keys, description, &validate); end

  def k(key); end

  def set(settings, key, value, *reasons); end

  def validate!(key, value, settings); end
end

class Bundler::Settings::Validator::Rule
end

class Bundler::Settings::Validator
  def self.validate!(key, value, settings); end
end

module Bundler::SharedHelpers
  extend ::T::Sig
end

class Bundler::UI::RGProxy
end

class Bundler::UI::Shell
  def add_color(string, *color); end

  def ask(msg); end

  def confirm(msg, newline=T.unsafe(nil)); end

  def debug(msg, newline=T.unsafe(nil)); end

  def debug?(); end

  def error(msg, newline=T.unsafe(nil)); end

  def info(msg, newline=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def level(name=T.unsafe(nil)); end

  def level=(level); end

  def no?(); end

  def quiet?(); end

  def shell=(shell); end

  def silence(&blk); end

  def trace(e, newline=T.unsafe(nil), force=T.unsafe(nil)); end

  def unprinted_warnings(); end

  def warn(msg, newline=T.unsafe(nil)); end

  def yes?(msg); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Bundler::UI::Shell
end

module Bundler::UI
  extend ::T::Sig
end

module Bundler::URICredentialsFilter
  extend ::T::Sig
end

module Bundler::VersionRanges
end

class Bundler::VersionRanges::NEq
  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::NEq
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def cover?(v); end

  def empty?(); end

  def left(); end

  def left=(_); end

  def right(); end

  def right=(_); end

  def single?(); end
  INFINITY = ::T.let(nil, ::T.untyped)
  UNIVERSAL = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class Bundler::VersionRanges::ReqR::Endpoint
  def inclusive(); end

  def inclusive=(_); end

  def version(); end

  def version=(_); end
end

class Bundler::VersionRanges::ReqR::Endpoint
  def self.[](*_); end

  def self.members(); end
end

class Bundler::VersionRanges::ReqR
  def self.[](*_); end

  def self.members(); end
end

module Bundler::VersionRanges
  extend ::T::Sig
  def self.empty?(ranges, neqs); end

  def self.for(requirement); end

  def self.for_many(requirements); end
end

module Bundler::YAMLSerializer
  extend ::T::Sig
end

module Bundler
  extend ::T::Sig
end

module Bunny
  PROTOCOL_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Bunny::AccessRefused
end

class Bunny::AccessRefused
end

module Bunny::Authentication
end

class Bunny::Authentication::CredentialsEncoder
  def encode_credentials(username, challenge); end

  def initialize(session); end

  def session(); end
end

class Bunny::Authentication::CredentialsEncoder
  def self.auth_mechanism(*mechanisms); end

  def self.for_session(session); end

  def self.registry(); end
end

class Bunny::Authentication::ExternalMechanismEncoder
  def encode_credentials(username, password); end
end

class Bunny::Authentication::ExternalMechanismEncoder
end

class Bunny::Authentication::PlainMechanismEncoder
  def encode_credentials(username, password); end
end

class Bunny::Authentication::PlainMechanismEncoder
end

module Bunny::Authentication
  extend ::T::Sig
end

class Bunny::AuthenticationFailureError
end

class Bunny::AuthenticationFailureError
end

class Bunny::BadLengthError
  def initialize(expected_length, actual_length); end
end

class Bunny::BadLengthError
end

class Bunny::Channel
  def ack(delivery_tag, multiple=T.unsafe(nil)); end

  def acknowledge(delivery_tag, multiple=T.unsafe(nil)); end

  def active(); end

  def add_consumer(queue, consumer_tag, no_ack, exclusive, arguments, &block); end

  def any_consumers?(); end

  def basic_ack(delivery_tag, multiple=T.unsafe(nil)); end

  def basic_cancel(consumer_tag); end

  def basic_consume(queue, consumer_tag=T.unsafe(nil), no_ack=T.unsafe(nil), exclusive=T.unsafe(nil), arguments=T.unsafe(nil), &block); end

  def basic_consume_with(consumer); end

  def basic_get(queue, opts=T.unsafe(nil)); end

  def basic_nack(delivery_tag, multiple=T.unsafe(nil), requeue=T.unsafe(nil)); end

  def basic_publish(payload, exchange, routing_key, opts=T.unsafe(nil)); end

  def basic_qos(count, global=T.unsafe(nil)); end

  def basic_recover(requeue); end

  def basic_reject(delivery_tag, requeue=T.unsafe(nil)); end

  def can_accept_queue_declare_ok?(method); end

  def channel_flow(active); end

  def channel_level_exception_after_operation_that_has_no_response?(method); end

  def client(); end

  def close(); end

  def closed!(); end

  def closed?(); end

  def confirm_select(callback=T.unsafe(nil)); end

  def connection(); end

  def consume(queue, consumer_tag=T.unsafe(nil), no_ack=T.unsafe(nil), exclusive=T.unsafe(nil), arguments=T.unsafe(nil), &block); end

  def consume_with(consumer); end

  def consumers(); end

  def default_exchange(); end

  def deregister_exchange(exchange); end

  def deregister_queue(queue); end

  def deregister_queue_named(name); end

  def direct(name, opts=T.unsafe(nil)); end

  def exchange(name, opts=T.unsafe(nil)); end

  def exchange_bind(source, destination, opts=T.unsafe(nil)); end

  def exchange_declare(name, type, opts=T.unsafe(nil)); end

  def exchange_delete(name, opts=T.unsafe(nil)); end

  def exchange_unbind(source, destination, opts=T.unsafe(nil)); end

  def exchanges(); end

  def fanout(name, opts=T.unsafe(nil)); end

  def find_exchange(name); end

  def find_queue(name); end

  def flow(active); end

  def frame_size(); end

  def generate_consumer_tag(name=T.unsafe(nil)); end

  def guarding_against_stale_delivery_tags(tag, &block); end

  def handle_ack_or_nack(delivery_tag_before_offset, multiple, nack); end

  def handle_basic_get_empty(basic_get_empty); end

  def handle_basic_get_ok(basic_get_ok, properties, content); end

  def handle_basic_return(basic_return, properties, content); end

  def handle_frameset(basic_deliver, properties, content); end

  def handle_method(method); end

  def headers(name, opts=T.unsafe(nil)); end

  def id(); end

  def id=(id); end

  def increment_recoveries_counter(); end

  def initialize(connection=T.unsafe(nil), id=T.unsafe(nil), work_pool=T.unsafe(nil)); end

  def instantiate_channel_level_exception(frame); end

  def maybe_kill_consumer_work_pool!(); end

  def maybe_pause_consumer_work_pool!(); end

  def maybe_start_consumer_work_pool!(); end

  def nack(delivery_tag, multiple=T.unsafe(nil), requeue=T.unsafe(nil)); end

  def nacked_set(); end

  def new_continuation(); end

  def next_publish_seq_no(); end

  def number(); end

  def on_error(&block); end

  def on_uncaught_exception(&block); end

  def open(); end

  def open?(); end

  def pending_server_named_queue_declaration?(); end

  def prefetch(count, global=T.unsafe(nil)); end

  def prefetch_count(); end

  def prefetch_global(); end

  def queue(name=T.unsafe(nil), opts=T.unsafe(nil)); end

  def queue_bind(name, exchange, opts=T.unsafe(nil)); end

  def queue_declare(name, opts=T.unsafe(nil)); end

  def queue_delete(name, opts=T.unsafe(nil)); end

  def queue_purge(name, opts=T.unsafe(nil)); end

  def queue_unbind(name, exchange, opts=T.unsafe(nil)); end

  def queues(); end

  def raise_if_channel_close!(method); end

  def raise_if_continuation_resulted_in_a_channel_error!(); end

  def raise_if_no_longer_open!(); end

  def read_and_reset_only_acks_received(); end

  def read_next_frame(options=T.unsafe(nil)); end

  def recover(ignored=T.unsafe(nil)); end

  def recover_cancelled_consumers!(); end

  def recover_confirm_mode(); end

  def recover_consumers(); end

  def recover_exchanges(); end

  def recover_from_network_failure(); end

  def recover_prefetch_setting(); end

  def recover_queues(); end

  def recover_tx_mode(); end

  def recoveries_counter(); end

  def recovers_cancelled_consumers?(); end

  def register_consumer(consumer_tag, consumer); end

  def register_exchange(exchange); end

  def register_queue(queue); end

  def reject(delivery_tag, requeue=T.unsafe(nil)); end

  def release_all_continuations(); end

  def reset_continuations(); end

  def status(); end

  def synchronize(&block); end

  def temporary_queue(opts=T.unsafe(nil)); end

  def topic(name, opts=T.unsafe(nil)); end

  def tx_commit(); end

  def tx_rollback(); end

  def tx_select(); end

  def unconfirmed_set(); end

  def unregister_consumer(consumer_tag); end

  def using_publisher_confirmations?(); end

  def using_publisher_confirms?(); end

  def using_tx?(); end

  def wait_for_confirms(); end

  def wait_on_basic_get_continuations(); end

  def wait_on_confirms_continuations(); end

  def wait_on_continuations(); end

  def wait_on_continuations_timeout(); end

  def with_continuation_timeout(&block); end

  def work_pool(); end
  DEFAULT_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  MAX_PREFETCH_COUNT = ::T.let(nil, ::T.untyped)
  SHORTSTR_LIMIT = ::T.let(nil, ::T.untyped)
end

class Bunny::Channel
end

class Bunny::ChannelAlreadyClosed
  def channel(); end

  def initialize(message, ch); end
end

class Bunny::ChannelAlreadyClosed
end

class Bunny::ChannelError
end

class Bunny::ChannelError
end

class Bunny::ChannelIdAllocator
  def allocated_channel_id?(i); end

  def initialize(max_channel=T.unsafe(nil)); end

  def next_channel_id(); end

  def release_channel_id(i); end

  def reset_channel_id_allocator(); end

  def synchronize(&block); end
end

class Bunny::ChannelIdAllocator
end

class Bunny::ChannelLevelException
  def channel(); end

  def channel_close(); end

  def initialize(message, ch, channel_close); end
end

class Bunny::ChannelLevelException
end

Bunny::Client = Bunny::Session

class Bunny::ClientTimeout
end

class Bunny::ClientTimeout
end

class Bunny::CommandInvalid
end

class Bunny::CommandInvalid
end

module Bunny::Concurrent
end

class Bunny::Concurrent::AtomicFixnum
  def ==(m); end

  def ===(v); end

  def dec(); end

  def decrement(); end

  def decrement_and_get(); end

  def get(); end

  def get_and_add(i); end

  def get_and_increment(); end

  def inc(); end

  def increment(); end

  def increment_and_get(); end

  def initialize(n=T.unsafe(nil)); end

  def set(n); end

  def to_i(); end
end

class Bunny::Concurrent::AtomicFixnum
end

class Bunny::Concurrent::ContinuationQueue
  def <<(item); end

  def clear(); end

  def empty?(); end

  def length(); end

  def poll(timeout_in_ms=T.unsafe(nil)); end

  def pop(); end

  def push(item); end

  def size(); end
end

class Bunny::Concurrent::ContinuationQueue
end

module Bunny::Concurrent
  extend ::T::Sig
end

class Bunny::ConnectionAlreadyClosed
  def initialize(); end
end

class Bunny::ConnectionAlreadyClosed
end

class Bunny::ConnectionClosedError
  def initialize(frame); end
end

class Bunny::ConnectionClosedError
end

Bunny::ConnectionError = Bunny::TCPConnectionFailed

class Bunny::ConnectionForced
end

class Bunny::ConnectionForced
end

class Bunny::ConnectionLevelException
  def connection(); end

  def connection_close(); end

  def initialize(message, connection, connection_close); end
end

class Bunny::ConnectionLevelException
end

class Bunny::ConnectionTimeout
end

class Bunny::ConnectionTimeout
end

class Bunny::Consumer
  def arguments(); end

  def automatic_acknowledgement?(); end

  def call(*args); end

  def cancel(); end

  def channel(); end

  def consumer_tag(); end

  def consumer_tag=(consumer_tag); end

  def exclusive(); end

  def handle_cancellation(basic_cancel); end

  def handle_delivery(*args); end

  def initialize(channel, queue, consumer_tag=T.unsafe(nil), no_ack=T.unsafe(nil), exclusive=T.unsafe(nil), arguments=T.unsafe(nil)); end

  def manual_acknowledgement?(); end

  def no_ack(); end

  def on_cancellation(&block); end

  def on_delivery(&block); end

  def queue(); end

  def queue_name(); end

  def recover_from_network_failure(); end
end

class Bunny::Consumer
end

class Bunny::ConsumerWorkPool
  def abort_on_exception(); end

  def backlog(); end

  def busy?(); end

  def initialize(size=T.unsafe(nil), abort_on_exception=T.unsafe(nil), shutdown_timeout=T.unsafe(nil)); end

  def join(timeout=T.unsafe(nil)); end

  def kill(); end

  def pause(); end

  def resume(); end

  def run_loop(); end

  def running?(); end

  def shutdown(wait_for_workers=T.unsafe(nil)); end

  def size(); end

  def start(); end

  def submit(callable=T.unsafe(nil), &block); end

  def threads(); end
end

class Bunny::ConsumerWorkPool
end

class Bunny::DeliveryInfo
  include ::Enumerable
  def [](k); end

  def channel(); end

  def consumer(); end

  def consumer_tag(); end

  def delivery_tag(); end

  def each(*args, &block); end

  def exchange(); end

  def initialize(basic_deliver, consumer, channel); end

  def redelivered(); end

  def redelivered?(); end

  def routing_key(); end

  def to_hash(); end
end

class Bunny::DeliveryInfo
end

class Bunny::Exception
end

class Bunny::Exception
end

class Bunny::Exchange
  def arguments(); end

  def auto_delete?(); end

  def bind(source, opts=T.unsafe(nil)); end

  def channel(); end

  def declare!(); end

  def delete(opts=T.unsafe(nil)); end

  def durable?(); end

  def handle_return(basic_return, properties, content); end

  def initialize(channel, type, name, opts=T.unsafe(nil)); end

  def internal?(); end

  def name(); end

  def on_return(&block); end

  def opts(); end

  def opts=(opts); end

  def predeclared?(); end

  def predefined?(); end

  def publish(payload, opts=T.unsafe(nil)); end

  def recover_from_network_failure(); end

  def status(); end

  def type(); end

  def unbind(source, opts=T.unsafe(nil)); end

  def wait_for_confirms(); end
end

class Bunny::Exchange
  def self.add_default_options(name, opts); end

  def self.default(channel_or_connection); end
end

class Bunny::ForcedChannelCloseError
end

class Bunny::ForcedChannelCloseError
end

class Bunny::ForcedConnectionCloseError
end

class Bunny::ForcedConnectionCloseError
end

class Bunny::FrameError
end

class Bunny::FrameError
end

module Bunny::Framing
  DATA_SLICE = ::T.let(nil, ::T.untyped)
  ENCODINGS_SUPPORTED = ::T.let(nil, ::T.untyped)
  HEADER_SLICE = ::T.let(nil, ::T.untyped)
  PAYLOAD_SLICE = ::T.let(nil, ::T.untyped)
end

module Bunny::Framing::IO
end

class Bunny::Framing::IO::Frame
end

class Bunny::Framing::IO::Frame
  def self.decode(io); end
end

module Bunny::Framing::IO
  extend ::T::Sig
end

module Bunny::Framing::String
end

class Bunny::Framing::String::Frame
end

class Bunny::Framing::String::Frame
  def self.decode(string); end
end

module Bunny::Framing::String
  extend ::T::Sig
end

module Bunny::Framing
  extend ::T::Sig
end

class Bunny::GetResponse
  include ::Enumerable
  def [](k); end

  def channel(); end

  def delivery_tag(); end

  def each(*args, &block); end

  def exchange(); end

  def initialize(get_ok, channel); end

  def redelivered(); end

  def redelivered?(); end

  def routing_key(); end

  def to_hash(); end
end

class Bunny::GetResponse
end

class Bunny::HeartbeatSender
  def beat(); end

  def initialize(transport, logger); end

  def run(); end

  def signal_activity!(); end

  def start(period=T.unsafe(nil)); end

  def stop(); end
end

class Bunny::HeartbeatSender
end

class Bunny::HostListDepleted
  def initialize(); end
end

class Bunny::HostListDepleted
end

class Bunny::InconsistentDataError
end

class Bunny::InconsistentDataError
end

class Bunny::InternalError
end

class Bunny::InternalError
end

class Bunny::MessageError
end

class Bunny::MessageError
end

class Bunny::MessageProperties
  include ::Enumerable
  def [](k); end

  def app_id(); end

  def cluster_id(); end

  def content_encoding(); end

  def content_type(); end

  def correlation_id(); end

  def delivery_mode(); end

  def each(*args, &block); end

  def expiration(); end

  def headers(); end

  def initialize(properties); end

  def message_id(); end

  def priority(); end

  def reply_to(); end

  def timestamp(); end

  def to_hash(); end

  def type(); end

  def user_id(); end
end

class Bunny::MessageProperties
end

class Bunny::MissingTLSCertificateFile
end

class Bunny::MissingTLSCertificateFile
end

class Bunny::MissingTLSKeyFile
end

class Bunny::MissingTLSKeyFile
end

class Bunny::NetworkErrorWrapper
  def initialize(other); end

  def other(); end
end

class Bunny::NetworkErrorWrapper
end

class Bunny::NetworkFailure
  def initialize(message, cause); end
end

class Bunny::NetworkFailure
end

class Bunny::NoFinalOctetError
  def initialize(); end
end

class Bunny::NoFinalOctetError
end

class Bunny::NotAllowedError
  def connection(); end

  def connection_close(); end

  def initialize(message, connection, connection_close=T.unsafe(nil)); end
end

class Bunny::NotAllowedError
end

class Bunny::NotFound
end

class Bunny::NotFound
end

class Bunny::PossibleAuthenticationFailureError
  def initialize(username, vhost, password_length); end

  def username(); end

  def vhost(); end
end

class Bunny::PossibleAuthenticationFailureError
end

class Bunny::PreconditionFailed
end

class Bunny::PreconditionFailed
end

class Bunny::ProtocolError
end

class Bunny::ProtocolError
end

class Bunny::Queue
  def arguments(); end

  def auto_delete?(); end

  def bind(exchange, opts=T.unsafe(nil)); end

  def channel(); end

  def consumer_count(); end

  def declare!(); end

  def delete(opts=T.unsafe(nil)); end

  def durable?(); end

  def exclusive?(); end

  def get(opts=T.unsafe(nil), &block); end

  def initialize(channel, name=T.unsafe(nil), opts=T.unsafe(nil)); end

  def message_count(); end

  def name(); end

  def options(); end

  def pop(opts=T.unsafe(nil), &block); end

  def publish(payload, opts=T.unsafe(nil)); end

  def purge(opts=T.unsafe(nil)); end

  def recover_bindings(); end

  def recover_from_network_failure(); end

  def server_named?(); end

  def status(); end

  def subscribe(opts=T.unsafe(nil), &block); end

  def subscribe_with(consumer, opts=T.unsafe(nil)); end

  def unbind(exchange, opts=T.unsafe(nil)); end
end

class Bunny::Queue
  def self.add_default_options(name, opts); end
end

class Bunny::ReaderLoop
  def initialize(transport, session, session_thread); end

  def io_error?(e); end

  def join(); end

  def kill(); end

  def log_exception(e, level: T.unsafe(nil)); end

  def raise(e); end

  def resume(); end

  def run_loop(); end

  def run_once(); end

  def start(); end

  def stop(); end

  def stopped?(); end

  def stopping?(); end

  def terminate?(); end

  def terminate_with(e); end
end

class Bunny::ReaderLoop
end

class Bunny::ResourceError
end

class Bunny::ResourceError
end

class Bunny::ResourceLocked
end

class Bunny::ResourceLocked
end

class Bunny::ReturnInfo
  include ::Enumerable
  def [](k); end

  def each(*args, &block); end

  def exchange(); end

  def initialize(basic_return); end

  def reply_code(); end

  def reply_text(); end

  def routing_key(); end

  def to_hash(); end
end

class Bunny::ReturnInfo
end

class Bunny::SSLSocket
  def initialize(*args); end

  def read_fully(count, timeout=T.unsafe(nil)); end

  def write_nonblock_fully(data, timeout=T.unsafe(nil)); end
  READ_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
  WRITE_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
end

class Bunny::SSLSocket
end

Bunny::SSLSocketImpl = Bunny::SSLSocket

Bunny::ServerDownError = Bunny::TCPConnectionFailed

class Bunny::Session
  def addresses_from(options); end

  def announce_network_failure_recovery(); end

  def automatically_recover?(); end

  def blocked?(); end

  def channel(n=T.unsafe(nil), consumer_pool_size=T.unsafe(nil), consumer_pool_abort_on_exception=T.unsafe(nil), consumer_pool_shutdown_timeout=T.unsafe(nil)); end

  def channel_id_allocator(); end

  def channel_max(); end

  def clean_up_and_fail_on_connection_close!(method); end

  def clean_up_on_shutdown(); end

  def close(); end

  def close_all_channels(); end

  def close_channel(ch); end

  def close_connection(sync=T.unsafe(nil)); end

  def close_transport(); end

  def closed?(); end

  def closing?(); end

  def configure_socket(&block); end

  def connected?(); end

  def connecting?(); end

  def continuation_timeout(); end

  def create_channel(n=T.unsafe(nil), consumer_pool_size=T.unsafe(nil), consumer_pool_abort_on_exception=T.unsafe(nil), consumer_pool_shutdown_timeout=T.unsafe(nil)); end

  def credentials_encoder_for(mechanism); end

  def decrement_recovery_attemp_counter!(); end

  def encode_credentials(username, password); end

  def exchange_exists?(name); end

  def find_channel(number); end

  def frame_max(); end

  def handle_frame(ch_number, method); end

  def handle_frameset(ch_number, frames); end

  def handle_network_failure(exception); end

  def heartbeat(); end

  def heartbeat_disabled?(val); end

  def heartbeat_from(options); end

  def heartbeat_interval(); end

  def heartbeat_timeout(); end

  def host(); end

  def host_from_address(address); end

  def host_with_port?(address); end

  def hostname(); end

  def ignoring_io_errors(&block); end

  def init_connection(); end

  def init_default_logger(logfile, level); end

  def init_default_logger_without_progname(logfile, level); end

  def initialize(connection_string_or_opts=T.unsafe(nil), optz=T.unsafe(nil)); end

  def initialize_heartbeat_sender(); end

  def initialize_transport(); end

  def instantiate_connection_level_exception(frame); end

  def local_port(); end

  def logger(); end

  def manually_closed?(); end

  def maybe_close_transport(); end

  def maybe_shutdown_heartbeat_sender(); end

  def maybe_shutdown_reader_loop(); end

  def mechanism(); end

  def mutex_impl(); end

  def negotiate_value(client_value, server_value); end

  def network_recovery_interval(); end

  def next_channel_id(); end

  def normalize_auth_mechanism(value); end

  def normalize_client_channel_max(n); end

  def normalize_log_level(level); end

  def on_blocked(&block); end

  def on_unblocked(&block); end

  def open?(); end

  def open_channel(ch); end

  def open_connection(); end

  def pass(); end

  def password(); end

  def password_from(options); end

  def port(); end

  def port_from(options); end

  def port_from_address(address); end

  def queue_exists?(name); end

  def raise_if_continuation_resulted_in_a_connection_error!(); end

  def reader_loop(); end

  def recover_channels(); end

  def recover_from_connection_close?(); end

  def recover_from_network_failure(); end

  def recoverable_network_failure?(exception); end

  def recovering_from_network_failure?(); end

  def recovery_attempts_limited?(); end

  def register_channel(ch); end

  def release_channel_id(i); end

  def reset_address_index(); end

  def reset_continuations(); end

  def reset_recovery_attempt_counter!(); end

  def send_frame(frame, signal_activity=T.unsafe(nil)); end

  def send_frame_without_timeout(frame, signal_activity=T.unsafe(nil)); end

  def send_frameset(frames, channel); end

  def send_frameset_without_timeout(frames, channel); end

  def send_preamble(); end

  def send_raw_without_timeout(data, channel); end

  def server_authentication_mechanisms(); end

  def server_capabilities(); end

  def server_locales(); end

  def server_properties(); end

  def should_retry_recovery?(); end

  def shut_down_all_consumer_work_pools!(); end

  def signal_activity!(); end

  def socket_configurator(); end

  def socket_configurator=(socket_configurator); end

  def ssl?(); end

  def start(); end

  def start_reader_loop(); end

  def status(); end

  def stop(); end

  def synchronised_find_channel(number); end

  def threaded(); end

  def threaded?(); end

  def tls?(); end

  def transport(); end

  def transport_write_timeout(); end

  def unregister_channel(ch); end

  def user(); end

  def username(); end

  def username_from(options); end

  def uses_ssl?(); end

  def uses_tls?(); end

  def validate_connection_options(options); end

  def vhost(); end

  def vhost_from(options); end

  def virtual_host(); end

  def wait_on_continuations(); end

  def with_channel(n=T.unsafe(nil)); end
  CHANNEL_MAX_LIMIT = ::T.let(nil, ::T.untyped)
  CONNECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  DEFAULT_CHANNEL_MAX = ::T.let(nil, ::T.untyped)
  DEFAULT_CLIENT_PROPERTIES = ::T.let(nil, ::T.untyped)
  DEFAULT_CONTINUATION_TIMEOUT = ::T.let(nil, ::T.untyped)
  DEFAULT_FRAME_MAX = ::T.let(nil, ::T.untyped)
  DEFAULT_HEARTBEAT = ::T.let(nil, ::T.untyped)
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  DEFAULT_LOCALE = ::T.let(nil, ::T.untyped)
  DEFAULT_NETWORK_RECOVERY_INTERVAL = ::T.let(nil, ::T.untyped)
  DEFAULT_PASSWORD = ::T.let(nil, ::T.untyped)
  DEFAULT_USER = ::T.let(nil, ::T.untyped)
  DEFAULT_VHOST = ::T.let(nil, ::T.untyped)
end

class Bunny::Session
  def self.parse_uri(uri); end
end

class Bunny::ShutdownSignal
end

class Bunny::ShutdownSignal
end

module Bunny::Socket
  def options(); end

  def options=(options); end

  def read_fully(count, timeout=T.unsafe(nil)); end

  def write_nonblock_fully(data, timeout=T.unsafe(nil)); end
  READ_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
  WRITE_RETRY_EXCEPTION_CLASSES = ::T.let(nil, ::T.untyped)
end

module Bunny::Socket
  extend ::T::Sig
  def self.open(host, port, options=T.unsafe(nil)); end
end

Bunny::SocketImpl = Bunny::Socket

class Bunny::TCPConnectionFailed
  def hostname(); end

  def initialize(e, hostname=T.unsafe(nil), port=T.unsafe(nil)); end

  def port(); end
end

class Bunny::TCPConnectionFailed
end

class Bunny::TCPConnectionFailedForAllHosts
  def initialize(); end
end

class Bunny::TCPConnectionFailedForAllHosts
end

Bunny::Timeout = Timeout

Bunny::Timer = Timeout

class Bunny::Transport
  def as_boolean(val); end

  def check_local_certificate_path!(s); end

  def check_local_key_path!(s); end

  def close(reason=T.unsafe(nil)); end

  def closed?(); end

  def configure_socket(&block); end

  def configure_tls_context(&block); end

  def connect(); end

  def connect_timeout(); end

  def connected?(); end

  def disconnect_timeout(); end

  def flush(); end

  def host(); end

  def hostname(); end

  def initialize(session, host, port, opts); end

  def initialize_socket(); end

  def initialize_tls_certificate_store(certs); end

  def initialize_tls_context(ctx, opts=T.unsafe(nil)); end

  def inline_client_certificate_from(opts); end

  def inline_client_key_from(opts); end

  def local_address(); end

  def maybe_initialize_socket(); end

  def open?(); end

  def port(); end

  def post_initialize_socket(); end

  def prepare_tls_context(opts); end

  def read_client_certificate!(); end

  def read_client_key!(); end

  def read_fully(count); end

  def read_next_frame(opts=T.unsafe(nil)); end

  def read_ready?(timeout=T.unsafe(nil)); end

  def read_timeout(); end

  def read_timeout=(v); end

  def send_frame(frame); end

  def send_frame_without_timeout(frame); end

  def session(); end

  def socket(); end

  def ssl?(); end

  def timeout_from(options); end

  def tls?(); end

  def tls_ca_certificates(); end

  def tls_ca_certificates_paths_from(opts); end

  def tls_certificate_from(opts); end

  def tls_certificate_path(); end

  def tls_certificate_path_from(opts); end

  def tls_context(); end

  def tls_enabled?(opts); end

  def tls_key_from(opts); end

  def tls_key_path(); end

  def tls_key_path_from(opts); end

  def uses_ssl?(); end

  def uses_tls?(); end

  def verify_peer(); end

  def wrap_in_tls_socket(socket); end

  def write(data); end

  def write_timeout(); end

  def write_without_timeout(data, raise_exceptions=T.unsafe(nil)); end
  DEFAULT_CONNECTION_TIMEOUT = ::T.let(nil, ::T.untyped)
  DEFAULT_READ_TIMEOUT = ::T.let(nil, ::T.untyped)
  DEFAULT_WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Bunny::Transport
  def self.ping!(host, port, timeout); end

  def self.reacheable?(host, port, timeout); end
end

class Bunny::UnexpectedFrame
end

class Bunny::UnexpectedFrame
end

class Bunny::VersionedDeliveryTag
  def initialize(tag, version); end

  def stale?(version); end

  def tag(); end

  def to_i(); end

  def version(); end
end

class Bunny::VersionedDeliveryTag
end

module Bunny
  extend ::T::Sig
  def self.new(connection_string_or_opts=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.protocol_version(); end

  def self.run(connection_string_or_opts=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def self.version(); end
end

module Byebug
  include ::Byebug::Helpers::ReflectionHelper
  def displays(); end

  def displays=(displays); end

  def init_file(); end

  def init_file=(init_file); end

  def mode(); end

  def mode=(mode); end

  def run_init_script(); end
  PORT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoirbSetting
end

class Byebug::AutolistSetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutolistSetting
end

class Byebug::AutoprySetting
  def banner(); end

  def value=(val); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutoprySetting
end

class Byebug::AutosaveSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::AutosaveSetting
end

class Byebug::BasenameSetting
  def banner(); end
end

class Byebug::BasenameSetting
end

class Byebug::BreakCommand
  include ::Byebug::Helpers::EvalHelper
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::BreakCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Breakpoint
  def enabled=(enabled); end

  def enabled?(); end

  def expr(); end

  def expr=(expr); end

  def hit_condition(); end

  def hit_condition=(hit_condition); end

  def hit_count(); end

  def hit_value(); end

  def hit_value=(hit_value); end

  def id(); end

  def initialize(_, _1, _2); end

  def pos(); end

  def source(); end
end

class Byebug::Breakpoint
  def self.add(file, line, expr=T.unsafe(nil)); end

  def self.first(); end

  def self.last(); end

  def self.none?(); end

  def self.potential_line?(filename, lineno); end

  def self.potential_lines(filename); end

  def self.remove(id); end
end

class Byebug::CallstyleSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::CallstyleSetting
end

class Byebug::CatchCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::CatchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Command
  def arguments(); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(); end

  def help(*args, &block); end

  def initialize(processor, input=T.unsafe(nil)); end

  def match(*args, &block); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def print(*args, &block); end

  def processor(); end

  def prv(*args, &block); end

  def puts(*args, &block); end
end

class Byebug::Command
  extend ::Forwardable
  extend ::Byebug::Helpers::StringHelper
  def self.allow_in_control(); end

  def self.allow_in_control=(allow_in_control); end

  def self.allow_in_post_mortem(); end

  def self.allow_in_post_mortem=(allow_in_post_mortem); end

  def self.always_run(); end

  def self.always_run=(always_run); end

  def self.columnize(width); end

  def self.help(); end

  def self.match(input); end
end

class Byebug::CommandList
  include ::Enumerable
  def each(); end

  def initialize(commands); end

  def match(input); end
end

class Byebug::CommandList
end

class Byebug::CommandNotFound
  def initialize(input, parent=T.unsafe(nil)); end
end

class Byebug::CommandNotFound
end

class Byebug::CommandProcessor
  include ::Byebug::Helpers::EvalHelper
  def after_repl(); end

  def at_breakpoint(brkpt); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def before_repl(); end

  def command_list(); end

  def commands(*args, &block); end

  def confirm(*args, &block); end

  def context(); end

  def errmsg(*args, &block); end

  def frame(*args, &block); end

  def initialize(context, interface=T.unsafe(nil)); end

  def interface(); end

  def pr(*args, &block); end

  def prc(*args, &block); end

  def prev_line(); end

  def prev_line=(prev_line); end

  def printer(); end

  def proceed!(); end

  def process_commands(); end

  def prompt(); end

  def prv(*args, &block); end

  def puts(*args, &block); end

  def repl(); end
end

class Byebug::CommandProcessor
  extend ::Forwardable
end

class Byebug::ConditionCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ConditionCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Context
  include ::Byebug::Helpers::FileHelper
  def at_breakpoint(breakpoint); end

  def at_catchpoint(exception); end

  def at_end(); end

  def at_line(); end

  def at_return(return_value); end

  def at_tracing(); end

  def backtrace(); end

  def dead?(); end

  def file(*args, &block); end

  def frame(); end

  def frame=(pos); end

  def frame_binding(*_); end

  def frame_class(*_); end

  def frame_file(*_); end

  def frame_line(*_); end

  def frame_method(*_); end

  def frame_self(*_); end

  def full_location(); end

  def ignored?(); end

  def interrupt(); end

  def line(*args, &block); end

  def location(); end

  def resume(); end

  def stack_size(); end

  def step_into(*_); end

  def step_out(*_); end

  def step_over(*_); end

  def stop_reason(); end

  def suspend(); end

  def suspended?(); end

  def switch(); end

  def thnum(); end

  def thread(); end

  def tracing(); end

  def tracing=(tracing); end
end

class Byebug::Context
  extend ::Byebug::Helpers::PathHelper
  extend ::Forwardable
  def self.ignored_files(); end

  def self.ignored_files=(ignored_files); end

  def self.interface(); end

  def self.interface=(interface); end

  def self.processor(); end

  def self.processor=(processor); end
end

class Byebug::ContinueCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::ContinueCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ControlProcessor
  def commands(); end
end

class Byebug::ControlProcessor
end

class Byebug::DebugCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DebugCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DebugThread
end

class Byebug::DebugThread
end

class Byebug::DeleteCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DeleteCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  include ::Byebug::Subcommands
end

class Byebug::DisableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DisableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DisplayCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::DownCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::DownCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EditCommand
  def execute(); end
end

class Byebug::EditCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  include ::Byebug::Subcommands
end

class Byebug::EnableCommand::BreakpointsCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand::DisplayCommand
  include ::Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::EnableCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::EnableCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FinishCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FinishCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Frame
  include ::Byebug::Helpers::FileHelper
  def _binding(); end

  def _class(); end

  def _method(); end

  def _self(); end

  def args(); end

  def c_frame?(); end

  def current?(); end

  def deco_args(); end

  def deco_block(); end

  def deco_call(); end

  def deco_class(); end

  def deco_file(); end

  def deco_method(); end

  def deco_pos(); end

  def file(); end

  def initialize(context, pos); end

  def line(); end

  def locals(); end

  def mark(); end

  def pos(); end

  def to_hash(); end
end

class Byebug::Frame
end

class Byebug::FrameCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::FrameCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::FullpathSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::FullpathSetting
end

class Byebug::HelpCommand
  def execute(); end
end

class Byebug::HelpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Helpers
end

module Byebug::Helpers::BinHelper
  def executable_file_extensions(); end

  def find_executable(path, cmd); end

  def real_executable?(file); end

  def search_paths(); end

  def which(cmd); end
end

module Byebug::Helpers::BinHelper
  extend ::T::Sig
end

module Byebug::Helpers::EvalHelper
  def error_eval(str, binding=T.unsafe(nil)); end

  def multiple_thread_eval(expression); end

  def separate_thread_eval(expression); end

  def silent_eval(str, binding=T.unsafe(nil)); end

  def warning_eval(str, binding=T.unsafe(nil)); end
end

module Byebug::Helpers::EvalHelper
  extend ::T::Sig
end

module Byebug::Helpers::FileHelper
  def get_line(filename, lineno); end

  def get_lines(filename); end

  def n_lines(filename); end

  def normalize(filename); end

  def shortpath(fullpath); end

  def virtual_file?(name); end
end

module Byebug::Helpers::FileHelper
  extend ::T::Sig
end

module Byebug::Helpers::FrameHelper
  def jump_frames(steps); end

  def switch_to_frame(frame); end
end

module Byebug::Helpers::FrameHelper
  extend ::T::Sig
end

module Byebug::Helpers::ParseHelper
  def get_int(str, cmd, min=T.unsafe(nil), max=T.unsafe(nil)); end

  def parse_steps(str, cmd); end

  def syntax_valid?(code); end
end

module Byebug::Helpers::ParseHelper
  extend ::T::Sig
end

module Byebug::Helpers::PathHelper
  def all_files(); end

  def bin_file(); end

  def gem_files(); end

  def lib_files(); end

  def root_path(); end

  def test_files(); end
end

module Byebug::Helpers::PathHelper
  extend ::T::Sig
end

module Byebug::Helpers::ReflectionHelper
  def commands(); end
end

module Byebug::Helpers::ReflectionHelper
  extend ::T::Sig
end

module Byebug::Helpers::StringHelper
  def camelize(str); end

  def deindent(str, leading_spaces: T.unsafe(nil)); end

  def prettify(str); end
end

module Byebug::Helpers::StringHelper
  extend ::T::Sig
end

module Byebug::Helpers::ThreadHelper
  def context_from_thread(thnum); end

  def current_thread?(ctx); end

  def display_context(ctx); end

  def thread_arguments(ctx); end
end

module Byebug::Helpers::ThreadHelper
  extend ::T::Sig
end

module Byebug::Helpers::ToggleHelper
  include ::Byebug::Helpers::ParseHelper
  def enable_disable_breakpoints(is_enable, args); end

  def enable_disable_display(is_enable, args); end
end

module Byebug::Helpers::ToggleHelper
  extend ::T::Sig
end

module Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def var_args(); end

  def var_global(); end

  def var_instance(str); end

  def var_list(ary, binding=T.unsafe(nil)); end

  def var_local(); end
end

module Byebug::Helpers::VarHelper
  extend ::T::Sig
end

module Byebug::Helpers
  extend ::T::Sig
end

class Byebug::HistfileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistfileSetting
end

class Byebug::History
  def buffer(); end

  def clear(); end

  def default_max_size(); end

  def ignore?(buf); end

  def last_ids(number); end

  def pop(); end

  def push(cmd); end

  def restore(); end

  def save(); end

  def size(); end

  def size=(size); end

  def specific_max_size(number); end

  def to_s(n_cmds); end
end

class Byebug::History
end

class Byebug::HistoryCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::HistoryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::HistsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::HistsizeSetting
end

class Byebug::InfoCommand
  include ::Byebug::Subcommands
end

class Byebug::InfoCommand::BreakpointsCommand
  def execute(); end
end

class Byebug::InfoCommand::BreakpointsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::DisplayCommand
  def execute(); end
end

class Byebug::InfoCommand::DisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::FileCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::StringHelper
  def execute(); end
end

class Byebug::InfoCommand::FileCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::LineCommand
  def execute(); end
end

class Byebug::InfoCommand::LineCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand::ProgramCommand
  def execute(); end
end

class Byebug::InfoCommand::ProgramCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::InfoCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Interface
  include ::Byebug::Helpers::FileHelper
  def autorestore(); end

  def autosave(); end

  def close(); end

  def command_queue(); end

  def command_queue=(command_queue); end

  def confirm(prompt); end

  def errmsg(message); end

  def error(); end

  def history(); end

  def history=(history); end

  def input(); end

  def last_if_empty(input); end

  def output(); end

  def prepare_input(prompt); end

  def print(message); end

  def puts(message); end

  def read_command(prompt); end

  def read_file(filename); end

  def read_input(prompt, save_hist=T.unsafe(nil)); end
end

class Byebug::Interface
end

class Byebug::InterruptCommand
  def execute(); end
end

class Byebug::InterruptCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::IrbCommand
  def execute(); end
end

class Byebug::IrbCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::KillCommand
  def execute(); end
end

class Byebug::KillCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::LinetraceSetting
  def banner(); end

  def value=(val); end
end

class Byebug::LinetraceSetting
end

class Byebug::ListCommand
  include ::Byebug::Helpers::FileHelper
  include ::Byebug::Helpers::ParseHelper
  def amend_final(*args, &block); end

  def execute(); end

  def max_line(*args, &block); end

  def size(*args, &block); end
end

class Byebug::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ListsizeSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::ListsizeSetting
end

class Byebug::LocalInterface
  def readline(prompt); end

  def with_repl_like_sigint(); end
  EOF_ALIAS = ::T.let(nil, ::T.untyped)
end

class Byebug::LocalInterface
end

class Byebug::MethodCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::MethodCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::NextCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::NextCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::PostMortemProcessor
  def commands(); end
end

class Byebug::PostMortemProcessor
end

class Byebug::PostMortemSetting
  def banner(); end

  def value=(val); end
end

class Byebug::PostMortemSetting
end

module Byebug::Printers
end

class Byebug::Printers::Base
  def type(); end
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedArgument
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base::MissedPath
end

class Byebug::Printers::Base
end

class Byebug::Printers::Plain
  def print(path, args=T.unsafe(nil)); end

  def print_collection(path, collection, &block); end

  def print_variables(variables, *_unused); end
end

class Byebug::Printers::Plain
end

module Byebug::Printers
  extend ::T::Sig
end

class Byebug::PryCommand
  def execute(); end
end

class Byebug::PryCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::QuitCommand
  def execute(); end
end

class Byebug::QuitCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Remote
end

class Byebug::Remote::Client
  def initialize(interface); end

  def interface(); end

  def socket(); end

  def start(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def started?(); end
end

class Byebug::Remote::Client
end

class Byebug::Remote::Server
  def actual_port(); end

  def initialize(wait_connection:, &block); end

  def start(host, port); end

  def wait_connection(); end
end

class Byebug::Remote::Server
end

module Byebug::Remote
  extend ::T::Sig
end

class Byebug::RemoteInterface
  def initialize(socket); end

  def readline(prompt); end
end

class Byebug::RemoteInterface
end

class Byebug::RestartCommand
  include ::Byebug::Helpers::BinHelper
  include ::Byebug::Helpers::PathHelper
  def execute(); end
end

class Byebug::RestartCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SaveCommand
  def execute(); end
end

class Byebug::SaveCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SavefileSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::SavefileSetting
end

class Byebug::ScriptInterface
  def initialize(file, verbose=T.unsafe(nil)); end
end

class Byebug::ScriptInterface
end

class Byebug::ScriptProcessor
  def commands(); end
end

class Byebug::ScriptProcessor
end

class Byebug::SetCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::SetCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::Setting
  def boolean?(); end

  def help(); end

  def integer?(); end

  def to_sym(); end

  def value(); end

  def value=(value); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::Setting
  def self.[](name); end

  def self.[]=(name, value); end

  def self.find(shortcut); end

  def self.help_all(); end

  def self.settings(); end
end

class Byebug::ShowCommand
  def execute(); end
end

class Byebug::ShowCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceCommand
  def execute(); end
end

class Byebug::SourceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::SourceFileFormatter
  include ::Byebug::Helpers::FileHelper
  def amend(line, ceiling); end

  def amend_final(line); end

  def amend_initial(line); end

  def annotator(); end

  def file(); end

  def initialize(file, annotator); end

  def lines(min, max); end

  def lines_around(center); end

  def max_initial_line(); end

  def max_line(); end

  def range_around(center); end

  def range_from(min); end

  def size(); end
end

class Byebug::SourceFileFormatter
end

class Byebug::StackOnErrorSetting
  def banner(); end
end

class Byebug::StackOnErrorSetting
end

class Byebug::StepCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::StepCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

module Byebug::Subcommands
  def execute(); end

  def subcommand_list(*args, &block); end
end

module Byebug::Subcommands::ClassMethods
  include ::Byebug::Helpers::ReflectionHelper
  def help(); end

  def subcommand_list(); end
end

module Byebug::Subcommands::ClassMethods
  extend ::T::Sig
end

module Byebug::Subcommands
  extend ::Forwardable
  extend ::T::Sig
  def self.included(command); end
end

class Byebug::ThreadCommand
  include ::Byebug::Subcommands
end

class Byebug::ThreadCommand::CurrentCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::CurrentCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ListCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ListCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::ResumeCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::ResumeCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::StopCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::StopCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand::SwitchCommand
  include ::Byebug::Helpers::ThreadHelper
  def execute(); end
end

class Byebug::ThreadCommand::SwitchCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::ThreadsTable
end

class Byebug::ThreadsTable
end

class Byebug::TracevarCommand
  def execute(); end
end

class Byebug::TracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UndisplayCommand
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UndisplayCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UntracevarCommand
  def execute(); end
end

class Byebug::UntracevarCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::UpCommand
  include ::Byebug::Helpers::FrameHelper
  include ::Byebug::Helpers::ParseHelper
  def execute(); end
end

class Byebug::UpCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  include ::Byebug::Subcommands
end

class Byebug::VarCommand::AllCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::AllCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ArgsCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ArgsCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::ConstCommand
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::ConstCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::GlobalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::GlobalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::InstanceCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::InstanceCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand::LocalCommand
  include ::Byebug::Helpers::VarHelper
  include ::Byebug::Helpers::EvalHelper
  def execute(); end
end

class Byebug::VarCommand::LocalCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::VarCommand
  extend ::Byebug::Subcommands::ClassMethods
  extend ::Byebug::Helpers::ReflectionHelper
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WhereCommand
  include ::Byebug::Helpers::FrameHelper
  def execute(); end
end

class Byebug::WhereCommand
  def self.description(); end

  def self.regexp(); end

  def self.short_description(); end
end

class Byebug::WidthSetting
  def banner(); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Byebug::WidthSetting
end

module Byebug
  extend ::Byebug
  extend ::Byebug::Helpers::ReflectionHelper
  extend ::T::Sig
  def self.actual_control_port(); end

  def self.actual_port(); end

  def self.attach(); end

  def self.handle_post_mortem(); end

  def self.interrupt(); end

  def self.load_settings(); end

  def self.parse_host_and_port(host_port_spec); end

  def self.spawn(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_client(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_control(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.start_server(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def self.wait_connection(); end

  def self.wait_connection=(wait_connection); end
end

class CGI
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class CGI::Cookie
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class CGI::Cookie
  extend ::T::Sig
end

module CGI::Escape
  extend ::T::Sig
end

module CGI::HtmlExtension
  def a(href=T.unsafe(nil)); end

  def base(href=T.unsafe(nil)); end

  def blockquote(cite=T.unsafe(nil)); end

  def caption(align=T.unsafe(nil)); end

  def checkbox(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def checkbox_group(name=T.unsafe(nil), *values); end

  def file_field(name=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def form(method=T.unsafe(nil), action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def hidden(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def html(attributes=T.unsafe(nil)); end

  def image_button(src=T.unsafe(nil), name=T.unsafe(nil), alt=T.unsafe(nil)); end

  def img(src=T.unsafe(nil), alt=T.unsafe(nil), width=T.unsafe(nil), height=T.unsafe(nil)); end

  def multipart_form(action=T.unsafe(nil), enctype=T.unsafe(nil)); end

  def password_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def popup_menu(name=T.unsafe(nil), *values); end

  def radio_button(name=T.unsafe(nil), value=T.unsafe(nil), checked=T.unsafe(nil)); end

  def radio_group(name=T.unsafe(nil), *values); end

  def reset(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def scrolling_list(name=T.unsafe(nil), *values); end

  def submit(value=T.unsafe(nil), name=T.unsafe(nil)); end

  def text_field(name=T.unsafe(nil), value=T.unsafe(nil), size=T.unsafe(nil), maxlength=T.unsafe(nil)); end

  def textarea(name=T.unsafe(nil), cols=T.unsafe(nil), rows=T.unsafe(nil)); end
end

module CGI::HtmlExtension
  extend ::T::Sig
end

class CGI::InvalidEncoding
  extend ::T::Sig
end

module CGI::QueryExtension
  extend ::T::Sig
end

module CGI::Util
  extend ::T::Sig
end

class CGI
  extend ::T::Sig
end

module CLAide
  VERSION = ::T.let(nil, ::T.untyped)
end

class CLAide::ANSI
  COLORS = ::T.let(nil, ::T.untyped)
  DEFAULT_BACKGROUND_COLOR = ::T.let(nil, ::T.untyped)
  DEFAULT_FOREGROUND_COLOR = ::T.let(nil, ::T.untyped)
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
  TEXT_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  TEXT_DISABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

module CLAide::ANSI::Cursor
end

module CLAide::ANSI::Cursor
  extend ::T::Sig
  def self.erase_display(); end

  def self.erase_line(); end

  def self.move_cursor(lines, columns=T.unsafe(nil)); end

  def self.restore_cursor_position(); end

  def self.save_cursor_position(); end

  def self.set_cursor_position(line=T.unsafe(nil), column=T.unsafe(nil)); end
end

module CLAide::ANSI::Graphics
end

module CLAide::ANSI::Graphics
  extend ::T::Sig
  def self.background_color(key); end

  def self.background_color_256(color); end

  def self.foreground_color(key); end

  def self.foreground_color_256(color); end

  def self.graphics_mode(codes); end

  def self.text_attribute(key); end
end

class CLAide::ANSI::StringEscaper
  def apply(*keys); end

  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def cyan(); end

  def green(); end

  def hidden(); end

  def initialize(string); end

  def magenta(); end

  def on_black(); end

  def on_blue(); end

  def on_cyan(); end

  def on_green(); end

  def on_magenta(); end

  def on_red(); end

  def on_white(); end

  def on_yellow(); end

  def red(); end

  def underline(); end

  def white(); end

  def wrap_in_ansi_sequence(open, close); end

  def yellow(); end
end

class CLAide::ANSI::StringEscaper
end

class CLAide::ANSI
  extend ::CLAide::ANSI::Cursor
  extend ::CLAide::ANSI::Graphics
  def self.code_for_key(key, map); end

  def self.disabled(); end

  def self.disabled=(disabled); end
end

class CLAide::ARGV
  def all_options(name); end

  def arguments(); end

  def arguments!(); end

  def empty?(); end

  def flag?(name, default=T.unsafe(nil)); end

  def initialize(argv); end

  def option(name, default=T.unsafe(nil)); end

  def options(); end

  def remainder(); end

  def remainder!(); end

  def shift_argument(); end
end

module CLAide::ARGV::Parser
end

module CLAide::ARGV::Parser
  extend ::T::Sig
  def self.argument_type(argument); end

  def self.parse(argv); end

  def self.parse_argument(type, argument); end

  def self.parse_flag(argument); end
end

class CLAide::ARGV
  def self.coerce(argv); end
end

class CLAide::Argument
  def ==(other); end

  def initialize(names, required, repeatable=T.unsafe(nil)); end

  def names(); end

  def repeatable(); end

  def repeatable=(repeatable); end

  def repeatable?(); end

  def required(); end

  def required=(required); end

  def required?(); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
end

class CLAide::Argument
end

class CLAide::Command
  def ansi_output(); end

  def ansi_output=(ansi_output); end

  def ansi_output?(); end

  def banner!(); end

  def handle_root_options(argv); end

  def help!(error_message=T.unsafe(nil)); end

  def initialize(argv); end

  def invoked_as_default(); end

  def invoked_as_default=(invoked_as_default); end

  def invoked_as_default?(); end

  def invoked_command_class(); end

  def print_version(); end

  def run(); end

  def validate!(); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_ROOT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class CLAide::Command::ArgumentSuggester
  def initialize(argument, command_class); end

  def possibilities(); end

  def suggested_argument(); end

  def suggestion(); end
end

class CLAide::Command::ArgumentSuggester
  def self.levenshtein_distance(a, b); end

  def self.prettify_suggestion(suggestion, argument_type); end
end

class CLAide::Command::Banner
  def command(); end

  def command=(command); end

  def formatted_banner(); end

  def initialize(command); end
  DESCRIPTION_SPACES = ::T.let(nil, ::T.untyped)
  MAX_WIDTH = ::T.let(nil, ::T.untyped)
  SUBCOMMAND_BULLET_SIZE = ::T.let(nil, ::T.untyped)
  TEXT_INDENT = ::T.let(nil, ::T.untyped)
end

module CLAide::Command::Banner::TextWrapper
end

module CLAide::Command::Banner::TextWrapper
  extend ::T::Sig
  def self.strip_heredoc(string); end

  def self.terminal_width(); end

  def self.word_wrap(line, line_width); end

  def self.wrap_formatted_text(string, indent=T.unsafe(nil), max_width=T.unsafe(nil)); end

  def self.wrap_with_indent(string, indent=T.unsafe(nil), max_width=T.unsafe(nil)); end
end

class CLAide::Command::Banner
end

module CLAide::Command::GemHelper
end

module CLAide::Command::GemHelper
  extend ::T::Sig
  def self.cache(); end

  def self.colorize_versions(versions); end

  def self.download_and_cache_specs(); end

  def self.gem_installed?(gem_name, version_string=T.unsafe(nil)); end

  def self.installed_version(gem_name); end

  def self.versions_string(plugin_name, index_cache=T.unsafe(nil)); end
end

class CLAide::Command::GemIndexCache
  def download_and_cache_specs(); end

  def specs(); end

  def specs_with_name(name); end
end

class CLAide::Command::GemIndexCache
end

class CLAide::Command::PluginManager
end

class CLAide::Command::PluginManager
  def self.installed_specifications_for_prefix(plugin_prefix); end

  def self.load_plugins(plugin_prefix); end

  def self.loaded_plugins(); end

  def self.plugin_gems_for_prefix(prefix); end

  def self.plugins_involved_in_exception(exception); end

  def self.safe_activate_and_require(spec, paths); end

  def self.specifications(); end
end

class CLAide::Command::Plugins
end

class CLAide::Command::Plugins::Create
end

class CLAide::Command::Plugins::Create
end

class CLAide::Command::Plugins::List
end

class CLAide::Command::Plugins::List
end

class CLAide::Command::Plugins::Search
end

class CLAide::Command::Plugins::Search
end

class CLAide::Command::Plugins
end

module CLAide::Command::PluginsHelper
end

module CLAide::Command::PluginsHelper
  extend ::T::Sig
  def self.download_json(); end

  def self.known_plugins(); end

  def self.matching_plugins(query, full_text_search); end

  def self.parse_json(json_str); end

  def self.plugin_prefix(); end

  def self.plugin_title(plugin); end

  def self.plugins_raw_url(); end

  def self.print_plugin(plugin, verbose=T.unsafe(nil)); end

  def self.print_verbose_plugin(plugin, ljust); end
end

class CLAide::Command
  def self.abstract_command(); end

  def self.abstract_command=(abstract_command); end

  def self.abstract_command?(); end

  def self.ansi_output(); end

  def self.ansi_output=(ansi_output); end

  def self.ansi_output?(); end

  def self.arguments(); end

  def self.arguments=(arguments); end

  def self.arguments_array=(arguments); end

  def self.arguments_string=(arguments); end

  def self.banner(banner_class=T.unsafe(nil)); end

  def self.banner!(); end

  def self.command(); end

  def self.command=(command); end

  def self.default_subcommand(); end

  def self.default_subcommand=(default_subcommand); end

  def self.description(); end

  def self.description=(description); end

  def self.find_subcommand(name); end

  def self.full_command(); end

  def self.handle_exception(command, exception); end

  def self.help!(error_message=T.unsafe(nil), help_class=T.unsafe(nil)); end

  def self.ignore_in_command_lookup(); end

  def self.ignore_in_command_lookup=(flag); end

  def self.ignore_in_command_lookup?(); end

  def self.inherited(subcommand); end

  def self.invoke(*args); end

  def self.load_default_subcommand(argv); end

  def self.options(); end

  def self.parse(argv); end

  def self.plugin_prefix=(prefix); end

  def self.plugin_prefixes(); end

  def self.plugin_prefixes=(plugin_prefixes); end

  def self.report_error(exception); end

  def self.root_command?(); end

  def self.run(argv=T.unsafe(nil)); end

  def self.subcommands(); end

  def self.subcommands_for_command_lookup(); end

  def self.summary(); end

  def self.summary=(summary); end

  def self.version(); end

  def self.version=(version); end
end

module CLAide::Executable
  def executable(name); end
end

class CLAide::Executable::Indenter
  def <<(value); end

  def indent(); end

  def indent=(indent); end

  def initialize(io=T.unsafe(nil)); end

  def io(); end

  def io=(io); end
end

class CLAide::Executable::Indenter
end

module CLAide::Executable
  extend ::T::Sig
  def self.execute_command(exe, command, raise_on_failure); end
end

class CLAide::Help
  include ::CLAide::InformativeError
  def banner(); end

  def error_message(); end

  def formatted_error_message(); end

  def initialize(banner, error_message=T.unsafe(nil)); end

  def prettify_error_message(message); end
end

class CLAide::Help
end

class CLAide::Informative
end

class CLAide::Informative
end

module CLAide::InformativeError
  def exit_status(); end

  def exit_status=(exit_status); end
end

module CLAide::InformativeError
  extend ::T::Sig
end

class CLAide::PlainInformative
end

class CLAide::PlainInformative
end

module CLAide::Plugins
end

class CLAide::Plugins::Configuration
  def initialize(name=T.unsafe(nil), plugin_prefix=T.unsafe(nil), plugin_list_url=T.unsafe(nil), plugin_template_url=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def plugin_list_url(); end

  def plugin_list_url=(plugin_list_url); end

  def plugin_prefix(); end

  def plugin_prefix=(plugin_prefix); end

  def plugin_template_url(); end

  def plugin_template_url=(plugin_template_url); end
end

class CLAide::Plugins::Configuration
end

module CLAide::Plugins
  extend ::T::Sig
  def self.config(); end

  def self.config=(config); end
end

class CLAide::TemplateRunner
  def clone_template(); end

  def configure_template(); end

  def git(*command); end

  def git!(*command); end

  def initialize(name, template_url); end

  def template_repo_url(); end
end

class CLAide::TemplateRunner
  extend ::CLAide::Executable
end

module CLAide
  extend ::T::Sig
end

class CSV
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(row); end

  def add_row(row); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def col_sep(); end

  def convert(name=T.unsafe(nil), &converter); end

  def converters(); end

  def each(); end

  def encoding(); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def field_size_limit(); end

  def fileno(*args, &block); end

  def flock(*args, &block); end

  def flush(*args, &block); end

  def force_quotes?(); end

  def fsync(*args, &block); end

  def gets(); end

  def header_convert(name=T.unsafe(nil), &converter); end

  def header_converters(); end

  def header_row?(); end

  def headers(); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def isatty(*args, &block); end

  def liberal_parsing?(); end

  def line(); end

  def lineno(); end

  def path(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def puts(row); end

  def quote_char(); end

  def readlines(); end

  def reopen(*args, &block); end

  def return_headers?(); end

  def rewind(); end

  def row_sep(); end

  def seek(*args, &block); end

  def shift(); end

  def skip_blanks?(); end

  def skip_lines(); end

  def stat(*args, &block); end

  def string(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def truncate(*args, &block); end

  def tty?(*args, &block); end

  def unconverted_fields?(); end

  def write_headers?(); end
  ConverterEncoding = ::T.let(nil, ::T.untyped)
  Converters = ::T.let(nil, ::T.untyped)
  DateMatcher = ::T.let(nil, ::T.untyped)
  DateTimeMatcher = ::T.let(nil, ::T.untyped)
  HeaderConverters = ::T.let(nil, ::T.untyped)
end

class CSV::FieldInfo
  def header(); end

  def header=(_); end

  def index(); end

  def index=(_); end

  def line(); end

  def line=(_); end
end

class CSV::FieldInfo
  extend ::T::Sig
  def self.[](*_); end

  def self.members(); end
end

class CSV::MalformedCSVError
  extend ::T::Sig
end

class CSV::Row
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(arg); end

  def ==(other); end

  def [](header_or_index, minimum_index=T.unsafe(nil)); end

  def []=(*args); end

  def delete(header_or_index, minimum_index=T.unsafe(nil)); end

  def delete_if(&block); end

  def each(&block); end

  def empty?(*args, &block); end

  def fetch(header, *varargs); end

  def field(header_or_index, minimum_index=T.unsafe(nil)); end

  def field?(data); end

  def field_row?(); end

  def fields(*headers_and_or_indices); end

  def has_key?(header); end

  def header?(name); end

  def header_row?(); end

  def headers(); end

  def include?(name); end

  def index(header, minimum_index=T.unsafe(nil)); end

  def initialize(headers, fields, header_row=T.unsafe(nil)); end

  def key?(header); end

  def length(*args, &block); end

  def member?(header); end

  def push(*args); end

  def row(); end

  def size(*args, &block); end

  def to_csv(**options); end

  def to_hash(); end

  def to_s(**options); end

  def values_at(*headers_and_or_indices); end
end

class CSV::Row
  extend ::T::Sig
  extend ::Forwardable
end

class CSV::Table
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(row_or_array); end

  def ==(other); end

  def [](index_or_header); end

  def []=(index_or_header, value); end

  def by_col(); end

  def by_col!(); end

  def by_col_or_row(); end

  def by_col_or_row!(); end

  def by_row(); end

  def by_row!(); end

  def delete(index_or_header); end

  def delete_if(&block); end

  def each(&block); end

  def empty?(*args, &block); end

  def headers(); end

  def initialize(array_of_rows); end

  def length(*args, &block); end

  def mode(); end

  def push(*rows); end

  def size(*args, &block); end

  def table(); end

  def to_a(); end

  def to_csv(write_headers: T.unsafe(nil), **options); end

  def to_s(write_headers: T.unsafe(nil), **options); end

  def values_at(*indices_or_headers); end
end

class CSV::Table
  extend ::T::Sig
  extend ::Forwardable
end

class CSV
  extend ::T::Sig
  extend ::Forwardable
  def self.filter(input=T.unsafe(nil), output=T.unsafe(nil), **options); end

  def self.generate(str=T.unsafe(nil), **options); end

  def self.generate_line(row, **options); end

  def self.instance(data=T.unsafe(nil), **options); end

  def self.open(filename, mode=T.unsafe(nil), **options); end

  def self.readlines(*args); end

  def self.table(path, **options); end
end

module CanCan
end

module CanCan::Ability
  def alias_action(*args); end

  def aliased_actions(); end

  def attributes_for(action, subject); end

  def authorize!(action, subject, *args); end

  def can(action=T.unsafe(nil), subject=T.unsafe(nil), conditions=T.unsafe(nil), &block); end

  def can?(action, subject, *extra_args); end

  def cannot(action=T.unsafe(nil), subject=T.unsafe(nil), conditions=T.unsafe(nil), &block); end

  def cannot?(*args); end

  def clear_aliased_actions(); end

  def has_block?(action, subject); end

  def has_raw_sql?(action, subject); end

  def merge(ability); end

  def model_adapter(model_class, action); end

  def unauthorized_message(action, subject); end

  def validate_target(target); end
end

module CanCan::Ability
  extend ::T::Sig
end

class CanCan::AccessDenied
  def action(); end

  def default_message=(default_message); end

  def initialize(message=T.unsafe(nil), action=T.unsafe(nil), subject=T.unsafe(nil)); end

  def subject(); end
end

class CanCan::AccessDenied
end

class CanCan::AuthorizationNotPerformed
end

class CanCan::AuthorizationNotPerformed
end

module CanCan::ControllerAdditions
  def authorize!(*args); end

  def can?(*args); end

  def cannot?(*args); end

  def current_ability(); end

  def unauthorized!(message=T.unsafe(nil)); end
end

module CanCan::ControllerAdditions
  extend ::T::Sig
  def self.included(base); end
end

class CanCan::ControllerResource
  def adapter(); end

  def assign_attributes(resource); end

  def authorization_action(); end

  def authorize_resource(); end

  def build_resource(); end

  def collection_actions(); end

  def collection_instance(); end

  def collection_instance=(instance); end

  def current_ability(); end

  def fetch_parent(name); end

  def find_resource(); end

  def id_param(); end

  def initial_attributes(); end

  def initialize(controller, *args); end

  def instance_name(); end

  def load_and_authorize_resource(); end

  def load_collection(); end

  def load_collection?(); end

  def load_instance?(); end

  def load_resource(); end

  def load_resource_instance(); end

  def member_action?(); end

  def name(); end

  def name_from_controller(); end

  def namespace(); end

  def namespaced_name(); end

  def new_actions(); end

  def parent?(); end

  def parent_name(); end

  def parent_resource(); end

  def resource_base(); end

  def resource_class(); end

  def resource_class_with_parent(); end

  def resource_instance(); end

  def resource_instance=(instance); end

  def resource_params(); end

  def resource_params_by_namespaced_name(); end

  def skip?(behavior); end
end

class CanCan::ControllerResource
  def self.add_before_filter(controller_class, method, *args); end
end

class CanCan::Error
end

class CanCan::Error
end

class CanCan::ImplementationRemoved
end

class CanCan::ImplementationRemoved
end

class CanCan::InheritedResource
end

class CanCan::InheritedResource
end

module CanCan::ModelAdapters
end

class CanCan::ModelAdapters::AbstractAdapter
  def database_records(); end

  def initialize(model_class, rules); end
end

class CanCan::ModelAdapters::AbstractAdapter
  def self.adapter_class(model_class); end

  def self.find(model_class, id); end

  def self.for_class?(member_class); end

  def self.inherited(subclass); end

  def self.matches_condition?(subject, name, value); end

  def self.matches_conditions_hash?(subject, conditions); end

  def self.override_condition_matching?(subject, name, value); end

  def self.override_conditions_hash_matching?(subject, conditions); end
end

class CanCan::ModelAdapters::ActiveRecordAdapter
  def conditions(); end

  def joins(); end

  def tableized_conditions(conditions, model_class=T.unsafe(nil)); end
end

class CanCan::ModelAdapters::ActiveRecordAdapter
  def self.for_class?(model_class); end

  def self.meta_where_match?(subject_value, method, value); end
end

class CanCan::ModelAdapters::DefaultAdapter
end

class CanCan::ModelAdapters::DefaultAdapter
end

module CanCan::ModelAdapters
  extend ::T::Sig
end

module CanCan::ModelAdditions
end

module CanCan::ModelAdditions
  extend ::T::Sig
  def self.included(base); end
end

class CanCan::NotImplemented
end

class CanCan::NotImplemented
end

class CanCan::Rule
  def actions(); end

  def associations_hash(conditions=T.unsafe(nil)); end

  def attributes_from_conditions(); end

  def base_behavior(); end

  def conditions(); end

  def conditions_empty?(); end

  def expanded_actions=(expanded_actions); end

  def initialize(base_behavior, action, subject, conditions, block); end

  def matches_conditions?(action, subject, extra_args); end

  def only_block?(); end

  def only_raw_sql?(); end

  def relevant?(action, subject); end

  def subjects(); end

  def unmergeable?(); end
end

class CanCan::Rule
end

module CanCan
  extend ::T::Sig
end

module Capybara
  VERSION = ::T.let(nil, ::T.untyped)
end

class Capybara::Ambiguous
end

class Capybara::Ambiguous
end

class Capybara::CapybaraError
end

class Capybara::CapybaraError
end

class Capybara::Config
  def always_include_port(*args, &block); end

  def always_include_port=(*args, &block); end

  def app(); end

  def app=(app); end

  def app_host(*args, &block); end

  def app_host=(*args, &block); end

  def asset_host(*args, &block); end

  def asset_host=(*args, &block); end

  def automatic_label_click(*args, &block); end

  def automatic_label_click=(*args, &block); end

  def automatic_reload(*args, &block); end

  def automatic_reload=(*args, &block); end

  def default_driver(); end

  def default_driver=(default_driver); end

  def default_host(*args, &block); end

  def default_host=(*args, &block); end

  def default_max_wait_time(*args, &block); end

  def default_max_wait_time=(*args, &block); end

  def default_normalize_ws(*args, &block); end

  def default_normalize_ws=(*args, &block); end

  def default_selector(*args, &block); end

  def default_selector=(*args, &block); end

  def default_set_options(*args, &block); end

  def default_set_options=(*args, &block); end

  def deprecate(method, alternate_method, once=T.unsafe(nil)); end

  def disable_animation(*args, &block); end

  def disable_animation=(*args, &block); end

  def enable_aria_label(*args, &block); end

  def enable_aria_label=(*args, &block); end

  def exact(*args, &block); end

  def exact=(*args, &block); end

  def exact_text(*args, &block); end

  def exact_text=(*args, &block); end

  def ignore_hidden_elements(*args, &block); end

  def ignore_hidden_elements=(*args, &block); end

  def javascript_driver(); end

  def javascript_driver=(javascript_driver); end

  def match(*args, &block); end

  def match=(*args, &block); end

  def predicates_wait(*args, &block); end

  def predicates_wait=(*args, &block); end

  def raise_server_errors(*args, &block); end

  def raise_server_errors=(*args, &block); end

  def reuse_server(); end

  def reuse_server=(reuse_server); end

  def run_server(*args, &block); end

  def run_server=(*args, &block); end

  def save_path(*args, &block); end

  def save_path=(*args, &block); end

  def server(); end

  def server=(name); end

  def server_errors(*args, &block); end

  def server_errors=(*args, &block); end

  def server_host(*args, &block); end

  def server_host=(*args, &block); end

  def server_port(*args, &block); end

  def server_port=(*args, &block); end

  def session_options(); end

  def test_id(*args, &block); end

  def test_id=(*args, &block); end

  def threadsafe(); end

  def threadsafe=(bool); end

  def visible_text_only(*args, &block); end

  def visible_text_only=(*args, &block); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::Config
  extend ::Forwardable
end

module Capybara::DSL
  def accept_alert(*args, &block); end

  def accept_confirm(*args, &block); end

  def accept_prompt(*args, &block); end

  def all(*args, &block); end

  def assert_all_of_selectors(*args, &block); end

  def assert_any_of_selectors(*args, &block); end

  def assert_current_path(*args, &block); end

  def assert_no_current_path(*args, &block); end

  def assert_no_selector(*args, &block); end

  def assert_no_text(*args, &block); end

  def assert_no_title(*args, &block); end

  def assert_none_of_selectors(*args, &block); end

  def assert_selector(*args, &block); end

  def assert_text(*args, &block); end

  def assert_title(*args, &block); end

  def attach_file(*args, &block); end

  def body(*args, &block); end

  def check(*args, &block); end

  def choose(*args, &block); end

  def click_button(*args, &block); end

  def click_link(*args, &block); end

  def click_link_or_button(*args, &block); end

  def click_on(*args, &block); end

  def current_host(*args, &block); end

  def current_path(*args, &block); end

  def current_scope(*args, &block); end

  def current_url(*args, &block); end

  def current_window(*args, &block); end

  def dismiss_confirm(*args, &block); end

  def dismiss_prompt(*args, &block); end

  def evaluate_script(*args, &block); end

  def execute_script(*args, &block); end

  def fill_in(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_button(*args, &block); end

  def find_by_id(*args, &block); end

  def find_field(*args, &block); end

  def find_link(*args, &block); end

  def first(*args, &block); end

  def go_back(*args, &block); end

  def go_forward(*args, &block); end

  def has_button?(*args, &block); end

  def has_checked_field?(*args, &block); end

  def has_content?(*args, &block); end

  def has_css?(*args, &block); end

  def has_current_path?(*args, &block); end

  def has_field?(*args, &block); end

  def has_link?(*args, &block); end

  def has_no_button?(*args, &block); end

  def has_no_checked_field?(*args, &block); end

  def has_no_content?(*args, &block); end

  def has_no_css?(*args, &block); end

  def has_no_current_path?(*args, &block); end

  def has_no_field?(*args, &block); end

  def has_no_link?(*args, &block); end

  def has_no_select?(*args, &block); end

  def has_no_selector?(*args, &block); end

  def has_no_table?(*args, &block); end

  def has_no_text?(*args, &block); end

  def has_no_title?(*args, &block); end

  def has_no_unchecked_field?(*args, &block); end

  def has_no_xpath?(*args, &block); end

  def has_select?(*args, &block); end

  def has_selector?(*args, &block); end

  def has_table?(*args, &block); end

  def has_text?(*args, &block); end

  def has_title?(*args, &block); end

  def has_unchecked_field?(*args, &block); end

  def has_xpath?(*args, &block); end

  def html(*args, &block); end

  def open_new_window(*args, &block); end

  def page(); end

  def query(*args, &block); end

  def refresh(*args, &block); end

  def refute_selector(*args, &block); end

  def reset_session!(*args, &block); end

  def resolve(*args, &block); end

  def response_headers(*args, &block); end

  def save_and_open_page(*args, &block); end

  def save_and_open_screenshot(*args, &block); end

  def save_page(*args, &block); end

  def save_screenshot(*args, &block); end

  def select(*args, &block); end

  def source(*args, &block); end

  def status_code(*args, &block); end

  def switch_to_frame(*args, &block); end

  def switch_to_window(*args, &block); end

  def text(*args, &block); end

  def title(*args, &block); end

  def uncheck(*args, &block); end

  def unselect(*args, &block); end

  def using_session(name_or_session, &block); end

  def using_wait_time(seconds, &block); end

  def visit(*args, &block); end

  def window_opened_by(*args, &block); end

  def windows(*args, &block); end

  def within(*args, &block); end

  def within_element(*args, &block); end

  def within_fieldset(*args, &block); end

  def within_frame(*args, &block); end

  def within_table(*args, &block); end

  def within_window(*args, &block); end
end

module Capybara::DSL
  extend ::T::Sig
  def self.extended(base); end

  def self.included(base); end
end

module Capybara::Driver
end

class Capybara::Driver::Base
  def accept_modal(type, **options, &blk); end

  def close_window(handle); end

  def current_url(); end

  def current_window_handle(); end

  def dismiss_modal(type, **options, &blk); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def find_css(query); end

  def find_xpath(query); end

  def frame_title(); end

  def frame_url(); end

  def fullscreen_window(handle); end

  def go_back(); end

  def go_forward(); end

  def html(); end

  def invalid_element_errors(); end

  def maximize_window(handle); end

  def needs_server?(); end

  def no_such_window_error(); end

  def open_new_window(); end

  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def response_headers(); end

  def save_screenshot(path, **options); end

  def session=(session); end

  def session_options(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(handle); end

  def visit(path); end

  def wait?(); end

  def window_handles(); end

  def window_size(handle); end
end

class Capybara::Driver::Base
end

class Capybara::Driver::Node
  def ==(other); end

  def [](name); end

  def all_text(); end

  def checked?(); end

  def click(keys=T.unsafe(nil), **options); end

  def disabled?(); end

  def double_click(keys=T.unsafe(nil), **options); end

  def drag_to(element); end

  def driver(); end

  def hover(); end

  def initialize(driver, native); end

  def multiple?(); end

  def native(); end

  def path(); end

  def readonly?(); end

  def right_click(keys=T.unsafe(nil), **options); end

  def select_option(); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def style(styles); end

  def tag_name(); end

  def trigger(event); end

  def unselect_option(); end

  def value(); end

  def visible?(); end

  def visible_text(); end
end

class Capybara::Driver::Node
end

module Capybara::Driver
  extend ::T::Sig
end

class Capybara::DriverNotFoundError
end

class Capybara::DriverNotFoundError
end

class Capybara::ElementNotFound
end

class Capybara::ElementNotFound
end

class Capybara::ExpectationNotMet
end

class Capybara::ExpectationNotMet
end

class Capybara::FileNotFound
end

class Capybara::FileNotFound
end

class Capybara::FrozenInTime
end

class Capybara::FrozenInTime
end

module Capybara::Helpers
end

class Capybara::Helpers::Timer
  def expired?(); end

  def initialize(expire_in); end

  def stalled?(); end
end

class Capybara::Helpers::Timer
end

module Capybara::Helpers
  extend ::T::Sig
  def self.declension(singular, plural, count); end

  def self.inject_asset_host(html, host: T.unsafe(nil)); end

  def self.monotonic_time(); end

  def self.normalize_whitespace(text); end

  def self.timer(expire_in:); end

  def self.to_regexp(text, exact: T.unsafe(nil), all_whitespace: T.unsafe(nil), options: T.unsafe(nil)); end
end

class Capybara::InfiniteRedirectError
end

class Capybara::InfiniteRedirectError
end

module Capybara::Minitest
end

module Capybara::Minitest::Assertions
  def assert_all_of_selectors(*args, &optional_filter_block); end

  def assert_any_of_selectors(*args, &optional_filter_block); end

  def assert_button(*args, &optional_filter_block); end

  def assert_checked_field(*args, &optional_filter_block); end

  def assert_content(*args); end

  def assert_css(*args, &optional_filter_block); end

  def assert_current_path(*args); end

  def assert_field(*args, &optional_filter_block); end

  def assert_link(*args, &optional_filter_block); end

  def assert_matches_css(*args, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_matches_xpath(*args, &optional_filter_block); end

  def assert_no_button(*args, &optional_filter_block); end

  def assert_no_checked_field(*args, &optional_filter_block); end

  def assert_no_content(*args); end

  def assert_no_css(*args, &optional_filter_block); end

  def assert_no_current_path(*args); end

  def assert_no_field(*args, &optional_filter_block); end

  def assert_no_link(*args, &optional_filter_block); end

  def assert_no_select(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_table(*args, &optional_filter_block); end

  def assert_no_text(*args); end

  def assert_no_title(*args); end

  def assert_no_unchecked_field(*args, &optional_filter_block); end

  def assert_no_xpath(*args, &optional_filter_block); end

  def assert_none_of_selectors(*args, &optional_filter_block); end

  def assert_not_matches_css(*args, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_not_matches_xpath(*args, &optional_filter_block); end

  def assert_select(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_style(*args, &optional_filter_block); end

  def assert_table(*args, &optional_filter_block); end

  def assert_text(*args); end

  def assert_title(*args); end

  def assert_unchecked_field(*args, &optional_filter_block); end

  def assert_xpath(*args, &optional_filter_block); end

  def refute_button(*args, &optional_filter_block); end

  def refute_checked_field(*args, &optional_filter_block); end

  def refute_content(*args); end

  def refute_css(*args, &optional_filter_block); end

  def refute_current_path(*args); end

  def refute_field(*args, &optional_filter_block); end

  def refute_link(*args, &optional_filter_block); end

  def refute_matches_css(*args, &optional_filter_block); end

  def refute_matches_selector(*args, &optional_filter_block); end

  def refute_matches_xpath(*args, &optional_filter_block); end

  def refute_select(*args, &optional_filter_block); end

  def refute_selector(*args, &optional_filter_block); end

  def refute_table(*args, &optional_filter_block); end

  def refute_text(*args); end

  def refute_title(*args); end

  def refute_unchecked_field(*args, &optional_filter_block); end

  def refute_xpath(*args, &optional_filter_block); end
end

module Capybara::Minitest::Assertions
  extend ::T::Sig
end

module Capybara::Minitest
  extend ::T::Sig
end

class Capybara::ModalNotFound
end

class Capybara::ModalNotFound
end

module Capybara::Node
end

module Capybara::Node::Actions
  def attach_file(locator=T.unsafe(nil), paths, make_visible: T.unsafe(nil), **options); end

  def check(locator=T.unsafe(nil), **options); end

  def choose(locator=T.unsafe(nil), **options); end

  def click_button(locator=T.unsafe(nil), **options); end

  def click_link(locator=T.unsafe(nil), **options); end

  def click_link_or_button(locator=T.unsafe(nil), **options); end

  def click_on(locator=T.unsafe(nil), **options); end

  def fill_in(locator=T.unsafe(nil), with:, currently_with: T.unsafe(nil), fill_options: T.unsafe(nil), **find_options); end

  def select(value=T.unsafe(nil), from: T.unsafe(nil), **options); end

  def uncheck(locator=T.unsafe(nil), **options); end

  def unselect(value=T.unsafe(nil), from: T.unsafe(nil), **options); end
  DATALIST_OPTIONS_SCRIPT = ::T.let(nil, ::T.untyped)
  RESET_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
  UPDATE_STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

module Capybara::Node::Actions
  extend ::T::Sig
end

class Capybara::Node::Base
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Actions
  include ::Capybara::Node::Matchers
  def base(); end

  def catch_error?(error, errors=T.unsafe(nil)); end

  def driver(); end

  def find_css(css); end

  def find_xpath(xpath); end

  def initialize(session, base); end

  def query_scope(); end

  def reload(); end

  def session(); end

  def session_options(); end

  def synchronize(seconds=T.unsafe(nil), errors: T.unsafe(nil)); end

  def to_capybara_node(); end
end

class Capybara::Node::Base
end

class Capybara::Node::Document
  include ::Capybara::Node::DocumentMatchers
  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end
end

class Capybara::Node::Document
end

module Capybara::Node::DocumentMatchers
  def assert_no_title(title, **options); end

  def assert_title(title, **options); end

  def has_no_title?(title, **options); end

  def has_title?(title, **options); end
end

module Capybara::Node::DocumentMatchers
  extend ::T::Sig
end

class Capybara::Node::Element
  def [](attribute); end

  def allow_reload!(); end

  def checked?(); end

  def click(*keys, **offset); end

  def disabled?(); end

  def double_click(*keys, **offset); end

  def drag_to(node); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def hover(); end

  def initialize(session, base, query_scope, query); end

  def multiple?(); end

  def native(); end

  def path(); end

  def readonly?(); end

  def right_click(*keys, **offset); end

  def select_option(); end

  def selected?(); end

  def send_keys(*args); end

  def set(value, **options); end

  def style(*styles); end

  def tag_name(); end

  def text(type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def trigger(event); end

  def unselect_option(); end

  def value(); end

  def visible?(); end
  STYLE_SCRIPT = ::T.let(nil, ::T.untyped)
end

class Capybara::Node::Element
end

module Capybara::Node::Finders
  def all(*args, **options, &optional_filter_block); end

  def ancestor(*args, **options, &optional_filter_block); end

  def find(*args, **options, &optional_filter_block); end

  def find_all(*args, **options, &optional_filter_block); end

  def find_button(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_by_id(id, **options, &optional_filter_block); end

  def find_field(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def find_link(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def first(*args, **options, &optional_filter_block); end

  def sibling(*args, **options, &optional_filter_block); end
end

module Capybara::Node::Finders
  extend ::T::Sig
end

module Capybara::Node::Matchers
  def ==(other); end

  def assert_all_of_selectors(*args, **options, &optional_filter_block); end

  def assert_any_of_selectors(*args, wait: T.unsafe(nil), **options, &optional_filter_block); end

  def assert_matches_selector(*args, &optional_filter_block); end

  def assert_no_selector(*args, &optional_filter_block); end

  def assert_no_text(*args); end

  def assert_none_of_selectors(*args, **options, &optional_filter_block); end

  def assert_not_matches_selector(*args, &optional_filter_block); end

  def assert_selector(*args, &optional_filter_block); end

  def assert_style(styles, **options); end

  def assert_text(*args); end

  def has_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_content?(*args, **options); end

  def has_css?(path, **options, &optional_filter_block); end

  def has_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_button?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_checked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_content?(*args, **options); end

  def has_no_css?(path, **options, &optional_filter_block); end

  def has_no_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_link?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_selector?(*args, **options, &optional_filter_block); end

  def has_no_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_text?(*args, **options); end

  def has_no_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_no_xpath?(path, **options, &optional_filter_block); end

  def has_select?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_selector?(*args, **options, &optional_filter_block); end

  def has_style?(styles, **options); end

  def has_table?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_text?(*args, **options); end

  def has_unchecked_field?(locator=T.unsafe(nil), **options, &optional_filter_block); end

  def has_xpath?(path, **options, &optional_filter_block); end

  def matches_css?(css, **options, &optional_filter_block); end

  def matches_selector?(*args, **options, &optional_filter_block); end

  def matches_xpath?(xpath, **options, &optional_filter_block); end

  def not_matches_css?(css, **options, &optional_filter_block); end

  def not_matches_selector?(*args, **options, &optional_filter_block); end

  def not_matches_xpath?(xpath, **options, &optional_filter_block); end

  def refute_matches_selector(*args, &optional_filter_block); end

  def refute_selector(*args, &optional_filter_block); end
end

module Capybara::Node::Matchers
  extend ::T::Sig
end

class Capybara::Node::Simple
  include ::Capybara::Node::Finders
  include ::Capybara::Node::Matchers
  include ::Capybara::Node::DocumentMatchers
  def [](name); end

  def allow_reload!(); end

  def checked?(); end

  def disabled?(); end

  def find_css(css); end

  def find_xpath(xpath); end

  def initialize(native); end

  def multiple?(); end

  def native(); end

  def path(); end

  def selected?(); end

  def session_options(); end

  def synchronize(_seconds=T.unsafe(nil)); end

  def tag_name(); end

  def text(_type=T.unsafe(nil), normalize_ws: T.unsafe(nil)); end

  def title(); end

  def value(); end

  def visible?(check_ancestors=T.unsafe(nil)); end
end

class Capybara::Node::Simple
end

module Capybara::Node
  extend ::T::Sig
end

class Capybara::NotSupportedByDriverError
end

class Capybara::NotSupportedByDriverError
end

module Capybara::Queries
end

class Capybara::Queries::AncestorQuery
end

class Capybara::Queries::AncestorQuery
end

class Capybara::Queries::BaseQuery
  def expects_none?(); end

  def failure_message(); end

  def initialize(options); end

  def matches_count?(count); end

  def negative_failure_message(); end

  def options(); end

  def session_options(); end

  def session_options=(session_options); end

  def wait(); end
  COUNT_KEYS = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::BaseQuery
  def self.wait(options, default=T.unsafe(nil)); end
end

class Capybara::Queries::CurrentPathQuery
  def initialize(expected_path, **options); end

  def resolves_for?(session); end
end

class Capybara::Queries::CurrentPathQuery
end

class Capybara::Queries::MatchQuery
end

class Capybara::Queries::MatchQuery
end

class Capybara::Queries::SelectorQuery
  def applied_description(); end

  def css(); end

  def description(applied=T.unsafe(nil)); end

  def exact?(); end

  def expression(); end

  def initialize(*args, session_options:, enable_aria_label: T.unsafe(nil), test_id: T.unsafe(nil), **options, &filter_block); end

  def label(); end

  def locator(); end

  def match(); end

  def matches_filters?(node); end

  def name(); end

  def resolve_for(node, exact=T.unsafe(nil)); end

  def selector(); end

  def supports_exact?(); end

  def visible(); end

  def xpath(exact=T.unsafe(nil)); end
  VALID_KEYS = ::T.let(nil, ::T.untyped)
  VALID_MATCH = ::T.let(nil, ::T.untyped)
end

class Capybara::Queries::SelectorQuery
end

class Capybara::Queries::SiblingQuery
end

class Capybara::Queries::SiblingQuery
end

class Capybara::Queries::StyleQuery
  def initialize(expected_styles, session_options:, **options); end

  def resolves_for?(node); end
end

class Capybara::Queries::StyleQuery
end

class Capybara::Queries::TextQuery
  def description(); end

  def initialize(type=T.unsafe(nil), expected_text, session_options:, **options); end

  def resolve_for(node); end
end

class Capybara::Queries::TextQuery
end

class Capybara::Queries::TitleQuery
  def initialize(expected_title, **options); end

  def resolves_for?(node); end
end

class Capybara::Queries::TitleQuery
end

module Capybara::Queries
  extend ::T::Sig
end

module Capybara::RackTest
end

class Capybara::RackTest::Browser
  include ::Rack::Test::Methods
  def app(); end

  def build_uri(path); end

  def current_host(); end

  def current_host=(current_host); end

  def current_url(); end

  def dom(); end

  def driver(); end

  def find(format, selector); end

  def follow(method, path, **attributes); end

  def html(); end

  def initialize(driver); end

  def options(); end

  def process(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def process_and_follow_redirects(method, path, attributes=T.unsafe(nil), env=T.unsafe(nil)); end

  def refresh(); end

  def request_path(); end

  def reset_cache!(); end

  def reset_host!(); end

  def submit(method, path, attributes); end

  def title(); end

  def visit(path, **attributes); end
end

class Capybara::RackTest::Browser
end

class Capybara::RackTest::CSSHandlers
  include ::Kernel
  def disabled(list); end

  def enabled(list); end
end

class Capybara::RackTest::CSSHandlers
end

class Capybara::RackTest::Driver
  def app(); end

  def browser(); end

  def delete(*args, &block); end

  def dom(); end

  def find_css(selector); end

  def find_xpath(selector); end

  def follow(method, path, **attributes); end

  def follow_redirects?(); end

  def get(*args, &block); end

  def header(key, value); end

  def initialize(app, **options); end

  def options(); end

  def post(*args, &block); end

  def put(*args, &block); end

  def redirect_limit(); end

  def request(); end

  def response(); end

  def submit(method, path, attributes); end

  def title(); end

  def visit(path, **attributes); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Driver
end

class Capybara::RackTest::Form
  def multipart?(); end

  def params(button); end

  def submit(button); end
end

class Capybara::RackTest::Form::NilUploadedFile
  def initialize(); end

  def read(); end

  def size(); end
end

class Capybara::RackTest::Form::NilUploadedFile
end

class Capybara::RackTest::Form::ParamsHash
  def to_params_hash(); end
end

class Capybara::RackTest::Form::ParamsHash
end

class Capybara::RackTest::Form
end

class Capybara::RackTest::Node
  def checkbox?(); end

  def checkbox_or_radio?(field=T.unsafe(nil)); end

  def click(keys=T.unsafe(nil), **offset); end

  def displayed_text(check_ancestor: T.unsafe(nil)); end

  def find_css(locator); end

  def find_xpath(locator); end

  def input_field?(); end

  def radio?(); end

  def style(_styles); end

  def text_or_password?(); end

  def textarea?(); end
  BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Capybara::RackTest::Node
end

module Capybara::RackTest
  extend ::T::Sig
end

class Capybara::ReadOnlyElementError
end

class Capybara::ReadOnlyElementError
end

class Capybara::ReadOnlySessionConfig
  def always_include_port=(_); end

  def app_host=(_); end

  def asset_host=(_); end

  def automatic_label_click=(_); end

  def automatic_reload=(_); end

  def default_host=(_); end

  def default_max_wait_time=(_); end

  def default_normalize_ws=(_); end

  def default_selector=(_); end

  def default_set_options=(_); end

  def disable_animation=(_); end

  def enable_aria_label=(_); end

  def exact=(_); end

  def exact_text=(_); end

  def ignore_hidden_elements=(_); end

  def match=(_); end

  def predicates_wait=(_); end

  def raise_server_errors=(_); end

  def run_server=(_); end

  def save_path=(_); end

  def server_errors=(_); end

  def server_host=(_); end

  def server_port=(_); end

  def test_id=(_); end

  def visible_text_only=(_); end
end

class Capybara::ReadOnlySessionConfig
end

class Capybara::Result
  include ::Enumerable
  def [](*args); end

  def at(*args); end

  def compare_count(); end

  def each(&block); end

  def empty?(); end

  def failure_message(); end

  def index(*_); end

  def initialize(elements, query); end

  def inspect(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def matches_count?(); end

  def negative_failure_message(); end

  def sample(*args, &block); end

  def size(*args, &block); end

  def unfiltered_size(); end

  def values_at(*args, &block); end
end

class Capybara::Result
  extend ::Forwardable
end

class Capybara::ScopeError
end

class Capybara::ScopeError
end

class Capybara::Selector
  def builder(); end

  def call(locator, selector_config: T.unsafe(nil), **options); end

  def css(*allowed_filters, &block); end

  def custom_filters(); end

  def default_visibility(fallback=T.unsafe(nil), options=T.unsafe(nil)); end

  def describe(*args, &block); end

  def describe_expression_filters(&block); end

  def describe_node_filters(&block); end

  def description(*args, &block); end

  def expression_filter(*args, &block); end

  def expression_filters(); end

  def filter(*args, &block); end

  def filter_set(name, filters_to_use=T.unsafe(nil)); end

  def format(); end

  def initialize(name, &block); end

  def label(label=T.unsafe(nil)); end

  def match(&block); end

  def match?(locator); end

  def name(); end

  def node_filter(*args, &block); end

  def node_filters(); end

  def visible(default_visibility=T.unsafe(nil), &block); end

  def xpath(*allowed_filters, &block); end
end

class Capybara::Selector::CSS
  ESCAPE = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
end

class Capybara::Selector::CSS::Splitter
  def split(css); end
end

class Capybara::Selector::CSS::Splitter
end

class Capybara::Selector::CSS
  def self.escape(str); end

  def self.escape_char(char); end

  def self.split(css); end
end

class Capybara::Selector::CSSBuilder
end

class Capybara::Selector::CSSBuilder
  def self.attribute_conditions(attributes); end

  def self.class_conditions(classes); end
end

class Capybara::Selector::FilterSet
  def describe(what=T.unsafe(nil), &block); end

  def description(node_filters: T.unsafe(nil), expression_filters: T.unsafe(nil), **options); end

  def descriptions(); end

  def expression_filter(name, *types_and_options, &block); end

  def expression_filter_descriptions(); end

  def expression_filters(); end

  def filter(name, *types_and_options, &block); end

  def import(name, filters=T.unsafe(nil)); end

  def initialize(name, &block); end

  def node_filter(name, *types_and_options, &block); end

  def node_filter_descriptions(); end

  def node_filters(); end

  def undeclared_descriptions(); end
end

class Capybara::Selector::FilterSet
  def self.add(name, &block); end

  def self.all(); end

  def self.remove(name); end
end

module Capybara::Selector::Filters
end

class Capybara::Selector::Filters::Base
  def default(); end

  def default?(); end

  def handles_option?(option_name); end

  def initialize(name, matcher, block, **options); end

  def matcher?(); end

  def skip?(value); end
end

class Capybara::Selector::Filters::Base
end

class Capybara::Selector::Filters::ExpressionFilter
  def apply_filter(expr, name, value); end
end

class Capybara::Selector::Filters::ExpressionFilter
end

class Capybara::Selector::Filters::IdentityExpressionFilter
  def apply_filter(expr, _name, _value); end

  def initialize(name); end
end

class Capybara::Selector::Filters::IdentityExpressionFilter
end

class Capybara::Selector::Filters::NodeFilter
  def matches?(node, name, value); end
end

class Capybara::Selector::Filters::NodeFilter
end

module Capybara::Selector::Filters
  extend ::T::Sig
end

class Capybara::Selector::RegexpDisassembler
  def initialize(regexp); end

  def substrings(); end
end

class Capybara::Selector::RegexpDisassembler
end

class Capybara::Selector::XPathBuilder
end

class Capybara::Selector::XPathBuilder
  def self.attribute_conditions(attributes); end

  def self.class_conditions(classes); end
end

class Capybara::Selector
  extend ::Forwardable
  def self.add(name, &block); end

  def self.all(); end

  def self.remove(name); end

  def self.update(name, &block); end
end

module Capybara::Selenium
end

class Capybara::Selenium::ChromeNode
  include ::Capybara::Selenium::Node::Html5Drag
end

class Capybara::Selenium::ChromeNode
end

class Capybara::Selenium::Driver
  def accept_modal(_type, **options); end

  def app(); end

  def browser(); end

  def dismiss_modal(_type, **options); end

  def find_css(selector); end

  def find_xpath(selector); end

  def initialize(app, **options); end

  def options(); end

  def quit(); end

  def save_screenshot(path, **_options); end

  def title(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  SPECIAL_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Driver::ChromeDriver
  def fullscreen_window(handle); end

  def reset!(); end

  def resize_window_to(handle, width, height); end
end

module Capybara::Selenium::Driver::ChromeDriver
  extend ::T::Sig
end

module Capybara::Selenium::Driver::MarionetteDriver
  def refresh(); end

  def reset!(); end

  def resize_window_to(handle, width, height); end

  def switch_to_frame(frame); end
end

module Capybara::Selenium::Driver::MarionetteDriver
  extend ::T::Sig
end

class Capybara::Selenium::Driver
  def self.load_selenium(); end
end

class Capybara::Selenium::MarionetteNode
  include ::Capybara::Selenium::Node::Html5Drag
end

class Capybara::Selenium::MarionetteNode
end

class Capybara::Selenium::Node
  def content_editable?(); end

  def find_css(locator); end

  def find_xpath(locator); end

  def scroll_if_needed(); end
end

module Capybara::Selenium::Node::Html5Drag
  HTML5_DRAG_DROP_SCRIPT = ::T.let(nil, ::T.untyped)
  MOUSEDOWN_TRACKER = ::T.let(nil, ::T.untyped)
end

module Capybara::Selenium::Node::Html5Drag
  extend ::T::Sig
end

class Capybara::Selenium::Node
end

module Capybara::Selenium
  extend ::T::Sig
end

class Capybara::Server
  def app(); end

  def boot(); end

  def error(); end

  def host(); end

  def initialize(app, *deprecated_options, port: T.unsafe(nil), host: T.unsafe(nil), reportable_errors: T.unsafe(nil), extra_middleware: T.unsafe(nil)); end

  def port(); end

  def reset_error!(); end

  def responsive?(); end

  def using_ssl?(); end

  def wait_for_pending_requests(); end
end

class Capybara::Server::AnimationDisabler
  def call(env); end

  def initialize(app); end
  DISABLE_MARKUP_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::AnimationDisabler
  def self.selector_for(css_or_bool); end
end

class Capybara::Server::Checker
  def initialize(host, port); end

  def request(&block); end

  def ssl?(); end
  TRY_HTTPS_ERRORS = ::T.let(nil, ::T.untyped)
end

class Capybara::Server::Checker
end

class Capybara::Server::Middleware
  def call(env); end

  def clear_error(); end

  def error(); end

  def initialize(app, server_errors, extra_middleware=T.unsafe(nil)); end

  def pending_requests?(); end
end

class Capybara::Server::Middleware::Counter
  def decrement(); end

  def increment(); end

  def value(); end
end

class Capybara::Server::Middleware::Counter
end

class Capybara::Server::Middleware
end

class Capybara::Server
  def self.ports(); end
end

class Capybara::Session
  include ::Capybara::SessionMatchers
  def accept_alert(text=T.unsafe(nil), **options, &blk); end

  def accept_confirm(text=T.unsafe(nil), **options, &blk); end

  def accept_prompt(text=T.unsafe(nil), **options, &blk); end

  def all(*args, &block); end

  def app(); end

  def assert_all_of_selectors(*args, &block); end

  def assert_any_of_selectors(*args, &block); end

  def assert_no_selector(*args, &block); end

  def assert_no_text(*args, &block); end

  def assert_no_title(*args, &block); end

  def assert_none_of_selectors(*args, &block); end

  def assert_selector(*args, &block); end

  def assert_text(*args, &block); end

  def assert_title(*args, &block); end

  def attach_file(*args, &block); end

  def body(); end

  def check(*args, &block); end

  def choose(*args, &block); end

  def cleanup!(); end

  def click_button(*args, &block); end

  def click_link(*args, &block); end

  def click_link_or_button(*args, &block); end

  def click_on(*args, &block); end

  def config(); end

  def configure(); end

  def current_host(); end

  def current_path(); end

  def current_scope(); end

  def current_url(); end

  def current_window(); end

  def dismiss_confirm(text=T.unsafe(nil), **options, &blk); end

  def dismiss_prompt(text=T.unsafe(nil), **options, &blk); end

  def document(); end

  def driver(); end

  def evaluate_async_script(script, *args); end

  def evaluate_script(script, *args); end

  def execute_script(script, *args); end

  def fill_in(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_button(*args, &block); end

  def find_by_id(*args, &block); end

  def find_field(*args, &block); end

  def find_link(*args, &block); end

  def first(*args, &block); end

  def go_back(); end

  def go_forward(); end

  def has_button?(*args, &block); end

  def has_checked_field?(*args, &block); end

  def has_content?(*args, &block); end

  def has_css?(*args, &block); end

  def has_field?(*args, &block); end

  def has_link?(*args, &block); end

  def has_no_button?(*args, &block); end

  def has_no_checked_field?(*args, &block); end

  def has_no_content?(*args, &block); end

  def has_no_css?(*args, &block); end

  def has_no_field?(*args, &block); end

  def has_no_link?(*args, &block); end

  def has_no_select?(*args, &block); end

  def has_no_selector?(*args, &block); end

  def has_no_table?(*args, &block); end

  def has_no_text?(*args, &block); end

  def has_no_title?(*args, &block); end

  def has_no_unchecked_field?(*args, &block); end

  def has_no_xpath?(*args, &block); end

  def has_select?(*args, &block); end

  def has_selector?(*args, &block); end

  def has_table?(*args, &block); end

  def has_text?(*args, &block); end

  def has_title?(*args, &block); end

  def has_unchecked_field?(*args, &block); end

  def has_xpath?(*args, &block); end

  def html(); end

  def initialize(mode, app=T.unsafe(nil)); end

  def mode(); end

  def open_new_window(); end

  def query(*args, &block); end

  def raise_server_error!(); end

  def refresh(); end

  def refute_selector(*args, &block); end

  def reset!(); end

  def reset_session!(); end

  def resolve(*args, &block); end

  def response_headers(); end

  def save_and_open_page(path=T.unsafe(nil)); end

  def save_and_open_screenshot(path=T.unsafe(nil), **options); end

  def save_page(path=T.unsafe(nil)); end

  def save_screenshot(path=T.unsafe(nil), **options); end

  def select(*args, &block); end

  def server(); end

  def source(); end

  def status_code(); end

  def switch_to_frame(frame); end

  def switch_to_window(window=T.unsafe(nil), **options, &window_locator); end

  def synchronized(); end

  def synchronized=(synchronized); end

  def text(*args, &block); end

  def title(*args, &block); end

  def uncheck(*args, &block); end

  def unselect(*args, &block); end

  def using_wait_time(seconds); end

  def visit(visit_uri); end

  def window_opened_by(**options); end

  def windows(); end

  def within(*args); end

  def within_element(*args); end

  def within_fieldset(locator); end

  def within_frame(*args); end

  def within_table(locator); end

  def within_window(window_or_proc); end
  DOCUMENT_METHODS = ::T.let(nil, ::T.untyped)
  DSL_METHODS = ::T.let(nil, ::T.untyped)
  MODAL_METHODS = ::T.let(nil, ::T.untyped)
  NODE_METHODS = ::T.let(nil, ::T.untyped)
  SESSION_METHODS = ::T.let(nil, ::T.untyped)
end

class Capybara::Session
  def self.instance_created?(); end
end

class Capybara::SessionConfig
  def always_include_port(); end

  def always_include_port=(always_include_port); end

  def app_host(); end

  def app_host=(url); end

  def asset_host(); end

  def asset_host=(asset_host); end

  def automatic_label_click(); end

  def automatic_label_click=(automatic_label_click); end

  def automatic_reload(); end

  def automatic_reload=(automatic_reload); end

  def default_host(); end

  def default_host=(url); end

  def default_max_wait_time(); end

  def default_max_wait_time=(default_max_wait_time); end

  def default_normalize_ws(); end

  def default_normalize_ws=(default_normalize_ws); end

  def default_selector(); end

  def default_selector=(default_selector); end

  def default_set_options(); end

  def default_set_options=(default_set_options); end

  def disable_animation(); end

  def disable_animation=(bool_or_allowlist); end

  def enable_aria_label(); end

  def enable_aria_label=(enable_aria_label); end

  def exact(); end

  def exact=(exact); end

  def exact_text(); end

  def exact_text=(exact_text); end

  def ignore_hidden_elements(); end

  def ignore_hidden_elements=(ignore_hidden_elements); end

  def match(); end

  def match=(match); end

  def predicates_wait(); end

  def predicates_wait=(predicates_wait); end

  def raise_server_errors(); end

  def raise_server_errors=(raise_server_errors); end

  def run_server(); end

  def run_server=(run_server); end

  def save_path(); end

  def save_path=(save_path); end

  def server_errors(); end

  def server_errors=(errors); end

  def server_host(); end

  def server_host=(server_host); end

  def server_port(); end

  def server_port=(server_port); end

  def test_id(); end

  def test_id=(id); end

  def visible_text_only(); end

  def visible_text_only=(visible_text_only); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Capybara::SessionConfig
end

module Capybara::SessionMatchers
  def assert_current_path(path, **options); end

  def assert_no_current_path(path, **options); end

  def has_current_path?(path, **options); end

  def has_no_current_path?(path, **options); end
end

module Capybara::SessionMatchers
  extend ::T::Sig
end

class Capybara::UnselectNotAllowed
end

class Capybara::UnselectNotAllowed
end

class Capybara::Window
  def ==(other); end

  def close(); end

  def closed?(); end

  def current?(); end

  def eql?(other); end

  def exists?(); end

  def fullscreen(); end

  def handle(); end

  def initialize(session, handle); end

  def maximize(); end

  def resize_to(width, height); end

  def session(); end

  def size(); end
end

class Capybara::Window
end

class Capybara::WindowError
end

class Capybara::WindowError
end

module Capybara
  extend ::Capybara::DSL
  extend ::T::Sig
  def self.HTML(html); end

  def self.add_selector(name, &block); end

  def self.always_include_port(*args, &block); end

  def self.always_include_port=(*args, &block); end

  def self.app(*args, &block); end

  def self.app=(*args, &block); end

  def self.app_host(*args, &block); end

  def self.app_host=(*args, &block); end

  def self.asset_host(*args, &block); end

  def self.asset_host=(*args, &block); end

  def self.automatic_label_click(*args, &block); end

  def self.automatic_label_click=(*args, &block); end

  def self.automatic_reload(*args, &block); end

  def self.automatic_reload=(*args, &block); end

  def self.configure(); end

  def self.current_driver(); end

  def self.current_driver=(name); end

  def self.current_session(); end

  def self.default_driver(*args, &block); end

  def self.default_driver=(*args, &block); end

  def self.default_host(*args, &block); end

  def self.default_host=(*args, &block); end

  def self.default_max_wait_time(*args, &block); end

  def self.default_max_wait_time=(*args, &block); end

  def self.default_normalize_ws(*args, &block); end

  def self.default_normalize_ws=(*args, &block); end

  def self.default_selector(*args, &block); end

  def self.default_selector=(*args, &block); end

  def self.default_set_options(*args, &block); end

  def self.default_set_options=(*args, &block); end

  def self.default_wait_time(*args, &block); end

  def self.default_wait_time=(*args, &block); end

  def self.disable_animation(*args, &block); end

  def self.disable_animation=(*args, &block); end

  def self.drivers(); end

  def self.enable_aria_label(*args, &block); end

  def self.enable_aria_label=(*args, &block); end

  def self.exact(*args, &block); end

  def self.exact=(*args, &block); end

  def self.exact_text(*args, &block); end

  def self.exact_text=(*args, &block); end

  def self.ignore_hidden_elements(*args, &block); end

  def self.ignore_hidden_elements=(*args, &block); end

  def self.javascript_driver(*args, &block); end

  def self.javascript_driver=(*args, &block); end

  def self.match(*args, &block); end

  def self.match=(*args, &block); end

  def self.mode(); end

  def self.modify_selector(name, &block); end

  def self.predicates_wait(*args, &block); end

  def self.predicates_wait=(*args, &block); end

  def self.raise_server_errors(*args, &block); end

  def self.raise_server_errors=(*args, &block); end

  def self.register_driver(name, &block); end

  def self.register_server(name, &block); end

  def self.reset!(); end

  def self.reset_sessions!(); end

  def self.reuse_server(*args, &block); end

  def self.reuse_server=(*args, &block); end

  def self.run_default_server(app, port); end

  def self.run_server(*args, &block); end

  def self.run_server=(*args, &block); end

  def self.save_path(*args, &block); end

  def self.save_path=(*args, &block); end

  def self.server(*args, &block); end

  def self.server=(*args, &block); end

  def self.server_errors(*args, &block); end

  def self.server_errors=(*args, &block); end

  def self.server_host(*args, &block); end

  def self.server_host=(*args, &block); end

  def self.server_port(*args, &block); end

  def self.server_port=(*args, &block); end

  def self.servers(); end

  def self.session_name(); end

  def self.session_name=(name); end

  def self.session_options(); end

  def self.string(html); end

  def self.test_id(*args, &block); end

  def self.test_id=(*args, &block); end

  def self.threadsafe(*args, &block); end

  def self.threadsafe=(*args, &block); end

  def self.use_default_driver(); end

  def self.using_driver(driver); end

  def self.using_session(name_or_session); end

  def self.using_wait_time(seconds); end

  def self.visible_text_only(*args, &block); end

  def self.visible_text_only=(*args, &block); end
end

module Carmen
  VERSION = ::T.let(nil, ::T.untyped)
end

class Carmen::Country
  def alpha_2_code(); end

  def alpha_3_code(); end

  def common_name(); end

  def numeric_code(); end

  def official_name(); end
end

class Carmen::Country
  extend ::Carmen::Querying
  extend ::SingleForwardable
  def self.all(); end

  def self.alpha_2_coded(code); end

  def self.alpha_3_coded(code); end

  def self.attribute_to_search_for_code(code); end

  def self.numeric_coded(code); end

  def self.numerically_coded(code); end

  def self.query_collection(); end
end

module Carmen::I18n
end

class Carmen::I18n::Simple
  def append_locale_path(path); end

  def available_locales(); end

  def cache(); end

  def cache=(cache); end

  def fallback_locale(); end

  def initialize(*initial_locale_paths); end

  def locale(); end

  def locale=(locale); end

  def locale_paths(); end

  def reset!(); end

  def t(key); end

  def translate(key); end
  DEFAULT_LOCALE = ::T.let(nil, ::T.untyped)
end

class Carmen::I18n::Simple
end

module Carmen::I18n
  extend ::T::Sig
end

module Carmen::Querying
  def coded(code); end

  def named(name, options=T.unsafe(nil)); end
end

module Carmen::Querying
  extend ::T::Sig
end

class Carmen::Region
  def code(); end

  def initialize(data=T.unsafe(nil), parent=T.unsafe(nil)); end

  def name(); end

  def parent(); end

  def path(suffix=T.unsafe(nil)); end

  def reset!(); end

  def subregion_class(); end

  def subregion_data_path(); end

  def subregions(); end

  def subregions?(); end

  def to_hash(); end

  def type(); end
end

class Carmen::Region
end

class Carmen::RegionCollection
  include ::Carmen::Querying
  def typed(type); end
end

class Carmen::RegionCollection
end

module Carmen::Utils
end

module Carmen::Utils
  extend ::T::Sig
  def self.deep_hash_merge(hashes); end

  def self.merge_arrays_by_keys(arrays, keys); end
end

class Carmen::World
  include ::Singleton
  def path(); end
end

class Carmen::World
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module Carmen
  extend ::T::Sig
  def self.append_data_path(path); end

  def self.clear_data_paths(); end

  def self.data_paths(); end

  def self.data_paths=(paths); end

  def self.i18n_backend(); end

  def self.i18n_backend=(backend); end

  def self.reset_data_paths(); end

  def self.reset_i18n_backend(); end

  def self.root_path(); end

  def self.root_path=(root_path); end
end

module ChildProcess
  VERSION = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractIO
  def _stdin=(io); end

  def inherit!(); end

  def stderr(); end

  def stderr=(io); end

  def stdin(); end

  def stdout(); end

  def stdout=(io); end
end

class ChildProcess::AbstractIO
end

class ChildProcess::AbstractProcess
  def alive?(); end

  def crashed?(); end

  def cwd(); end

  def cwd=(cwd); end

  def detach(); end

  def detach=(detach); end

  def duplex(); end

  def duplex=(duplex); end

  def environment(); end

  def exit_code(); end

  def exited?(); end

  def initialize(args); end

  def io(); end

  def leader(); end

  def leader=(leader); end

  def pid(); end

  def poll_for_exit(timeout); end

  def start(); end

  def started?(); end

  def stop(timeout=T.unsafe(nil)); end

  def wait(); end
  POLL_INTERVAL = ::T.let(nil, ::T.untyped)
end

class ChildProcess::AbstractProcess
end

class ChildProcess::Error
end

class ChildProcess::Error
end

class ChildProcess::InvalidEnvironmentVariable
end

class ChildProcess::InvalidEnvironmentVariable
end

class ChildProcess::LaunchError
end

class ChildProcess::LaunchError
end

class ChildProcess::MissingPlatformError
  def initialize(); end
end

class ChildProcess::MissingPlatformError
end

class ChildProcess::SubclassResponsibility
end

class ChildProcess::SubclassResponsibility
end

class ChildProcess::TimeoutError
end

class ChildProcess::TimeoutError
end

module ChildProcess::Unix
end

class ChildProcess::Unix::ForkExecProcess
end

class ChildProcess::Unix::ForkExecProcess
end

class ChildProcess::Unix::IO
end

class ChildProcess::Unix::IO
end

class ChildProcess::Unix::Process
end

class ChildProcess::Unix::Process
end

module ChildProcess::Unix
  extend ::T::Sig
end

module ChildProcess
  extend ::T::Sig
  def self.arch(); end

  def self.build(*args); end

  def self.close_on_exec(file); end

  def self.jruby?(); end

  def self.linux?(); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.new(*args); end

  def self.os(); end

  def self.platform(); end

  def self.platform_name(); end

  def self.posix_spawn=(bool); end

  def self.posix_spawn?(); end

  def self.unix?(); end

  def self.windows?(); end
end

class Class
  def class_attribute(*attrs); end

  def descendants(); end

  def json_creatable?(); end

  def subclasses(); end
end

class Class
  extend ::T::Sig
end

class ClosedQueueError
  extend ::T::Sig
end

module Coffee
end

module Coffee::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

class Coffee::Rails::Engine
end

class Coffee::Rails::Engine
end

module Coffee::Rails::JsHook
end

module Coffee::Rails::JsHook
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class Coffee::Rails::TemplateHandler
end

class Coffee::Rails::TemplateHandler
  def self.call(template); end

  def self.erb_handler(); end
end

module Coffee::Rails
  extend ::T::Sig
end

module Coffee
  extend ::T::Sig
end

module CoffeeScript
end

CoffeeScript::CompilationError = ExecJS::ProgramError

CoffeeScript::EngineError = ExecJS::RuntimeError

CoffeeScript::Error = ExecJS::Error

module CoffeeScript::Source
  COMPILE_FUNCTION_SOURCE = ::T.let(nil, ::T.untyped)
end

module CoffeeScript::Source
  extend ::T::Sig
  def self.bare_option(); end

  def self.bundled_path(); end

  def self.contents(); end

  def self.context(); end

  def self.path(); end

  def self.path=(path); end

  def self.version(); end
end

module CoffeeScript
  extend ::T::Sig
  def self.compile(script, options=T.unsafe(nil)); end

  def self.engine(); end

  def self.engine=(engine); end

  def self.version(); end
end

module Colored2
  COLORS = ::T.let(nil, ::T.untyped)
  EFFECTS = ::T.let(nil, ::T.untyped)
end

class Colored2::AsciiDecorator
  def decorate(options=T.unsafe(nil)); end

  def disable!(*args, &block); end

  def enable!(*args, &block); end

  def initialize(a_string); end

  def my_class(); end

  def my_class=(my_class); end

  def string(); end

  def string=(string); end

  def un_decorate(); end
end

class Colored2::AsciiDecorator
  extend ::Forwardable
  def self.__background_next(); end

  def self.__background_next=(__background_next); end

  def self.__colors_disabled(); end

  def self.__colors_disabled=(__colors_disabled); end

  def self.background_next!(); end

  def self.background_next?(); end

  def self.disable!(); end

  def self.enable!(); end

  def self.enabled?(); end

  def self.foreground_next!(); end
end

class Colored2::BackgroundColor
  def value(); end
end

class Colored2::BackgroundColor
end

class Colored2::Code
  def escape(); end

  def escape=(escape); end

  def initialize(name); end

  def name(); end

  def name=(name); end

  def value(shift=T.unsafe(nil)); end
end

class Colored2::Code
end

class Colored2::Effect
  def codes(); end
end

class Colored2::Effect
end

class Colored2::TextColor
  def codes(); end
end

class Colored2::TextColor
end

module Colored2
  extend ::T::Sig
  def self.background_next!(); end

  def self.background_next?(); end

  def self.decorate(a_class); end

  def self.disable!(); end

  def self.enable!(); end

  def self.foreground_next!(); end

  def self.included(from_class); end
end

class Commits
  def base(); end

  def head(); end

  def initialize(base_head); end
end

class Commits
end

module Comparable
  extend ::T::Sig
end

class Complex
  extend ::T::Sig
  def self.polar(*_); end

  def self.rect(*_); end

  def self.rectangular(*_); end
end

class CompositeReadIO
  def initialize(*ios); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class CompositeReadIO
end

module Concurrent
  AtExit = ::T.let(nil, ::T.untyped)
  NULL = ::T.let(nil, ::T.untyped)
  NULL_LOGGER = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExchanger
  def exchange(value, timeout=T.unsafe(nil)); end

  def exchange!(value, timeout=T.unsafe(nil)); end

  def try_exchange(value, timeout=T.unsafe(nil)); end
end

class Concurrent::AbstractExchanger
end

class Concurrent::AbstractExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def auto_terminate=(value); end

  def auto_terminate?(); end

  def fallback_policy(); end

  def initialize(*args, &block); end

  def kill(); end

  def running?(); end

  def shutdown(); end

  def shutdown?(); end

  def shuttingdown?(); end

  def wait_for_termination(timeout=T.unsafe(nil)); end
  FALLBACK_POLICIES = ::T.let(nil, ::T.untyped)
end

class Concurrent::AbstractExecutorService
end

class Concurrent::AbstractThreadLocalVar
  def allocate_storage(); end

  def bind(value, &block); end

  def default(); end

  def initialize(default=T.unsafe(nil), &default_block); end

  def value(); end

  def value=(value); end
end

class Concurrent::AbstractThreadLocalVar
end

class Concurrent::Agent
  include ::Concurrent::Concern::Observable
  def <<(action); end

  def await(); end

  def await_for(timeout); end

  def await_for!(timeout); end

  def deref(); end

  def error(); end

  def error_mode(); end

  def failed?(); end

  def initialize(initial, opts=T.unsafe(nil)); end

  def post(*args, &action); end

  def reason(); end

  def restart(new_value, opts=T.unsafe(nil)); end

  def send(*args, &action); end

  def send!(*args, &action); end

  def send_off(*args, &action); end

  def send_off!(*args, &action); end

  def send_via(executor, *args, &action); end

  def send_via!(executor, *args, &action); end

  def stopped?(); end

  def value(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
  def initialize(message=T.unsafe(nil)); end
end

class Concurrent::Agent::Error
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent::ValidationError
end

class Concurrent::Agent
  def self.await(*agents); end

  def self.await_for(timeout, *agents); end

  def self.await_for!(timeout, *agents); end
end

class Concurrent::Array
end

class Concurrent::Array
end

module Concurrent::Async
  def async(); end

  def await(); end

  def call(); end

  def cast(); end

  def init_synchronization(); end
end

module Concurrent::Async
  extend ::T::Sig
  def self.included(base); end

  def self.validate_argc(obj, method, *args); end
end

class Concurrent::Atom
  include ::Concurrent::Concern::Observable
  def compare_and_set(old_value, new_value); end

  def deref(); end

  def initialize(value, opts=T.unsafe(nil)); end

  def reset(new_value); end

  def swap(*args); end

  def value(); end
end

class Concurrent::Atom
  def self.new(*args, &block); end
end

class Concurrent::AtomicBoolean
end

class Concurrent::AtomicBoolean
end

module Concurrent::AtomicDirectUpdate
  def try_update(); end

  def try_update!(); end

  def update(); end
end

module Concurrent::AtomicDirectUpdate
  extend ::T::Sig
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicFixnum
end

class Concurrent::AtomicMarkableReference
  def compare_and_set(expected_val, new_val, expected_mark, new_mark); end

  def compare_and_swap(expected_val, new_val, expected_mark, new_mark); end

  def get(); end

  def initialize(value=T.unsafe(nil), mark=T.unsafe(nil)); end

  def mark(); end

  def marked?(); end

  def set(new_val, new_mark); end

  def try_update(); end

  def try_update!(); end

  def update(); end

  def value(); end
end

class Concurrent::AtomicMarkableReference
  def self.new(*args, &block); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  def compare_and_set(old_value, new_value); end
end

module Concurrent::AtomicNumericCompareAndSetWrapper
  extend ::T::Sig
end

class Concurrent::AtomicReference
end

class Concurrent::AtomicReference
end

class Concurrent::CachedThreadPool
end

class Concurrent::CachedThreadPool
end

class Concurrent::CancelledOperationError
end

class Concurrent::CancelledOperationError
end

module Concurrent::Collection
end

class Concurrent::Collection::CopyOnNotifyObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnNotifyObserverSet
end

class Concurrent::Collection::CopyOnWriteObserverSet
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def initialize(); end

  def notify_and_delete_observers(*args, &block); end

  def notify_observers(*args, &block); end

  def ns_initialize(); end
end

class Concurrent::Collection::CopyOnWriteObserverSet
end

Concurrent::Collection::MapImplementation = Concurrent::Collection::MriMapBackend

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::MriMapBackend
end

class Concurrent::Collection::NonConcurrentMapBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
end

class Concurrent::Collection::NonConcurrentMapBackend
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::NonConcurrentPriorityQueue
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def <<(item); end

  def clear(); end

  def delete(item); end

  def deq(); end

  def empty?(); end

  def enq(item); end

  def has_priority?(item); end

  def include?(item); end

  def initialize(opts=T.unsafe(nil)); end

  def length(); end

  def peek(); end

  def pop(); end

  def push(item); end

  def shift(); end

  def size(); end
end

class Concurrent::Collection::RubyNonConcurrentPriorityQueue
  def self.from_list(list, opts=T.unsafe(nil)); end
end

module Concurrent::Collection
  extend ::T::Sig
end

module Concurrent::Concern
end

module Concurrent::Concern::Dereferenceable
  def apply_deref_options(value); end

  def deref(); end

  def ns_set_deref_options(opts); end

  def set_deref_options(opts=T.unsafe(nil)); end

  def value(); end

  def value=(value); end
end

module Concurrent::Concern::Dereferenceable
  extend ::T::Sig
end

module Concurrent::Concern::Logging
  include ::Logger::Severity
  def log(level, progname, message=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Logging
  extend ::T::Sig
end

module Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def compare_and_set_state(next_state, *expected_current); end

  def complete?(); end

  def event(); end

  def exception(*args); end

  def fulfilled?(); end

  def get_arguments_from(opts=T.unsafe(nil)); end

  def if_state(*expected_states); end

  def incomplete?(); end

  def init_obligation(); end

  def no_error!(timeout=T.unsafe(nil)); end

  def ns_check_state?(expected); end

  def ns_set_state(value); end

  def pending?(); end

  def realized?(); end

  def reason(); end

  def rejected?(); end

  def set_state(success, value, reason); end

  def state(); end

  def state=(value); end

  def unscheduled?(); end

  def value(timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end
end

module Concurrent::Concern::Obligation
  extend ::T::Sig
end

module Concurrent::Concern::Observable
  def add_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end

  def count_observers(); end

  def delete_observer(observer); end

  def delete_observers(); end

  def observers(); end

  def observers=(observers); end

  def with_observer(observer=T.unsafe(nil), func=T.unsafe(nil), &block); end
end

module Concurrent::Concern::Observable
  extend ::T::Sig
end

module Concurrent::Concern
  extend ::T::Sig
end

class Concurrent::ConcurrentUpdateError
  CONC_UP_ERR_BACKTRACE = ::T.let(nil, ::T.untyped)
end

class Concurrent::ConcurrentUpdateError
end

class Concurrent::ConfigurationError
end

class Concurrent::ConfigurationError
end

class Concurrent::CountDownLatch
end

class Concurrent::CountDownLatch
end

class Concurrent::CyclicBarrier
  def broken?(); end

  def initialize(parties, &block); end

  def ns_generation_done(generation, status, continue=T.unsafe(nil)); end

  def ns_initialize(parties, &block); end

  def ns_next_generation(); end

  def number_waiting(); end

  def parties(); end

  def reset(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::CyclicBarrier
end

class Concurrent::Delay
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  def initialize(opts=T.unsafe(nil), &block); end

  def ns_initialize(opts, &block); end

  def reconfigure(&block); end
end

class Concurrent::Delay
end

class Concurrent::DependencyCounter
  def initialize(count, &block); end

  def update(time, value, reason); end
end

class Concurrent::DependencyCounter
end

class Concurrent::Error
end

class Concurrent::Error
end

class Concurrent::Event
  def initialize(); end

  def ns_initialize(); end

  def ns_set(); end

  def reset(); end

  def set(); end

  def set?(); end

  def try?(); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::Event
end

class Concurrent::Exchanger
end

class Concurrent::Exchanger
end

module Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def <<(task); end

  def can_overflow?(); end

  def post(*args, &task); end

  def serialized?(); end
end

module Concurrent::ExecutorService
  extend ::T::Sig
end

class Concurrent::FixedThreadPool
  def initialize(num_threads, opts=T.unsafe(nil)); end
end

class Concurrent::FixedThreadPool
end

class Concurrent::Future
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def initialize(opts=T.unsafe(nil), &block); end

  def set(value=T.unsafe(nil), &block); end

  def wait_or_cancel(timeout); end
end

class Concurrent::Future
  def self.execute(opts=T.unsafe(nil), &block); end
end

class Concurrent::Hash
end

class Concurrent::Hash
end

class Concurrent::IVar
  include ::Concurrent::Concern::Obligation
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def check_for_block_or_value!(block_given, value); end

  def complete(success, value, reason); end

  def complete_without_notification(success, value, reason); end

  def fail(reason=T.unsafe(nil)); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil), &block); end

  def notify_observers(value, reason); end

  def ns_complete_without_notification(success, value, reason); end

  def ns_initialize(value, opts); end

  def safe_execute(task, args=T.unsafe(nil)); end

  def set(value=T.unsafe(nil)); end

  def try_set(value=T.unsafe(nil), &block); end
end

class Concurrent::IVar
end

class Concurrent::IllegalOperationError
end

class Concurrent::IllegalOperationError
end

class Concurrent::ImmediateExecutor
  include ::Concurrent::SerialExecutorService
  def initialize(); end
end

class Concurrent::ImmediateExecutor
end

class Concurrent::ImmutabilityError
end

class Concurrent::ImmutabilityError
end

module Concurrent::ImmutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::ImmutableStruct
  extend ::T::Sig
  def self.included(base); end

  def self.new(*args, &block); end
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::IndirectImmediateExecutor
end

class Concurrent::InitializationError
end

class Concurrent::InitializationError
end

class Concurrent::LifecycleError
end

class Concurrent::LifecycleError
end

class Concurrent::LockFreeStack
  include ::Enumerable
  def clear(); end

  def clear_each(&block); end

  def clear_if(head); end

  def compare_and_clear(head); end

  def compare_and_pop(head); end

  def compare_and_push(head, value); end

  def each(head=T.unsafe(nil)); end

  def empty?(head=T.unsafe(nil)); end

  def initialize(head=T.unsafe(nil)); end

  def peek(); end

  def pop(); end

  def push(value); end

  def replace_if(head, new_head); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Concurrent::LockFreeStack::Node
  def initialize(value, next_node); end

  def next_node(); end

  def value(); end

  def value=(value); end
end

class Concurrent::LockFreeStack::Node
  def self.[](*_); end
end

class Concurrent::LockFreeStack
  def self.new(*args, &block); end

  def self.of1(value); end

  def self.of2(value1, value2); end
end

class Concurrent::MVar
  include ::Concurrent::Concern::Dereferenceable
  def borrow(timeout=T.unsafe(nil)); end

  def empty?(); end

  def full?(); end

  def initialize(value=T.unsafe(nil), opts=T.unsafe(nil)); end

  def modify(timeout=T.unsafe(nil)); end

  def modify!(); end

  def put(value, timeout=T.unsafe(nil)); end

  def set!(value); end

  def synchronize(&block); end

  def take(timeout=T.unsafe(nil)); end

  def try_put!(value); end

  def try_take!(); end
  EMPTY = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::MVar
  def self.new(*args, &block); end
end

class Concurrent::Map
  def each(); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def value?(value); end

  def values(); end
end

class Concurrent::Map
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::MaxRestartFrequencyError
end

class Concurrent::Maybe
  include ::Comparable
  def fulfilled?(); end

  def initialize(just, nothing); end

  def just(); end

  def just?(); end

  def nothing(); end

  def nothing?(); end

  def or(other); end

  def reason(); end

  def rejected?(); end

  def value(); end
  NONE = ::T.let(nil, ::T.untyped)
end

class Concurrent::Maybe
  def self.from(*args); end

  def self.just(value); end

  def self.nothing(error=T.unsafe(nil)); end
end

class Concurrent::MultipleAssignmentError
  def initialize(message=T.unsafe(nil), inspection_data=T.unsafe(nil)); end

  def inspection_data(); end
end

class Concurrent::MultipleAssignmentError
end

class Concurrent::MultipleErrors
  def errors(); end

  def initialize(errors, message=T.unsafe(nil)); end
end

class Concurrent::MultipleErrors
end

module Concurrent::MutableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::MutableStruct
  extend ::T::Sig
  def self.new(*args, &block); end
end

class Concurrent::MutexAtomicBoolean
  def false?(); end

  def initialize(initial=T.unsafe(nil)); end

  def make_false(); end

  def make_true(); end

  def ns_initialize(initial); end

  def true?(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicBoolean
end

class Concurrent::MutexAtomicFixnum
  def compare_and_set(expect, update); end

  def decrement(delta=T.unsafe(nil)); end

  def down(delta=T.unsafe(nil)); end

  def increment(delta=T.unsafe(nil)); end

  def initialize(initial=T.unsafe(nil)); end

  def ns_initialize(initial); end

  def up(delta=T.unsafe(nil)); end

  def update(); end

  def value(); end

  def value=(value); end
end

class Concurrent::MutexAtomicFixnum
end

class Concurrent::MutexAtomicReference
  include ::Concurrent::AtomicDirectUpdate
  include ::Concurrent::AtomicNumericCompareAndSetWrapper
  def _compare_and_set(old_value, new_value); end

  def compare_and_swap(old_value, new_value); end

  def get(); end

  def get_and_set(new_value); end

  def initialize(value=T.unsafe(nil)); end

  def ns_initialize(value); end

  def set(new_value); end

  def swap(new_value); end

  def value(); end

  def value=(new_value); end
end

class Concurrent::MutexAtomicReference
end

class Concurrent::MutexCountDownLatch
  def count(); end

  def count_down(); end

  def initialize(count=T.unsafe(nil)); end

  def ns_initialize(count); end

  def wait(timeout=T.unsafe(nil)); end
end

class Concurrent::MutexCountDownLatch
end

class Concurrent::MutexSemaphore
  def acquire(permits=T.unsafe(nil)); end

  def available_permits(); end

  def drain_permits(); end

  def initialize(count); end

  def ns_initialize(count); end

  def reduce_permits(reduction); end

  def release(permits=T.unsafe(nil)); end

  def try_acquire(permits=T.unsafe(nil), timeout=T.unsafe(nil)); end
end

class Concurrent::MutexSemaphore
end

module Concurrent::Options
end

module Concurrent::Options
  extend ::T::Sig
  def self.executor(executor_identifier); end

  def self.executor_from_options(opts=T.unsafe(nil)); end
end

class Concurrent::Promise
  def catch(&block); end

  def execute(); end

  def flat_map(&block); end

  def initialize(opts=T.unsafe(nil), &block); end

  def notify_child(child); end

  def on_error(&block); end

  def on_fulfill(result); end

  def on_reject(reason); end

  def on_success(&block); end

  def realize(task); end

  def rescue(&block); end

  def root?(); end

  def set(value=T.unsafe(nil), &block); end

  def set_pending(); end

  def set_state!(success, value, reason); end

  def synchronized_set_state!(success, value, reason); end

  def then(*args, &block); end

  def zip(*others); end
end

class Concurrent::Promise
  def self.aggregate(method, *promises); end

  def self.all?(*promises); end

  def self.any?(*promises); end

  def self.execute(opts=T.unsafe(nil), &block); end

  def self.fulfill(value, opts=T.unsafe(nil)); end

  def self.reject(reason, opts=T.unsafe(nil)); end

  def self.zip(*promises); end
end

class Concurrent::PromiseExecutionError
end

class Concurrent::PromiseExecutionError
end

module Concurrent::Promises
end

class Concurrent::Promises::AbstractEventFuture
  include ::Concurrent::Promises::InternalStates
  def add_callback_clear_delayed_node(node); end

  def add_callback_notify_blocked(promise, index); end

  def blocks(); end

  def callbacks(); end

  def chain(*args, &task); end

  def chain_on(executor, *args, &task); end

  def chain_resolvable(resolvable); end

  def default_executor(); end

  def initialize(promise, default_executor); end

  def internal_state(); end

  def on_resolution(*args, &callback); end

  def on_resolution!(*args, &callback); end

  def on_resolution_using(executor, *args, &callback); end

  def pending?(); end

  def promise(); end

  def resolve_with(state, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolved?(); end

  def state(); end

  def tangle(resolvable); end

  def touch(); end

  def touched?(); end

  def wait(timeout=T.unsafe(nil)); end

  def waiting_threads(); end

  def with_default_executor(executor); end

  def with_hidden_resolvable(); end
end

class Concurrent::Promises::AbstractEventFuture
  def self.new(*args, &block); end
end

class Concurrent::Promises::Event
  def &(other); end

  def any(event_or_future); end

  def delay(); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def to_event(); end

  def to_future(); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Event
end

module Concurrent::Promises::FactoryMethods
  include ::Concurrent::Promises::FactoryMethods::Configuration
  def any(*futures_and_or_events); end

  def any_event(*futures_and_or_events); end

  def any_event_on(default_executor, *futures_and_or_events); end

  def any_fulfilled_future(*futures_and_or_events); end

  def any_fulfilled_future_on(default_executor, *futures_and_or_events); end

  def any_resolved_future(*futures_and_or_events); end

  def any_resolved_future_on(default_executor, *futures_and_or_events); end

  def delay(*args, &task); end

  def delay_on(default_executor, *args, &task); end

  def fulfilled_future(value, default_executor=T.unsafe(nil)); end

  def future(*args, &task); end

  def future_on(default_executor, *args, &task); end

  def make_future(argument=T.unsafe(nil), default_executor=T.unsafe(nil)); end

  def rejected_future(reason, default_executor=T.unsafe(nil)); end

  def resolvable_event(); end

  def resolvable_event_on(default_executor=T.unsafe(nil)); end

  def resolvable_future(); end

  def resolvable_future_on(default_executor=T.unsafe(nil)); end

  def resolved_event(default_executor=T.unsafe(nil)); end

  def resolved_future(fulfilled, value, reason, default_executor=T.unsafe(nil)); end

  def schedule(intended_time, *args, &task); end

  def schedule_on(default_executor, intended_time, *args, &task); end

  def zip(*futures_and_or_events); end

  def zip_events(*futures_and_or_events); end

  def zip_events_on(default_executor, *futures_and_or_events); end

  def zip_futures(*futures_and_or_events); end

  def zip_futures_on(default_executor, *futures_and_or_events); end
end

module Concurrent::Promises::FactoryMethods::Configuration
  def default_executor(); end
end

module Concurrent::Promises::FactoryMethods::Configuration
  extend ::T::Sig
end

module Concurrent::Promises::FactoryMethods
  extend ::Concurrent::ReInclude
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
  extend ::T::Sig
end

class Concurrent::Promises::Future
  def &(other); end

  def any(event_or_future); end

  def apply(args, block); end

  def delay(); end

  def exception(*args); end

  def flat(level=T.unsafe(nil)); end

  def flat_event(); end

  def flat_future(level=T.unsafe(nil)); end

  def fulfilled?(); end

  def on_fulfillment(*args, &callback); end

  def on_fulfillment!(*args, &callback); end

  def on_fulfillment_using(executor, *args, &callback); end

  def on_rejection(*args, &callback); end

  def on_rejection!(*args, &callback); end

  def on_rejection_using(executor, *args, &callback); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def rejected?(); end

  def rescue(*args, &task); end

  def rescue_on(executor, *args, &task); end

  def result(timeout=T.unsafe(nil)); end

  def run(run_test=T.unsafe(nil)); end

  def schedule(intended_time); end

  def then(*args, &task); end

  def then_on(executor, *args, &task); end

  def to_event(); end

  def to_future(); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil)); end

  def zip(other); end

  def |(event_or_future); end
end

class Concurrent::Promises::Future
end

module Concurrent::Promises::InternalStates
  PENDING = ::T.let(nil, ::T.untyped)
  RESERVED = ::T.let(nil, ::T.untyped)
  RESOLVED = ::T.let(nil, ::T.untyped)
end

module Concurrent::Promises::InternalStates
  extend ::T::Sig
end

module Concurrent::Promises::Resolvable
  include ::Concurrent::Promises::InternalStates
end

module Concurrent::Promises::Resolvable
  extend ::T::Sig
end

class Concurrent::Promises::ResolvableEvent
  include ::Concurrent::Promises::Resolvable
  def resolve(raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableEvent
end

class Concurrent::Promises::ResolvableFuture
  include ::Concurrent::Promises::Resolvable
  def evaluate_to(*args, &block); end

  def evaluate_to!(*args, &block); end

  def fulfill(value, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def reason(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def reject(reason, raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def resolve(fulfilled=T.unsafe(nil), value=T.unsafe(nil), reason=T.unsafe(nil), raise_on_reassign=T.unsafe(nil), reserved=T.unsafe(nil)); end

  def result(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def value!(timeout=T.unsafe(nil), timeout_value=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end

  def wait!(timeout=T.unsafe(nil), resolve_on_timeout=T.unsafe(nil)); end
end

class Concurrent::Promises::ResolvableFuture
end

module Concurrent::Promises
  extend ::Concurrent::Promises::FactoryMethods
  extend ::Concurrent::Promises::FactoryMethods::Configuration
  extend ::T::Sig
end

module Concurrent::ReInclude
  def extended(base); end

  def include(*modules); end

  def included(base); end
end

module Concurrent::ReInclude
  extend ::T::Sig
end

class Concurrent::ReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def has_waiters?(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end

  def write_locked?(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::ReentrantReadWriteLock
  def acquire_read_lock(); end

  def acquire_write_lock(); end

  def release_read_lock(); end

  def release_write_lock(); end

  def try_read_lock(); end

  def try_write_lock(); end

  def with_read_lock(); end

  def with_write_lock(); end
  MAX_READERS = ::T.let(nil, ::T.untyped)
  MAX_WRITERS = ::T.let(nil, ::T.untyped)
  READER_BITS = ::T.let(nil, ::T.untyped)
  READ_LOCK_MASK = ::T.let(nil, ::T.untyped)
  RUNNING_WRITER = ::T.let(nil, ::T.untyped)
  WAITING_WRITER = ::T.let(nil, ::T.untyped)
  WRITER_BITS = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_HELD = ::T.let(nil, ::T.untyped)
  WRITE_LOCK_MASK = ::T.let(nil, ::T.untyped)
end

class Concurrent::ReentrantReadWriteLock
  def self.new(*args, &block); end
end

class Concurrent::RejectedExecutionError
end

class Concurrent::RejectedExecutionError
end

class Concurrent::ResourceLimitError
end

class Concurrent::ResourceLimitError
end

class Concurrent::RubyExchanger
  def compare_and_set_slot(expected, value); end

  def slot(); end

  def slot=(value); end

  def swap_slot(value); end

  def update_slot(&block); end
end

class Concurrent::RubyExchanger
  def self.new(*args, &block); end
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubyExecutorService
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubySingleThreadExecutor
end

class Concurrent::RubyThreadLocalVar
end

class Concurrent::RubyThreadLocalVar
  def self.thread_finalizer(array); end

  def self.threadlocal_finalizer(index); end
end

class Concurrent::RubyThreadPoolExecutor
  def completed_task_count(); end

  def idletime(); end

  def initialize(opts=T.unsafe(nil)); end

  def largest_length(); end

  def length(); end

  def max_length(); end

  def max_queue(); end

  def min_length(); end

  def queue_length(); end

  def ready_worker(worker); end

  def remaining_capacity(); end

  def remove_busy_worker(worker); end

  def scheduled_task_count(); end

  def worker_died(worker); end

  def worker_not_old_enough(worker); end

  def worker_task_completed(); end
  DEFAULT_MAX_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MAX_QUEUE_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_MIN_POOL_SIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_THREAD_IDLETIMEOUT = ::T.let(nil, ::T.untyped)
end

class Concurrent::RubyThreadPoolExecutor
end

class Concurrent::SafeTaskExecutor
  def execute(*args); end

  def initialize(task, opts=T.unsafe(nil)); end
end

class Concurrent::SafeTaskExecutor
end

class Concurrent::ScheduledTask
  include ::Comparable
  def cancel(); end

  def cancelled?(); end

  def execute(); end

  def executor(); end

  def initial_delay(); end

  def initialize(delay, opts=T.unsafe(nil), &task); end

  def ns_reschedule(delay); end

  def ns_schedule(delay); end

  def process_task(); end

  def processing?(); end

  def reschedule(delay); end

  def reset(); end

  def schedule_time(); end
end

class Concurrent::ScheduledTask
  def self.execute(delay, opts=T.unsafe(nil), &task); end
end

class Concurrent::Semaphore
end

class Concurrent::Semaphore
end

module Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def serialized?(); end
end

module Concurrent::SerialExecutorService
  extend ::T::Sig
end

class Concurrent::SerializedExecution
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(); end

  def post(executor, *args, &task); end

  def posts(posts); end
end

class Concurrent::SerializedExecution::Job
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def call(); end

  def executor(); end

  def executor=(_); end
end

class Concurrent::SerializedExecution::Job
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::SerializedExecution
end

class Concurrent::SerializedExecutionDelegator
  include ::Concurrent::SerialExecutorService
  include ::Concurrent::ExecutorService
  include ::Concurrent::Concern::Logging
  include ::Logger::Severity
  def initialize(executor); end
end

class Concurrent::SerializedExecutionDelegator
end

class Concurrent::Set
end

class Concurrent::Set
end

module Concurrent::SettableStruct
  include ::Concurrent::Synchronization::AbstractStruct
  def ==(other); end

  def [](member); end

  def []=(member, value); end

  def each(&block); end

  def each_pair(&block); end

  def inspect(); end

  def merge(other, &block); end

  def select(&block); end

  def to_a(); end

  def to_h(); end

  def to_s(); end

  def values(); end

  def values_at(*indexes); end
end

module Concurrent::SettableStruct
  extend ::T::Sig
  def self.new(*args, &block); end
end

class Concurrent::SimpleExecutorService
end

class Concurrent::SimpleExecutorService
  def self.<<(task); end

  def self.post(*args); end
end

class Concurrent::SingleThreadExecutor
end

class Concurrent::SingleThreadExecutor
end

module Concurrent::Synchronization
end

class Concurrent::Synchronization::AbstractLockableObject
  def ns_broadcast(); end

  def ns_signal(); end

  def ns_wait(timeout=T.unsafe(nil)); end

  def ns_wait_until(timeout=T.unsafe(nil), &condition); end

  def synchronize(); end
end

class Concurrent::Synchronization::AbstractLockableObject
end

class Concurrent::Synchronization::AbstractObject
  def full_memory_barrier(); end
end

class Concurrent::Synchronization::AbstractObject
  def self.attr_volatile(*names); end
end

module Concurrent::Synchronization::AbstractStruct
  def initialize(*values); end

  def length(); end

  def members(); end

  def ns_each(); end

  def ns_each_pair(); end

  def ns_equality(other); end

  def ns_get(member); end

  def ns_inspect(); end

  def ns_merge(other, &block); end

  def ns_select(); end

  def ns_to_h(); end

  def ns_values(); end

  def ns_values_at(indexes); end

  def pr_underscore(clazz); end

  def size(); end
end

module Concurrent::Synchronization::AbstractStruct
  extend ::T::Sig
  def self.define_struct_class(parent, base, name, members, &block); end
end

class Concurrent::Synchronization::Condition
  def broadcast(); end

  def initialize(lock); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Condition
  def self.private_new(*args, &block); end
end

module Concurrent::Synchronization::ConditionSignalling
  def ns_broadcast(); end

  def ns_signal(); end
end

module Concurrent::Synchronization::ConditionSignalling
  extend ::T::Sig
end

class Concurrent::Synchronization::Lock
  def broadcast(); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(timeout=T.unsafe(nil), &condition); end
end

class Concurrent::Synchronization::Lock
end

class Concurrent::Synchronization::LockableObject
  def new_condition(); end
end

class Concurrent::Synchronization::LockableObject
end

class Concurrent::Synchronization::MonitorLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MonitorLockableObject
  def self.new(*args, &block); end
end

module Concurrent::Synchronization::MriAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::MriAttrVolatile
  extend ::T::Sig
  def self.included(base); end
end

class Concurrent::Synchronization::MriObject
  include ::Concurrent::Synchronization::MriAttrVolatile
end

class Concurrent::Synchronization::MriObject
end

class Concurrent::Synchronization::MutexLockableObject
  include ::Concurrent::Synchronization::ConditionSignalling
  def initialize(*defaults); end
end

class Concurrent::Synchronization::MutexLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::Object
end

class Concurrent::Synchronization::Object
  def self.atomic_attribute?(name); end

  def self.atomic_attributes(inherited=T.unsafe(nil)); end

  def self.attr_atomic(*names); end

  def self.ensure_safe_initialization_when_final_fields_are_present(); end

  def self.safe_initialization!(); end

  def self.safe_initialization?(); end
end

module Concurrent::Synchronization::RbxAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
  extend ::T::Sig
end

module Concurrent::Synchronization::RbxAttrVolatile
  extend ::T::Sig
  def self.included(base); end
end

class Concurrent::Synchronization::RbxLockableObject
  def initialize(*defaults); end

  def synchronize(&block); end
end

class Concurrent::Synchronization::RbxLockableObject
  def self.new(*args, &block); end
end

class Concurrent::Synchronization::RbxObject
  include ::Concurrent::Synchronization::RbxAttrVolatile
end

class Concurrent::Synchronization::RbxObject
  extend ::Concurrent::Synchronization::RbxAttrVolatile::ClassMethods
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  def full_memory_barrier(); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  def attr_volatile(*names); end
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
  extend ::T::Sig
end

module Concurrent::Synchronization::TruffleRubyAttrVolatile
  extend ::T::Sig
  def self.included(base); end
end

class Concurrent::Synchronization::TruffleRubyObject
  include ::Concurrent::Synchronization::TruffleRubyAttrVolatile
end

class Concurrent::Synchronization::TruffleRubyObject
  extend ::Concurrent::Synchronization::TruffleRubyAttrVolatile::ClassMethods
end

Concurrent::Synchronization::Volatile = Concurrent::Synchronization::MriAttrVolatile

module Concurrent::Synchronization
  extend ::T::Sig
end

class Concurrent::SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
end

class Concurrent::SynchronizedDelegator
end

class Concurrent::TVar
  def initialize(value); end

  def unsafe_increment_version(); end

  def unsafe_lock(); end

  def unsafe_value(); end

  def unsafe_value=(value); end

  def unsafe_version(); end

  def value(); end

  def value=(value); end
end

class Concurrent::TVar
  def self.new(*args, &block); end
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadLocalVar
end

class Concurrent::ThreadPoolExecutor
end

class Concurrent::ThreadPoolExecutor
end

module Concurrent::ThreadSafe
end

module Concurrent::ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

module Concurrent::ThreadSafe::Util
  extend ::T::Sig
end

module Concurrent::ThreadSafe
  extend ::T::Sig
end

class Concurrent::TimeoutError
end

class Concurrent::TimeoutError
end

class Concurrent::TimerSet
  def initialize(opts=T.unsafe(nil)); end

  def post(delay, *args, &task); end
end

class Concurrent::TimerSet
end

class Concurrent::TimerTask
  include ::Concurrent::Concern::Dereferenceable
  include ::Concurrent::Concern::Observable
  def execute(); end

  def execution_interval(); end

  def execution_interval=(value); end

  def initialize(opts=T.unsafe(nil), &task); end

  def timeout_interval(); end

  def timeout_interval=(value); end
  EXECUTION_INTERVAL = ::T.let(nil, ::T.untyped)
  TIMEOUT_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Concurrent::TimerTask
  def self.execute(opts=T.unsafe(nil), &task); end
end

class Concurrent::Transaction
  def abort(); end

  def commit(); end

  def read(tvar); end

  def unlock(); end

  def valid?(); end

  def write(tvar, value); end
  ABORTED = ::T.let(nil, ::T.untyped)
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::AbortError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::LeaveError
end

class Concurrent::Transaction::ReadLogEntry
  def tvar(); end

  def tvar=(_); end

  def version(); end

  def version=(_); end
end

class Concurrent::Transaction::ReadLogEntry
  def self.[](*_); end

  def self.members(); end
end

class Concurrent::Transaction
  def self.current(); end

  def self.current=(transaction); end
end

class Concurrent::Tuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(); end

  def get(i); end

  def initialize(size); end

  def set(i, value); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class Concurrent::Tuple
end

module Concurrent::Utility
end

module Concurrent::Utility::EngineDetector
  def on_cruby?(); end

  def on_jruby?(); end

  def on_jruby_9000?(); end

  def on_linux?(); end

  def on_osx?(); end

  def on_rbx?(); end

  def on_truffleruby?(); end

  def on_windows?(); end

  def ruby_engine(); end

  def ruby_version(version=T.unsafe(nil), comparison, major, minor, patch); end
end

module Concurrent::Utility::EngineDetector
  extend ::T::Sig
end

module Concurrent::Utility::NativeExtensionLoader
  def allow_c_extensions?(); end

  def c_extensions_loaded?(); end

  def java_extensions_loaded?(); end

  def load_native_extensions(); end
end

module Concurrent::Utility::NativeExtensionLoader
  extend ::T::Sig
end

module Concurrent::Utility::NativeInteger
  def ensure_integer(value); end

  def ensure_integer_and_bounds(value); end

  def ensure_lower_bound(value); end

  def ensure_positive(value); end

  def ensure_positive_and_no_zero(value); end

  def ensure_upper_bound(value); end
  MAX_VALUE = ::T.let(nil, ::T.untyped)
  MIN_VALUE = ::T.let(nil, ::T.untyped)
end

module Concurrent::Utility::NativeInteger
  extend ::Concurrent::Utility::NativeInteger
  extend ::T::Sig
end

class Concurrent::Utility::ProcessorCounter
  def physical_processor_count(); end

  def processor_count(); end
end

class Concurrent::Utility::ProcessorCounter
end

module Concurrent::Utility
  extend ::T::Sig
end

module Concurrent
  extend ::Concurrent::Utility::EngineDetector
  extend ::Concurrent::Utility::NativeExtensionLoader
  extend ::Concurrent::Concern::Logging
  extend ::Logger::Severity
  extend ::T::Sig
  def self.abort_transaction(); end

  def self.atomically(); end

  def self.call_dataflow(method, executor, *inputs, &block); end

  def self.create_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.create_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.dataflow(*inputs, &block); end

  def self.dataflow!(*inputs, &block); end

  def self.dataflow_with(executor, *inputs, &block); end

  def self.dataflow_with!(executor, *inputs, &block); end

  def self.disable_at_exit_handlers!(); end

  def self.executor(executor_identifier); end

  def self.global_fast_executor(); end

  def self.global_immediate_executor(); end

  def self.global_io_executor(); end

  def self.global_logger(); end

  def self.global_logger=(value); end

  def self.global_timer_set(); end

  def self.leave_transaction(); end

  def self.monotonic_time(); end

  def self.new_fast_executor(opts=T.unsafe(nil)); end

  def self.new_io_executor(opts=T.unsafe(nil)); end

  def self.physical_processor_count(); end

  def self.processor_count(); end

  def self.processor_counter(); end

  def self.use_simple_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end

  def self.use_stdlib_logger(level=T.unsafe(nil), output=T.unsafe(nil)); end
end

ConditionVariable = Thread::ConditionVariable

class ConnectionPool
  def available(); end

  def checkin(); end

  def checkout(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil), &block); end

  def shutdown(&block); end

  def size(); end

  def with(options=T.unsafe(nil)); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class ConnectionPool::Error
end

class ConnectionPool::Error
end

class ConnectionPool::PoolShuttingDownError
end

class ConnectionPool::PoolShuttingDownError
end

class ConnectionPool::TimedStack
  def <<(obj, options=T.unsafe(nil)); end

  def empty?(); end

  def initialize(size=T.unsafe(nil), &block); end

  def length(); end

  def max(); end

  def pop(timeout=T.unsafe(nil), options=T.unsafe(nil)); end

  def push(obj, options=T.unsafe(nil)); end

  def shutdown(&block); end
end

class ConnectionPool::TimedStack
end

class ConnectionPool::Wrapper
  def initialize(options=T.unsafe(nil), &block); end

  def method_missing(name, *args, &block); end

  def pool_available(); end

  def pool_shutdown(&block); end

  def pool_size(); end

  def respond_to?(id, *args); end

  def with(&block); end
  METHODS = ::T.let(nil, ::T.untyped)
end

class ConnectionPool::Wrapper
end

class ConnectionPool
  def self.monotonic_time(); end

  def self.wrap(options, &block); end
end

module Cork
  VERSION = ::T.let(nil, ::T.untyped)
end

class Cork::Board
  def ansi(); end

  def ansi?(); end

  def disable_wrap(); end

  def disable_wrap=(disable_wrap); end

  def disable_wrap?(); end

  def err(); end

  def gets(); end

  def indentation_level(); end

  def info(message); end

  def initialize(verbose: T.unsafe(nil), silent: T.unsafe(nil), ansi: T.unsafe(nil), input: T.unsafe(nil), out: T.unsafe(nil), err: T.unsafe(nil)); end

  def input(); end

  def labeled(label, value, justification=T.unsafe(nil)); end

  def message(message, verbose_prefix=T.unsafe(nil), relative_indentation=T.unsafe(nil)); end

  def notice(message); end

  def out(); end

  def path(pathname, relative_to=T.unsafe(nil)); end

  def print(message); end

  def print_warnings(); end

  def puts(message=T.unsafe(nil)); end

  def puts_indented(message=T.unsafe(nil)); end

  def section(title, verbose_prefix=T.unsafe(nil), relative_indentation=T.unsafe(nil), titled=T.unsafe(nil)); end

  def silent(); end

  def silent?(); end

  def title(title, verbose_prefix=T.unsafe(nil), relative_indentation=T.unsafe(nil)); end

  def verbose(); end

  def verbose?(); end

  def warn(message, actions=T.unsafe(nil), verbose_only=T.unsafe(nil)); end

  def warnings(); end
end

class Cork::Board
end

module Cork::TextWrapper
end

module Cork::TextWrapper
  extend ::T::Sig
  def self.strip_heredoc(string); end

  def self.word_wrap(line, line_width); end

  def self.wrap_formatted_text(string, indent=T.unsafe(nil), width=T.unsafe(nil)); end

  def self.wrap_with_indent(string, indent=T.unsafe(nil), width=T.unsafe(nil)); end
end

module Cork
  extend ::T::Sig
end

module Crack
end

class Crack::REXMLParser
end

class Crack::REXMLParser
  def self.parse(xml); end
end

class Crack::XML
end

class Crack::XML
  def self.parse(xml); end

  def self.parser(); end

  def self.parser=(parser); end
end

module Crack
  extend ::T::Sig
end

module Crass
end

class Crass::Parser
  def consume_at_rule(input=T.unsafe(nil)); end

  def consume_component_value(input=T.unsafe(nil)); end

  def consume_declaration(input=T.unsafe(nil)); end

  def consume_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def consume_function(input=T.unsafe(nil)); end

  def consume_qualified_rule(input=T.unsafe(nil)); end

  def consume_rules(flags=T.unsafe(nil)); end

  def consume_simple_block(input=T.unsafe(nil)); end

  def create_node(type, properties=T.unsafe(nil)); end

  def create_selector(input); end

  def create_style_rule(rule); end

  def initialize(input, options=T.unsafe(nil)); end

  def parse_component_value(input=T.unsafe(nil)); end

  def parse_component_values(input=T.unsafe(nil)); end

  def parse_declaration(input=T.unsafe(nil)); end

  def parse_declarations(input=T.unsafe(nil), options=T.unsafe(nil)); end

  def parse_properties(input=T.unsafe(nil)); end

  def parse_rule(input=T.unsafe(nil)); end

  def parse_value(nodes); end

  def tokens(); end
  BLOCK_END_TOKENS = ::T.let(nil, ::T.untyped)
end

class Crass::Parser
  def self.parse_properties(input, options=T.unsafe(nil)); end

  def self.parse_rules(input, options=T.unsafe(nil)); end

  def self.parse_stylesheet(input, options=T.unsafe(nil)); end

  def self.stringify(nodes, options=T.unsafe(nil)); end
end

class Crass::Scanner
  def consume(); end

  def consume_rest(); end

  def current(); end

  def eos?(); end

  def initialize(input); end

  def mark(); end

  def marked(); end

  def marker(); end

  def marker=(marker); end

  def peek(length=T.unsafe(nil)); end

  def pos(); end

  def pos=(pos); end

  def reconsume(); end

  def reset(); end

  def scan(pattern); end

  def scan_until(pattern); end

  def string(); end
end

class Crass::Scanner
end

class Crass::TokenScanner
  def collect(); end

  def consume(); end

  def current(); end

  def initialize(tokens); end

  def peek(); end

  def pos(); end

  def reconsume(); end

  def reset(); end

  def tokens(); end
end

class Crass::TokenScanner
end

class Crass::Tokenizer
  def consume(); end

  def consume_bad_url(); end

  def consume_comments(); end

  def consume_escaped(); end

  def consume_ident(); end

  def consume_name(); end

  def consume_number(); end

  def consume_numeric(); end

  def consume_string(ending=T.unsafe(nil)); end

  def consume_unicode_range(); end

  def consume_url(); end

  def convert_string_to_number(str); end

  def create_token(type, properties=T.unsafe(nil)); end

  def initialize(input, options=T.unsafe(nil)); end

  def preprocess(input); end

  def start_identifier?(text=T.unsafe(nil)); end

  def start_number?(text=T.unsafe(nil)); end

  def tokenize(); end

  def valid_escape?(text=T.unsafe(nil)); end
  RE_COMMENT_CLOSE = ::T.let(nil, ::T.untyped)
  RE_DIGIT = ::T.let(nil, ::T.untyped)
  RE_ESCAPE = ::T.let(nil, ::T.untyped)
  RE_HEX = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_NAME_START = ::T.let(nil, ::T.untyped)
  RE_NON_PRINTABLE = ::T.let(nil, ::T.untyped)
  RE_NUMBER_DECIMAL = ::T.let(nil, ::T.untyped)
  RE_NUMBER_EXPONENT = ::T.let(nil, ::T.untyped)
  RE_NUMBER_SIGN = ::T.let(nil, ::T.untyped)
  RE_NUMBER_STR = ::T.let(nil, ::T.untyped)
  RE_QUOTED_URL_START = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_END = ::T.let(nil, ::T.untyped)
  RE_UNICODE_RANGE_START = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE = ::T.let(nil, ::T.untyped)
  RE_WHITESPACE_ANCHORED = ::T.let(nil, ::T.untyped)
end

class Crass::Tokenizer
  def self.tokenize(input, options=T.unsafe(nil)); end
end

module Crass
  extend ::T::Sig
  def self.parse(input, options=T.unsafe(nil)); end

  def self.parse_properties(input, options=T.unsafe(nil)); end
end

module DRb
end

class DRb::DRbArray
  def _dump(lv); end

  def initialize(ary); end
end

class DRb::DRbArray
  def self._load(s); end
end

class DRb::DRbBadScheme
end

class DRb::DRbBadScheme
end

class DRb::DRbBadURI
end

class DRb::DRbBadURI
end

class DRb::DRbConn
  def alive?(); end

  def close(); end

  def initialize(remote_uri); end

  def send_message(ref, msg_id, arg, block); end

  def uri(); end
  POOL_SIZE = ::T.let(nil, ::T.untyped)
end

class DRb::DRbConn
  def self.open(remote_uri); end
end

class DRb::DRbConnError
end

class DRb::DRbConnError
end

class DRb::DRbError
end

class DRb::DRbError
end

class DRb::DRbIdConv
  def to_id(obj); end

  def to_obj(ref); end
end

class DRb::DRbIdConv
end

class DRb::DRbMessage
  def dump(obj, error=T.unsafe(nil)); end

  def initialize(config); end

  def load(soc); end

  def recv_reply(stream); end

  def recv_request(stream); end

  def send_reply(stream, succ, result); end

  def send_request(stream, ref, msg_id, arg, b); end
end

class DRb::DRbMessage
end

class DRb::DRbObject
  def ==(other); end

  def __drbref(); end

  def __drburi(); end

  def _dump(lv); end

  def eql?(other); end

  def initialize(obj, uri=T.unsafe(nil)); end

  def method_missing(msg_id, *a, &b); end

  def respond_to?(msg_id, priv=T.unsafe(nil)); end
end

class DRb::DRbObject
  def self._load(s); end

  def self.new_with(uri, ref); end

  def self.new_with_uri(uri); end

  def self.prepare_backtrace(uri, result); end

  def self.with_friend(uri); end
end

module DRb::DRbProtocol
end

module DRb::DRbProtocol
  extend ::T::Sig
  def self.add_protocol(prot); end

  def self.auto_load(uri); end

  def self.open(uri, config, first=T.unsafe(nil)); end

  def self.open_server(uri, config, first=T.unsafe(nil)); end

  def self.uri_option(uri, config, first=T.unsafe(nil)); end
end

class DRb::DRbRemoteError
  def initialize(error); end

  def reason(); end
end

class DRb::DRbRemoteError
end

class DRb::DRbServer
  def alive?(); end

  def check_insecure_method(obj, msg_id); end

  def config(); end

  def front(); end

  def here?(uri); end

  def initialize(uri=T.unsafe(nil), front=T.unsafe(nil), config_or_acl=T.unsafe(nil)); end

  def safe_level(); end

  def stop_service(); end

  def thread(); end

  def to_id(obj); end

  def to_obj(ref); end

  def uri(); end

  def verbose(); end

  def verbose=(v); end
  INSECURE_METHOD = ::T.let(nil, ::T.untyped)
end

class DRb::DRbServer::InvokeMethod
  include ::DRb::DRbServer::InvokeMethod18Mixin
  def initialize(drb_server, client); end

  def perform(); end
end

class DRb::DRbServer::InvokeMethod
end

module DRb::DRbServer::InvokeMethod18Mixin
  def block_yield(x); end

  def perform_with_block(); end
end

module DRb::DRbServer::InvokeMethod18Mixin
  extend ::T::Sig
end

class DRb::DRbServer
  def self.default_acl(acl); end

  def self.default_argc_limit(argc); end

  def self.default_id_conv(idconv); end

  def self.default_load_limit(sz); end

  def self.default_safe_level(level); end

  def self.make_config(hash=T.unsafe(nil)); end

  def self.verbose(); end

  def self.verbose=(on); end
end

class DRb::DRbServerNotFound
end

class DRb::DRbServerNotFound
end

class DRb::DRbTCPSocket
  def accept(); end

  def alive?(); end

  def close(); end

  def initialize(uri, soc, config=T.unsafe(nil)); end

  def peeraddr(); end

  def recv_reply(); end

  def recv_request(); end

  def send_reply(succ, result); end

  def send_request(ref, msg_id, arg, b); end

  def set_sockopt(soc); end

  def shutdown(); end

  def stream(); end

  def uri(); end
end

class DRb::DRbTCPSocket
  def self.getservername(); end

  def self.open(uri, config); end

  def self.open_server(uri, config); end

  def self.open_server_inaddr_any(host, port); end

  def self.parse_uri(uri); end

  def self.uri_option(uri, config); end
end

class DRb::DRbURIOption
  def ==(other); end

  def eql?(other); end

  def initialize(option); end

  def option(); end
end

class DRb::DRbURIOption
end

module DRb::DRbUndumped
  def _dump(dummy); end
end

module DRb::DRbUndumped
  extend ::T::Sig
end

class DRb::DRbUnknown
  def _dump(lv); end

  def buf(); end

  def exception(); end

  def initialize(err, buf); end

  def name(); end

  def reload(); end
end

class DRb::DRbUnknown
  def self._load(s); end
end

class DRb::DRbUnknownError
  def _dump(lv); end

  def initialize(unknown); end

  def unknown(); end
end

class DRb::DRbUnknownError
  def self._load(s); end
end

module DRb
  extend ::T::Sig
  def self.config(); end

  def self.current_server(); end

  def self.fetch_server(uri); end

  def self.front(); end

  def self.here?(uri); end

  def self.install_acl(acl); end

  def self.install_id_conv(idconv); end

  def self.mutex(); end

  def self.primary_server(); end

  def self.primary_server=(primary_server); end

  def self.regist_server(server); end

  def self.remove_server(server); end

  def self.start_service(uri=T.unsafe(nil), front=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.stop_service(); end

  def self.thread(); end

  def self.to_id(obj); end

  def self.to_obj(ref); end

  def self.uri(); end
end

DRbIdConv = DRb::DRbIdConv

DRbObject = DRb::DRbObject

DRbUndumped = DRb::DRbUndumped

module Dalli
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dalli::Client
  def add(key, value, ttl=T.unsafe(nil), options=T.unsafe(nil)); end

  def alive!(); end

  def append(key, value); end

  def cas(key, ttl=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def cas!(key, ttl=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def close(); end

  def decr(key, amt=T.unsafe(nil), ttl=T.unsafe(nil), default=T.unsafe(nil)); end

  def delete(key); end

  def fetch(key, ttl=T.unsafe(nil), options=T.unsafe(nil)); end

  def flush(delay=T.unsafe(nil)); end

  def flush_all(delay=T.unsafe(nil)); end

  def get(key, options=T.unsafe(nil)); end

  def get_multi(*keys); end

  def incr(key, amt=T.unsafe(nil), ttl=T.unsafe(nil), default=T.unsafe(nil)); end

  def initialize(servers=T.unsafe(nil), options=T.unsafe(nil)); end

  def multi(); end

  def prepend(key, value); end

  def replace(key, value, ttl=T.unsafe(nil), options=T.unsafe(nil)); end

  def reset(); end

  def reset_stats(); end

  def set(key, value, ttl=T.unsafe(nil), options=T.unsafe(nil)); end

  def stats(type=T.unsafe(nil)); end

  def touch(key, ttl=T.unsafe(nil)); end

  def version(); end

  def with(); end
  CACHE_NILS = ::T.let(nil, ::T.untyped)
end

class Dalli::Client
end

class Dalli::Compressor
end

class Dalli::Compressor
  def self.compress(data); end

  def self.decompress(data); end
end

class Dalli::DalliError
end

class Dalli::DalliError
end

class Dalli::GzipCompressor
end

class Dalli::GzipCompressor
  def self.compress(data); end

  def self.decompress(data); end
end

class Dalli::MarshalError
end

class Dalli::MarshalError
end

class Dalli::NetworkError
end

class Dalli::NetworkError
end

class Dalli::Railtie
end

class Dalli::Railtie
end

class Dalli::Ring
  def continuum(); end

  def continuum=(continuum); end

  def initialize(servers, options); end

  def lock(); end

  def server_for_key(key); end

  def servers(); end

  def servers=(servers); end
  POINTS_PER_SERVER = ::T.let(nil, ::T.untyped)
end

class Dalli::Ring::Entry
  def initialize(val, srv); end

  def server(); end

  def value(); end
end

class Dalli::Ring::Entry
end

class Dalli::Ring
end

class Dalli::RingError
end

class Dalli::RingError
end

class Dalli::Server
  def alive?(); end

  def close(); end

  def compressor(); end

  def hostname(); end

  def hostname=(hostname); end

  def initialize(attribs, options=T.unsafe(nil)); end

  def lock!(); end

  def multi_response_abort(); end

  def multi_response_completed?(); end

  def multi_response_nonblock(); end

  def multi_response_start(); end

  def name(); end

  def options(); end

  def options=(options); end

  def port(); end

  def port=(port); end

  def request(op, *args); end

  def serializer(); end

  def sock(); end

  def socket_type(); end

  def unlock!(); end

  def weight(); end

  def weight=(weight); end
  CAS_HEADER = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_WEIGHT = ::T.let(nil, ::T.untyped)
  FLAG_COMPRESSED = ::T.let(nil, ::T.untyped)
  FLAG_SERIALIZED = ::T.let(nil, ::T.untyped)
  FORMAT = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  KV_HEADER = ::T.let(nil, ::T.untyped)
  MAX_ACCEPTABLE_EXPIRATION_INTERVAL = ::T.let(nil, ::T.untyped)
  NORMAL_HEADER = ::T.let(nil, ::T.untyped)
  NOT_FOUND = ::T.let(nil, ::T.untyped)
  OPCODES = ::T.let(nil, ::T.untyped)
  OP_FORMAT = ::T.let(nil, ::T.untyped)
  REQUEST = ::T.let(nil, ::T.untyped)
  RESPONSE = ::T.let(nil, ::T.untyped)
  RESPONSE_CODES = ::T.let(nil, ::T.untyped)
end

module Dalli::Server::KSocket
end

module Dalli::Server::KSocket::InstanceMethods
  def read_available(); end

  def readfull(count); end
end

module Dalli::Server::KSocket::InstanceMethods
  extend ::T::Sig
end

class Dalli::Server::KSocket::TCP
  include ::Dalli::Server::KSocket
  include ::Dalli::Server::KSocket::InstanceMethods
  def options(); end

  def options=(options); end

  def server(); end

  def server=(server); end
end

class Dalli::Server::KSocket::TCP
  extend ::Dalli::Server::TCPSocketOptions
  def self.open(host, port, server, options=T.unsafe(nil)); end
end

class Dalli::Server::KSocket::UNIX
  include ::Dalli::Server::KSocket
  include ::Dalli::Server::KSocket::InstanceMethods
  def options(); end

  def options=(options); end

  def server(); end

  def server=(server); end
end

class Dalli::Server::KSocket::UNIX
  def self.open(path, server, options=T.unsafe(nil)); end
end

module Dalli::Server::KSocket
  extend ::T::Sig
  def self.included(receiver); end
end

class Dalli::Server::NilObject
end

class Dalli::Server::NilObject
end

module Dalli::Server::TCPSocketOptions
  def setsockopts(sock, options); end
end

module Dalli::Server::TCPSocketOptions
  extend ::T::Sig
end

class Dalli::Server
end

module Dalli::Threadsafe
  def alive?(); end

  def close(); end

  def init_threadsafe(); end

  def lock!(); end

  def multi_response_abort(); end

  def multi_response_nonblock(); end

  def multi_response_start(); end

  def request(op, *args); end

  def unlock!(); end
end

module Dalli::Threadsafe
  extend ::T::Sig
  def self.extended(obj); end
end

class Dalli::UnmarshalError
end

class Dalli::UnmarshalError
end

class Dalli::ValueOverMaxSize
end

class Dalli::ValueOverMaxSize
end

module Dalli
  extend ::T::Sig
  def self.default_logger(); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.rails_logger(); end
end

module Danger
  DESCRIPTION = ::T.let(nil, ::T.untyped)
  GEM_NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Danger::Bitrise
  def initialize(env); end
end

class Danger::Bitrise
  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Buddybuild
  def initialize(env); end
end

class Danger::Buddybuild
  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Buildkite
  def initialize(env); end
end

class Danger::Buildkite
  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::CI
  def initialize(_env); end

  def pull_request_id(); end

  def pull_request_id=(pull_request_id); end

  def repo_slug(); end

  def repo_slug=(repo_slug); end

  def repo_url(); end

  def repo_url=(repo_url); end

  def supported_request_sources(); end

  def supported_request_sources=(supported_request_sources); end

  def supports?(request_source); end
end

class Danger::CI
  def self.available_ci_sources(); end

  def self.inherited(child_class); end

  def self.validates_as_ci?(_env); end

  def self.validates_as_pr?(_env); end
end

class Danger::CIDocs
end

class Danger::CIDocs
end

class Danger::CircleAPI
  def client(); end

  def fetch_build(repo_slug, build_number, token); end

  def fetch_pull_request_url(repo_slug, build_number, token); end

  def pull_request?(env); end

  def pull_request_url(env); end
end

class Danger::CircleAPI
end

class Danger::CircleCI
  def initialize(env); end
end

class Danger::CircleCI
  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Codeship
  def initialize(env); end
end

class Danger::Codeship
  def self.owner_for_github(env); end

  def self.pr_from_env(env); end

  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Comment
  def body(); end

  def generated_by_danger?(danger_id); end

  def id(); end

  def initialize(id, body); end
end

class Danger::Comment
  def self.from_github(comment); end

  def self.from_gitlab(comment); end
end

class Danger::DSLError
  def contents(); end

  def description(); end

  def dsl_path(); end

  def initialize(description, dsl_path, backtrace, contents=T.unsafe(nil)); end

  def to_markdown(); end
end

class Danger::DSLError
end

class Danger::Dangerfile
  include ::Danger::Dangerfile::DSL
  def core_dsl_attributes(); end

  def defined_in_file(); end

  def defined_in_file=(defined_in_file); end

  def env=(env); end

  def external_dsl_attributes(); end

  def fail(*args, &blk); end

  def failed?(); end

  def init_plugins(); end

  def initialize(env_manager, cork_board=T.unsafe(nil)); end

  def method_missing(method_sym, *arguments, &_block); end

  def method_values_for_plugin_hashes(plugin_hashes); end

  def parse(path, contents=T.unsafe(nil)); end

  def plugins(); end

  def plugins=(plugins); end

  def post_results(danger_id, new_comment, remove_previous_comments); end

  def print_known_info(); end

  def print_results(); end

  def refresh_plugins(); end

  def run(base_branch, head_branch, dangerfile_path, danger_id, new_comment, remove_previous_comments); end

  def setup_for_running(base_branch, head_branch); end

  def ui(); end

  def ui=(ui); end

  def verbose(); end

  def verbose=(verbose); end

  def warn(*args, &blk); end
end

module Danger::Dangerfile::DSL
  def env(); end

  def initialize(); end
end

module Danger::Dangerfile::DSL
  extend ::T::Sig
end

class Danger::Dangerfile
  def self.core_plugin_classes(); end

  def self.essential_plugin_classes(); end
end

class Danger::DangerfileBitbucketCloudPlugin
  def base_commit(); end

  def branch_for_base(); end

  def branch_for_head(); end

  def head_commit(); end

  def html_link(paths, full_path: T.unsafe(nil)); end

  def markdown_link(paths, full_path: T.unsafe(nil)); end

  def pr_author(); end

  def pr_body(); end

  def pr_description(); end

  def pr_json(); end

  def pr_link(); end

  def pr_title(); end
end

class Danger::DangerfileBitbucketCloudPlugin
  def self.new(dangerfile); end
end

class Danger::DangerfileBitbucketServerPlugin
  def base_commit(); end

  def branch_for_base(); end

  def branch_for_head(); end

  def head_commit(); end

  def html_link(paths, full_path: T.unsafe(nil)); end

  def markdown_link(paths, full_path: T.unsafe(nil)); end

  def pr_author(); end

  def pr_body(); end

  def pr_description(); end

  def pr_json(); end

  def pr_link(); end

  def pr_title(); end
end

class Danger::DangerfileBitbucketServerPlugin
  def self.new(dangerfile); end
end

class Danger::DangerfileCommand
end

class Danger::DangerfileCommand
end

class Danger::DangerfileDangerPlugin
  def import_dangerfile(opts); end

  def import_plugin(path_or_url); end

  def scm_provider(); end
end

class Danger::DangerfileDangerPlugin
end

class Danger::DangerfileGem
end

class Danger::DangerfileGem
end

class Danger::DangerfileGenerator
end

class Danger::DangerfileGenerator
  def self.create_dangerfile(_path, _ui); end
end

class Danger::DangerfileGitHubPlugin
  def api(); end

  def base_commit(); end

  def branch_for_base(); end

  def branch_for_head(); end

  def dismiss_out_of_range_messages(dismiss=T.unsafe(nil)); end

  def head_commit(); end

  def html_link(paths, full_path: T.unsafe(nil)); end

  def mr_author(); end

  def mr_body(); end

  def mr_json(); end

  def mr_labels(); end

  def mr_title(); end

  def pr_author(); end

  def pr_body(); end

  def pr_diff(); end

  def pr_json(); end

  def pr_labels(); end

  def pr_title(); end

  def review(); end
end

class Danger::DangerfileGitHubPlugin
  def self.new(dangerfile); end
end

class Danger::DangerfileGitLabPlugin
  def api(); end

  def base_commit(); end

  def branch_for_base(); end

  def branch_for_head(); end

  def branch_for_merge(); end

  def head_commit(); end

  def html_link(paths, full_path: T.unsafe(nil)); end

  def mr_author(); end

  def mr_body(); end

  def mr_diff(); end

  def mr_json(); end

  def mr_labels(); end

  def mr_title(); end

  def pr_author(); end

  def pr_body(); end

  def pr_diff(); end

  def pr_json(); end

  def pr_labels(); end

  def pr_title(); end
end

class Danger::DangerfileGitLabPlugin
  def self.new(dangerfile); end
end

class Danger::DangerfileGitPlugin
  def added_files(); end

  def commits(); end

  def deleted_files(); end

  def deletions(); end

  def diff(); end

  def diff_for_file(file); end

  def info_for_file(file); end

  def insertions(); end

  def lines_of_code(); end

  def modified_files(); end

  def renamed_files(); end
end

class Danger::DangerfileGitPlugin
end

class Danger::DangerfileInit
end

class Danger::DangerfileInit
end

class Danger::DangerfileLocalOnlyPlugin
end

class Danger::DangerfileLocalOnlyPlugin
  def self.new(dangerfile); end
end

class Danger::DangerfileMessagingPlugin
  def fail(*failures, **options); end

  def failure(*failures, **options); end

  def markdown(*markdowns, **options); end

  def message(*messages, **options); end

  def status_report(); end

  def violation_report(); end

  def warn(*warnings, **options); end
end

class Danger::DangerfileMessagingPlugin
end

class Danger::DangerfileVSTSPlugin
  def base_commit(); end

  def branch_for_base(); end

  def branch_for_head(); end

  def head_commit(); end

  def markdown_link(paths, full_path: T.unsafe(nil)); end

  def pr_author(); end

  def pr_body(); end

  def pr_description(); end

  def pr_json(); end

  def pr_link(); end

  def pr_title(); end
end

class Danger::DangerfileVSTSPlugin
  def self.new(dangerfile); end
end

class Danger::DotCi
  def initialize(env); end
end

class Danger::DotCi
  def self.pull_request_id(env); end

  def self.repo_url(env); end

  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Drone
  def initialize(env); end
end

class Danger::Drone
  def self.validates_as_ci?(env); end

  def self.validates_as_ci_post_06?(env); end

  def self.validates_as_ci_pre_06?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::DryRun
end

class Danger::DryRun
end

class Danger::EmojiMapper
  def initialize(template); end

  def map(emoji); end
  DATA = ::T.let(nil, ::T.untyped)
end

class Danger::EmojiMapper
end

class Danger::EnvironmentManager
  def ci_source(); end

  def ci_source=(ci_source); end

  def clean_up(); end

  def ensure_danger_branches_are_setup(); end

  def fill_environment_vars(); end

  def initialize(env, ui=T.unsafe(nil)); end

  def meta_info_for_base(); end

  def meta_info_for_head(); end

  def pr?(); end

  def raise_error_for_no_request_source(env, ui); end

  def request_source(); end

  def request_source=(request_source); end

  def scm(); end

  def scm=(scm); end

  def ui(); end

  def ui=(ui); end
end

class Danger::EnvironmentManager
  def self.danger_base_branch(); end

  def self.danger_head_branch(); end

  def self.local_ci_source(env); end

  def self.pr?(env); end
end

class Danger::Executor
  def initialize(system_env); end

  def run(env: T.unsafe(nil), dm: T.unsafe(nil), cork: T.unsafe(nil), base: T.unsafe(nil), head: T.unsafe(nil), dangerfile_path: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), fail_on_errors: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end

  def validate!(cork); end
end

class Danger::Executor
end

class Danger::FileList
  include ::Danger::Helpers::ArraySubclass
  include ::Comparable
  def include?(pattern); end
end

class Danger::FileList
end

class Danger::FindRepoInfoFromLogs
  def call(); end

  def initialize(github_host, remote_logs); end
end

class Danger::FindRepoInfoFromLogs
end

class Danger::FindRepoInfoFromURL
  def call(); end

  def initialize(url); end
  REGEXP = ::T.let(nil, ::T.untyped)
end

class Danger::FindRepoInfoFromURL
end

class Danger::GemsResolver
  def call(); end

  def initialize(gem_names); end
end

class Danger::GemsResolver
end

class Danger::GitLabCI
  def initialize(env); end

  def project_url(); end
end

class Danger::GitLabCI
  def self.determine_merge_request_id(env); end

  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::GitRepo
  def diff(); end

  def diff=(diff); end

  def diff_for_folder(folder, from: T.unsafe(nil), to: T.unsafe(nil)); end

  def ensure_commitish_exists!(commitish); end

  def ensure_commitish_exists_on_branch!(branch, commitish); end

  def exec(string); end

  def folder(); end

  def folder=(folder); end

  def head_commit(); end

  def log(); end

  def log=(log); end

  def origins(); end

  def renamed_files(); end
end

class Danger::GitRepo
end

class Danger::HTTPCache
  def delete(key); end

  def entry_has_expired(entry, ttl); end

  def expires_in(); end

  def initialize(cache_file=T.unsafe(nil), options=T.unsafe(nil)); end

  def read(key); end

  def write(key, value); end
end

class Danger::HTTPCache
end

module Danger::Helpers
end

module Danger::Helpers::ArraySubclass
  include ::Comparable
  def initialize(array); end

  def kind_of?(compare_class); end

  def method_missing(name, *args, &block); end

  def to_a(); end

  def to_ary(); end
end

module Danger::Helpers::ArraySubclass
  extend ::T::Sig
end

module Danger::Helpers::CommentsHelper
  include ::Danger::Helpers::CommentsParsingHelper
  def apply_template(tables: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), template: T.unsafe(nil)); end

  def generate_comment(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), previous_violations: T.unsafe(nil), danger_id: T.unsafe(nil), template: T.unsafe(nil)); end

  def generate_description(warnings: T.unsafe(nil), errors: T.unsafe(nil)); end

  def generate_inline_comment_body(emoji, message, danger_id: T.unsafe(nil), resolved: T.unsafe(nil), template: T.unsafe(nil)); end

  def generate_inline_markdown_body(markdown, danger_id: T.unsafe(nil), template: T.unsafe(nil)); end

  def markdown_link_to_message(message, _); end

  def markdown_parser(text); end

  def messages_are_equivalent(m1, m2); end

  def process_markdown(violation, hide_link=T.unsafe(nil)); end

  def random_compliment(); end

  def table(name, emoji, violations, all_previous_violations, template: T.unsafe(nil)); end
end

module Danger::Helpers::CommentsHelper
  extend ::T::Sig
end

module Danger::Helpers::CommentsParsingHelper
  def parse_comment(comment); end

  def parse_message_from_row(row); end

  def parse_tables_from_comment(comment); end

  def table_kind_from_title(title); end

  def violations_from_table(table); end
  GITHUB_OLD_REGEX = ::T.let(nil, ::T.untyped)
  NEW_REGEX = ::T.let(nil, ::T.untyped)
end

module Danger::Helpers::CommentsParsingHelper
  extend ::T::Sig
end

module Danger::Helpers
  extend ::T::Sig
end

class Danger::Init
  def circle_token(); end

  def considered_an_oss_repo?(); end

  def current_repo_slug(); end

  def darwin?(); end

  def info(); end

  def note_about_clicking_links(); end

  def setup_access_token(); end

  def setup_danger_ci(); end

  def setup_dangerfile(); end

  def setup_github_account(); end

  def show_todo_state(); end

  def thanks(); end

  def travis_token(); end

  def ui(); end

  def ui=(ui); end

  def unsure_ci(); end

  def unsure_token(); end

  def uses_circle(); end

  def uses_travis(); end
end

class Danger::Init
end

class Danger::Interviewer
  def ask_with_answers(question, possible_answers); end

  def green_bang(); end

  def header(title); end

  def initialize(cork_board); end

  def link(url); end

  def no_delay(); end

  def no_delay=(no_delay); end

  def no_waiting(); end

  def no_waiting=(no_waiting); end

  def pause(time); end

  def red_bang(); end

  def run_command(command, output_command=T.unsafe(nil)); end

  def say(output); end

  def show_prompt(); end

  def ui(); end

  def ui=(ui); end

  def wait_for_return(); end

  def yellow_bang(); end
end

class Danger::Interviewer
end

class Danger::Jenkins
  def initialize(env); end
end

class Danger::Jenkins::EnvNotFound
  def initialize(); end
end

class Danger::Jenkins::EnvNotFound
end

class Danger::Jenkins
  def self.pull_request_id(env); end

  def self.repo_url(env); end

  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Local
end

class Danger::Local
end

class Danger::LocalGitRepo
  def base_commit(); end

  def base_commit=(base_commit); end

  def git(); end

  def head_commit(); end

  def head_commit=(head_commit); end

  def initialize(env=T.unsafe(nil)); end

  def run_git(command); end
end

class Danger::LocalGitRepo
  def self.validates_as_ci?(env); end
end

class Danger::LocalOnlyGitRepo
  def base_commit(); end

  def base_commit=(base_commit); end

  def git(); end

  def head_commit(); end

  def head_commit=(head_commit); end

  def initialize(env=T.unsafe(nil)); end

  def run_git(command); end
  BASE_VAR = ::T.let(nil, ::T.untyped)
  HEAD_VAR = ::T.let(nil, ::T.untyped)
end

class Danger::LocalOnlyGitRepo
  def self.validates_as_ci?(env); end
end

class Danger::LocalPullRequest
  def initialize(log_line); end

  def pull_request_id(); end

  def sha(); end

  def valid?(); end
end

class Danger::LocalPullRequest
end

class Danger::LocalSetup
  def cork(); end

  def dm(); end

  def initialize(dangerfile, cork); end

  def setup(verbose: T.unsafe(nil)); end
end

class Danger::LocalSetup
end

class Danger::Markdown
  def ==(other); end

  def eql?(other); end

  def file(); end

  def file=(file); end

  def initialize(message, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def inline?(); end

  def line(); end

  def line=(line); end

  def message(); end

  def message=(message); end
end

class Danger::Markdown
end

class Danger::NoPullRequest
  def valid?(); end
end

class Danger::NoPullRequest
end

class Danger::NoRepoInfo
  def id(); end

  def slug(); end
end

class Danger::NoRepoInfo
end

class Danger::PR
end

class Danger::PR
end

class Danger::Plugin
  def initialize(dangerfile); end

  def method_missing(method_sym, *arguments, &block); end
end

class Danger::Plugin
  def self.all_plugins(); end

  def self.clear_external_plugins(); end

  def self.inherited(plugin); end

  def self.instance_name(); end
end

class Danger::PluginFileResolver
  def initialize(references); end

  def resolve(); end
end

class Danger::PluginFileResolver
end

class Danger::PluginJSON
  def cork(); end

  def cork=(cork); end
end

class Danger::PluginJSON
end

class Danger::PluginLint
  def cork(); end

  def cork=(cork); end
end

class Danger::PluginLint
end

class Danger::PluginLinter
  def errors(); end

  def errors=(errors); end

  def failed?(); end

  def initialize(json); end

  def json(); end

  def json=(json); end

  def lint(); end

  def print_summary(ui); end

  def warnings(); end

  def warnings=(warnings); end
end

class Danger::PluginLinter::Rule
  def description(); end

  def description=(description); end

  def function(); end

  def function=(function); end

  def initialize(modifier, ref, title, description, function); end

  def metadata(); end

  def metadata=(metadata); end

  def modifier(); end

  def modifier=(modifier); end

  def object_applied_to(); end

  def ref(); end

  def ref=(ref); end

  def title(); end

  def title=(title); end

  def type(); end

  def type=(type); end
end

class Danger::PluginLinter::Rule
end

class Danger::PluginLinter
end

class Danger::PluginParser
  def attribute_parser(gem_path, attribute); end

  def classes_in_file(); end

  def initialize(paths, verbose=T.unsafe(nil)); end

  def method_params(method); end

  def method_parser(gem_path, meth); end

  def method_return_string(meth); end

  def parse(); end

  def plugins_from_classes(classes); end

  def registry(); end

  def registry=(registry); end

  def setup_yard(verbose); end

  def to_h(classes); end

  def to_json(); end

  def to_json_string(); end
end

class Danger::PluginParser
end

class Danger::PluginReadme
  def cork(); end

  def cork=(cork); end

  def json(); end

  def json=(json); end

  def markdown(); end

  def markdown=(markdown); end
end

class Danger::PluginReadme
end

class Danger::PrySetup
  def initialize(cork); end

  def setup_pry(dangerfile_path); end
  DANGERFILE_COPY = ::T.let(nil, ::T.untyped)
end

class Danger::PrySetup
end

class Danger::PullRequestFinder
  def call(); end

  def initialize(specific_pull_request_id, repo_slug=T.unsafe(nil), remote: T.unsafe(nil), git_logs: T.unsafe(nil)); end
end

class Danger::PullRequestFinder
end

class Danger::RemotePullRequest
  def base(); end

  def head(); end

  def initialize(pull_request_id, head, base); end

  def pull_request_id(); end

  def sha(); end

  def valid?(); end
end

class Danger::RemotePullRequest
end

class Danger::RepoInfo
  def id(); end

  def initialize(slug, id); end

  def slug(); end
end

class Danger::RepoInfo
end

module Danger::RequestSources
end

class Danger::RequestSources::BitbucketCloud
  include ::Danger::Helpers::CommentsHelper
  include ::Danger::Helpers::CommentsParsingHelper
  def delete_old_comments(danger_id: T.unsafe(nil)); end

  def initialize(ci_source, environment); end

  def pr_json(); end

  def pr_json=(pr_json); end

  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end
end

class Danger::RequestSources::BitbucketCloud
end

class Danger::RequestSources::BitbucketCloudAPI
  def credentials_given?(); end

  def delete_comment(id); end

  def fetch_last_comments(); end

  def fetch_pr_json(); end

  def initialize(repo_slug, pull_request_id, branch_name, environment); end

  def post_comment(text); end

  def project(); end

  def project=(project); end

  def pull_request_id(); end

  def pull_request_id=(pull_request_id); end

  def slug(); end

  def slug=(slug); end
end

class Danger::RequestSources::BitbucketCloudAPI
end

class Danger::RequestSources::BitbucketServer
  include ::Danger::Helpers::CommentsHelper
  include ::Danger::Helpers::CommentsParsingHelper
  def delete_old_comments(danger_id: T.unsafe(nil)); end

  def initialize(ci_source, environment); end

  def pr_json(); end

  def pr_json=(pr_json); end

  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end
end

class Danger::RequestSources::BitbucketServer
end

class Danger::RequestSources::BitbucketServerAPI
  def credentials_given?(); end

  def delete_comment(id, version); end

  def fetch_last_comments(); end

  def fetch_pr_json(); end

  def host(); end

  def host=(host); end

  def initialize(project, slug, pull_request_id, environment); end

  def post_comment(text); end

  def pr_api_endpoint(); end

  def pr_api_endpoint=(pr_api_endpoint); end
end

class Danger::RequestSources::BitbucketServerAPI
end

class Danger::RequestSources::GitHub
  include ::Danger::Helpers::CommentsHelper
  include ::Danger::Helpers::CommentsParsingHelper
  def api_url(); end

  def client(); end

  def delete_old_comments!(except: T.unsafe(nil), danger_id: T.unsafe(nil)); end

  def dismiss_out_of_range_messages(); end

  def dismiss_out_of_range_messages=(dismiss_out_of_range_messages); end

  def dismiss_out_of_range_messages_for(kind); end

  def fetch_issue_details(pr_json); end

  def file_url(organisation: T.unsafe(nil), repository: T.unsafe(nil), branch: T.unsafe(nil), path: T.unsafe(nil)); end

  def find_position_in_diff(diff_lines, message, kind); end

  def get_pr_from_branch(repo_name, branch_name, owner); end

  def ignored_violations_from_pr(); end

  def initialize(ci_source, environment); end

  def issue_comments(); end

  def issue_json(); end

  def issue_json=(issue_json); end

  def markdown_link_to_message(message, hide_link); end

  def pr_diff(); end

  def pr_json(); end

  def pr_json=(pr_json); end

  def review(); end

  def submit_inline_comments!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), previous_violations: T.unsafe(nil), danger_id: T.unsafe(nil)); end

  def submit_inline_comments_for_kind!(kind, messages, diff_lines, danger_comments, previous_violations, danger_id: T.unsafe(nil)); end

  def submit_pull_request_status!(warnings: T.unsafe(nil), errors: T.unsafe(nil), details_url: T.unsafe(nil), danger_id: T.unsafe(nil)); end

  def support_tokenless_auth(); end

  def support_tokenless_auth=(support_tokenless_auth); end

  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end

  def verify_ssl(); end
end

class Danger::RequestSources::GitHub
end

module Danger::RequestSources::GitHubSource
end

class Danger::RequestSources::GitHubSource::Review
  include ::Danger::Helpers::CommentsHelper
  include ::Danger::Helpers::CommentsParsingHelper
  def body(); end

  def fail(message, sticky=T.unsafe(nil), file=T.unsafe(nil), line=T.unsafe(nil)); end

  def generated_by_danger?(danger_id=T.unsafe(nil)); end

  def id(); end

  def initialize(client, ci_source, review_json=T.unsafe(nil)); end

  def markdown(message, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def message(message, sticky=T.unsafe(nil), file=T.unsafe(nil), line=T.unsafe(nil)); end

  def review_json(); end

  def start(); end

  def status(); end

  def submit(); end

  def warn(message, sticky=T.unsafe(nil), file=T.unsafe(nil), line=T.unsafe(nil)); end
  EVENT_APPROVE = ::T.let(nil, ::T.untyped)
  EVENT_COMMENT = ::T.let(nil, ::T.untyped)
  EVENT_REQUEST_CHANGES = ::T.let(nil, ::T.untyped)
  STATUS_APPROVED = ::T.let(nil, ::T.untyped)
  STATUS_COMMENTED = ::T.let(nil, ::T.untyped)
  STATUS_PENDING = ::T.let(nil, ::T.untyped)
  STATUS_REQUESTED_CHANGES = ::T.let(nil, ::T.untyped)
end

class Danger::RequestSources::GitHubSource::Review
end

class Danger::RequestSources::GitHubSource::ReviewResolver
end

class Danger::RequestSources::GitHubSource::ReviewResolver
  def self.same_body?(body1, body2); end

  def self.should_submit?(review, body); end
end

class Danger::RequestSources::GitHubSource::ReviewUnsupported
  def body(); end

  def fail(message, sticky=T.unsafe(nil), file=T.unsafe(nil), line=T.unsafe(nil)); end

  def id(); end

  def markdown(message, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def message(message, sticky=T.unsafe(nil), file=T.unsafe(nil), line=T.unsafe(nil)); end

  def review_json(); end

  def start(); end

  def status(); end

  def submit(); end

  def warn(message, sticky=T.unsafe(nil), file=T.unsafe(nil), line=T.unsafe(nil)); end
end

class Danger::RequestSources::GitHubSource::ReviewUnsupported
end

module Danger::RequestSources::GitHubSource
  extend ::T::Sig
end

class Danger::RequestSources::GitLab
  include ::Danger::Helpers::CommentsHelper
  include ::Danger::Helpers::CommentsParsingHelper
  def base_commit(); end

  def client(); end

  def commits_json(); end

  def commits_json=(commits_json); end

  def delete_old_comments!(except: T.unsafe(nil), danger_id: T.unsafe(nil)); end

  def endpoint(); end

  def file_url(organisation: T.unsafe(nil), repository: T.unsafe(nil), branch: T.unsafe(nil), path: T.unsafe(nil)); end

  def ignored_violations_from_pr(); end

  def initialize(ci_source, environment); end

  def mr_comments(); end

  def mr_diff(); end

  def mr_json(); end

  def mr_json=(mr_json); end

  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end
end

class Danger::RequestSources::GitLab
end

class Danger::RequestSources::LocalOnly
  include ::Danger::Helpers::CommentsHelper
  include ::Danger::Helpers::CommentsParsingHelper
  def commits_json(); end

  def commits_json=(commits_json); end

  def initialize(ci_source, environment); end

  def mr_json(); end

  def mr_json=(mr_json); end

  def update_pull_request!(_hash_needed); end
end

class Danger::RequestSources::LocalOnly
end

class Danger::RequestSources::RequestSource
  def ci_source(); end

  def ci_source=(ci_source); end

  def environment(); end

  def environment=(environment); end

  def fetch_details(); end

  def file_url(_organisation: T.unsafe(nil), _repository: T.unsafe(nil), _branch: T.unsafe(nil), _path: T.unsafe(nil)); end

  def host(); end

  def host=(host); end

  def ignored_violations(); end

  def ignored_violations=(ignored_violations); end

  def initialize(_ci_source, _environment); end

  def organisation(); end

  def scm(); end

  def scm=(scm); end

  def setup_danger_branches(); end

  def update_pull_request!(_warnings: T.unsafe(nil), _errors: T.unsafe(nil), _messages: T.unsafe(nil), _markdowns: T.unsafe(nil)); end

  def validates_as_api_source?(); end

  def validates_as_ci?(); end
  DANGER_REPO_NAME = ::T.let(nil, ::T.untyped)
end

class Danger::RequestSources::RequestSource
  def self.available_request_sources(); end

  def self.available_source_names_and_envs(); end

  def self.env_vars(); end

  def self.inherited(child_class); end

  def self.optional_env_vars(); end

  def self.source_name(); end
end

class Danger::RequestSources::VSTS
  include ::Danger::Helpers::CommentsHelper
  include ::Danger::Helpers::CommentsParsingHelper
  def initialize(ci_source, environment); end

  def post_new_comment(comment); end

  def pr_json(); end

  def pr_json=(pr_json); end

  def update_old_comment(new_comment, danger_id: T.unsafe(nil)); end

  def update_pull_request!(warnings: T.unsafe(nil), errors: T.unsafe(nil), messages: T.unsafe(nil), markdowns: T.unsafe(nil), danger_id: T.unsafe(nil), new_comment: T.unsafe(nil), remove_previous_comments: T.unsafe(nil)); end
end

class Danger::RequestSources::VSTS
end

class Danger::RequestSources::VSTSAPI
  def credentials_given?(); end

  def fetch_last_comments(); end

  def fetch_pr_json(); end

  def host(); end

  def host=(host); end

  def initialize(_project, slug, pull_request_id, environment); end

  def min_api_version_for_comments(); end

  def min_api_version_for_comments=(min_api_version_for_comments); end

  def post_comment(text); end

  def pr_api_endpoint(); end

  def pr_api_endpoint=(pr_api_endpoint); end

  def supports_comments?(); end

  def update_comment(thread, id, new_comment); end
end

class Danger::RequestSources::VSTSAPI
end

module Danger::RequestSources
  extend ::T::Sig
end

class Danger::Runner
  def cork(); end

  def cork=(cork); end
end

class Danger::Runner
end

class Danger::Screwdriver
  def initialize(env); end
end

class Danger::Screwdriver
  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Semaphore
  def initialize(env); end
end

class Danger::Semaphore
  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Surf
  def initialize(env); end
end

class Danger::Surf
  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Systems
end

class Danger::Systems
end

class Danger::TeamCity
  def initialize(env); end
end

class Danger::TeamCity
  def self.validates_as_bitbucket_cloud_pr?(env); end

  def self.validates_as_bitbucket_server_pr?(env); end

  def self.validates_as_ci?(env); end

  def self.validates_as_github_pr?(env); end

  def self.validates_as_gitlab_pr?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::Travis
  def initialize(env); end
end

class Danger::Travis
  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

class Danger::VSTS
  def initialize(env); end
end

class Danger::VSTS
  def self.github_slug(env); end

  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end

  def self.vsts_slug(env); end
end

class Danger::Violation
  def ==(other); end

  def eql?(other); end

  def file(); end

  def file=(file); end

  def initialize(message, sticky, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def inline?(); end

  def line(); end

  def line=(line); end

  def message(); end

  def message=(message); end

  def sticky(); end

  def sticky=(sticky); end
end

class Danger::Violation
end

class Danger::XcodeServer
  def initialize(env); end
end

class Danger::XcodeServer
  def self.validates_as_ci?(env); end

  def self.validates_as_pr?(env); end
end

module Danger
  extend ::T::Sig
  def self.danger_outdated?(); end

  def self.gem_path(); end
end

module Dante
  VERSION = ::T.let(nil, ::T.untyped)
end

class Dante::Runner
  def daemon_running?(); end

  def daemon_stopped?(); end

  def daemonize(); end

  def description(); end

  def description=(description); end

  def execute(opts=T.unsafe(nil), &block); end

  def initialize(name, defaults=T.unsafe(nil), &block); end

  def interrupt(); end

  def kill_pid(k=T.unsafe(nil)); end

  def log(message); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def parse_options(); end

  def redirect_output!(); end

  def restart(); end

  def start(); end

  def stop(kill_arg=T.unsafe(nil)); end

  def store_pid(pid); end

  def until_true(timeout_seconds, interval=T.unsafe(nil), &block); end

  def verify_options_hook(); end

  def verify_options_hook=(verify_options_hook); end

  def with_options(&block); end
  MAX_START_TRIES = ::T.let(nil, ::T.untyped)
end

class Dante::Runner
  def self.run(*args, &block); end
end

module Dante
  extend ::T::Sig
  def self.run(name, options=T.unsafe(nil), &blk); end
end

class Data
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Data
  extend ::T::Sig
end

module Datadog
  LOG_PREFIX = ::T.let(nil, ::T.untyped)
end

class Datadog::AllSampler
  def sample(span); end
end

class Datadog::AllSampler
end

module Datadog::Configurable
  IDENTITY = ::T.let(nil, ::T.untyped)
end

module Datadog::Configurable::ClassMethods
  def get_option(name); end

  def reset_options!(); end

  def set_option(name, value); end

  def sorted_options(); end

  def to_h(); end
end

module Datadog::Configurable::ClassMethods
  extend ::T::Sig
end

module Datadog::Configurable
  extend ::T::Sig
  def self.included(base); end
end

class Datadog::Configuration
  def [](integration_name, configuration_name=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def tracer(options=T.unsafe(nil)); end

  def use(integration_name, options=T.unsafe(nil), &block); end
end

class Datadog::Configuration::InvalidIntegrationError
end

class Datadog::Configuration::InvalidIntegrationError
end

class Datadog::Configuration::PinSetup
  def call(); end

  def initialize(target, opts=T.unsafe(nil)); end
end

class Datadog::Configuration::PinSetup
end

class Datadog::Configuration::Proxy
  def [](param); end

  def []=(param, value); end

  def initialize(integration); end

  def merge(*args, &block); end

  def reset_options!(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end
end

class Datadog::Configuration::Proxy
  extend ::Forwardable
end

class Datadog::Configuration::Resolver
  include ::TSort
  def call(); end

  def initialize(dependency_graph=T.unsafe(nil)); end

  def tsort_each_child(node, &blk); end

  def tsort_each_node(&blk); end
end

class Datadog::Configuration::Resolver
end

class Datadog::Configuration
end

class Datadog::Context
  def add_span(span); end

  def close_span(span); end

  def current_root_span(); end

  def current_span(); end

  def finished?(); end

  def get(); end

  def initialize(options=T.unsafe(nil)); end

  def max_length(); end

  def sampled?(); end

  def sampling_priority(); end

  def sampling_priority=(priority); end

  def span_id(); end

  def trace_id(); end
  DEFAULT_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class Datadog::Context
end

class Datadog::ContextFlush
  def each_partial_trace(context); end

  def initialize(options=T.unsafe(nil)); end
end

class Datadog::ContextFlush
end

module Datadog::Contrib
end

module Datadog::Contrib::ActiveModelSerializers
end

module Datadog::Contrib::ActiveModelSerializers::Event
end

module Datadog::Contrib::ActiveModelSerializers::Event::ClassMethods
  def configuration(); end

  def process(span, event, _id, payload); end

  def span_options(); end

  def tracer(); end
end

module Datadog::Contrib::ActiveModelSerializers::Event::ClassMethods
  extend ::T::Sig
end

module Datadog::Contrib::ActiveModelSerializers::Event
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::ActiveModelSerializers::Events
  ALL = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::ActiveModelSerializers::Events::Render
  include ::Datadog::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Subscriber
  EVENT_NAME = ::T.let(nil, ::T.untyped)
  SPAN_NAME = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::ActiveModelSerializers::Events::Render
  extend ::Datadog::Contrib::ActiveModelSerializers::Event::ClassMethods
  extend ::T::Sig
  def self.event_name(); end

  def self.span_name(); end
end

module Datadog::Contrib::ActiveModelSerializers::Events::Serialize
  include ::Datadog::Contrib::ActiveModelSerializers::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Subscriber
  EVENT_NAME = ::T.let(nil, ::T.untyped)
  SPAN_NAME = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::ActiveModelSerializers::Events::Serialize
  extend ::Datadog::Contrib::ActiveModelSerializers::Event::ClassMethods
  extend ::T::Sig
  def self.event_name(); end

  def self.span_name(); end
end

module Datadog::Contrib::ActiveModelSerializers::Events
  extend ::T::Sig
  def self.all(); end

  def self.subscribe!(); end

  def self.subscriptions(); end
end

module Datadog::Contrib::ActiveModelSerializers::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  VERSION_REQUIRED = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::ActiveModelSerializers::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patched?(); end
end

module Datadog::Contrib::ActiveModelSerializers
  extend ::T::Sig
end

module Datadog::Contrib::ActiveRecord
end

module Datadog::Contrib::ActiveRecord::Configuration
end

class Datadog::Contrib::ActiveRecord::Configuration::Resolver
  def configurations(); end

  def connection_resolver(); end

  def initialize(configurations=T.unsafe(nil)); end

  def normalize(hash); end

  def resolve(spec); end
end

class Datadog::Contrib::ActiveRecord::Configuration::Resolver
end

class Datadog::Contrib::ActiveRecord::Configuration::Settings
  def orm_service_name(); end

  def orm_service_name=(value); end
end

class Datadog::Contrib::ActiveRecord::Configuration::Settings
end

module Datadog::Contrib::ActiveRecord::Configuration
  extend ::T::Sig
end

module Datadog::Contrib::ActiveRecord::Event
end

module Datadog::Contrib::ActiveRecord::Event::ClassMethods
  def configuration(); end

  def span_options(); end

  def tracer(); end
end

module Datadog::Contrib::ActiveRecord::Event::ClassMethods
  extend ::T::Sig
end

module Datadog::Contrib::ActiveRecord::Event
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::ActiveRecord::Events
  ALL = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::ActiveRecord::Events::Instantiation
  include ::Datadog::Contrib::ActiveRecord::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Subscriber
  DEFAULT_SERVICE_NAME = ::T.let(nil, ::T.untyped)
  EVENT_NAME = ::T.let(nil, ::T.untyped)
  SPAN_NAME = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::ActiveRecord::Events::Instantiation
  extend ::Datadog::Contrib::ActiveRecord::Event::ClassMethods
  extend ::T::Sig
  def self.event_name(); end

  def self.process(span, event, _id, payload); end

  def self.span_name(); end
end

module Datadog::Contrib::ActiveRecord::Events::SQL
  include ::Datadog::Contrib::ActiveRecord::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Subscriber
  EVENT_NAME = ::T.let(nil, ::T.untyped)
  SPAN_NAME = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::ActiveRecord::Events::SQL
  extend ::Datadog::Contrib::ActiveRecord::Event::ClassMethods
  extend ::T::Sig
  def self.event_name(); end

  def self.process(span, event, _id, payload); end

  def self.span_name(); end
end

module Datadog::Contrib::ActiveRecord::Events
  extend ::T::Sig
  def self.all(); end

  def self.subscribe!(); end

  def self.subscriptions(); end
end

class Datadog::Contrib::ActiveRecord::Integration
  include ::Datadog::Contrib::Integration
  include ::Datadog::Contrib::Configurable
  include ::Datadog::Contrib::Configurable::InstanceMethods
  include ::Datadog::Contrib::Patchable
  include ::Datadog::Contrib::Patchable::InstanceMethods
  include ::Datadog::Contrib::Registerable
  include ::Datadog::Contrib::Registerable::InstanceMethods
end

class Datadog::Contrib::ActiveRecord::Integration
  extend ::Datadog::Contrib::Patchable::ClassMethods
  extend ::Datadog::Contrib::Registerable::ClassMethods
end

module Datadog::Contrib::ActiveRecord::Patcher
  include ::Datadog::Contrib::Patcher
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  include ::Datadog::Contrib::Patcher::InstanceMethods
end

module Datadog::Contrib::ActiveRecord::Patcher
  extend ::Datadog::Patcher::CommonMethods
  extend ::Datadog::Contrib::Patcher::InstanceMethods
  extend ::T::Sig
  def self.patched?(); end
end

module Datadog::Contrib::ActiveRecord::Utils
end

module Datadog::Contrib::ActiveRecord::Utils
  extend ::T::Sig
  def self.adapter_host(); end

  def self.adapter_name(); end

  def self.adapter_port(); end

  def self.connection_by_id(object_id); end

  def self.connection_config(object_id=T.unsafe(nil)); end

  def self.connection_config_by_id(object_id); end

  def self.database_name(); end

  def self.default_connection_config(); end
end

module Datadog::Contrib::ActiveRecord
  extend ::T::Sig
end

module Datadog::Contrib::ActiveSupport
end

module Datadog::Contrib::ActiveSupport::Notifications
end

module Datadog::Contrib::ActiveSupport::Notifications::Event
end

module Datadog::Contrib::ActiveSupport::Notifications::Event
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::ActiveSupport::Notifications::Subscriber
end

module Datadog::Contrib::ActiveSupport::Notifications::Subscriber
  extend ::T::Sig
  def self.included(base); end
end

class Datadog::Contrib::ActiveSupport::Notifications::Subscription
  def after_trace(&block); end

  def before_trace(&block); end

  def call(name, start, finish, id, payload); end

  def callbacks(); end

  def finish(name, id, payload); end

  def finish_span(name, id, payload, finish=T.unsafe(nil)); end

  def handler(); end

  def initialize(tracer, span_name, options, &block); end

  def options(); end

  def options=(options); end

  def span_name(); end

  def span_name=(span_name); end

  def start(name, id, payload); end

  def start_span(name, id, payload, start=T.unsafe(nil)); end

  def subscribe(pattern); end

  def subscribers(); end

  def tracer(); end

  def tracer=(tracer); end

  def unsubscribe(pattern); end

  def unsubscribe_all(); end
end

class Datadog::Contrib::ActiveSupport::Notifications::Subscription::Callbacks
  def add(key, &block); end

  def blocks(); end

  def run(event, key, *args); end
end

class Datadog::Contrib::ActiveSupport::Notifications::Subscription::Callbacks
end

class Datadog::Contrib::ActiveSupport::Notifications::Subscription::Handler
  def block(); end

  def initialize(&block); end

  def run(span, name, id, payload); end

  def run!(*args); end
end

class Datadog::Contrib::ActiveSupport::Notifications::Subscription::Handler
end

class Datadog::Contrib::ActiveSupport::Notifications::Subscription
end

module Datadog::Contrib::ActiveSupport::Notifications
  extend ::T::Sig
end

module Datadog::Contrib::ActiveSupport
  extend ::T::Sig
end

module Datadog::Contrib::Aws
  AGENT = ::T.let(nil, ::T.untyped)
  RESOURCE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Aws::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Aws::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patched?(); end
end

module Datadog::Contrib::Aws
  extend ::T::Sig
end

module Datadog::Contrib::Base
end

module Datadog::Contrib::Base
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::ConcurrentRuby
end

module Datadog::Contrib::ConcurrentRuby::Configuration
end

class Datadog::Contrib::ConcurrentRuby::Configuration::Settings
end

class Datadog::Contrib::ConcurrentRuby::Configuration::Settings
end

module Datadog::Contrib::ConcurrentRuby::Configuration
  extend ::T::Sig
end

class Datadog::Contrib::ConcurrentRuby::Integration
  include ::Datadog::Contrib::Integration
  include ::Datadog::Contrib::Configurable
  include ::Datadog::Contrib::Configurable::InstanceMethods
  include ::Datadog::Contrib::Patchable
  include ::Datadog::Contrib::Patchable::InstanceMethods
  include ::Datadog::Contrib::Registerable
  include ::Datadog::Contrib::Registerable::InstanceMethods
end

class Datadog::Contrib::ConcurrentRuby::Integration
  extend ::Datadog::Contrib::Patchable::ClassMethods
  extend ::Datadog::Contrib::Registerable::ClassMethods
end

module Datadog::Contrib::ConcurrentRuby::Patcher
  include ::Datadog::Contrib::Patcher
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  include ::Datadog::Contrib::Patcher::InstanceMethods
end

module Datadog::Contrib::ConcurrentRuby::Patcher
  extend ::Datadog::Patcher::CommonMethods
  extend ::Datadog::Contrib::Patcher::InstanceMethods
  extend ::T::Sig
  def self.patch_future(); end

  def self.patched?(); end
end

module Datadog::Contrib::ConcurrentRuby
  extend ::T::Sig
end

module Datadog::Contrib::Configurable
end

module Datadog::Contrib::Configurable::InstanceMethods
  def configuration(name=T.unsafe(nil)); end

  def configurations(); end

  def configure(name, options=T.unsafe(nil), &block); end

  def default_configuration(); end

  def reset_configuration!(); end

  def resolver(); end

  def resolver=(resolver); end
end

module Datadog::Contrib::Configurable::InstanceMethods
  extend ::T::Sig
end

module Datadog::Contrib::Configurable
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::Configuration
end

class Datadog::Contrib::Configuration::Option
  def definition(); end

  def get(); end

  def initialize(definition, context); end

  def reset(); end

  def set(value); end
end

class Datadog::Contrib::Configuration::Option
end

class Datadog::Contrib::Configuration::OptionDefinition
  def default(); end

  def default_value(); end

  def depends_on(); end

  def initialize(name, meta=T.unsafe(nil), &block); end

  def lazy(); end

  def name(); end

  def setter(); end
  IDENTITY = ::T.let(nil, ::T.untyped)
end

class Datadog::Contrib::Configuration::OptionDefinition
end

class Datadog::Contrib::Configuration::OptionDefinitionSet
  def dependency_graph(); end

  def dependency_order(); end
end

class Datadog::Contrib::Configuration::OptionDefinitionSet
end

class Datadog::Contrib::Configuration::OptionSet
end

class Datadog::Contrib::Configuration::OptionSet
end

module Datadog::Contrib::Configuration::Options
end

module Datadog::Contrib::Configuration::Options::InstanceMethods
  def get_option(name); end

  def options(); end

  def reset_options!(); end

  def set_option(name, value); end

  def to_h(); end
end

module Datadog::Contrib::Configuration::Options::InstanceMethods
  extend ::T::Sig
end

module Datadog::Contrib::Configuration::Options
  extend ::T::Sig
  def self.included(base); end
end

class Datadog::Contrib::Configuration::Resolver
  def resolve(name); end
end

class Datadog::Contrib::Configuration::Resolver
end

class Datadog::Contrib::Configuration::Settings
  include ::Datadog::Contrib::Configuration::Options
  include ::Datadog::Contrib::Configuration::Options::InstanceMethods
  def [](name); end

  def []=(name, value); end

  def configure(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def service_name(); end

  def service_name=(value); end

  def tracer(); end

  def tracer=(value); end
end

class Datadog::Contrib::Configuration::Settings
end

module Datadog::Contrib::Configuration
  extend ::T::Sig
end

module Datadog::Contrib::Dalli
  CMD_TAG = ::T.let(nil, ::T.untyped)
  COMPATIBLE_WITH = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Dalli::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Dalli::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patched?(); end
end

module Datadog::Contrib::Dalli
  extend ::T::Sig
end

module Datadog::Contrib::DelayedJob
end

module Datadog::Contrib::DelayedJob::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::DelayedJob::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patched?(); end
end

module Datadog::Contrib::DelayedJob
  extend ::T::Sig
end

module Datadog::Contrib::Elasticsearch
  BODY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  PARAMS = ::T.let(nil, ::T.untyped)
  SERVICE = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Elasticsearch::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Elasticsearch::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patch_elasticsearch_transport_client(); end

  def self.patched?(); end
end

module Datadog::Contrib::Elasticsearch
  extend ::T::Sig
end

module Datadog::Contrib::Excon
end

module Datadog::Contrib::Excon::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  DEFAULT_SERVICE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Excon::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.add_middleware(); end

  def self.compatible?(); end

  def self.patch(); end

  def self.patched?(); end
end

module Datadog::Contrib::Excon
  extend ::T::Sig
end

module Datadog::Contrib::Faraday
  COMPATIBLE_UNTIL = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  SERVICE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Faraday::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  DEFAULT_ERROR_HANDLER = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Faraday::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patched?(); end

  def self.register_service(name); end
end

module Datadog::Contrib::Faraday
  extend ::T::Sig
end

module Datadog::Contrib::GRPC
  SERVICE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::GRPC::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::GRPC::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.add_pin(); end

  def self.compatible?(); end

  def self.patch(); end

  def self.patched?(); end

  def self.prepend_interceptor(); end
end

module Datadog::Contrib::GRPC
  extend ::T::Sig
end

module Datadog::Contrib::Grape
  SERVICE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Grape::Endpoint
  KEY_RENDER = ::T.let(nil, ::T.untyped)
  KEY_RUN = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Grape::Endpoint
  extend ::T::Sig
  def self.endpoint_render(name, start, finish, id, payload); end

  def self.endpoint_run(name, start, finish, id, payload); end

  def self.endpoint_run_filters(name, start, finish, id, payload); end

  def self.endpoint_start_process(*_); end

  def self.endpoint_start_render(*_); end

  def self.subscribe(); end
end

module Datadog::Contrib::Grape::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Grape::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patch_endpoint_render(); end

  def self.patch_endpoint_run(); end

  def self.patched?(); end
end

module Datadog::Contrib::Grape
  extend ::T::Sig
end

module Datadog::Contrib::GraphQL
end

module Datadog::Contrib::GraphQL::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::GraphQL::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patch_schema!(schema); end

  def self.patched?(); end
end

module Datadog::Contrib::GraphQL
  extend ::T::Sig
end

module Datadog::Contrib::HTTP
  APP = ::T.let(nil, ::T.untyped)
  BODY = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  SERVICE = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::HTTP::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::HTTP::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patch_http(); end

  def self.patched?(); end
end

module Datadog::Contrib::HTTP
  extend ::T::Sig
  def self.should_skip_distributed_tracing?(pin); end

  def self.should_skip_tracing?(req, address, port, transport, pin); end
end

module Datadog::Contrib::Integration
end

module Datadog::Contrib::Integration
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::MongoDB
  APP = ::T.let(nil, ::T.untyped)
  SERVICE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::MongoDB::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::MongoDB::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.add_mongo_monitoring(); end

  def self.patch(); end

  def self.patch_mongo_client(); end

  def self.patched?(); end
end

module Datadog::Contrib::MongoDB
  extend ::T::Sig
end

module Datadog::Contrib::Mysql2
end

module Datadog::Contrib::Mysql2::Client
end

module Datadog::Contrib::Mysql2::Client::InstanceMethods
  def datadog_pin(); end

  def query(sql, options=T.unsafe(nil)); end
end

module Datadog::Contrib::Mysql2::Client::InstanceMethods
  extend ::T::Sig
end

module Datadog::Contrib::Mysql2::Client::InstanceMethodsCompatibility
  def query(*args); end
end

module Datadog::Contrib::Mysql2::Client::InstanceMethodsCompatibility
  extend ::T::Sig
end

module Datadog::Contrib::Mysql2::Client
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::Mysql2::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Mysql2::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.compatible?(); end

  def self.patch(); end

  def self.patch_mysql2_client(); end

  def self.patched?(); end
end

module Datadog::Contrib::Mysql2
  extend ::T::Sig
end

module Datadog::Contrib::Patchable
end

module Datadog::Contrib::Patchable::ClassMethods
  def compatible?(); end

  def present?(); end

  def version(); end
end

module Datadog::Contrib::Patchable::ClassMethods
  extend ::T::Sig
end

module Datadog::Contrib::Patchable::InstanceMethods
  def patch(); end

  def patcher(); end
end

module Datadog::Contrib::Patchable::InstanceMethods
  extend ::T::Sig
end

module Datadog::Contrib::Patchable
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::Patcher
end

module Datadog::Contrib::Patcher::ClassMethods
  def patch(); end
end

module Datadog::Contrib::Patcher::ClassMethods
  extend ::T::Sig
end

module Datadog::Contrib::Patcher::InstanceMethods
  def patch(); end
end

module Datadog::Contrib::Patcher::InstanceMethods
  extend ::T::Sig
end

module Datadog::Contrib::Patcher
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::Racecar
end

module Datadog::Contrib::Racecar::Event
end

module Datadog::Contrib::Racecar::Event::ClassMethods
  def configuration(); end

  def process(span, event, _id, payload); end

  def span_options(); end

  def subscription(*args); end

  def tracer(); end
end

module Datadog::Contrib::Racecar::Event::ClassMethods
  extend ::T::Sig
end

module Datadog::Contrib::Racecar::Event
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::Racecar::Events
  ALL = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Racecar::Events::Batch
  include ::Datadog::Contrib::Racecar::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Subscriber
  EVENT_NAME = ::T.let(nil, ::T.untyped)
  SPAN_NAME = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Racecar::Events::Batch
  extend ::Datadog::Contrib::Racecar::Event::ClassMethods
  extend ::T::Sig
  def self.event_name(); end

  def self.span_name(); end
end

module Datadog::Contrib::Racecar::Events::Message
  include ::Datadog::Contrib::Racecar::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Event
  include ::Datadog::Contrib::ActiveSupport::Notifications::Subscriber
  EVENT_NAME = ::T.let(nil, ::T.untyped)
  SPAN_NAME = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Racecar::Events::Message
  extend ::Datadog::Contrib::Racecar::Event::ClassMethods
  extend ::T::Sig
  def self.event_name(); end

  def self.span_name(); end
end

module Datadog::Contrib::Racecar::Events
  extend ::T::Sig
  def self.all(); end

  def self.subscribe!(); end

  def self.subscriptions(); end
end

module Datadog::Contrib::Racecar::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Racecar::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patched?(); end
end

module Datadog::Contrib::Racecar
  extend ::T::Sig
end

module Datadog::Contrib::Rack
end

module Datadog::Contrib::Rack::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  DEFAULT_HEADERS = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Rack::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.enable_middleware_names(); end

  def self.patch(); end

  def self.patched?(); end

  def self.retain_middleware_name(middleware); end
end

module Datadog::Contrib::Rack::QueueTime
  QUEUE_START = ::T.let(nil, ::T.untyped)
  REQUEST_START = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Rack::QueueTime
  extend ::T::Sig
  def self.get_request_start(env, now=T.unsafe(nil)); end
end

class Datadog::Contrib::Rack::TraceMiddleware
  def call(env); end

  def compute_queue_time(env, tracer); end

  def initialize(app); end

  def resource_name_for(env, status); end

  def set_request_tags!(request_span, env, status, headers, response, original_env); end
  RACK_REQUEST_SPAN = ::T.let(nil, ::T.untyped)
  REQUEST_SPAN_DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Datadog::Contrib::Rack::TraceMiddleware
end

module Datadog::Contrib::Rack
  extend ::T::Sig
end

module Datadog::Contrib::Rails
end

module Datadog::Contrib::Rails::ActionController
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Rails::ActionController
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.exception_controller?(payload); end

  def self.finish_processing(payload); end

  def self.instrument(); end

  def self.start_processing(payload); end
end

module Datadog::Contrib::Rails::ActionControllerPatch
end

module Datadog::Contrib::Rails::ActionControllerPatch::ProcessActionPatch
  def datadog_response_status(); end

  def process_action(*args); end
end

module Datadog::Contrib::Rails::ActionControllerPatch::ProcessActionPatch
  extend ::T::Sig
end

module Datadog::Contrib::Rails::ActionControllerPatch
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::Rails::ActionView
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Rails::ActionView
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.instrument(); end
end

module Datadog::Contrib::Rails::ActiveSupport
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Rails::ActiveSupport
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.finish_trace_cache(payload); end

  def self.instrument(); end

  def self.start_trace_cache(payload); end
end

class Datadog::Contrib::Rails::ExceptionMiddleware
  def call(env); end

  def initialize(app); end
end

class Datadog::Contrib::Rails::ExceptionMiddleware
end

module Datadog::Contrib::Rails::Framework
end

module Datadog::Contrib::Rails::Framework
  extend ::T::Sig
  def self.activate_active_record!(config); end

  def self.activate_rack!(config); end

  def self.config_with_defaults(); end

  def self.set_service_info!(config); end

  def self.setup(); end
end

module Datadog::Contrib::Rails::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Rails::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.compatible?(); end

  def self.patch(); end

  def self.patched?(); end
end

module Datadog::Contrib::Rails::Utils
end

module Datadog::Contrib::Rails::Utils
  extend ::T::Sig
  def self.app_name(); end

  def self.exception_is_error?(exception); end

  def self.normalize_template_name(name); end
end

module Datadog::Contrib::Rails
  extend ::T::Sig
end

module Datadog::Contrib::Rake
end

module Datadog::Contrib::Rake::Instrumentation
  SPAN_NAME_EXECUTE = ::T.let(nil, ::T.untyped)
  SPAN_NAME_INVOKE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Rake::Instrumentation::InstanceMethods
  def execute(args=T.unsafe(nil)); end

  def invoke(*args); end
end

module Datadog::Contrib::Rake::Instrumentation::InstanceMethods
  extend ::T::Sig
end

module Datadog::Contrib::Rake::Instrumentation
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::Rake::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Rake::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.compatible?(); end

  def self.configuration(); end

  def self.patch(); end

  def self.patch_rake(); end

  def self.patched?(); end
end

module Datadog::Contrib::Rake
  extend ::T::Sig
end

module Datadog::Contrib::Redis
  DRIVER = ::T.let(nil, ::T.untyped)
  SERVICE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Redis::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Redis::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.compatible?(); end

  def self.patch(); end

  def self.patch_redis_client(); end

  def self.patched?(); end
end

module Datadog::Contrib::Redis::Quantize
  CMD_MAX_LEN = ::T.let(nil, ::T.untyped)
  PLACEHOLDER = ::T.let(nil, ::T.untyped)
  TOO_LONG_MARK = ::T.let(nil, ::T.untyped)
  VALUE_MAX_LEN = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Redis::Quantize
  extend ::T::Sig
  def self.format_arg(arg); end

  def self.format_command_args(command_args); end
end

module Datadog::Contrib::Redis::Tags
end

module Datadog::Contrib::Redis::Tags
  extend ::T::Sig
  def self.set_common_tags(client, span); end
end

module Datadog::Contrib::Redis
  extend ::T::Sig
end

module Datadog::Contrib::Registerable
end

module Datadog::Contrib::Registerable::ClassMethods
  def register_as(name, options=T.unsafe(nil)); end
end

module Datadog::Contrib::Registerable::ClassMethods
  extend ::T::Sig
end

module Datadog::Contrib::Registerable::InstanceMethods
  def initialize(name, options=T.unsafe(nil)); end

  def name(); end
end

module Datadog::Contrib::Registerable::InstanceMethods
  extend ::T::Sig
end

module Datadog::Contrib::Registerable
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::Resque
  SERVICE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Resque::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::Resque::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patched?(); end
end

module Datadog::Contrib::Resque
  extend ::T::Sig
  def self.sync_writer(); end

  def self.sync_writer=(sync_writer); end
end

module Datadog::Contrib::RestClient
end

module Datadog::Contrib::RestClient::Configuration
end

class Datadog::Contrib::RestClient::Configuration::Settings
  def distributed_tracing(); end

  def distributed_tracing=(value); end
  NAME = ::T.let(nil, ::T.untyped)
end

class Datadog::Contrib::RestClient::Configuration::Settings
end

module Datadog::Contrib::RestClient::Configuration
  extend ::T::Sig
end

class Datadog::Contrib::RestClient::Integration
  include ::Datadog::Contrib::Integration
  include ::Datadog::Contrib::Configurable
  include ::Datadog::Contrib::Configurable::InstanceMethods
  include ::Datadog::Contrib::Patchable
  include ::Datadog::Contrib::Patchable::InstanceMethods
  include ::Datadog::Contrib::Registerable
  include ::Datadog::Contrib::Registerable::InstanceMethods
end

class Datadog::Contrib::RestClient::Integration
  extend ::Datadog::Contrib::Patchable::ClassMethods
  extend ::Datadog::Contrib::Registerable::ClassMethods
end

module Datadog::Contrib::RestClient::Patcher
  include ::Datadog::Contrib::Patcher
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  include ::Datadog::Contrib::Patcher::InstanceMethods
end

module Datadog::Contrib::RestClient::Patcher
  extend ::Datadog::Patcher::CommonMethods
  extend ::Datadog::Contrib::Patcher::InstanceMethods
  extend ::T::Sig
  def self.patched?(); end
end

module Datadog::Contrib::RestClient
  extend ::T::Sig
end

module Datadog::Contrib::Sequel
end

module Datadog::Contrib::Sequel::Configuration
end

class Datadog::Contrib::Sequel::Configuration::Settings
end

class Datadog::Contrib::Sequel::Configuration::Settings
end

module Datadog::Contrib::Sequel::Configuration
  extend ::T::Sig
end

module Datadog::Contrib::Sequel::Database
end

module Datadog::Contrib::Sequel::Database::InstanceMethods
  def datadog_pin(); end

  def run(sql, options=T.unsafe(nil)); end
end

module Datadog::Contrib::Sequel::Database::InstanceMethods
  extend ::T::Sig
end

module Datadog::Contrib::Sequel::Database
  extend ::T::Sig
  def self.included(base); end
end

module Datadog::Contrib::Sequel::Dataset
end

module Datadog::Contrib::Sequel::Dataset::InstanceMethods
  def datadog_pin(); end

  def execute(sql, options=T.unsafe(nil), &block); end

  def execute_ddl(sql, options=T.unsafe(nil), &block); end

  def execute_dui(sql, options=T.unsafe(nil), &block); end

  def execute_insert(sql, options=T.unsafe(nil), &block); end
end

module Datadog::Contrib::Sequel::Dataset::InstanceMethods
  extend ::T::Sig
end

module Datadog::Contrib::Sequel::Dataset
  extend ::T::Sig
  def self.included(base); end
end

class Datadog::Contrib::Sequel::Integration
  include ::Datadog::Contrib::Integration
  include ::Datadog::Contrib::Configurable
  include ::Datadog::Contrib::Configurable::InstanceMethods
  include ::Datadog::Contrib::Patchable
  include ::Datadog::Contrib::Patchable::InstanceMethods
  include ::Datadog::Contrib::Registerable
  include ::Datadog::Contrib::Registerable::InstanceMethods
  APP = ::T.let(nil, ::T.untyped)
end

class Datadog::Contrib::Sequel::Integration
  extend ::Datadog::Contrib::Patchable::ClassMethods
  extend ::Datadog::Contrib::Registerable::ClassMethods
end

module Datadog::Contrib::Sequel::Patcher
  include ::Datadog::Contrib::Patcher
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  include ::Datadog::Contrib::Patcher::InstanceMethods
end

module Datadog::Contrib::Sequel::Patcher
  extend ::Datadog::Patcher::CommonMethods
  extend ::Datadog::Contrib::Patcher::InstanceMethods
  extend ::T::Sig
  def self.patch_sequel_database(); end

  def self.patch_sequel_dataset(); end

  def self.patched?(); end
end

module Datadog::Contrib::Sequel::Utils
end

module Datadog::Contrib::Sequel::Utils
  extend ::T::Sig
  def self.adapter_name(database); end

  def self.parse_opts(sql, opts, db_opts); end
end

module Datadog::Contrib::Sequel
  extend ::T::Sig
end

module Datadog::Contrib::Sidekiq
end

module Datadog::Contrib::Sidekiq::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  VERSION_REQUIRED = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::Sidekiq::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.compatible?(); end

  def self.patch(); end
end

class Datadog::Contrib::Sidekiq::Tracer
  def call(worker, job, queue); end

  def initialize(options=T.unsafe(nil)); end
end

class Datadog::Contrib::Sidekiq::Tracer
end

module Datadog::Contrib::Sidekiq
  extend ::T::Sig
end

module Datadog::Contrib::SuckerPunch
  COMPATIBLE_WITH = ::T.let(nil, ::T.untyped)
  SERVICE = ::T.let(nil, ::T.untyped)
end

module Datadog::Contrib::SuckerPunch::Patcher
  include ::Datadog::Contrib::Base
  include ::Datadog::Registry::Registerable
  include ::Datadog::Configurable
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::Contrib::SuckerPunch::Patcher
  extend ::Datadog::Configurable::ClassMethods
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch(); end

  def self.patched?(); end
end

module Datadog::Contrib::SuckerPunch
  extend ::T::Sig
end

module Datadog::Contrib
  extend ::T::Sig
end

class Datadog::DefaultContextProvider
  def context(); end

  def context=(ctx); end
end

class Datadog::DefaultContextProvider
end

class Datadog::DistributedHeaders
  include ::Datadog::Ext::DistributedTracing
  def initialize(env); end

  def parent_id(); end

  def sampling_priority(); end

  def trace_id(); end

  def valid?(); end
end

class Datadog::DistributedHeaders
end

module Datadog::Encoding
end

class Datadog::Encoding::Encoder
  def content_type(); end

  def encode(_); end

  def encode_services(services); end

  def encode_traces(traces); end
end

class Datadog::Encoding::Encoder
end

class Datadog::Encoding::JSONEncoder
  def encode(obj); end
end

class Datadog::Encoding::JSONEncoder
end

class Datadog::Encoding::MsgpackEncoder
  def encode(obj); end
end

class Datadog::Encoding::MsgpackEncoder
end

module Datadog::Encoding
  extend ::T::Sig
end

class Datadog::Error
  def backtrace(); end

  def initialize(type=T.unsafe(nil), message=T.unsafe(nil), backtrace=T.unsafe(nil)); end

  def message(); end

  def type(); end
  BlankError = ::T.let(nil, ::T.untyped)
  ContainsMessage = ::T.let(nil, ::T.untyped)
end

class Datadog::Error
  def self.build_from(value); end
end

module Datadog::Ext
end

module Datadog::Ext::AppTypes
  CACHE = ::T.let(nil, ::T.untyped)
  CUSTOM = ::T.let(nil, ::T.untyped)
  DB = ::T.let(nil, ::T.untyped)
  WEB = ::T.let(nil, ::T.untyped)
  WORKER = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::AppTypes
  extend ::T::Sig
end

module Datadog::Ext::CACHE
  MAX_KEY_SIZE = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::CACHE
  extend ::T::Sig
end

module Datadog::Ext::DistributedTracing
  GRPC_METADATA_PARENT_ID = ::T.let(nil, ::T.untyped)
  GRPC_METADATA_SAMPLING_PRIORITY = ::T.let(nil, ::T.untyped)
  GRPC_METADATA_TRACE_ID = ::T.let(nil, ::T.untyped)
  HTTP_HEADER_PARENT_ID = ::T.let(nil, ::T.untyped)
  HTTP_HEADER_SAMPLING_PRIORITY = ::T.let(nil, ::T.untyped)
  HTTP_HEADER_TRACE_ID = ::T.let(nil, ::T.untyped)
  SAMPLING_PRIORITY_KEY = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::DistributedTracing
  extend ::T::Sig
end

module Datadog::Ext::Errors
  MSG = ::T.let(nil, ::T.untyped)
  STACK = ::T.let(nil, ::T.untyped)
  STATUS = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::Errors
  extend ::T::Sig
end

module Datadog::Ext::HTTP
  BASE_URL = ::T.let(nil, ::T.untyped)
  ERROR_RANGE = ::T.let(nil, ::T.untyped)
  METHOD = ::T.let(nil, ::T.untyped)
  STATUS_CODE = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::HTTP::Headers
end

module Datadog::Ext::HTTP::Headers
  extend ::T::Sig
  def self.to_tag(name); end
end

module Datadog::Ext::HTTP::RequestHeaders
  PREFIX = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::HTTP::RequestHeaders
  extend ::T::Sig
  def self.to_tag(name); end
end

module Datadog::Ext::HTTP::ResponseHeaders
  PREFIX = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::HTTP::ResponseHeaders
  extend ::T::Sig
  def self.to_tag(name); end
end

module Datadog::Ext::HTTP
  extend ::T::Sig
end

module Datadog::Ext::NET
  TARGET_HOST = ::T.let(nil, ::T.untyped)
  TARGET_PORT = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::NET
  extend ::T::Sig
end

module Datadog::Ext::Priority
  AUTO_KEEP = ::T.let(nil, ::T.untyped)
  AUTO_REJECT = ::T.let(nil, ::T.untyped)
  USER_KEEP = ::T.let(nil, ::T.untyped)
  USER_REJECT = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::Priority
  extend ::T::Sig
end

module Datadog::Ext::Redis
  DB = ::T.let(nil, ::T.untyped)
  PIPELINE_LEN = ::T.let(nil, ::T.untyped)
  RAW_COMMAND = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::Redis
  extend ::T::Sig
end

module Datadog::Ext::SQL
  QUERY = ::T.let(nil, ::T.untyped)
  TYPE = ::T.let(nil, ::T.untyped)
end

module Datadog::Ext::SQL
  extend ::T::Sig
end

module Datadog::Ext
  extend ::T::Sig
end

module Datadog::HTTPPropagator
  include ::Datadog::Ext::DistributedTracing
end

module Datadog::HTTPPropagator
  extend ::T::Sig
  def self.extract(env); end

  def self.inject!(context, env); end
end

class Datadog::HTTPTransport
  def client_error?(code); end

  def downgrade!(); end

  def downgrade?(code); end

  def handle_response(response); end

  def hostname(); end

  def hostname=(hostname); end

  def informational?(code); end

  def initialize(hostname, port, options=T.unsafe(nil)); end

  def port(); end

  def port=(port); end

  def post(url, data, count=T.unsafe(nil)); end

  def redirect?(code); end

  def send(endpoint, data); end

  def server_error?(code); end

  def services_endpoint(); end

  def stats(); end

  def success?(code); end

  def traces_endpoint(); end
  RUBY_INTERPRETER = ::T.let(nil, ::T.untyped)
  TIMEOUT = ::T.let(nil, ::T.untyped)
  TRACE_COUNT_HEADER = ::T.let(nil, ::T.untyped)
  V2 = ::T.let(nil, ::T.untyped)
  V3 = ::T.let(nil, ::T.untyped)
  V4 = ::T.let(nil, ::T.untyped)
end

class Datadog::HTTPTransport
end

class Datadog::InvalidOptionError
end

class Datadog::InvalidOptionError
end

class Datadog::Logger
  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def initialize(*args, &block); end

  def log(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end
end

class Datadog::Logger
end

module Datadog::Monkey
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

module Datadog::Monkey
  extend ::T::Sig
  def self.autopatch_modules(); end

  def self.get_patched_modules(); end

  def self.log_deprecation_warning(method); end

  def self.patch(modules); end

  def self.patch_all(); end

  def self.patch_module(m); end

  def self.registry(); end

  def self.registry=(registry); end

  def self.without_warnings(&block); end
end

module Datadog::Patcher
end

module Datadog::Patcher::CommonMethods
  def do_once(key=T.unsafe(nil)); end

  def done?(key); end

  def without_warnings(); end
end

module Datadog::Patcher::CommonMethods
  extend ::T::Sig
end

module Datadog::Patcher
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.included(base); end
end

class Datadog::Pin
  def app(); end

  def app=(app); end

  def app_type(); end

  def app_type=(app_type); end

  def config(); end

  def config=(config); end

  def enabled?(); end

  def initialize(service_name, options=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def onto(obj); end

  def service(); end

  def service=(name); end

  def service_name(); end

  def service_name=(name); end

  def tags(); end

  def tags=(tags); end

  def tracer(); end

  def tracer=(tracer); end
end

class Datadog::Pin
  def self.get_from(obj); end
end

module Datadog::Pipeline
end

class Datadog::Pipeline::SpanFilter
  def call(trace); end

  def initialize(filter=T.unsafe(nil), &block); end
end

class Datadog::Pipeline::SpanFilter
end

class Datadog::Pipeline::SpanProcessor
  def call(trace); end

  def initialize(operation=T.unsafe(nil), &block); end
end

class Datadog::Pipeline::SpanProcessor
end

module Datadog::Pipeline
  extend ::T::Sig
  def self.before_flush(*processors, &processor_block); end

  def self.process!(traces); end

  def self.processors=(value); end
end

class Datadog::PrioritySampler
  def initialize(opts=T.unsafe(nil)); end

  def sample(span); end

  def update(*args, &block); end
end

class Datadog::PrioritySampler
  extend ::Forwardable
end

module Datadog::Quantization
end

module Datadog::Quantization::HTTP
  PLACEHOLDER = ::T.let(nil, ::T.untyped)
end

module Datadog::Quantization::HTTP
  extend ::T::Sig
  def self.query(query, options=T.unsafe(nil)); end

  def self.query!(query, options=T.unsafe(nil)); end

  def self.url(url, options=T.unsafe(nil)); end

  def self.url!(url, options=T.unsafe(nil)); end
end

module Datadog::Quantization::Hash
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  EXCLUDE_KEYS = ::T.let(nil, ::T.untyped)
  PLACEHOLDER = ::T.let(nil, ::T.untyped)
  SHOW_KEYS = ::T.let(nil, ::T.untyped)
end

module Datadog::Quantization::Hash
  extend ::T::Sig
  def self.convert_value(value); end

  def self.format(hash_obj, options=T.unsafe(nil)); end

  def self.format!(hash_obj, options=T.unsafe(nil)); end

  def self.format_array(value, options); end

  def self.format_hash(hash_obj, options=T.unsafe(nil)); end

  def self.format_value(value, options=T.unsafe(nil)); end

  def self.indifferent_equals(value); end

  def self.merge_options(original, additional); end
end

module Datadog::Quantization
  extend ::T::Sig
end

module Datadog::RailsActionPatcher
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::RailsActionPatcher
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch_action_controller(); end

  def self.patch_process_action(); end
end

module Datadog::RailsCachePatcher
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
end

module Datadog::RailsCachePatcher
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.cache_store_class(k); end

  def self.patch_cache_store(); end

  def self.patch_cache_store_delete(); end

  def self.patch_cache_store_fetch(); end

  def self.patch_cache_store_read(); end

  def self.patch_cache_store_write(); end

  def self.reload_cache_store(); end
end

module Datadog::RailsRendererPatcher
  include ::Datadog::Patcher
  include ::Datadog::Patcher::CommonMethods
  SPAN_NAME_RENDER_PARTIAL = ::T.let(nil, ::T.untyped)
  SPAN_NAME_RENDER_TEMPLATE = ::T.let(nil, ::T.untyped)
  TAG_LAYOUT = ::T.let(nil, ::T.untyped)
  TAG_TEMPLATE_NAME = ::T.let(nil, ::T.untyped)
end

module Datadog::RailsRendererPatcher
  extend ::Datadog::Patcher::CommonMethods
  extend ::T::Sig
  def self.patch_partial_renderer(klass); end

  def self.patch_renderer(); end

  def self.patch_template_renderer(klass); end
end

class Datadog::RateByServiceSampler
  def initialize(rate=T.unsafe(nil), opts=T.unsafe(nil)); end

  def sample(span); end

  def update(rate_by_service); end
  DEFAULT_KEY = ::T.let(nil, ::T.untyped)
end

class Datadog::RateByServiceSampler
end

class Datadog::RateSampler
  def initialize(sample_rate=T.unsafe(nil)); end

  def sample(span); end

  def sample_rate(); end

  def sample_rate=(sample_rate); end
  KNUTH_FACTOR = ::T.let(nil, ::T.untyped)
  SAMPLE_RATE_METRIC_KEY = ::T.let(nil, ::T.untyped)
end

class Datadog::RateSampler
end

class Datadog::Registry
  include ::Enumerable
  def [](name); end

  def add(name, klass, auto_patch=T.unsafe(nil)); end

  def each(); end

  def to_h(); end
end

class Datadog::Registry::Entry
  def auto_patch(); end

  def auto_patch=(_); end

  def klass(); end

  def klass=(_); end

  def name(); end

  def name=(_); end
end

class Datadog::Registry::Entry
  def self.[](*_); end

  def self.members(); end
end

module Datadog::Registry::Registerable
end

module Datadog::Registry::Registerable
  extend ::T::Sig
  def self.included(base); end
end

class Datadog::Registry
end

class Datadog::Sampler
  def sample(_span); end
end

class Datadog::Sampler
end

class Datadog::Span
  def context(); end

  def context=(context); end

  def end_time(); end

  def end_time=(end_time); end

  def finish(finish_time=T.unsafe(nil)); end

  def finished?(); end

  def get_metric(key); end

  def get_tag(key); end

  def initialize(tracer, name, options=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def parent(); end

  def parent=(parent); end

  def parent_id(); end

  def parent_id=(parent_id); end

  def resource(); end

  def resource=(resource); end

  def sampled(); end

  def sampled=(sampled); end

  def service(); end

  def service=(service); end

  def set_error(e); end

  def set_metric(key, value); end

  def set_parent(parent); end

  def set_tag(key, value); end

  def span_id(); end

  def span_id=(span_id); end

  def span_type(); end

  def span_type=(span_type); end

  def start_time(); end

  def start_time=(start_time); end

  def status(); end

  def status=(status); end

  def to_hash(); end

  def trace_id(); end

  def trace_id=(trace_id); end

  def tracer(); end

  def tracer=(tracer); end
  MAX_ID = ::T.let(nil, ::T.untyped)
end

class Datadog::Span
end

class Datadog::Statsd
  include ::Datadog::StatsdDisabled
  def batch(); end

  def buffer(); end

  def close(); end

  def connection(); end

  def count(stat, count, opts=T.unsafe(nil)); end

  def decrement(stat, opts=T.unsafe(nil)); end

  def distribution(stat, value, opts=T.unsafe(nil)); end

  def event(title, text, opts=T.unsafe(nil)); end

  def gauge(stat, value, opts=T.unsafe(nil)); end

  def histogram(stat, value, opts=T.unsafe(nil)); end

  def increment(stat, opts=T.unsafe(nil)); end

  def initialize(host=T.unsafe(nil), port=T.unsafe(nil), namespace: T.unsafe(nil), tags: T.unsafe(nil), max_buffer_bytes: T.unsafe(nil), socket_path: T.unsafe(nil), logger: T.unsafe(nil)); end

  def max_buffer_bytes(); end

  def namespace(); end

  def service_check(name, status, opts=T.unsafe(nil)); end

  def set(stat, value, opts=T.unsafe(nil)); end

  def tags(); end

  def time(stat, opts=T.unsafe(nil)); end

  def timing(stat, ms, opts=T.unsafe(nil)); end
  COUNTER_TYPE = ::T.let(nil, ::T.untyped)
  CRITICAL = ::T.let(nil, ::T.untyped)
  DISTRIBUTION_TYPE = ::T.let(nil, ::T.untyped)
  GAUGE_TYPE = ::T.let(nil, ::T.untyped)
  HISTOGRAM_TYPE = ::T.let(nil, ::T.untyped)
  MAX_EVENT_SIZE = ::T.let(nil, ::T.untyped)
  OK = ::T.let(nil, ::T.untyped)
  OPTS_KEYS = ::T.let(nil, ::T.untyped)
  PROCESS_TIME_SUPPORTED = ::T.let(nil, ::T.untyped)
  SC_OPT_KEYS = ::T.let(nil, ::T.untyped)
  SET_TYPE = ::T.let(nil, ::T.untyped)
  TIMING_TYPE = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

class Datadog::Statsd::Batch
  def add(message); end

  def flush(); end

  def initialize(connection, max_buffer_bytes); end

  def open(); end

  def open?(); end
end

class Datadog::Statsd::Batch
end

class Datadog::Statsd::Connection
  def close(); end

  def host(); end

  def initialize(host, port, socket_path, logger); end

  def port(); end

  def socket_path(); end

  def write(message); end
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Datadog::Statsd::Connection
end

class Datadog::Statsd
  def self.open(*args); end
end

module Datadog::StatsdDisabled
  extend ::T::Sig
end

class Datadog::ThreadLocalContext
  def local(); end

  def local=(ctx); end
end

class Datadog::ThreadLocalContext
end

class Datadog::TraceBuffer
  def close(); end

  def empty?(); end

  def initialize(max_size); end

  def length(); end

  def pop(); end

  def push(trace); end
end

class Datadog::TraceBuffer
end

class Datadog::Tracer
  def active_root_span(); end

  def active_span(); end

  def call_context(); end

  def configure(options=T.unsafe(nil)); end

  def default_service(); end

  def default_service=(default_service); end

  def enabled(); end

  def enabled=(enabled); end

  def initialize(options=T.unsafe(nil)); end

  def provider(); end

  def record(context); end

  def sampler(); end

  def services(); end

  def set_service_info(service, app, app_type); end

  def set_tags(tags); end

  def shutdown!(); end

  def start_span(name, options=T.unsafe(nil)); end

  def tags(); end

  def trace(name, options=T.unsafe(nil)); end

  def writer(); end

  def writer=(writer); end
  ALLOWED_SPAN_OPTIONS = ::T.let(nil, ::T.untyped)
  DEFAULT_ON_ERROR = ::T.let(nil, ::T.untyped)
end

class Datadog::Tracer
  def self.debug_logging(); end

  def self.debug_logging=(value); end

  def self.log(); end

  def self.log=(logger); end
end

module Datadog::Utils
  STRING_PLACEHOLDER = ::T.let(nil, ::T.untyped)
end

module Datadog::Utils::Database
end

module Datadog::Utils::Database
  extend ::T::Sig
  def self.normalize_vendor(vendor); end
end

module Datadog::Utils
  extend ::T::Sig
  def self.next_id(); end

  def self.truncate(value, size, omission=T.unsafe(nil)); end

  def self.utf8_encode(str, options=T.unsafe(nil)); end
end

module Datadog::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Datadog::VERSION
  extend ::T::Sig
end

module Datadog::Vendor
end

module Datadog::Vendor::ActiveRecord
end

module Datadog::Vendor::ActiveRecord::ConnectionAdapters
end

class Datadog::Vendor::ActiveRecord::ConnectionAdapters::ConnectionSpecification
  def adapter_method(); end

  def config(); end

  def initialize(name, config, adapter_method); end

  def name(); end

  def to_hash(); end
end

class Datadog::Vendor::ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
  def initialize(url); end

  def to_hash(); end
end

class Datadog::Vendor::ActiveRecord::ConnectionAdapters::ConnectionSpecification::ConnectionUrlResolver
end

class Datadog::Vendor::ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
  def configurations(); end

  def initialize(configurations); end

  def resolve(config); end

  def resolve_all(); end

  def spec(config); end
end

class Datadog::Vendor::ActiveRecord::ConnectionAdapters::ConnectionSpecification::Resolver
end

class Datadog::Vendor::ActiveRecord::ConnectionAdapters::ConnectionSpecification
end

module Datadog::Vendor::ActiveRecord::ConnectionAdapters
  extend ::T::Sig
end

module Datadog::Vendor::ActiveRecord::ConnectionHandling
  RAILS_ENV = ::T.let(nil, ::T.untyped)
end

module Datadog::Vendor::ActiveRecord::ConnectionHandling
  extend ::T::Sig
end

module Datadog::Vendor::ActiveRecord
  extend ::T::Sig
end

module Datadog::Vendor
  extend ::T::Sig
end

module Datadog::Workers
end

class Datadog::Workers::AsyncTransport
  def callback_services(); end

  def callback_traces(); end

  def enqueue_service(service); end

  def enqueue_trace(trace); end

  def flush_data(); end

  def initialize(transport, buff_size, trace_task, service_task, interval); end

  def join(); end

  def service_buffer(); end

  def start(); end

  def stop(); end

  def trace_buffer(); end
  BACK_OFF_MAX = ::T.let(nil, ::T.untyped)
  BACK_OFF_RATIO = ::T.let(nil, ::T.untyped)
  DEFAULT_TIMEOUT = ::T.let(nil, ::T.untyped)
  SHUTDOWN_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Datadog::Workers::AsyncTransport
end

module Datadog::Workers
  extend ::T::Sig
end

class Datadog::Writer
  def initialize(options=T.unsafe(nil)); end

  def priority_sampler(); end

  def send_services(services, transport); end

  def send_spans(traces, transport); end

  def start(); end

  def stats(); end

  def stop(); end

  def transport(); end

  def worker(); end

  def write(trace, services); end
  HOSTNAME = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
end

class Datadog::Writer
end

module Datadog
  extend ::T::Sig
  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(target=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.registry(); end

  def self.tracer(); end
end

class Date
  include ::DateAndTime::Calculations
  include ::DateAndTime::Zones
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def acts_like_date?(); end

  def advance(options); end

  def ago(seconds); end

  def at_beginning_of_day(); end

  def at_end_of_day(); end

  def at_midday(); end

  def at_middle_of_day(); end

  def at_midnight(); end

  def at_noon(); end

  def beginning_of_day(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def default_inspect(); end

  def end_of_day(); end

  def in(seconds); end

  def midday(); end

  def middle_of_day(); end

  def midnight(); end

  def minus_with_duration(other); end

  def minus_without_duration(_); end

  def noon(); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def readable_inspect(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Date::Infinity
  def initialize(d=T.unsafe(nil)); end
end

class Date::Infinity
  extend ::T::Sig
end

class Date
  extend ::T::Sig
  def self.beginning_of_week(); end

  def self.beginning_of_week=(week_start); end

  def self.beginning_of_week_default(); end

  def self.beginning_of_week_default=(beginning_of_week_default); end

  def self.closest_wday(wday); end

  def self.current(); end

  def self.find_beginning_of_week!(week_start); end

  def self.mock_date(); end

  def self.mocked_time_stack_item(); end

  def self.parse_with_mock_date(*args); end

  def self.parse_without_mock_date(*_); end

  def self.strptime_with_mock_date(str=T.unsafe(nil), fmt=T.unsafe(nil), start=T.unsafe(nil)); end

  def self.strptime_without_mock_date(*_); end

  def self.today_with_mock_date(); end

  def self.today_without_mock_date(*_); end

  def self.tomorrow(); end

  def self.yesterday(); end
end

module DateAndTime
end

module DateAndTime::Calculations
  def all_day(); end

  def all_month(); end

  def all_quarter(); end

  def all_week(start_day=T.unsafe(nil)); end

  def all_year(); end

  def at_beginning_of_month(); end

  def at_beginning_of_quarter(); end

  def at_beginning_of_week(start_day=T.unsafe(nil)); end

  def at_beginning_of_year(); end

  def at_end_of_month(); end

  def at_end_of_quarter(); end

  def at_end_of_week(start_day=T.unsafe(nil)); end

  def at_end_of_year(); end

  def beginning_of_month(); end

  def beginning_of_quarter(); end

  def beginning_of_week(start_day=T.unsafe(nil)); end

  def beginning_of_year(); end

  def days_ago(days); end

  def days_since(days); end

  def days_to_week_start(start_day=T.unsafe(nil)); end

  def end_of_month(); end

  def end_of_quarter(); end

  def end_of_week(start_day=T.unsafe(nil)); end

  def end_of_year(); end

  def future?(); end

  def last_month(); end

  def last_quarter(); end

  def last_week(start_day=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def last_weekday(); end

  def last_year(); end

  def monday(); end

  def months_ago(months); end

  def months_since(months); end

  def next_day(days=T.unsafe(nil)); end

  def next_month(months=T.unsafe(nil)); end

  def next_occurring(day_of_week); end

  def next_quarter(); end

  def next_week(given_day_in_next_week=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def next_weekday(); end

  def next_year(years=T.unsafe(nil)); end

  def on_weekday?(); end

  def on_weekend?(); end

  def past?(); end

  def prev_day(days=T.unsafe(nil)); end

  def prev_month(months=T.unsafe(nil)); end

  def prev_occurring(day_of_week); end

  def prev_quarter(); end

  def prev_week(start_day=T.unsafe(nil), same_time: T.unsafe(nil)); end

  def prev_weekday(); end

  def prev_year(years=T.unsafe(nil)); end

  def sunday(); end

  def today?(); end

  def tomorrow(); end

  def weeks_ago(weeks); end

  def weeks_since(weeks); end

  def years_ago(years); end

  def years_since(years); end

  def yesterday(); end
  DAYS_INTO_WEEK = ::T.let(nil, ::T.untyped)
  WEEKEND_DAYS = ::T.let(nil, ::T.untyped)
end

module DateAndTime::Calculations
  extend ::T::Sig
end

module DateAndTime::Compatibility
  def preserve_timezone(); end
end

module DateAndTime::Compatibility
  extend ::T::Sig
  def self.preserve_timezone(); end

  def self.preserve_timezone=(obj); end
end

module DateAndTime::Zones
  def in_time_zone(zone=T.unsafe(nil)); end
end

module DateAndTime::Zones
  extend ::T::Sig
end

module DateAndTime
  extend ::T::Sig
end

class DateTime
  include ::DateAndTime::Compatibility
  def acts_like_time?(); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def getgm(); end

  def getlocal(utc_offset=T.unsafe(nil)); end

  def getutc(); end

  def gmtime(); end

  def localtime(utc_offset=T.unsafe(nil)); end

  def nsec(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def subsec(); end

  def to_f(); end

  def to_i(); end

  def usec(); end

  def utc(); end

  def utc?(); end

  def utc_offset(); end
end

class DateTime
  extend ::T::Sig
  def self.civil_from_format(utc_or_local, year, month=T.unsafe(nil), day=T.unsafe(nil), hour=T.unsafe(nil), min=T.unsafe(nil), sec=T.unsafe(nil)); end

  def self.mock_time(); end

  def self.now_with_mock_time(); end

  def self.now_without_mock_time(*_); end
end

class Delegator
  include ::ActiveSupport::Tryable
  def !=(obj); end

  def ==(obj); end

  def __getobj__(); end

  def __setobj__(obj); end

  def eql?(obj); end

  def initialize(obj); end

  def marshal_dump(); end

  def marshal_load(data); end

  def method_missing(m, *args, &block); end

  def methods(all=T.unsafe(nil)); end

  def protected_methods(all=T.unsafe(nil)); end

  def public_methods(all=T.unsafe(nil)); end
end

class Delegator
  extend ::T::Sig
  def self.const_missing(n); end

  def self.delegating_block(mid); end

  def self.public_api(); end
end

module Devise
  def allow_unconfirmed_access_for(); end

  def allow_unconfirmed_access_for=(obj); end

  def authentication_keys(); end

  def authentication_keys=(obj); end

  def case_insensitive_keys(); end

  def case_insensitive_keys=(obj); end

  def clean_up_csrf_token_on_authentication(); end

  def clean_up_csrf_token_on_authentication=(obj); end

  def confirm_within(); end

  def confirm_within=(obj); end

  def confirmation_keys(); end

  def confirmation_keys=(obj); end

  def default_scope(); end

  def default_scope=(obj); end

  def email_regexp(); end

  def email_regexp=(obj); end

  def expire_all_remember_me_on_sign_out(); end

  def expire_all_remember_me_on_sign_out=(obj); end

  def extend_remember_period(); end

  def extend_remember_period=(obj); end

  def helpers(); end

  def http_authenticatable(); end

  def http_authenticatable=(obj); end

  def http_authenticatable_on_xhr(); end

  def http_authenticatable_on_xhr=(obj); end

  def http_authentication_key(); end

  def http_authentication_key=(obj); end

  def http_authentication_realm(); end

  def http_authentication_realm=(obj); end

  def last_attempt_warning(); end

  def last_attempt_warning=(obj); end

  def lock_strategy(); end

  def lock_strategy=(obj); end

  def mailer_sender(); end

  def mailer_sender=(obj); end

  def mappings(); end

  def maximum_attempts(); end

  def maximum_attempts=(obj); end

  def navigational_formats(); end

  def navigational_formats=(obj); end

  def omniauth_configs(); end

  def omniauth_path_prefix(); end

  def omniauth_path_prefix=(obj); end

  def params_authenticatable(); end

  def params_authenticatable=(obj); end

  def paranoid(); end

  def paranoid=(obj); end

  def parent_controller(); end

  def parent_controller=(obj); end

  def parent_mailer(); end

  def parent_mailer=(obj); end

  def password_length(); end

  def password_length=(obj); end

  def pepper(); end

  def pepper=(obj); end

  def reconfirmable(); end

  def reconfirmable=(obj); end

  def reload_routes(); end

  def reload_routes=(obj); end

  def remember_for(); end

  def remember_for=(obj); end

  def rememberable_options(); end

  def rememberable_options=(obj); end

  def request_keys(); end

  def request_keys=(obj); end

  def reset_password_keys(); end

  def reset_password_keys=(obj); end

  def reset_password_within(); end

  def reset_password_within=(obj); end

  def router_name(); end

  def router_name=(obj); end

  def scoped_views(); end

  def scoped_views=(obj); end

  def secret_key(); end

  def secret_key=(obj); end

  def send_email_changed_notification(); end

  def send_email_changed_notification=(obj); end

  def send_password_change_notification(); end

  def send_password_change_notification=(obj); end

  def sign_in_after_change_password(); end

  def sign_in_after_change_password=(obj); end

  def sign_in_after_reset_password(); end

  def sign_in_after_reset_password=(obj); end

  def sign_out_all_scopes(); end

  def sign_out_all_scopes=(obj); end

  def sign_out_via(); end

  def sign_out_via=(obj); end

  def skip_session_storage(); end

  def skip_session_storage=(obj); end

  def stretches(); end

  def stretches=(obj); end

  def strip_whitespace_keys(); end

  def strip_whitespace_keys=(obj); end

  def timeout_in(); end

  def timeout_in=(obj); end

  def token_generator(); end

  def token_generator=(obj); end

  def unlock_in(); end

  def unlock_in=(obj); end

  def unlock_keys(); end

  def unlock_keys=(obj); end

  def unlock_strategy(); end

  def unlock_strategy=(obj); end

  def warden_config(); end

  def warden_config=(obj); end
  ALL = ::T.let(nil, ::T.untyped)
  CONTROLLERS = ::T.let(nil, ::T.untyped)
  NO_INPUT = ::T.let(nil, ::T.untyped)
  ROUTES = ::T.let(nil, ::T.untyped)
  STRATEGIES = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
  URL_HELPERS = ::T.let(nil, ::T.untyped)
end

class Devise::ConfirmationsController
  def after_confirmation_path_for(resource_name, resource); end

  def after_resending_confirmation_instructions_path_for(resource_name); end

  def create(); end

  def new(); end

  def show(); end
end

class Devise::ConfirmationsController
end

module Devise::Controllers
end

module Devise::Controllers::Helpers
  include ::Devise::Controllers::SignInOut
  include ::Devise::Controllers::StoreLocation
  def after_sign_in_path_for(resource_or_scope); end

  def after_sign_out_path_for(resource_or_scope); end

  def allow_params_authentication!(); end

  def devise_controller?(); end

  def devise_parameter_sanitizer(); end

  def handle_unverified_request(); end

  def is_flashing_format?(); end

  def is_navigational_format?(); end

  def request_format(); end

  def sign_in_and_redirect(resource_or_scope, *args); end

  def sign_out_and_redirect(resource_or_scope); end

  def signed_in_root_path(resource_or_scope); end

  def warden(); end
end

module Devise::Controllers::Helpers
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.define_helpers(mapping); end
end

module Devise::Controllers::Rememberable
  def forget_cookie_values(resource); end

  def forget_me(resource); end

  def remember_cookie_values(resource); end

  def remember_key(resource, scope); end

  def remember_me(resource); end

  def remember_me_is_active?(resource); end
end

module Devise::Controllers::Rememberable
  extend ::T::Sig
  def self.cookie_values(); end
end

module Devise::Controllers::ScopedViews
end

module Devise::Controllers::ScopedViews
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Devise::Controllers::SignInOut
  def bypass_sign_in(resource, scope: T.unsafe(nil)); end

  def sign_in(resource_or_scope, *args); end

  def sign_out(resource_or_scope=T.unsafe(nil)); end

  def sign_out_all_scopes(lock=T.unsafe(nil)); end

  def signed_in?(scope=T.unsafe(nil)); end
end

module Devise::Controllers::SignInOut
  extend ::T::Sig
end

module Devise::Controllers::StoreLocation
  def store_location_for(resource_or_scope, location); end

  def stored_location_for(resource_or_scope); end
end

module Devise::Controllers::StoreLocation
  extend ::T::Sig
end

module Devise::Controllers::UrlHelpers
end

module Devise::Controllers::UrlHelpers
  extend ::T::Sig
  def self.generate_helpers!(routes=T.unsafe(nil)); end

  def self.remove_helpers!(); end
end

module Devise::Controllers
  extend ::T::Sig
end

class Devise::Delegator
  def call(env); end

  def failure_app(env); end
end

class Devise::Delegator
end

module Devise::Encryptor
end

module Devise::Encryptor
  extend ::T::Sig
  def self.compare(klass, hashed_password, password); end

  def self.digest(klass, password); end
end

class Devise::Engine
end

class Devise::Engine
end

class Devise::FailureApp
  include ::ActionDispatch::Routing::UrlFor
  include ::ActionDispatch::Routing::PolymorphicRoutes
  include ::AbstractController::UrlFor
  include ::ActionController::UrlFor
  include ::AbstractController::Logger
  include ::ActiveSupport::Benchmarkable
  include ::ActionController::Redirecting
  include ::ActionDispatch::Routing::RouteSet::MountedHelpers
  include ::Devise::Controllers::StoreLocation
  def attempted_path(); end

  def default_url_options(); end

  def default_url_options=(val); end

  def default_url_options?(); end

  def flash(*args, &block); end

  def http_auth(); end

  def http_auth?(); end

  def http_auth_body(); end

  def http_auth_header?(); end

  def i18n_message(default=T.unsafe(nil)); end

  def i18n_options(options); end

  def is_flashing_format?(); end

  def is_navigational_format?(); end

  def logger(); end

  def logger=(value); end

  def recall(); end

  def recall_app(app); end

  def redirect(); end

  def redirect_url(); end

  def relative_url_root(); end

  def relative_url_root?(); end

  def request_format(); end

  def respond(); end

  def route(scope); end

  def scope(); end

  def scope_class(); end

  def scope_url(); end

  def skip_format?(); end

  def store_location!(); end

  def warden(); end

  def warden_message(); end

  def warden_options(); end
end

class Devise::FailureApp
  extend ::AbstractController::UrlFor::ClassMethods
  def self.call(env); end

  def self.default_url_options(*args); end

  def self.default_url_options=(val); end

  def self.default_url_options?(); end

  def self.logger(); end

  def self.logger=(value); end
end

class Devise::Getter
  def get(); end

  def initialize(name); end
end

class Devise::Getter
end

module Devise::Hooks
end

class Devise::Hooks::Proxy
  include ::Devise::Controllers::Rememberable
  include ::Devise::Controllers::SignInOut
  def cookies(*args, &block); end

  def initialize(warden); end

  def request(*args, &block); end

  def session(); end

  def warden(); end
end

class Devise::Hooks::Proxy
end

module Devise::Hooks
  extend ::T::Sig
end

module Devise::Mailers
end

module Devise::Mailers::Helpers
  def devise_mail(record, action, opts=T.unsafe(nil), &block); end

  def devise_mapping(); end

  def headers_for(action, opts); end

  def initialize_from_record(record); end

  def mailer_from(mapping); end

  def mailer_reply_to(mapping); end

  def mailer_sender(mapping, sender=T.unsafe(nil)); end

  def resource(); end

  def scope_name(); end

  def subject_for(key); end

  def template_paths(); end
end

module Devise::Mailers::Helpers
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Devise::Mailers
  extend ::T::Sig
end

class Devise::Mapping
  def authenticatable?(); end

  def class_name(); end

  def confirmable?(); end

  def controllers(); end

  def database_authenticatable?(); end

  def failure_app(); end

  def format(); end

  def fullpath(); end

  def initialize(name, options); end

  def lockable?(); end

  def modules(); end

  def name(); end

  def no_input_strategies(); end

  def omniauthable?(); end

  def path(); end

  def path_names(); end

  def recoverable?(); end

  def registerable?(); end

  def rememberable?(); end

  def router_name(); end

  def routes(); end

  def scoped_path(); end

  def sign_out_via(); end

  def singular(); end

  def strategies(); end

  def timeoutable?(); end

  def to(); end

  def trackable?(); end

  def used_helpers(); end

  def used_routes(); end

  def validatable?(); end
end

class Devise::Mapping
  def self.add_module(m); end

  def self.find_by_path!(path, path_type=T.unsafe(nil)); end

  def self.find_scope!(obj); end
end

class Devise::MissingWarden
  def initialize(); end
end

class Devise::MissingWarden
end

module Devise::Models
  def devise(*modules); end

  def devise_modules_hook!(); end
end

module Devise::Models::Authenticatable
  def active_for_authentication?(); end

  def apply_to_attribute_or_variable(attr, method); end

  def authenticatable_salt(); end

  def devise_mailer(); end

  def downcase_keys(); end

  def inactive_message(); end

  def inspect(); end

  def send_devise_notification(notification, *args); end

  def serializable_hash(options=T.unsafe(nil)); end

  def strip_whitespace(); end

  def unauthenticated_message(); end

  def valid_for_authentication?(); end
  BLACKLIST_FOR_SERIALIZATION = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Authenticatable::ClassMethods
  def authentication_keys(); end

  def authentication_keys=(value); end

  def case_insensitive_keys(); end

  def case_insensitive_keys=(value); end

  def devise_parameter_filter(); end

  def find_first_by_auth_conditions(tainted_conditions, opts=T.unsafe(nil)); end

  def find_for_authentication(tainted_conditions); end

  def find_or_initialize_with_error_by(attribute, value, error=T.unsafe(nil)); end

  def find_or_initialize_with_errors(required_attributes, attributes, error=T.unsafe(nil)); end

  def http_authenticatable(); end

  def http_authenticatable=(value); end

  def http_authenticatable?(strategy); end

  def http_authentication_key(); end

  def http_authentication_key=(value); end

  def params_authenticatable(); end

  def params_authenticatable=(value); end

  def params_authenticatable?(strategy); end

  def request_keys(); end

  def request_keys=(value); end

  def serialize_from_session(key, salt); end

  def serialize_into_session(record); end

  def skip_session_storage(); end

  def skip_session_storage=(value); end

  def strip_whitespace_keys(); end

  def strip_whitespace_keys=(value); end
end

module Devise::Models::Authenticatable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Authenticatable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.required_fields(klass); end
end

module Devise::Models::Confirmable
  def active_for_authentication?(); end

  def after_confirmation(); end

  def confirm(args=T.unsafe(nil)); end

  def confirmation_period_expired?(); end

  def confirmation_period_valid?(); end

  def confirmation_required?(); end

  def confirmed?(); end

  def generate_confirmation_token(); end

  def generate_confirmation_token!(); end

  def inactive_message(); end

  def initialize(*args, &block); end

  def pending_any_confirmation(); end

  def pending_reconfirmation?(); end

  def postpone_email_change?(); end

  def postpone_email_change_until_confirmation_and_regenerate_confirmation_token(); end

  def reconfirmation_required?(); end

  def resend_confirmation_instructions(); end

  def send_confirmation_instructions(); end

  def send_confirmation_notification?(); end

  def send_email_changed_notification?(); end

  def send_on_create_confirmation_instructions(); end

  def send_reconfirmation_instructions(); end

  def skip_confirmation!(); end

  def skip_confirmation_notification!(); end

  def skip_reconfirmation!(); end

  def skip_reconfirmation_in_callback!(); end
end

module Devise::Models::Confirmable::ClassMethods
  def allow_unconfirmed_access_for(); end

  def allow_unconfirmed_access_for=(value); end

  def confirm_by_token(confirmation_token); end

  def confirm_within(); end

  def confirm_within=(value); end

  def confirmation_keys(); end

  def confirmation_keys=(value); end

  def find_by_unconfirmed_email_with_errors(attributes=T.unsafe(nil)); end

  def reconfirmable(); end

  def reconfirmable=(value); end

  def send_confirmation_instructions(attributes=T.unsafe(nil)); end
end

module Devise::Models::Confirmable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Confirmable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.required_fields(klass); end
end

module Devise::Models::DatabaseAuthenticatable
  def after_database_authentication(); end

  def authenticatable_salt(); end

  def clean_up_passwords(); end

  def destroy_with_password(current_password); end

  def initialize(*args, &block); end

  def password=(new_password); end

  def password_digest(password); end

  def send_email_changed_notification(); end

  def send_email_changed_notification?(); end

  def send_password_change_notification(); end

  def send_password_change_notification?(); end

  def skip_email_changed_notification!(); end

  def skip_password_change_notification!(); end

  def update_with_password(params, *options); end

  def update_without_password(params, *options); end

  def valid_password?(password); end
end

module Devise::Models::DatabaseAuthenticatable::ClassMethods
  def find_for_database_authentication(conditions); end

  def pepper(); end

  def pepper=(value); end

  def send_email_changed_notification(); end

  def send_email_changed_notification=(value); end

  def send_password_change_notification(); end

  def send_password_change_notification=(value); end

  def stretches(); end

  def stretches=(value); end
end

module Devise::Models::DatabaseAuthenticatable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::DatabaseAuthenticatable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.required_fields(klass); end
end

module Devise::Models::Lockable
  def access_locked?(); end

  def active_for_authentication?(); end

  def attempts_exceeded?(); end

  def if_access_locked(); end

  def inactive_message(); end

  def increment_failed_attempts(); end

  def last_attempt?(); end

  def lock_access!(opts=T.unsafe(nil)); end

  def lock_expired?(); end

  def lock_strategy_enabled?(*args, &block); end

  def resend_unlock_instructions(); end

  def send_unlock_instructions(); end

  def unauthenticated_message(); end

  def unlock_access!(); end

  def unlock_strategy_enabled?(*args, &block); end

  def valid_for_authentication?(); end
end

module Devise::Models::Lockable::ClassMethods
  def last_attempt_warning(); end

  def last_attempt_warning=(value); end

  def lock_strategy(); end

  def lock_strategy=(value); end

  def lock_strategy_enabled?(strategy); end

  def maximum_attempts(); end

  def maximum_attempts=(value); end

  def send_unlock_instructions(attributes=T.unsafe(nil)); end

  def unlock_access_by_token(unlock_token); end

  def unlock_in(); end

  def unlock_in=(value); end

  def unlock_keys(); end

  def unlock_keys=(value); end

  def unlock_strategy(); end

  def unlock_strategy=(value); end

  def unlock_strategy_enabled?(strategy); end
  BOTH_STRATEGIES = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Lockable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Lockable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.required_fields(klass); end
end

class Devise::Models::MissingAttribute
  def initialize(attributes); end
end

class Devise::Models::MissingAttribute
end

module Devise::Models::Omniauthable
end

module Devise::Models::Omniauthable::ClassMethods
  def omniauth_providers(); end

  def omniauth_providers=(value); end
end

module Devise::Models::Omniauthable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Omniauthable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.required_fields(klass); end
end

module Devise::Models::Recoverable
  def clear_reset_password_token(); end

  def clear_reset_password_token?(); end

  def reset_password(new_password, new_password_confirmation); end

  def reset_password_period_valid?(); end

  def send_reset_password_instructions(); end

  def send_reset_password_instructions_notification(token); end

  def set_reset_password_token(); end
end

module Devise::Models::Recoverable::ClassMethods
  def reset_password_by_token(attributes=T.unsafe(nil)); end

  def reset_password_keys(); end

  def reset_password_keys=(value); end

  def reset_password_within(); end

  def reset_password_within=(value); end

  def send_reset_password_instructions(attributes=T.unsafe(nil)); end

  def sign_in_after_reset_password(); end

  def sign_in_after_reset_password=(value); end

  def with_reset_password_token(token); end
end

module Devise::Models::Recoverable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Recoverable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.required_fields(klass); end
end

module Devise::Models::Registerable
end

module Devise::Models::Registerable::ClassMethods
  def new_with_session(params, session); end

  def sign_in_after_change_password(); end

  def sign_in_after_change_password=(value); end
end

module Devise::Models::Registerable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Registerable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.required_fields(klass); end
end

module Devise::Models::Rememberable
  def after_remembered(); end

  def extend_remember_period(); end

  def forget_me!(); end

  def remember_expires_at(); end

  def remember_me(); end

  def remember_me!(); end

  def remember_me=(remember_me); end

  def remember_me?(token, generated_at); end

  def rememberable_options(); end

  def rememberable_value(); end
end

module Devise::Models::Rememberable::ClassMethods
  def expire_all_remember_me_on_sign_out(); end

  def expire_all_remember_me_on_sign_out=(value); end

  def extend_remember_period(); end

  def extend_remember_period=(value); end

  def remember_for(); end

  def remember_for=(value); end

  def remember_token(); end

  def rememberable_options(); end

  def rememberable_options=(value); end

  def serialize_from_cookie(*args); end

  def serialize_into_cookie(record); end
end

module Devise::Models::Rememberable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Rememberable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.required_fields(klass); end
end

module Devise::Models::Timeoutable
  def timedout?(last_access); end

  def timeout_in(); end
end

module Devise::Models::Timeoutable::ClassMethods
  def timeout_in(); end

  def timeout_in=(value); end
end

module Devise::Models::Timeoutable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Timeoutable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.required_fields(klass); end
end

module Devise::Models::Trackable
  def extract_ip_from(request); end

  def update_tracked_fields(request); end

  def update_tracked_fields!(request); end
end

module Devise::Models::Trackable
  extend ::T::Sig
  def self.required_fields(klass); end
end

module Devise::Models::Validatable
  def email_required?(); end

  def password_required?(); end
  VALIDATIONS = ::T.let(nil, ::T.untyped)
end

module Devise::Models::Validatable::ClassMethods
  def email_regexp(); end

  def email_regexp=(value); end

  def password_length(); end

  def password_length=(value); end
end

module Devise::Models::Validatable::ClassMethods
  extend ::T::Sig
  def self.available_configs(); end

  def self.available_configs=(available_configs); end
end

module Devise::Models::Validatable
  extend ::T::Sig
  def self.assert_validations_api!(base); end

  def self.included(base); end

  def self.required_fields(klass); end
end

module Devise::Models
  extend ::T::Sig
  def self.check_fields!(klass); end

  def self.config(mod, *accessors); end
end

module Devise::OmniAuth
end

class Devise::OmniAuth::Config
  def args(); end

  def autoload_strategy(); end

  def find_strategy(); end

  def initialize(provider, args); end

  def options(); end

  def provider(); end

  def strategy(); end

  def strategy=(strategy); end

  def strategy_class(); end

  def strategy_name(); end
end

class Devise::OmniAuth::Config
end

module Devise::OmniAuth::UrlHelpers
  def omniauth_authorize_path(resource_or_scope, provider, *args); end

  def omniauth_authorize_url(resource_or_scope, provider, *args); end

  def omniauth_callback_path(resource_or_scope, provider, *args); end

  def omniauth_callback_url(resource_or_scope, provider, *args); end
end

module Devise::OmniAuth::UrlHelpers
  extend ::T::Sig
end

module Devise::OmniAuth
  extend ::T::Sig
end

class Devise::ParameterFilter
  def filter(conditions); end

  def filtered_hash_by_method_for_given_keys(conditions, method, condition_keys); end

  def initialize(case_insensitive_keys, strip_whitespace_keys); end

  def stringify_params(conditions); end
end

class Devise::ParameterFilter
end

class Devise::ParameterSanitizer
  def initialize(resource_class, resource_name, params); end

  def permit(action, keys: T.unsafe(nil), except: T.unsafe(nil), &block); end

  def sanitize(action); end
  DEFAULT_PERMITTED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Devise::ParameterSanitizer
end

class Devise::PasswordsController
  def after_resetting_password_path_for(resource); end

  def after_sending_reset_password_instructions_path_for(resource_name); end

  def assert_reset_token_passed(); end

  def create(); end

  def edit(); end

  def new(); end

  def unlockable?(resource); end

  def update(); end
end

class Devise::PasswordsController
end

class Devise::RegistrationsController
  def account_update_params(); end

  def after_inactive_sign_up_path_for(resource); end

  def after_sign_up_path_for(resource); end

  def after_update_path_for(resource); end

  def authenticate_scope!(); end

  def build_resource(hash=T.unsafe(nil)); end

  def cancel(); end

  def create(); end

  def destroy(); end

  def edit(); end

  def new(); end

  def sign_up(resource_name, resource); end

  def sign_up_params(); end

  def update(); end

  def update_needs_confirmation?(resource, previous); end

  def update_resource(resource, params); end
end

class Devise::RegistrationsController
end

module Devise::RouteSet
  def finalize!(); end
end

module Devise::RouteSet
  extend ::T::Sig
end

class Devise::SecretKeyFinder
  def find(); end

  def initialize(application); end
end

class Devise::SecretKeyFinder
end

class Devise::SessionsController
  def auth_options(); end

  def create(); end

  def destroy(); end

  def new(); end

  def serialize_options(resource); end

  def sign_in_params(); end
end

class Devise::SessionsController
end

module Devise::Strategies
end

class Devise::Strategies::Authenticatable
  def authentication_hash(); end

  def authentication_hash=(authentication_hash); end

  def authentication_type(); end

  def authentication_type=(authentication_type); end

  def clean_up_csrf?(); end

  def password(); end

  def password=(password); end
end

class Devise::Strategies::Authenticatable
end

class Devise::Strategies::Base
  def mapping(); end
end

class Devise::Strategies::Base
end

class Devise::Strategies::DatabaseAuthenticatable
  def authenticate!(); end
end

class Devise::Strategies::DatabaseAuthenticatable
end

class Devise::Strategies::Rememberable
  def authenticate!(); end
end

class Devise::Strategies::Rememberable
end

module Devise::Strategies
  extend ::T::Sig
end

module Devise::Test
end

module Devise::Test::ControllerHelpers
  def _catch_warden(&block); end

  def _process_unauthenticated(env, options=T.unsafe(nil)); end

  def process(*_); end

  def setup_controller_for_warden(); end

  def sign_in(resource, deprecated=T.unsafe(nil), scope: T.unsafe(nil)); end

  def sign_out(resource_or_scope); end

  def warden(); end
end

module Devise::Test::ControllerHelpers
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Devise::Test::IntegrationHelpers
  def setup_integration_for_devise(); end

  def sign_in(resource, scope: T.unsafe(nil)); end

  def sign_out(resource_or_scope); end

  def teardown_integration_for_devise(); end
end

module Devise::Test::IntegrationHelpers
  extend ::T::Sig
  def self.included(base); end
end

module Devise::Test
  extend ::T::Sig
end

module Devise::TestHelpers
end

module Devise::TestHelpers
  extend ::T::Sig
  def self.included(base); end
end

class Devise::TimeInflector
  include ::ActionView::Helpers::DateHelper
end

class Devise::TimeInflector
  def self.instance(); end

  def self.time_ago_in_words(*args, &block); end
end

class Devise::TokenGenerator
  def digest(klass, column, value); end

  def generate(klass, column); end

  def initialize(key_generator, digest=T.unsafe(nil)); end
end

class Devise::TokenGenerator
end

class Devise::UnlocksController
  def after_sending_unlock_instructions_path_for(resource); end

  def after_unlock_path_for(resource); end

  def create(); end

  def new(); end

  def show(); end
end

class Devise::UnlocksController
end

module Devise
  extend ::T::Sig
  def self.activerecord51?(); end

  def self.add_mapping(resource, options); end

  def self.add_module(module_name, options=T.unsafe(nil)); end

  def self.allow_unconfirmed_access_for(); end

  def self.allow_unconfirmed_access_for=(obj); end

  def self.authentication_keys(); end

  def self.authentication_keys=(obj); end

  def self.available_router_name(); end

  def self.case_insensitive_keys(); end

  def self.case_insensitive_keys=(obj); end

  def self.clean_up_csrf_token_on_authentication(); end

  def self.clean_up_csrf_token_on_authentication=(obj); end

  def self.configure_warden!(); end

  def self.confirm_within(); end

  def self.confirm_within=(obj); end

  def self.confirmation_keys(); end

  def self.confirmation_keys=(obj); end

  def self.default_scope(); end

  def self.default_scope=(obj); end

  def self.email_regexp(); end

  def self.email_regexp=(obj); end

  def self.expire_all_remember_me_on_sign_out(); end

  def self.expire_all_remember_me_on_sign_out=(obj); end

  def self.extend_remember_period(); end

  def self.extend_remember_period=(obj); end

  def self.friendly_token(length=T.unsafe(nil)); end

  def self.helpers(); end

  def self.http_authenticatable(); end

  def self.http_authenticatable=(obj); end

  def self.http_authenticatable_on_xhr(); end

  def self.http_authenticatable_on_xhr=(obj); end

  def self.http_authentication_key(); end

  def self.http_authentication_key=(obj); end

  def self.http_authentication_realm(); end

  def self.http_authentication_realm=(obj); end

  def self.include_helpers(scope); end

  def self.last_attempt_warning(); end

  def self.last_attempt_warning=(obj); end

  def self.lock_strategy(); end

  def self.lock_strategy=(obj); end

  def self.mailer(); end

  def self.mailer=(class_name); end

  def self.mailer_sender(); end

  def self.mailer_sender=(obj); end

  def self.mappings(); end

  def self.maximum_attempts(); end

  def self.maximum_attempts=(obj); end

  def self.navigational_formats(); end

  def self.navigational_formats=(obj); end

  def self.omniauth(provider, *args); end

  def self.omniauth_configs(); end

  def self.omniauth_path_prefix(); end

  def self.omniauth_path_prefix=(obj); end

  def self.omniauth_providers(); end

  def self.params_authenticatable(); end

  def self.params_authenticatable=(obj); end

  def self.paranoid(); end

  def self.paranoid=(obj); end

  def self.parent_controller(); end

  def self.parent_controller=(obj); end

  def self.parent_mailer(); end

  def self.parent_mailer=(obj); end

  def self.password_length(); end

  def self.password_length=(obj); end

  def self.pepper(); end

  def self.pepper=(obj); end

  def self.rails51?(); end

  def self.reconfirmable(); end

  def self.reconfirmable=(obj); end

  def self.ref(arg); end

  def self.regenerate_helpers!(); end

  def self.reload_routes(); end

  def self.reload_routes=(obj); end

  def self.remember_for(); end

  def self.remember_for=(obj); end

  def self.rememberable_options(); end

  def self.rememberable_options=(obj); end

  def self.request_keys(); end

  def self.request_keys=(obj); end

  def self.reset_password_keys(); end

  def self.reset_password_keys=(obj); end

  def self.reset_password_within(); end

  def self.reset_password_within=(obj); end

  def self.router_name(); end

  def self.router_name=(obj); end

  def self.scoped_views(); end

  def self.scoped_views=(obj); end

  def self.secret_key(); end

  def self.secret_key=(obj); end

  def self.secure_compare(a, b); end

  def self.send_email_changed_notification(); end

  def self.send_email_changed_notification=(obj); end

  def self.send_password_change_notification(); end

  def self.send_password_change_notification=(obj); end

  def self.setup(); end

  def self.sign_in_after_change_password(); end

  def self.sign_in_after_change_password=(obj); end

  def self.sign_in_after_reset_password(); end

  def self.sign_in_after_reset_password=(obj); end

  def self.sign_out_all_scopes(); end

  def self.sign_out_all_scopes=(obj); end

  def self.sign_out_via(); end

  def self.sign_out_via=(obj); end

  def self.skip_session_storage(); end

  def self.skip_session_storage=(obj); end

  def self.stretches(); end

  def self.stretches=(obj); end

  def self.strip_whitespace_keys(); end

  def self.strip_whitespace_keys=(obj); end

  def self.timeout_in(); end

  def self.timeout_in=(obj); end

  def self.token_generator(); end

  def self.token_generator=(obj); end

  def self.unlock_in(); end

  def self.unlock_in=(obj); end

  def self.unlock_keys(); end

  def self.unlock_keys=(obj); end

  def self.unlock_strategy(); end

  def self.unlock_strategy=(obj); end

  def self.warden(&block); end

  def self.warden_config(); end

  def self.warden_config=(obj); end
end

class DeviseController
  include ::Devise::Controllers::ScopedViews
  def assert_is_devise_resource!(); end

  def clean_up_passwords(object); end

  def devise_i18n_options(options); end

  def devise_mapping(); end

  def find_message(kind, options=T.unsafe(nil)); end

  def navigational_formats(); end

  def require_no_authentication(); end

  def resource(); end

  def resource=(new_resource); end

  def resource_class(); end

  def resource_name(); end

  def resource_params(); end

  def respond_with_navigational(*args, &block); end

  def scope_name(); end

  def set_flash_message(key, kind, options=T.unsafe(nil)); end

  def set_flash_message!(key, kind, options=T.unsafe(nil)); end

  def set_minimum_password_length(); end

  def signed_in_resource(); end

  def successfully_sent?(resource); end

  def translation_scope(); end

  def unknown_action!(msg); end
end

class DeviseController
end

module DeviseHelper
  def devise_error_messages!(); end
end

module DeviseHelper
  extend ::T::Sig
end

class DidYouMean::ClassNameChecker
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def class_name(); end

  def class_names(); end

  def corrections(); end

  def initialize(exception); end

  def scopes(); end
end

class DidYouMean::ClassNameChecker
  extend ::T::Sig
end

module DidYouMean::Correctable
  def corrections(); end

  def original_message(); end

  def spell_checker(); end

  def to_s(); end
end

module DidYouMean::Correctable
  extend ::T::Sig
end

class DidYouMean::DeprecatedIgnoredCallers
  def +(*_); end

  def <<(*_); end
end

class DidYouMean::DeprecatedIgnoredCallers
end

module DidYouMean::Jaro
  extend ::T::Sig
  def self.distance(str1, str2); end
end

module DidYouMean::JaroWinkler
  extend ::T::Sig
  def self.distance(str1, str2); end
end

class DidYouMean::KeyErrorChecker
  def corrections(); end

  def initialize(key_error); end
end

class DidYouMean::KeyErrorChecker
end

module DidYouMean::Levenshtein
  extend ::T::Sig
  def self.distance(str1, str2); end

  def self.min3(a, b, c); end
end

class DidYouMean::MethodNameChecker
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def corrections(); end

  def initialize(exception); end

  def method_name(); end

  def method_names(); end

  def receiver(); end
end

class DidYouMean::MethodNameChecker
  extend ::T::Sig
end

class DidYouMean::NullChecker
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def corrections(); end

  def initialize(*_); end
end

class DidYouMean::NullChecker
  extend ::T::Sig
end

class DidYouMean::PlainFormatter
  def message_for(corrections); end
end

class DidYouMean::PlainFormatter
end

class DidYouMean::SpellChecker
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def correct(input); end

  def initialize(dictionary:); end
end

class DidYouMean::SpellChecker
  extend ::T::Sig
end

class DidYouMean::VariableNameChecker
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def corrections(); end

  def cvar_names(); end

  def initialize(exception); end

  def ivar_names(); end

  def lvar_names(); end

  def method_names(); end

  def name(); end
  RB_PREDEFINED_OBJECTS = ::T.let(nil, ::T.untyped)
end

class DidYouMean::VariableNameChecker
  extend ::T::Sig
end

module DidYouMean
  extend ::T::Sig
  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Digest::Base
  extend ::T::Sig
end

class Digest::Class
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Digest::Class
  extend ::T::Sig
end

module Digest::Instance
  extend ::T::Sig
end

class Digest::MD5
  extend ::T::Sig
end

class Digest::SHA1
  extend ::T::Sig
end

class Digest::SHA2
  extend ::T::Sig
end

class Digest::SHA256
  extend ::T::Sig
end

class Digest::SHA384
  extend ::T::Sig
end

class Digest::SHA512
  extend ::T::Sig
end

module Digest::UUID
  DNS_NAMESPACE = ::T.let(nil, ::T.untyped)
  OID_NAMESPACE = ::T.let(nil, ::T.untyped)
  URL_NAMESPACE = ::T.let(nil, ::T.untyped)
  X500_NAMESPACE = ::T.let(nil, ::T.untyped)
end

module Digest::UUID
  extend ::T::Sig
  def self.uuid_from_hash(hash_class, uuid_namespace, name); end

  def self.uuid_v3(uuid_namespace, name); end

  def self.uuid_v4(); end

  def self.uuid_v5(uuid_namespace, name); end
end

module Digest
  extend ::T::Sig
end

class Dir
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module Dir::Tmpname
  extend ::T::Sig
end

class Dir
  extend ::T::Sig
  def self.children(*_); end

  def self.each_child(*_); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.tmpdir(); end
end

class DomainName
  def <(other); end

  def <=(other); end

  def ==(other); end

  def >(other); end

  def >=(other); end

  def canonical?(); end

  def canonical_tld?(); end

  def cookie_domain?(domain, host_only=T.unsafe(nil)); end

  def domain(); end

  def domain_idn(); end

  def hostname(); end

  def hostname_idn(); end

  def idn(); end

  def initialize(hostname); end

  def ipaddr(); end

  def ipaddr?(); end

  def superdomain(); end

  def tld(); end

  def tld_idn(); end

  def to_str(); end

  def uri_host(); end
  DOT = ::T.let(nil, ::T.untyped)
  ETLD_DATA = ::T.let(nil, ::T.untyped)
  ETLD_DATA_DATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module DomainName::Punycode
  BASE = ::T.let(nil, ::T.untyped)
  CUTOFF = ::T.let(nil, ::T.untyped)
  DAMP = ::T.let(nil, ::T.untyped)
  DECODE_DIGIT = ::T.let(nil, ::T.untyped)
  DELIMITER = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  ENCODE_DIGIT = ::T.let(nil, ::T.untyped)
  INITIAL_BIAS = ::T.let(nil, ::T.untyped)
  INITIAL_N = ::T.let(nil, ::T.untyped)
  LOBASE = ::T.let(nil, ::T.untyped)
  MAXINT = ::T.let(nil, ::T.untyped)
  PREFIX = ::T.let(nil, ::T.untyped)
  RE_NONBASIC = ::T.let(nil, ::T.untyped)
  SKEW = ::T.let(nil, ::T.untyped)
  TMAX = ::T.let(nil, ::T.untyped)
  TMIN = ::T.let(nil, ::T.untyped)
end

class DomainName::Punycode::ArgumentError
end

class DomainName::Punycode::ArgumentError
end

class DomainName::Punycode::BufferOverflowError
end

class DomainName::Punycode::BufferOverflowError
end

module DomainName::Punycode
  extend ::T::Sig
  def self.decode(string); end

  def self.decode_hostname(hostname); end

  def self.encode(string); end

  def self.encode_hostname(hostname); end
end

class DomainName
  def self.etld_data(); end

  def self.normalize(domain); end
end

class EOFError
  include ::REST::Error::Connection
  include ::REST::Error
end

class EOFError
  extend ::T::Sig
end

class ERB
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end

  def result_with_hash(hash); end
end

class ERB::Compiler
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class ERB::Compiler::Buffer
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class ERB::Compiler::Buffer
  extend ::T::Sig
end

class ERB::Compiler::ExplicitScanner
  extend ::T::Sig
end

class ERB::Compiler::PercentLine
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class ERB::Compiler::PercentLine
  extend ::T::Sig
end

class ERB::Compiler::Scanner
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  DEFAULT_ETAGS = ::T.let(nil, ::T.untyped)
  DEFAULT_STAGS = ::T.let(nil, ::T.untyped)
end

class ERB::Compiler::Scanner
  extend ::T::Sig
end

class ERB::Compiler::SimpleScanner
  extend ::T::Sig
end

class ERB::Compiler::TrimScanner
  extend ::T::Sig
end

class ERB::Compiler
  extend ::T::Sig
end

module ERB::DefMethod
  extend ::T::Sig
end

module ERB::Util
  HTML_ESCAPE = ::T.let(nil, ::T.untyped)
  HTML_ESCAPE_ONCE_REGEXP = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE = ::T.let(nil, ::T.untyped)
  JSON_ESCAPE_REGEXP = ::T.let(nil, ::T.untyped)
end

module ERB::Util
  extend ::T::Sig
  def self.html_escape_once(s); end

  def self.json_escape(s); end

  def self.unwrapped_html_escape(s); end
end

class ERB
  extend ::T::Sig
end

Emitter = Psych::Stream::Emitter

class Encoding
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def _dump(*_); end
end

class Encoding::CompatibilityError
  extend ::T::Sig
end

class Encoding::Converter
  def convert(_); end

  def convpath(); end

  def destination_encoding(); end

  def finish(); end

  def initialize(*_); end

  def insert_output(_); end

  def last_error(); end

  def primitive_convert(*_); end

  def primitive_errinfo(); end

  def putback(*_); end

  def replacement(); end

  def replacement=(replacement); end

  def source_encoding(); end
end

class Encoding::Converter
  extend ::T::Sig
  def self.asciicompat_encoding(_); end

  def self.search_convpath(*_); end
end

class Encoding::ConverterNotFoundError
  extend ::T::Sig
end

class Encoding::InvalidByteSequenceError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_bytes(); end

  def incomplete_input?(); end

  def readagain_bytes(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::InvalidByteSequenceError
  extend ::T::Sig
end

class Encoding::UndefinedConversionError
  def destination_encoding(); end

  def destination_encoding_name(); end

  def error_char(); end

  def source_encoding(); end

  def source_encoding_name(); end
end

class Encoding::UndefinedConversionError
  extend ::T::Sig
end

class Encoding
  extend ::T::Sig
  def self._load(_); end

  def self.locale_charmap(); end
end

class EncodingError
  extend ::T::Sig
end

module Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def as_json(options=T.unsafe(nil)); end

  def chunk(); end

  def chunk_while(); end

  def drop_last(n); end

  def each_entry(*_); end

  def each_with_object(_); end

  def exclude?(object); end

  def grep_v(_); end

  def index_by(); end

  def lazy(); end

  def many?(); end

  def pluck(*keys); end

  def slice_after(*_); end

  def slice_before(*_); end

  def slice_when(); end

  def sum(identity=T.unsafe(nil), &block); end

  def to_set(klass=T.unsafe(nil), *args, &block); end

  def uniq(); end

  def without(*elements); end

  def zip(*_); end
end

module Enumerable
  extend ::T::Sig
end

class Enumerator
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Enumerator::Generator
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def each(*_); end

  def initialize(*_); end
end

class Enumerator::Generator
  extend ::T::Sig
end

class Enumerator::Lazy
  def chunk(*_); end

  def chunk_while(*_); end

  def force(*_); end

  def slice_when(*_); end
end

class Enumerator::Lazy
  extend ::T::Sig
end

class Enumerator::Yielder
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Enumerator::Yielder
  extend ::T::Sig
end

class Enumerator
  extend ::T::Sig
end

class Errno::E2BIG
  extend ::T::Sig
end

class Errno::EACCES
  extend ::T::Sig
end

class Errno::EADDRINUSE
  extend ::T::Sig
end

class Errno::EADDRNOTAVAIL
  extend ::T::Sig
end

class Errno::EAFNOSUPPORT
  extend ::T::Sig
end

class Errno::EAGAIN
  extend ::T::Sig
end

class Errno::EALREADY
  extend ::T::Sig
end

class Errno::EAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EAUTH
end

class Errno::EBADF
  extend ::T::Sig
end

class Errno::EBADMSG
  extend ::T::Sig
end

class Errno::EBADRPC
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EBADRPC
end

class Errno::EBUSY
  extend ::T::Sig
end

class Errno::ECANCELED
  extend ::T::Sig
end

Errno::ECAPMODE = Errno::NOERROR

class Errno::ECHILD
  extend ::T::Sig
end

class Errno::ECONNABORTED
  include ::REST::Error::Connection
  include ::REST::Error
end

class Errno::ECONNABORTED
  extend ::T::Sig
end

class Errno::ECONNREFUSED
  include ::REST::Error::Connection
  include ::REST::Error
end

class Errno::ECONNREFUSED
  extend ::T::Sig
end

class Errno::ECONNRESET
  include ::REST::Error::Connection
  include ::REST::Error
end

class Errno::ECONNRESET
  extend ::T::Sig
end

class Errno::EDEADLK
  extend ::T::Sig
end

Errno::EDEADLOCK = Errno::NOERROR

class Errno::EDESTADDRREQ
  extend ::T::Sig
end

class Errno::EDOM
  extend ::T::Sig
end

Errno::EDOOFUS = Errno::NOERROR

class Errno::EDQUOT
  extend ::T::Sig
end

class Errno::EEXIST
  extend ::T::Sig
end

class Errno::EFAULT
  extend ::T::Sig
end

class Errno::EFBIG
  extend ::T::Sig
end

class Errno::EFTYPE
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EFTYPE
end

class Errno::EHOSTDOWN
  include ::REST::Error::Connection
  include ::REST::Error
end

class Errno::EHOSTDOWN
  extend ::T::Sig
end

class Errno::EHOSTUNREACH
  include ::REST::Error::Connection
  include ::REST::Error
end

class Errno::EHOSTUNREACH
  extend ::T::Sig
end

class Errno::EIDRM
  extend ::T::Sig
end

class Errno::EILSEQ
  extend ::T::Sig
end

class Errno::EINPROGRESS
  extend ::T::Sig
end

class Errno::EINTR
  extend ::T::Sig
end

class Errno::EINVAL
  include ::REST::Error::Connection
  include ::REST::Error
end

class Errno::EINVAL
  extend ::T::Sig
end

class Errno::EIO
  extend ::T::Sig
end

Errno::EIPSEC = Errno::NOERROR

class Errno::EISCONN
  extend ::T::Sig
end

class Errno::EISDIR
  extend ::T::Sig
end

class Errno::ELOOP
  extend ::T::Sig
end

class Errno::EMFILE
  extend ::T::Sig
end

class Errno::EMLINK
  extend ::T::Sig
end

class Errno::EMSGSIZE
  extend ::T::Sig
end

class Errno::EMULTIHOP
  extend ::T::Sig
end

class Errno::ENAMETOOLONG
  extend ::T::Sig
end

class Errno::ENEEDAUTH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENEEDAUTH
end

class Errno::ENETDOWN
  extend ::T::Sig
end

class Errno::ENETRESET
  extend ::T::Sig
end

class Errno::ENETUNREACH
  include ::REST::Error::Connection
  include ::REST::Error
end

class Errno::ENETUNREACH
  extend ::T::Sig
end

class Errno::ENFILE
  extend ::T::Sig
end

class Errno::ENOATTR
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOATTR
end

class Errno::ENOBUFS
  extend ::T::Sig
end

class Errno::ENODATA
  extend ::T::Sig
end

class Errno::ENODEV
  extend ::T::Sig
end

class Errno::ENOENT
  extend ::T::Sig
end

class Errno::ENOEXEC
  extend ::T::Sig
end

class Errno::ENOLCK
  extend ::T::Sig
end

class Errno::ENOLINK
  extend ::T::Sig
end

class Errno::ENOMEM
  extend ::T::Sig
end

class Errno::ENOMSG
  extend ::T::Sig
end

class Errno::ENOPROTOOPT
  extend ::T::Sig
end

class Errno::ENOSPC
  extend ::T::Sig
end

class Errno::ENOSR
  extend ::T::Sig
end

class Errno::ENOSTR
  extend ::T::Sig
end

class Errno::ENOSYS
  extend ::T::Sig
end

class Errno::ENOTBLK
  extend ::T::Sig
end

Errno::ENOTCAPABLE = Errno::NOERROR

class Errno::ENOTCONN
  extend ::T::Sig
end

class Errno::ENOTDIR
  extend ::T::Sig
end

class Errno::ENOTEMPTY
  extend ::T::Sig
end

class Errno::ENOTRECOVERABLE
  extend ::T::Sig
end

class Errno::ENOTSOCK
  extend ::T::Sig
end

class Errno::ENOTSUP
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ENOTSUP
end

class Errno::ENOTTY
  extend ::T::Sig
end

class Errno::ENXIO
  extend ::T::Sig
end

class Errno::EOPNOTSUPP
  extend ::T::Sig
end

class Errno::EOVERFLOW
  extend ::T::Sig
end

class Errno::EOWNERDEAD
  extend ::T::Sig
end

class Errno::EPERM
  extend ::T::Sig
end

class Errno::EPFNOSUPPORT
  extend ::T::Sig
end

class Errno::EPIPE
  extend ::T::Sig
end

class Errno::EPROCLIM
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCLIM
end

class Errno::EPROCUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROCUNAVAIL
end

class Errno::EPROGMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGMISMATCH
end

class Errno::EPROGUNAVAIL
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::EPROGUNAVAIL
end

class Errno::EPROTO
  extend ::T::Sig
end

class Errno::EPROTONOSUPPORT
  extend ::T::Sig
end

class Errno::EPROTOTYPE
  extend ::T::Sig
end

class Errno::ERANGE
  extend ::T::Sig
end

class Errno::EREMOTE
  extend ::T::Sig
end

class Errno::EROFS
  extend ::T::Sig
end

class Errno::ERPCMISMATCH
  Errno = ::T.let(nil, ::T.untyped)
end

class Errno::ERPCMISMATCH
end

class Errno::ESHUTDOWN
  extend ::T::Sig
end

class Errno::ESOCKTNOSUPPORT
  extend ::T::Sig
end

class Errno::ESPIPE
  extend ::T::Sig
end

class Errno::ESRCH
  extend ::T::Sig
end

class Errno::ESTALE
  extend ::T::Sig
end

class Errno::ETIME
  extend ::T::Sig
end

class Errno::ETIMEDOUT
  include ::REST::Error::Timeout
  include ::REST::Error
end

class Errno::ETIMEDOUT
  extend ::T::Sig
end

class Errno::ETOOMANYREFS
  extend ::T::Sig
end

class Errno::ETXTBSY
  extend ::T::Sig
end

class Errno::EUSERS
  extend ::T::Sig
end

class Errno::EXDEV
  extend ::T::Sig
end

class Errno::NOERROR
  extend ::T::Sig
end

module Errno
  extend ::T::Sig
end

module ErrorHandler
  extend ::T::Sig
end

module Errors
  extend ::T::Sig
end

module Erubi
  RANGE_ALL = ::T.let(nil, ::T.untyped)
  RANGE_FIRST = ::T.let(nil, ::T.untyped)
  RANGE_LAST = ::T.let(nil, ::T.untyped)
  TEXT_END = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Erubi::Engine
  def bufvar(); end

  def filename(); end

  def initialize(input, properties=T.unsafe(nil)); end

  def src(); end
end

class Erubi::Engine
end

module Erubi
  extend ::T::Sig
  def self.h(value); end
end

class Etc::Group
  def gid(); end

  def gid=(_); end

  def mem(); end

  def mem=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end
end

class Etc::Group
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(); end

  def self.members(); end
end

class Etc::Passwd
  def change(); end

  def change=(_); end

  def dir(); end

  def dir=(_); end

  def expire(); end

  def expire=(_); end

  def gecos(); end

  def gecos=(_); end

  def gid(); end

  def gid=(_); end

  def name(); end

  def name=(_); end

  def passwd(); end

  def passwd=(_); end

  def shell(); end

  def shell=(_); end

  def uclass(); end

  def uclass=(_); end

  def uid(); end

  def uid=(_); end
end

class Etc::Passwd
  extend ::T::Sig
  extend ::Enumerable
  def self.[](*_); end

  def self.each(); end

  def self.members(); end
end

module Etc
  extend ::T::Sig
  def self.confstr(_); end

  def self.endgrent(); end

  def self.endpwent(); end

  def self.getgrent(); end

  def self.getgrgid(*_); end

  def self.getgrnam(_); end

  def self.getlogin(); end

  def self.getpwent(); end

  def self.getpwnam(_); end

  def self.getpwuid(*_); end

  def self.group(); end

  def self.nprocessors(); end

  def self.passwd(); end

  def self.setgrent(); end

  def self.setpwent(); end

  def self.sysconf(_); end

  def self.sysconfdir(); end

  def self.systmpdir(); end

  def self.uname(); end
end

module Events
end

class Events::BaseEvent
  def _deprecated_json(); end

  def initialize(action:, model:, user: T.unsafe(nil)); end

  def json(*args, &block); end

  def object(); end

  def properties(); end

  def routing_key(); end

  def subject(); end

  def to_json(); end

  def verb(); end
end

class Events::BaseEvent
  extend ::Gem::Deprecate
end

module Events
  extend ::T::Sig
end

class Exception
  include ::ActiveSupport::Dependencies::Blamable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def __bb_context(); end

  def full_message(*_); end

end

class Exception
  extend ::T::Sig
  def self.exception(*_); end

  def self.to_tty?(); end
end

module Exception2MessageMapper
  def bind(cl); end
end

Exception2MessageMapper::E2MM = Exception2MessageMapper

class Exception2MessageMapper::ErrNotRegisteredException
end

class Exception2MessageMapper::ErrNotRegisteredException
end

module Exception2MessageMapper
  extend ::T::Sig
  def self.Fail(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.Raise(klass=T.unsafe(nil), err=T.unsafe(nil), *rest); end

  def self.def_e2message(k, c, m); end

  def self.def_exception(k, n, m, s=T.unsafe(nil)); end

  def self.e2mm_message(klass, exp); end

  def self.extend_object(cl); end

  def self.message(klass, exp); end
end

module Exchange
  extend ::T::Sig
end

class ExchangeSchema
end

module ExecJS
  VERSION = ::T.let(nil, ::T.untyped)
end

class ExecJS::DisabledRuntime
end

class ExecJS::DisabledRuntime
end

class ExecJS::DuktapeRuntime
end

class ExecJS::DuktapeRuntime::Context
  def call(identifier, *args); end
end

class ExecJS::DuktapeRuntime::Context
end

class ExecJS::DuktapeRuntime
end

module ExecJS::Encoding
  def encode(string); end
end

module ExecJS::Encoding
  extend ::T::Sig
end

class ExecJS::Error
end

class ExecJS::Error
end

class ExecJS::ExternalRuntime
  def encode_source(source); end

  def encode_unicode_codepoints(str); end

  def exec_runtime(filename); end

  def exec_runtime_error(output); end

  def generate_compile_method(path); end

  def initialize(options); end

  def json2_source(); end

  def which(command); end
end

class ExecJS::ExternalRuntime::Context
  def call(identifier, *args); end

  def create_tempfile(basename); end

  def extract_result(output, filename); end

  def write_to_tempfile(contents); end
end

class ExecJS::ExternalRuntime::Context
end

class ExecJS::ExternalRuntime
end

class ExecJS::MiniRacerRuntime
end

class ExecJS::MiniRacerRuntime::Context
  def call(identifier, *args); end
end

class ExecJS::MiniRacerRuntime::Context
end

class ExecJS::MiniRacerRuntime
end

class ExecJS::ProgramError
end

class ExecJS::ProgramError
end

class ExecJS::RubyRacerRuntime
end

class ExecJS::RubyRacerRuntime::Context
  def unbox(value); end
end

class ExecJS::RubyRacerRuntime::Context
end

class ExecJS::RubyRacerRuntime
end

class ExecJS::RubyRhinoRuntime
end

class ExecJS::RubyRhinoRuntime::Context
  def unbox(value); end

  def wrap_error(e); end
end

class ExecJS::RubyRhinoRuntime::Context
end

class ExecJS::RubyRhinoRuntime
end

class ExecJS::Runtime
  def available?(); end

  def compile(source, options=T.unsafe(nil)); end

  def context_class(); end

  def deprecated?(); end

  def eval(source, options=T.unsafe(nil)); end

  def exec(source, options=T.unsafe(nil)); end

  def name(); end
end

class ExecJS::Runtime::Context
  include ::ExecJS::Encoding
  def call(properties, *args); end

  def eval(source, options=T.unsafe(nil)); end

  def exec(source, options=T.unsafe(nil)); end

  def initialize(runtime, source=T.unsafe(nil), options=T.unsafe(nil)); end
end

class ExecJS::Runtime::Context
end

class ExecJS::Runtime
end

class ExecJS::RuntimeError
end

class ExecJS::RuntimeError
end

class ExecJS::RuntimeUnavailable
end

class ExecJS::RuntimeUnavailable
end

module ExecJS::Runtimes
  Disabled = ::T.let(nil, ::T.untyped)
  Duktape = ::T.let(nil, ::T.untyped)
  JScript = ::T.let(nil, ::T.untyped)
  JavaScriptCore = ::T.let(nil, ::T.untyped)
  MiniRacer = ::T.let(nil, ::T.untyped)
  Node = ::T.let(nil, ::T.untyped)
  RubyRacer = ::T.let(nil, ::T.untyped)
  RubyRhino = ::T.let(nil, ::T.untyped)
  SpiderMonkey = ::T.let(nil, ::T.untyped)
  Spidermonkey = ::T.let(nil, ::T.untyped)
  V8 = ::T.let(nil, ::T.untyped)
end

module ExecJS::Runtimes
  extend ::T::Sig
  def self.autodetect(); end

  def self.best_available(); end

  def self.from_environment(); end

  def self.names(); end

  def self.runtimes(); end
end

module ExecJS
  extend ::T::Sig
  def self.compile(source, options=T.unsafe(nil)); end

  def self.cygwin?(); end

  def self.eval(source, options=T.unsafe(nil)); end

  def self.exec(source, options=T.unsafe(nil)); end

  def self.root(); end

  def self.runtime(); end

  def self.runtime=(runtime); end

  def self.runtimes(); end

  def self.windows?(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FSEvent
  def callback(); end

  def initialize(args=T.unsafe(nil), &block); end

  def open_pipe(); end

  def paths(); end

  def process_running?(pid); end

  def run(); end

  def stop(); end

  def watch(watch_paths, options=T.unsafe(nil), &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class FSEvent
  def self.root_path(); end

  def self.watcher_path(); end
end

class Fabricate
end

class Fabricate
  def self.attributes_for(name, overrides=T.unsafe(nil), &block); end

  def self.attributes_for_times(count, name, overrides=T.unsafe(nil), &block); end

  def self.build(name, overrides=T.unsafe(nil), &block); end

  def self.build_times(count, name, overrides=T.unsafe(nil), &block); end

  def self.create(name, overrides=T.unsafe(nil), &block); end

  def self.fail_if_initializing(name); end

  def self.schematic(name); end

  def self.sequence(name=T.unsafe(nil), start=T.unsafe(nil), &block); end

  def self.times(count, name, overrides=T.unsafe(nil), &block); end

  def self.to_params(name, overrides=T.unsafe(nil), &block); end
end

module Fabrication
end

module Fabrication::Config
  def configure(); end

  def fabricator_dir(); end

  def fabricator_dir=(folders); end

  def fabricator_path(); end

  def fabricator_path=(folders); end

  def fabricator_paths(); end

  def generator_for(default_generators, klass); end

  def generators(); end

  def path_prefix(); end

  def path_prefix=(folders); end

  def path_prefixes(); end

  def recursion_limit(); end

  def recursion_limit=(limit); end

  def register_with_steps=(register_with_steps); end

  def register_with_steps?(); end

  def reset_defaults(); end

  def sequence_start(); end

  def sequence_start=(sequence_start); end
end

module Fabrication::Config
  extend ::Fabrication::Config
  extend ::T::Sig
end

module Fabrication::Cucumber
end

module Fabrication::Cucumber::Fabrications
end

module Fabrication::Cucumber::Fabrications
  extend ::T::Sig
  def self.[](fabricator); end

  def self.[]=(fabricator, fabrication); end
end

class Fabrication::Cucumber::StepFabricator
  def from_table(table, extra=T.unsafe(nil)); end

  def has_many(children); end

  def initialize(model_name, opts=T.unsafe(nil)); end

  def klass(); end

  def model(); end

  def n(count, attrs=T.unsafe(nil)); end

  def parent(); end
end

class Fabrication::Cucumber::StepFabricator
end

module Fabrication::Cucumber
  extend ::T::Sig
end

class Fabrication::DuplicateFabricatorError
  def initialize(string); end
end

class Fabrication::DuplicateFabricatorError
end

module Fabrication::Generator
end

class Fabrication::Generator::ActiveRecord
end

class Fabrication::Generator::ActiveRecord
  def self.supports?(klass); end
end

class Fabrication::Generator::Base
  def _attributes(); end

  def _instance(); end

  def _instance=(_instance); end

  def _klass(); end

  def _klass=(_klass); end

  def _transient_attributes(); end

  def _transient_attributes=(_transient_attributes); end

  def build(attributes=T.unsafe(nil), callbacks=T.unsafe(nil)); end

  def build_instance(); end

  def build_instance_with_constructor_override(callback); end

  def build_instance_with_init_callback(callback); end

  def create(attributes=T.unsafe(nil), callbacks=T.unsafe(nil)); end

  def execute_callbacks(callbacks); end

  def initialize(klass); end

  def method_missing(method_name, *args, &block); end

  def persist(); end

  def process_attributes(attributes); end

  def set_attributes(); end

  def to_hash(attributes=T.unsafe(nil), callbacks=T.unsafe(nil)); end

  def to_params(attributes=T.unsafe(nil)); end
end

class Fabrication::Generator::Base
  def self.supports?(_klass); end
end

class Fabrication::Generator::DataMapper
end

class Fabrication::Generator::DataMapper
  def self.supports?(klass); end
end

class Fabrication::Generator::Mongoid
end

class Fabrication::Generator::Mongoid
  def self.supports?(klass); end
end

class Fabrication::Generator::Sequel
end

class Fabrication::Generator::Sequel
  def self.supports?(klass); end
end

module Fabrication::Generator
  extend ::T::Sig
end

class Fabrication::InfiniteRecursionError
  def initialize(name); end
end

class Fabrication::InfiniteRecursionError
end

class Fabrication::MisplacedFabricateError
  def initialize(name); end
end

class Fabrication::MisplacedFabricateError
end

class Fabrication::Railtie
end

class Fabrication::Railtie
end

module Fabrication::Schematic
end

class Fabrication::Schematic::Attribute
  def initialize(klass, name, value, params=T.unsafe(nil), &block); end

  def klass(); end

  def klass=(klass); end

  def name(); end

  def name=(name); end

  def params(); end

  def params=(params); end

  def processed_value(processed_attributes); end

  def transient!(); end

  def transient?(); end

  def value(); end

  def value=(value); end

  def value_proc?(); end

  def value_static?(); end
end

class Fabrication::Schematic::Attribute
end

class Fabrication::Schematic::Definition
  def append_or_update_attribute(attribute_name, value, params=T.unsafe(nil), &block); end

  def attribute(name); end

  def attributes(); end

  def attributes=(attributes); end

  def block(); end

  def block=(block); end

  def build(overrides=T.unsafe(nil), &block); end

  def callbacks(); end

  def callbacks=(callbacks); end

  def fabricate(overrides=T.unsafe(nil), &block); end

  def generate_value(name, params); end

  def generator(); end

  def initialize(name, options=T.unsafe(nil), &block); end

  def klass(); end

  def load_body(); end

  def loaded?(); end

  def merge(overrides=T.unsafe(nil), &block); end

  def name(); end

  def name=(name); end

  def options(); end

  def options=(options); end

  def parent(); end

  def process_block(&block); end

  def sorted_attributes(); end

  def to_attributes(overrides=T.unsafe(nil), &block); end

  def to_params(overrides=T.unsafe(nil), &block); end
  GENERATORS = ::T.let(nil, ::T.untyped)
end

class Fabrication::Schematic::Definition
end

class Fabrication::Schematic::Evaluator
  def after_build(&block); end

  def after_create(&block); end

  def after_save(&block); end

  def after_validation(&block); end

  def before_create(&block); end

  def before_save(&block); end

  def before_validation(&block); end

  def init_with(*args); end

  def initialize_with(&block); end

  def method_missing(method_name, *args, &block); end

  def on_init(&block); end

  def process(definition, &block); end

  def transient(*field_names); end
end

class Fabrication::Schematic::Evaluator
end

class Fabrication::Schematic::Manager
  include ::Singleton
  def [](name); end

  def build_stack(); end

  def clear(); end

  def create_stack(); end

  def empty?(); end

  def initializing?(); end

  def load_definitions(); end

  def preinitialize(); end

  def prevent_recursion!(); end

  def raise_if_registered(name); end

  def register(name, options, &block); end

  def schematics(); end

  def store(name, aliases, options, &block); end

  def to_params_stack(); end
end

class Fabrication::Schematic::Manager
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Fabrication::Schematic::Runner
  def initialize(klass); end

  def klass(); end

  def klass=(klass); end

  def sequence(name=T.unsafe(nil), start=T.unsafe(nil), &block); end
end

class Fabrication::Schematic::Runner
end

module Fabrication::Schematic
  extend ::T::Sig
end

class Fabrication::Sequencer
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Fabrication::Sequencer
  def self.reset(); end

  def self.sequence(name=T.unsafe(nil), start=T.unsafe(nil), &block); end

  def self.sequence_blocks(); end

  def self.sequences(); end
end

class Fabrication::Support
end

class Fabrication::Support
  def self.class_for(class_or_to_s); end

  def self.constantize(camel_cased_word); end

  def self.extract_options!(args); end

  def self.fabricatable?(name); end

  def self.find_definitions(); end

  def self.hash_class(); end

  def self.singularize(string); end

  def self.underscore(string); end

  def self.variable_name_to_class_name(name); end
end

class Fabrication::Transform
end

class Fabrication::Transform
  def self.apply_to(schematic, attributes_hash); end

  def self.clear_all(); end

  def self.define(attribute, transform); end

  def self.only_for(schematic, attribute, transform); end
end

class Fabrication::UnfabricatableError
  def initialize(name, original_error); end
end

class Fabrication::UnfabricatableError
end

class Fabrication::UnknownFabricatorError
  def initialize(name); end
end

class Fabrication::UnknownFabricatorError
end

module Fabrication
  extend ::T::Sig
  def self.clear_definitions(); end

  def self.configure(&block); end

  def self.manager(); end

  def self.schematics(); end
end

module FabricationMethods
  def fabrications(); end
end

module FabricationMethods
  extend ::T::Sig
end

class FalseClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class FalseClass
  extend ::T::Sig
end

module Faraday
  VERSION = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter
  def call(env); end

  def initialize(app=T.unsafe(nil), opts=T.unsafe(nil), &block); end
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::EMHttp
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end

  def error_message(client); end

  def parallel?(env); end

  def perform_request(env); end

  def perform_single_request(env); end

  def raise_error(msg); end
end

class Faraday::Adapter::EMHttp::Manager
  def add(); end

  def check_finished(); end

  def perform_request(); end

  def reset(); end

  def run(); end

  def running?(); end
end

class Faraday::Adapter::EMHttp::Manager
end

module Faraday::Adapter::EMHttp::Options
  def configure_compression(options, env); end

  def configure_proxy(options, env); end

  def configure_socket(options, env); end

  def configure_ssl(options, env); end

  def configure_timeout(options, env); end

  def connection_config(env); end

  def read_body(env); end

  def request_config(env); end

  def request_options(env); end
end

module Faraday::Adapter::EMHttp::Options
  extend ::T::Sig
end

class Faraday::Adapter::EMHttp
  def self.setup_parallel_manager(options=T.unsafe(nil)); end
end

class Faraday::Adapter::EMSynchrony
  include ::Faraday::Adapter::EMHttp::Options
  def create_request(env); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
  def add(request, method, *args, &block); end

  def run(); end
end

class Faraday::Adapter::EMSynchrony::ParallelManager
end

class Faraday::Adapter::EMSynchrony
  def self.setup_parallel_manager(options=T.unsafe(nil)); end
end

class Faraday::Adapter::Excon
  def create_connection(env, opts); end

  def read_body(env); end
end

class Faraday::Adapter::Excon
end

class Faraday::Adapter::HTTPClient
  def client(); end

  def configure_client(); end

  def configure_proxy(proxy); end

  def configure_socket(bind); end

  def configure_ssl(ssl); end

  def configure_timeouts(req); end

  def ssl_cert_store(ssl); end

  def ssl_verify_mode(ssl); end
end

class Faraday::Adapter::HTTPClient
end

class Faraday::Adapter::NetHttp
  NET_HTTP_EXCEPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::NetHttp
end

class Faraday::Adapter::NetHttpPersistent
end

class Faraday::Adapter::NetHttpPersistent
end

module Faraday::Adapter::Parallelism
  def inherited(subclass); end

  def supports_parallel=(supports_parallel); end

  def supports_parallel?(); end
end

module Faraday::Adapter::Parallelism
  extend ::T::Sig
end

class Faraday::Adapter::Patron
  def configure_ssl(session, ssl); end
  CURL_TIMEOUT_MESSAGES = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Patron
end

class Faraday::Adapter::Rack
  def execute_request(env, rack_env); end

  def initialize(faraday_app, rack_app); end
  SPECIAL_HEADERS = ::T.let(nil, ::T.untyped)
end

class Faraday::Adapter::Rack
end

class Faraday::Adapter::Test
  def configure(); end

  def initialize(app, stubs=T.unsafe(nil), &block); end

  def stubs(); end

  def stubs=(stubs); end
end

class Faraday::Adapter::Test::Stub
  def headers_match?(request_headers); end

  def initialize(host, full, headers, body, block); end

  def matches?(request_host, request_uri, request_headers, request_body); end

  def params_match?(request_params); end

  def path_match?(request_path, meta); end
end

class Faraday::Adapter::Test::Stub
end

class Faraday::Adapter::Test::Stubs
  def delete(path, headers=T.unsafe(nil), &block); end

  def empty?(); end

  def get(path, headers=T.unsafe(nil), &block); end

  def head(path, headers=T.unsafe(nil), &block); end

  def match(request_method, host, path, headers, body); end

  def matches?(stack, host, path, headers, body); end

  def new_stub(request_method, path, headers=T.unsafe(nil), body=T.unsafe(nil), &block); end

  def options(path, headers=T.unsafe(nil), &block); end

  def patch(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def post(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def put(path, body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def verify_stubbed_calls(); end
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs::NotFound
end

class Faraday::Adapter::Test::Stubs
end

class Faraday::Adapter::Test
end

class Faraday::Adapter::Typhoeus
  def call(); end
end

class Faraday::Adapter::Typhoeus
end

class Faraday::Adapter
  extend ::Faraday::Adapter::Parallelism
  extend ::Faraday::AutoloadHelper
end

module Faraday::AutoloadHelper
  def all_loaded_constants(); end

  def autoload_all(prefix, options); end

  def load_autoloaded_constants(); end
end

module Faraday::AutoloadHelper
  extend ::T::Sig
end

class Faraday::ClientError
  def initialize(ex, response=T.unsafe(nil)); end

  def response(); end

  def wrapped_exception(); end
end

class Faraday::ClientError
end

class Faraday::CompositeReadIO
  def close(); end

  def ensure_open_and_readable(); end

  def initialize(*parts); end

  def length(); end

  def read(length=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end
end

class Faraday::CompositeReadIO
end

class Faraday::Connection
  def adapter(*args, &block); end

  def app(*args, &block); end

  def authorization(type, token); end

  def basic_auth(login, pass); end

  def build(*args, &block); end

  def build_exclusive_url(url=T.unsafe(nil), params=T.unsafe(nil), params_encoder=T.unsafe(nil)); end

  def build_request(method); end

  def build_url(url=T.unsafe(nil), extra_params=T.unsafe(nil)); end

  def builder(); end

  def default_parallel_manager(); end

  def default_parallel_manager=(default_parallel_manager); end

  def delete(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def find_default_proxy(); end

  def get(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def head(url=T.unsafe(nil), params=T.unsafe(nil), headers=T.unsafe(nil)); end

  def headers(); end

  def headers=(hash); end

  def host(*args, &block); end

  def host=(*args, &block); end

  def in_parallel(manager=T.unsafe(nil)); end

  def in_parallel?(); end

  def initialize(url=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def parallel_manager(); end

  def params(); end

  def params=(hash); end

  def patch(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def path_prefix(*args, &block); end

  def path_prefix=(value); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def post(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def proxy(arg=T.unsafe(nil)); end

  def proxy=(new_value); end

  def proxy_for_request(url); end

  def proxy_from_env(url); end

  def put(url=T.unsafe(nil), body=T.unsafe(nil), headers=T.unsafe(nil), &block); end

  def request(*args, &block); end

  def response(*args, &block); end

  def run_request(method, url, body, headers); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end

  def set_authorization_header(header_type, *args); end

  def ssl(); end

  def token_auth(token, options=T.unsafe(nil)); end

  def url_prefix(); end

  def url_prefix=(url, encoder=T.unsafe(nil)); end

  def use(*args, &block); end

  def with_uri_credentials(uri); end
  METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Connection
  extend ::Forwardable
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionFailed
end

class Faraday::ConnectionOptions
  def new_builder(block); end
end

class Faraday::ConnectionOptions
end

class Faraday::Env
  def []=(key, value); end

  def clear_body(); end

  def custom_members(); end

  def in_member_set?(key); end

  def needs_body?(); end

  def parallel?(); end

  def params_encoder(*args, &block); end

  def parse_body?(); end

  def success?(); end
  ContentLength = ::T.let(nil, ::T.untyped)
  MethodsWithBodies = ::T.let(nil, ::T.untyped)
  StatusesWithoutBody = ::T.let(nil, ::T.untyped)
  SuccessfulStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Env
  extend ::Forwardable
  def self.member_set(); end
end

class Faraday::Error
end

Faraday::Error::ClientError = Faraday::ClientError

Faraday::Error::ConnectionFailed = Faraday::ConnectionFailed

Faraday::Error::ParsingError = Faraday::ParsingError

Faraday::Error::ResourceNotFound = Faraday::ResourceNotFound

Faraday::Error::RetriableResponse = Faraday::RetriableResponse

Faraday::Error::SSLError = Faraday::SSLError

Faraday::Error::TimeoutError = Faraday::TimeoutError

class Faraday::Error
end

module Faraday::FlatParamsEncoder
end

module Faraday::FlatParamsEncoder
  extend ::T::Sig
  def self.decode(query); end

  def self.encode(params); end

  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::HttpCache
  def call(env); end

  def call!(env); end

  def create_storage(options); end

  def initialize(app, options=T.unsafe(nil)); end

  def request(); end

  def storage(); end
  CACHE_STATUSES = ::T.let(nil, ::T.untyped)
  ERROR_STATUSES = ::T.let(nil, ::T.untyped)
  EVENT_NAME = ::T.let(nil, ::T.untyped)
  UNSAFE_METHODS = ::T.let(nil, ::T.untyped)
  VALID_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::HttpCache::CacheControl
  def initialize(header); end

  def max_age(); end

  def must_revalidate?(); end

  def no_cache?(); end

  def no_store?(); end

  def normalize_max_ages(age); end

  def private?(); end

  def proxy_revalidate?(); end

  def public?(); end

  def s_maxage(); end

  def shared_max_age(); end
end

class Faraday::HttpCache::CacheControl
end

class Faraday::HttpCache::MemoryStore
  def delete(key); end

  def read(key); end

  def write(key, value); end
end

class Faraday::HttpCache::MemoryStore
end

class Faraday::HttpCache::Request
  def cache_control(); end

  def cacheable?(); end

  def headers(); end

  def initialize(options); end

  def method(); end

  def no_cache?(); end

  def serializable_hash(); end

  def url(); end
end

class Faraday::HttpCache::Request
  def self.from_env(env); end
end

class Faraday::HttpCache::Response
  def age(); end

  def cacheable_in_private_cache?(); end

  def cacheable_in_shared_cache?(); end

  def date(); end

  def etag(); end

  def fresh?(); end

  def initialize(payload=T.unsafe(nil)); end

  def last_modified(); end

  def max_age(); end

  def not_modified?(); end

  def payload(); end

  def serializable_hash(); end

  def to_response(env); end

  def ttl(); end
  CACHEABLE_STATUS_CODES = ::T.let(nil, ::T.untyped)
end

class Faraday::HttpCache::Response
end

class Faraday::HttpCache::Storage
  def cache(); end

  def delete(url); end

  def initialize(options=T.unsafe(nil)); end

  def read(request, klass=T.unsafe(nil)); end

  def write(request, response); end
end

class Faraday::HttpCache::Storage
end

class Faraday::HttpCache
end

class Faraday::Middleware
  def initialize(app=T.unsafe(nil)); end
end

class Faraday::Middleware
  extend ::Faraday::MiddlewareRegistry
  def self.dependency(lib=T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.load_error(); end

  def self.loaded?(); end
end

module Faraday::MiddlewareRegistry
  def fetch_middleware(key); end

  def load_middleware(key); end

  def lookup_middleware(key); end

  def middleware_mutex(&block); end

  def register_middleware(autoload_path=T.unsafe(nil), mapping=T.unsafe(nil)); end
end

module Faraday::MiddlewareRegistry
  extend ::T::Sig
end

module Faraday::NestedParamsEncoder
end

module Faraday::NestedParamsEncoder
  extend ::T::Sig
  def self.decode(query); end

  def self.dehash(hash, depth); end

  def self.encode(params); end

  def self.escape(*args, &block); end

  def self.unescape(*args, &block); end
end

class Faraday::Options
  def [](key); end

  def clear(); end

  def delete(key); end

  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, *args); end

  def has_key?(key); end

  def has_value?(value); end

  def key?(key); end

  def keys(); end

  def merge(other); end

  def merge!(other); end

  def symbolized_key_set(); end

  def to_hash(); end

  def update(obj); end

  def value?(value); end

  def values_at(*keys); end
end

class Faraday::Options
  def self.attribute_options(); end

  def self.fetch_error_class(); end

  def self.from(value); end

  def self.inherited(subclass); end

  def self.memoized(key); end

  def self.memoized_attributes(); end

  def self.options(mapping); end

  def self.options_for(key); end
end

class Faraday::ParsingError
end

class Faraday::ParsingError
end

Faraday::Parts = Parts

class Faraday::ProxyOptions
  def host(*args, &block); end

  def host=(*args, &block); end

  def path(*args, &block); end

  def path=(*args, &block); end

  def port(*args, &block); end

  def port=(*args, &block); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end
end

class Faraday::ProxyOptions
  extend ::Forwardable
end

class Faraday::RackBuilder
  def ==(other); end

  def [](idx); end

  def adapter(key, *args, &block); end

  def app(); end

  def build(options=T.unsafe(nil)); end

  def build_env(connection, request); end

  def build_response(connection, request); end

  def delete(handler); end

  def handlers(); end

  def handlers=(handlers); end

  def initialize(handlers=T.unsafe(nil)); end

  def insert(index, *args, &block); end

  def insert_after(index, *args, &block); end

  def insert_before(index, *args, &block); end

  def lock!(); end

  def locked?(); end

  def request(key, *args, &block); end

  def response(key, *args, &block); end

  def swap(index, *args, &block); end

  def to_app(inner_app); end

  def use(klass, *args, &block); end
end

class Faraday::RackBuilder::Handler
  def ==(other); end

  def build(app); end

  def initialize(klass, *args, &block); end

  def klass(); end

  def name(); end
end

class Faraday::RackBuilder::Handler
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder::StackLocked
end

class Faraday::RackBuilder
end

class Faraday::Request
  def [](key); end

  def []=(key, value); end

  def headers=(hash); end

  def marshal_dump(); end

  def marshal_load(serialised); end

  def params=(hash); end

  def to_env(connection); end

  def url(path, params=T.unsafe(nil)); end
end

class Faraday::Request::Authorization
  def call(env); end

  def initialize(app, type, token); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Authorization
  def self.build_hash(type, hash); end

  def self.header(type, token); end
end

class Faraday::Request::BasicAuthentication
end

class Faraday::Request::BasicAuthentication
  def self.header(login, pass); end
end

class Faraday::Request::Instrumentation
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation::Options
end

class Faraday::Request::Instrumentation
end

class Faraday::Request::Multipart
  def create_multipart(env, params); end

  def has_multipart?(obj); end

  def process_params(params, prefix=T.unsafe(nil), pieces=T.unsafe(nil), &block); end

  def unique_boundary(); end
  DEFAULT_BOUNDARY_PREFIX = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Multipart
end

Faraday::Request::OAuth = FaradayMiddleware::OAuth

Faraday::Request::OAuth2 = FaradayMiddleware::OAuth2

class Faraday::Request::Retry
  def build_exception_matcher(exceptions); end

  def calculate_sleep_amount(retries, env); end

  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  DEFAULT_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
  DEFAULT_CHECK = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::Retry::Options
end

class Faraday::Request::Retry
end

class Faraday::Request::TokenAuthentication
  def initialize(app, token, options=T.unsafe(nil)); end
end

class Faraday::Request::TokenAuthentication
  def self.header(token, options=T.unsafe(nil)); end
end

class Faraday::Request::UrlEncoded
  def call(env); end

  def match_content_type(env); end

  def process_request?(env); end

  def request_type(env); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class Faraday::Request::UrlEncoded
  def self.mime_type(); end

  def self.mime_type=(mime_type); end
end

class Faraday::Request
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
  def self.create(request_method); end
end

class Faraday::RequestOptions
  include ::FaradayMiddleware::OptionsExtension
  def []=(key, value); end
end

class Faraday::RequestOptions
end

class Faraday::ResourceNotFound
end

class Faraday::ResourceNotFound
end

class Faraday::Response
  def [](*args, &block); end

  def apply_request(request_env); end

  def body(); end

  def env(); end

  def finish(env); end

  def finished?(); end

  def headers(); end

  def initialize(env=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(env); end

  def on_complete(); end

  def reason_phrase(); end

  def status(); end

  def success?(); end

  def to_hash(*args, &block); end
end

class Faraday::Response::Logger
  def debug(*args, &block); end

  def error(*args, &block); end

  def fatal(*args, &block); end

  def filter(filter_word, filter_replacement); end

  def info(*args, &block); end

  def initialize(app, logger=T.unsafe(nil), options=T.unsafe(nil)); end

  def warn(*args, &block); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::Logger
  extend ::Forwardable
end

Faraday::Response::Mashify = FaradayMiddleware::Mashify

class Faraday::Response::Middleware
  def call(env); end

  def on_complete(env); end
end

class Faraday::Response::Middleware
end

Faraday::Response::ParseJson = FaradayMiddleware::ParseJson

Faraday::Response::ParseMarshal = FaradayMiddleware::ParseMarshal

Faraday::Response::ParseXml = FaradayMiddleware::ParseXml

Faraday::Response::ParseYaml = FaradayMiddleware::ParseYaml

class Faraday::Response::RaiseError
  def response_values(env); end
  ClientErrorStatuses = ::T.let(nil, ::T.untyped)
end

class Faraday::Response::RaiseError
end

Faraday::Response::Rashify = FaradayMiddleware::Rashify

class Faraday::Response
  extend ::Forwardable
  extend ::Faraday::MiddlewareRegistry
  extend ::Faraday::AutoloadHelper
end

class Faraday::RetriableResponse
end

class Faraday::RetriableResponse
end

class Faraday::SSLError
end

class Faraday::SSLError
end

class Faraday::SSLOptions
  def disable?(); end

  def verify?(); end
end

class Faraday::SSLOptions
end

class Faraday::TimeoutError
  def initialize(ex=T.unsafe(nil)); end
end

class Faraday::TimeoutError
end

Faraday::Timer = Timeout

Faraday::UploadIO = UploadIO

module Faraday::Utils
  def URI(url); end

  def build_nested_query(params); end

  def build_query(params); end

  def deep_merge(source, hash); end

  def deep_merge!(target, hash); end

  def default_params_encoder(); end

  def default_uri_parser(); end

  def default_uri_parser=(parser); end

  def escape(s); end

  def normalize_params(params, name, v=T.unsafe(nil)); end

  def normalize_path(url); end

  def parse_nested_query(query); end

  def parse_query(query); end

  def sort_query_params(query); end

  def unescape(s); end
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def fetch(k, *args, &block); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def initialize_names(); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def parse(header_string); end

  def replace(other); end

  def update(other); end
  KeyMap = ::T.let(nil, ::T.untyped)
end

class Faraday::Utils::Headers
  def self.from(value); end
end

class Faraday::Utils::ParamsHash
  def [](key); end

  def []=(key, value); end

  def delete(key); end

  def has_key?(key); end

  def include?(key); end

  def key?(key); end

  def member?(key); end

  def merge(params); end

  def merge!(params); end

  def merge_query(query, encoder=T.unsafe(nil)); end

  def replace(other); end

  def to_query(encoder=T.unsafe(nil)); end

  def update(params); end
end

class Faraday::Utils::ParamsHash
end

module Faraday::Utils
  extend ::Faraday::Utils
  extend ::T::Sig
  def self.default_params_encoder=(default_params_encoder); end
end

module Faraday
  extend ::T::Sig
  def self.const_missing(name); end

  def self.default_adapter(); end

  def self.default_adapter=(adapter); end

  def self.default_connection(); end

  def self.default_connection=(default_connection); end

  def self.default_connection_options(); end

  def self.default_connection_options=(options); end

  def self.ignore_env_proxy(); end

  def self.ignore_env_proxy=(ignore_env_proxy); end

  def self.lib_path(); end

  def self.lib_path=(lib_path); end

  def self.new(url=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.require_lib(*libs); end

  def self.require_libs(*libs); end

  def self.respond_to?(symbol, include_private=T.unsafe(nil)); end

  def self.root_path(); end

  def self.root_path=(root_path); end
end

module FaradayMiddleware
end

class FaradayMiddleware::Caching
  def build_query(*args, &block); end

  def cache(); end

  def cache_key(env); end

  def cache_on_complete(env); end

  def call(env); end

  def finalize_response(response, env); end

  def initialize(app, cache=T.unsafe(nil), options=T.unsafe(nil)); end

  def params_to_ignore(); end

  def parse_query(*args, &block); end

  def store_response_in_cache(key, response); end
  CACHEABLE_STATUS_CODES = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::Caching
  extend ::Forwardable
end

class FaradayMiddleware::Chunked
  def chunked_encoding?(headers); end
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::Chunked
end

class FaradayMiddleware::EncodeJson
  def call(env); end

  def encode(data); end

  def has_body?(env); end

  def match_content_type(env); end

  def process_request?(env); end

  def request_type(env); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  MIME_TYPE = ::T.let(nil, ::T.untyped)
  MIME_TYPE_REGEX = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::EncodeJson
end

class FaradayMiddleware::FollowRedirects
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  ENV_TO_CLEAR = ::T.let(nil, ::T.untyped)
  FOLLOW_LIMIT = ::T.let(nil, ::T.untyped)
  REDIRECT_CODES = ::T.let(nil, ::T.untyped)
  URI_UNSAFE = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::FollowRedirects
end

class FaradayMiddleware::Gzip
  def call(env); end

  def inflate(body); end

  def reset_body(env); end

  def uncompress_gzip(body); end
  ACCEPT_ENCODING = ::T.let(nil, ::T.untyped)
  CONTENT_ENCODING = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  RUBY_ENCODING = ::T.let(nil, ::T.untyped)
  SUPPORTED_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::Gzip
end

class FaradayMiddleware::Instrumentation
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class FaradayMiddleware::Instrumentation
end

class FaradayMiddleware::Mashify
  def initialize(app=T.unsafe(nil), options=T.unsafe(nil)); end

  def mash_class(); end

  def mash_class=(mash_class); end

  def parse(body); end
end

class FaradayMiddleware::Mashify
  def self.mash_class(); end

  def self.mash_class=(mash_class); end
end

class FaradayMiddleware::MethodOverride
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end

  def rewrite_request(env, original_method); end

  def rewrite_request?(method); end
  HEADER = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::MethodOverride
end

class FaradayMiddleware::OAuth
  def body_params(env); end

  def call(env); end

  def include_body_params?(env); end

  def initialize(app, options); end

  def oauth_header(env); end

  def oauth_options(env); end

  def parse_nested_query(*args, &block); end

  def sign_request?(env); end

  def signature_params(params); end
  AUTH_HEADER = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_URLENCODED = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::OAuth
  extend ::Forwardable
end

class FaradayMiddleware::OAuth2
  def build_query(*args, &block); end

  def call(env); end

  def initialize(app, token=T.unsafe(nil), options=T.unsafe(nil)); end

  def param_name(); end

  def parse_query(*args, &block); end

  def query_params(url); end

  def token_type(); end
  AUTH_HEADER = ::T.let(nil, ::T.untyped)
  PARAM_NAME = ::T.let(nil, ::T.untyped)
  TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::OAuth2
  extend ::Forwardable
end

module FaradayMiddleware::OptionsExtension
  def each(); end

  def fetch(key, *args); end

  def preserve_raw(); end

  def preserve_raw=(preserve_raw); end

  def to_hash(); end
end

module FaradayMiddleware::OptionsExtension
  extend ::T::Sig
end

class FaradayMiddleware::ParseDates
  def initialize(app, options=T.unsafe(nil)); end
  ISO_DATE_FORMAT = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::ParseDates
end

class FaradayMiddleware::ParseJson
end

class FaradayMiddleware::ParseJson::MimeTypeFix
  def first_char(body); end
  BRACKETS = ::T.let(nil, ::T.untyped)
  MIME_TYPE = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::ParseJson::MimeTypeFix
end

class FaradayMiddleware::ParseJson
end

class FaradayMiddleware::ParseMarshal
end

class FaradayMiddleware::ParseMarshal
end

class FaradayMiddleware::ParseXml
end

class FaradayMiddleware::ParseXml
end

class FaradayMiddleware::ParseYaml
end

class FaradayMiddleware::ParseYaml
end

class FaradayMiddleware::RackCompatible
  def call(env); end

  def finalize_response(env, rack_response); end

  def headers_to_rack(env); end

  def initialize(app, rack_handler, *args); end

  def prepare_env(faraday_env); end

  def restore_env(rack_env); end
  NonPrefixedHeaders = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::RackCompatible
end

class FaradayMiddleware::Rashify
end

class FaradayMiddleware::Rashify
end

class FaradayMiddleware::ResponseMiddleware
  def call(environment); end

  def initialize(app=T.unsafe(nil), options=T.unsafe(nil)); end

  def parse(body); end

  def parse_response?(env); end

  def preserve_raw?(env); end

  def process_response(env); end

  def process_response_type?(type); end

  def response_type(env); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
end

class FaradayMiddleware::ResponseMiddleware
  def self.define_parser(parser=T.unsafe(nil)); end

  def self.parser(); end

  def self.parser=(parser); end
end

module FaradayMiddleware
  extend ::T::Sig
end

module Fcntl
  FD_CLOEXEC = ::T.let(nil, ::T.untyped)
  F_DUPFD = ::T.let(nil, ::T.untyped)
  F_GETFD = ::T.let(nil, ::T.untyped)
  F_GETFL = ::T.let(nil, ::T.untyped)
  F_GETLK = ::T.let(nil, ::T.untyped)
  F_RDLCK = ::T.let(nil, ::T.untyped)
  F_SETFD = ::T.let(nil, ::T.untyped)
  F_SETFL = ::T.let(nil, ::T.untyped)
  F_SETLK = ::T.let(nil, ::T.untyped)
  F_SETLKW = ::T.let(nil, ::T.untyped)
  F_UNLCK = ::T.let(nil, ::T.untyped)
  F_WRLCK = ::T.let(nil, ::T.untyped)
  O_ACCMODE = ::T.let(nil, ::T.untyped)
  O_APPEND = ::T.let(nil, ::T.untyped)
  O_CREAT = ::T.let(nil, ::T.untyped)
  O_EXCL = ::T.let(nil, ::T.untyped)
  O_NDELAY = ::T.let(nil, ::T.untyped)
  O_NOCTTY = ::T.let(nil, ::T.untyped)
  O_NONBLOCK = ::T.let(nil, ::T.untyped)
  O_RDONLY = ::T.let(nil, ::T.untyped)
  O_RDWR = ::T.let(nil, ::T.untyped)
  O_TRUNC = ::T.let(nil, ::T.untyped)
  O_WRONLY = ::T.let(nil, ::T.untyped)
end

module Fcntl
  extend ::T::Sig
end

class Fiber
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def resume(*_); end

  def transfer(*_); end
end

class Fiber
  extend ::T::Sig
  def self.current(); end

  def self.yield(*_); end
end

class FiberError
  extend ::T::Sig
end

class File
  Separator = ::T.let(nil, ::T.untyped)
end

module File::Constants
  extend ::T::Sig
end

class File::Stat
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def size?(); end
end

class File::Stat
  extend ::T::Sig
end

class File
  extend ::T::Sig
  def self.atomic_write(file_name, temp_dir=T.unsafe(nil)); end

  def self.empty?(_); end

  def self.exists?(_); end

  def self.lutime(*_); end

  def self.mkfifo(*_); end

  def self.probe_stat_in(dir); end

end

FileList = Rake::FileList

module FileTest
  extend ::T::Sig
  def self.blockdev?(_); end

  def self.chardev?(_); end

  def self.directory?(_); end

  def self.empty?(_); end

  def self.executable?(_); end

  def self.executable_real?(_); end

  def self.exist?(_); end

  def self.exists?(_); end

  def self.file?(_); end

  def self.grpowned?(_); end

  def self.identical?(_, _1); end

  def self.owned?(_); end

  def self.pipe?(_); end

  def self.readable?(_); end

  def self.readable_real?(_); end

  def self.setgid?(_); end

  def self.setuid?(_); end

  def self.size(_); end

  def self.size?(_); end

  def self.socket?(_); end

  def self.sticky?(_); end

  def self.symlink?(_); end

  def self.world_readable?(_); end

  def self.world_writable?(_); end

  def self.writable?(_); end

  def self.writable_real?(_); end

  def self.zero?(_); end
end

module FileUtils
  include ::FileUtils::StreamUtils_
  def ruby(*args, &block); end

  def safe_ln(*args); end

  def sh(*cmd, &block); end

  def split_all(path); end
  LN_SUPPORTED = ::T.let(nil, ::T.untyped)
  RUBY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module FileUtils::DryRun
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::DryRun
  extend ::T::Sig
  extend ::FileUtils::DryRun
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

class FileUtils::Entry_
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def blockdev?(); end

  def chardev?(); end

  def chmod(mode); end

  def chown(uid, gid); end

  def copy(dest); end

  def copy_file(dest); end

  def copy_metadata(path); end

  def dereference?(); end

  def directory?(); end

  def door?(); end

  def entries(); end

  def exist?(); end

  def file?(); end

  def initialize(a, b=T.unsafe(nil), deref=T.unsafe(nil)); end

  def lstat(); end

  def lstat!(); end

  def path(); end

  def pipe?(); end

  def platform_support(); end

  def postorder_traverse(); end

  def prefix(); end

  def preorder_traverse(); end

  def rel(); end

  def remove(); end

  def remove_dir1(); end

  def remove_file(); end

  def socket?(); end

  def stat(); end

  def stat!(); end

  def symlink?(); end

  def traverse(); end

  def wrap_traverse(pre, post); end
end

class FileUtils::Entry_
  extend ::T::Sig
end

module FileUtils::LowMethods
  extend ::T::Sig
end

module FileUtils::NoWrite
  include ::FileUtils::LowMethods
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::NoWrite
  extend ::T::Sig
  extend ::FileUtils::NoWrite
  extend ::FileUtils::LowMethods
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils::StreamUtils_
  extend ::T::Sig
end

module FileUtils::Verbose
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module FileUtils::Verbose
  extend ::T::Sig
  extend ::FileUtils::Verbose
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
end

module FileUtils
  extend ::T::Sig
  extend ::FileUtils::StreamUtils_
  def self.cd(dir, verbose: T.unsafe(nil), &block); end

  def self.chdir(dir, verbose: T.unsafe(nil), &block); end

  def self.chmod(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chmod_R(mode, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.chown(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.chown_R(user, group, list, noop: T.unsafe(nil), verbose: T.unsafe(nil), force: T.unsafe(nil)); end

  def self.cmp(a, b); end

  def self.collect_method(opt); end

  def self.commands(); end

  def self.compare_file(a, b); end

  def self.compare_stream(a, b); end

  def self.copy(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.copy_entry(src, dest, preserve=T.unsafe(nil), dereference_root=T.unsafe(nil), remove_destination=T.unsafe(nil)); end

  def self.copy_file(src, dest, preserve=T.unsafe(nil), dereference=T.unsafe(nil)); end

  def self.copy_stream(src, dest); end

  def self.cp(src, dest, preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.getwd(); end

  def self.have_option?(mid, opt); end

  def self.identical?(a, b); end

  def self.install(src, dest, mode: T.unsafe(nil), owner: T.unsafe(nil), group: T.unsafe(nil), preserve: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.link(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_s(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.ln_sf(src, dest, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.makedirs(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkdir(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.mkpath(list, mode: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.move(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.mv(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.options(); end

  def self.options_of(mid); end

  def self.private_module_function(name); end

  def self.pwd(); end

  def self.remove(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.remove_dir(path, force=T.unsafe(nil)); end

  def self.remove_entry(path, force=T.unsafe(nil)); end

  def self.remove_entry_secure(path, force=T.unsafe(nil)); end

  def self.remove_file(path, force=T.unsafe(nil)); end

  def self.rm(list, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_f(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rm_rf(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.rmdir(list, parents: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.rmtree(list, noop: T.unsafe(nil), verbose: T.unsafe(nil), secure: T.unsafe(nil)); end

  def self.safe_unlink(list, noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.symlink(src, dest, force: T.unsafe(nil), noop: T.unsafe(nil), verbose: T.unsafe(nil)); end

  def self.uptodate?(new, old_list); end
end

module Find
end

module Find
  extend ::T::Sig
  def self.find(*paths, ignore_error: T.unsafe(nil)); end

  def self.prune(); end
end

class FindMaxNumViolations
  def call(); end

  def initialize(violations); end
  LIMIT = ::T.let(nil, ::T.untyped)
end

class FindMaxNumViolations
end

class Float
  include ::ActiveSupport::NumericWithFormat
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::Float
  def to_d(precision=T.unsafe(nil)); end
end

class Float
  extend ::T::Sig
end

class FloatDomainError
  extend ::T::Sig
end

module Formtastic
  def deprecation(); end

  def deprecation=(obj); end
end

class Formtastic::ActionClassFinder
  def initialize(builder); end
end

class Formtastic::ActionClassFinder
end

module Formtastic::Actions
end

module Formtastic::Actions::Base
  include ::Formtastic::LocalizedString
  def accesskey(); end

  def builder(); end

  def builder=(builder); end

  def button_html(); end

  def button_html_from_options(); end

  def check_supported_methods!(); end

  def default_button_html(); end

  def default_wrapper_classes(); end

  def default_wrapper_html_options(); end

  def default_wrapper_id(); end

  def extra_button_html_options(); end

  def i18n_key(); end

  def initialize(builder, template, object, object_name, method, options); end

  def method(); end

  def method=(method); end

  def new_or_persisted_object?(); end

  def object(); end

  def object=(object); end

  def object_name(); end

  def object_name=(object_name); end

  def options(); end

  def options=(options); end

  def sanitized_object_name(); end

  def submit_i18n_key(); end

  def supported_methods(); end

  def template(); end

  def template=(template); end

  def text(); end

  def to_html(); end

  def wrapper(&block); end

  def wrapper_class(); end

  def wrapper_classes_from_options(); end

  def wrapper_html_options(); end

  def wrapper_html_options_from_options(); end

  def wrapper_id(); end

  def wrapper_id_from_options(); end
end

module Formtastic::Actions::Base
  extend ::T::Sig
end

class Formtastic::Actions::ButtonAction
  include ::Formtastic::Actions::Base
  include ::Formtastic::LocalizedString
  include ::Formtastic::Actions::Buttonish
end

class Formtastic::Actions::ButtonAction
end

module Formtastic::Actions::Buttonish
  def extra_button_html_options(); end

  def supported_methods(); end
end

module Formtastic::Actions::Buttonish
  extend ::T::Sig
end

class Formtastic::Actions::InputAction
  include ::Formtastic::Actions::Base
  include ::Formtastic::LocalizedString
  include ::Formtastic::Actions::Buttonish
end

class Formtastic::Actions::InputAction
end

class Formtastic::Actions::LinkAction
  include ::Formtastic::Actions::Base
  include ::Formtastic::LocalizedString
  def url(); end
end

class Formtastic::Actions::LinkAction
end

module Formtastic::Actions
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

Formtastic::Deprecation = ActiveSupport::Deprecation

class Formtastic::Engine
end

class Formtastic::Engine
end

class Formtastic::FormBuilder
  include ::Formtastic::HtmlAttributes
  include ::Formtastic::Helpers::InputHelper
  include ::Formtastic::Helpers::InputsHelper
  include ::Formtastic::Helpers::ActionHelper
  include ::Formtastic::Helpers::ActionsHelper
  include ::Formtastic::Helpers::FieldsetWrapper
  include ::Formtastic::Helpers::ErrorsHelper
  include ::Formtastic::Helpers::FileColumnDetection
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Helpers::Enum
  include ::Formtastic::LocalizedString
  def action_class_finder(); end

  def action_class_finder=(val); end

  def action_class_finder?(); end

  def action_namespaces(); end

  def action_namespaces=(val); end

  def action_namespaces?(); end

  def all_fields_required_by_default(); end

  def all_fields_required_by_default=(val); end

  def all_fields_required_by_default?(); end

  def auto_index(); end

  def collection_label_methods(); end

  def collection_label_methods=(val); end

  def collection_label_methods?(); end

  def collection_value_methods(); end

  def collection_value_methods=(val); end

  def collection_value_methods?(); end

  def custom_namespace(); end

  def custom_namespace=(val); end

  def custom_namespace?(); end

  def default_commit_button_accesskey(); end

  def default_commit_button_accesskey=(val); end

  def default_commit_button_accesskey?(); end

  def default_error_list_class(); end

  def default_error_list_class=(val); end

  def default_error_list_class?(); end

  def default_hint_class(); end

  def default_hint_class=(val); end

  def default_hint_class?(); end

  def default_inline_error_class(); end

  def default_inline_error_class=(val); end

  def default_inline_error_class?(); end

  def default_text_area_height(); end

  def default_text_area_height=(val); end

  def default_text_area_height?(); end

  def default_text_area_width(); end

  def default_text_area_width=(val); end

  def default_text_area_width?(); end

  def default_text_field_size(); end

  def default_text_field_size=(val); end

  def default_text_field_size?(); end

  def escape_html_entities_in_hints_and_labels(); end

  def escape_html_entities_in_hints_and_labels=(val); end

  def escape_html_entities_in_hints_and_labels?(); end

  def file_metadata_suffixes(); end

  def file_metadata_suffixes=(val); end

  def file_metadata_suffixes?(); end

  def file_methods(); end

  def file_methods=(val); end

  def file_methods?(); end

  def i18n_cache_lookups(); end

  def i18n_cache_lookups=(val); end

  def i18n_cache_lookups?(); end

  def i18n_localizer(); end

  def i18n_localizer=(val); end

  def i18n_localizer?(); end

  def i18n_lookups_by_default(); end

  def i18n_lookups_by_default=(val); end

  def i18n_lookups_by_default?(); end

  def include_blank_for_select_by_default(); end

  def include_blank_for_select_by_default=(val); end

  def include_blank_for_select_by_default?(); end

  def initialize(object_name, object, template, options, block=T.unsafe(nil)); end

  def inline_errors(); end

  def inline_errors=(val); end

  def inline_errors?(); end

  def input_class_finder(); end

  def input_class_finder=(val); end

  def input_class_finder?(); end

  def input_namespaces(); end

  def input_namespaces=(val); end

  def input_namespaces?(); end

  def label_str_method(); end

  def label_str_method=(val); end

  def label_str_method?(); end

  def optional_string(); end

  def optional_string=(val); end

  def optional_string?(); end

  def perform_browser_validations(); end

  def perform_browser_validations=(val); end

  def perform_browser_validations?(); end

  def priority_countries(); end

  def priority_countries=(val); end

  def priority_countries?(); end

  def priority_time_zones(); end

  def priority_time_zones=(val); end

  def priority_time_zones?(); end

  def required_string(); end

  def required_string=(val); end

  def required_string?(); end

  def semantic_fields_for(record_or_name_or_array, *args, &block); end

  def skipped_columns(); end

  def skipped_columns=(val); end

  def skipped_columns?(); end

  def template(); end

  def use_required_attribute(); end

  def use_required_attribute=(val); end

  def use_required_attribute?(); end
end

class Formtastic::FormBuilder
  def self.action_class_finder(); end

  def self.action_class_finder=(val); end

  def self.action_class_finder?(); end

  def self.action_namespaces(); end

  def self.action_namespaces=(val); end

  def self.action_namespaces?(); end

  def self.all_fields_required_by_default(); end

  def self.all_fields_required_by_default=(val); end

  def self.all_fields_required_by_default?(); end

  def self.collection_label_methods(); end

  def self.collection_label_methods=(val); end

  def self.collection_label_methods?(); end

  def self.collection_value_methods(); end

  def self.collection_value_methods=(val); end

  def self.collection_value_methods?(); end

  def self.configure(name, default=T.unsafe(nil)); end

  def self.custom_namespace(); end

  def self.custom_namespace=(val); end

  def self.custom_namespace?(); end

  def self.default_commit_button_accesskey(); end

  def self.default_commit_button_accesskey=(val); end

  def self.default_commit_button_accesskey?(); end

  def self.default_error_list_class(); end

  def self.default_error_list_class=(val); end

  def self.default_error_list_class?(); end

  def self.default_hint_class(); end

  def self.default_hint_class=(val); end

  def self.default_hint_class?(); end

  def self.default_inline_error_class(); end

  def self.default_inline_error_class=(val); end

  def self.default_inline_error_class?(); end

  def self.default_text_area_height(); end

  def self.default_text_area_height=(val); end

  def self.default_text_area_height?(); end

  def self.default_text_area_width(); end

  def self.default_text_area_width=(val); end

  def self.default_text_area_width?(); end

  def self.default_text_field_size(); end

  def self.default_text_field_size=(val); end

  def self.default_text_field_size?(); end

  def self.escape_html_entities_in_hints_and_labels(); end

  def self.escape_html_entities_in_hints_and_labels=(val); end

  def self.escape_html_entities_in_hints_and_labels?(); end

  def self.file_metadata_suffixes(); end

  def self.file_metadata_suffixes=(val); end

  def self.file_metadata_suffixes?(); end

  def self.file_methods(); end

  def self.file_methods=(val); end

  def self.file_methods?(); end

  def self.i18n_cache_lookups(); end

  def self.i18n_cache_lookups=(val); end

  def self.i18n_cache_lookups?(); end

  def self.i18n_localizer(); end

  def self.i18n_localizer=(val); end

  def self.i18n_localizer?(); end

  def self.i18n_lookups_by_default(); end

  def self.i18n_lookups_by_default=(val); end

  def self.i18n_lookups_by_default?(); end

  def self.include_blank_for_select_by_default(); end

  def self.include_blank_for_select_by_default=(val); end

  def self.include_blank_for_select_by_default?(); end

  def self.inline_errors(); end

  def self.inline_errors=(val); end

  def self.inline_errors?(); end

  def self.input_class_finder(); end

  def self.input_class_finder=(val); end

  def self.input_class_finder?(); end

  def self.input_namespaces(); end

  def self.input_namespaces=(val); end

  def self.input_namespaces?(); end

  def self.label_str_method(); end

  def self.label_str_method=(val); end

  def self.label_str_method?(); end

  def self.optional_string(); end

  def self.optional_string=(val); end

  def self.optional_string?(); end

  def self.perform_browser_validations(); end

  def self.perform_browser_validations=(val); end

  def self.perform_browser_validations?(); end

  def self.priority_countries(); end

  def self.priority_countries=(val); end

  def self.priority_countries?(); end

  def self.priority_time_zones(); end

  def self.priority_time_zones=(val); end

  def self.priority_time_zones?(); end

  def self.required_string(); end

  def self.required_string=(val); end

  def self.required_string?(); end

  def self.skipped_columns(); end

  def self.skipped_columns=(val); end

  def self.skipped_columns?(); end

  def self.use_required_attribute(); end

  def self.use_required_attribute=(val); end

  def self.use_required_attribute?(); end
end

module Formtastic::Helpers
end

module Formtastic::Helpers::ActionHelper
  def action(method, options=T.unsafe(nil)); end

  def action_class(as); end

  def custom_action_class_name(as); end

  def default_action_type(method, options=T.unsafe(nil)); end

  def namespaced_action_class(as); end

  def standard_action_class_name(as); end
end

module Formtastic::Helpers::ActionHelper
  extend ::T::Sig
end

module Formtastic::Helpers::ActionsHelper
  include ::Formtastic::Helpers::FieldsetWrapper
  def actions(*args, &block); end

  def default_actions(); end
end

module Formtastic::Helpers::ActionsHelper
  extend ::T::Sig
end

module Formtastic::Helpers::Enum
  def enum_for(method); end
end

module Formtastic::Helpers::Enum
  extend ::T::Sig
end

module Formtastic::Helpers::ErrorsHelper
  include ::Formtastic::Helpers::FileColumnDetection
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::LocalizedString
  def error_keys(method, options); end

  def has_errors?(method, options); end

  def render_inline_errors?(); end

  def semantic_errors(*args); end
  INLINE_ERROR_TYPES = ::T.let(nil, ::T.untyped)
end

module Formtastic::Helpers::ErrorsHelper
  extend ::T::Sig
end

module Formtastic::Helpers::FieldsetWrapper
  def field_set_and_list_wrapping(*args, &block); end

  def field_set_legend(html_options); end

  def parent_child_index(parent); end
end

module Formtastic::Helpers::FieldsetWrapper
  extend ::T::Sig
end

module Formtastic::Helpers::FileColumnDetection
  def is_file?(method, options=T.unsafe(nil)); end
end

module Formtastic::Helpers::FileColumnDetection
  extend ::T::Sig
end

module Formtastic::Helpers::FormHelper
  def builder(); end

  def builder=(obj); end

  def default_form_class(); end

  def default_form_class=(obj); end

  def default_form_model_class_proc(); end

  def default_form_model_class_proc=(obj); end

  def formtastic_field_error_proc(); end

  def formtastic_field_error_proc=(obj); end

  def semantic_fields_for(record_name, record_object=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def semantic_form_for(record_or_name_or_array, *args, &proc); end

  def with_custom_field_error_proc(&block); end
end

module Formtastic::Helpers::FormHelper
  extend ::T::Sig
  def self.builder(); end

  def self.builder=(obj); end

  def self.default_form_class(); end

  def self.default_form_class=(obj); end

  def self.default_form_model_class_proc(); end

  def self.default_form_model_class_proc=(obj); end

  def self.formtastic_field_error_proc(); end

  def self.formtastic_field_error_proc=(obj); end
end

module Formtastic::Helpers::InputHelper
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Helpers::Enum
  include ::Formtastic::Helpers::FileColumnDetection
  def column_for(method); end

  def custom_input_class_name(as); end

  def default_input_type(method, options=T.unsafe(nil)); end

  def input(method, options=T.unsafe(nil)); end

  def input_class(as); end

  def input_class_by_trying(as); end

  def input_class_with_const_defined(as); end

  def namespaced_input_class(as); end

  def standard_input_class_name(as); end
end

module Formtastic::Helpers::InputHelper
  extend ::T::Sig
end

module Formtastic::Helpers::InputsHelper
  include ::Formtastic::Helpers::FieldsetWrapper
  include ::Formtastic::LocalizedString
  def association_columns(*by_associations); end

  def content_columns(); end

  def default_columns_for_object(); end

  def field_set_title_from_args(*args); end

  def fieldset_contents_from_column_list(columns); end

  def inputs(*args, &block); end

  def inputs_for_nested_attributes(*args, &block); end
end

module Formtastic::Helpers::InputsHelper
  extend ::T::Sig
end

module Formtastic::Helpers::Reflection
  def association_macro_for_method(method); end

  def association_primary_key_for_method(method); end

  def reflection_for(method); end
end

module Formtastic::Helpers::Reflection
  extend ::T::Sig
end

module Formtastic::Helpers
  extend ::T::Sig
end

module Formtastic::HtmlAttributes
  def dom_id_namespace(); end

  def humanized_attribute_name(method); end
end

module Formtastic::HtmlAttributes
  extend ::T::Sig
end

module Formtastic::I18n
  DEFAULT_SCOPE = ::T.let(nil, ::T.untyped)
  DEFAULT_VALUES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
end

module Formtastic::I18n
  extend ::T::Sig
  def self.t(*args); end

  def self.translate(*args); end
end

class Formtastic::InputClassFinder
  def initialize(builder); end
end

class Formtastic::InputClassFinder
end

module Formtastic::Inputs
end

module Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  def builder(); end

  def builder=(builder); end

  def initialize(builder, template, object, object_name, method, options); end

  def input_wrapping(&block); end

  def method(); end

  def method=(method); end

  def object(); end

  def object=(object); end

  def object_name(); end

  def object_name=(object_name); end

  def options(); end

  def options=(options); end

  def removed_option!(old_option_name); end

  def template(); end

  def template=(template); end

  def warn_and_correct_option!(old_option_name, new_option_name); end

  def warn_deprecated_option!(old_option_name, instructions); end
end

module Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  def association(); end

  def association_primary_key(); end

  def belongs_to?(); end

  def has_many?(); end

  def reflection(); end
end

module Formtastic::Inputs::Base::Associations
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Choices
  def choice_html(choice); end

  def choice_html_options(choice); end

  def choice_html_safe_value(choice); end

  def choice_input_dom_id(choice); end

  def choice_label(choice); end

  def choice_value(choice); end

  def choice_wrapping(html_options, &block); end

  def choice_wrapping_html_options(choice); end

  def choices_group_wrapping(&block); end

  def choices_group_wrapping_html_options(); end

  def choices_wrapping(&block); end

  def choices_wrapping_html_options(); end

  def custom_choice_html_options(choice); end

  def default_choice_html_options(choice); end

  def label_html_options(); end

  def legend_html(); end

  def value_as_class?(); end
end

module Formtastic::Inputs::Base::Choices
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Collections
  def collection(); end

  def collection_for_boolean(); end

  def collection_from_association(); end

  def collection_from_enum(); end

  def collection_from_enum?(); end

  def collection_from_options(); end

  def label_and_value_method(); end

  def label_and_value_method_from_collection(_collection); end

  def label_method(); end

  def label_method_from_options(); end

  def raw_collection(); end

  def send_or_call(duck, object); end

  def send_or_call_or_object(duck, object); end

  def value_method(); end

  def value_method_from_options(); end
end

module Formtastic::Inputs::Base::Collections
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Database
  def column(); end

  def column?(); end
end

module Formtastic::Inputs::Base::Database
  extend ::T::Sig
end

module Formtastic::Inputs::Base::DatetimePickerish
  include ::Formtastic::Inputs::Base::Placeholder
  def default_maxlength(); end

  def default_size(); end

  def default_step(); end

  def extra_input_html_options(); end

  def html_input_type(); end

  def input_html_options(); end

  def maxlength(); end

  def size(); end

  def step(); end

  def step_from_macro(sym); end

  def value(); end
end

module Formtastic::Inputs::Base::DatetimePickerish
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Errors
  def error_first_html(); end

  def error_html(); end

  def error_keys(); end

  def error_list_html(); end

  def error_none_html(); end

  def error_sentence_html(); end

  def errors(); end

  def errors?(); end
end

module Formtastic::Inputs::Base::Errors
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Fileish
  def file?(); end
end

module Formtastic::Inputs::Base::Fileish
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Hints
  def hint?(); end

  def hint_html(); end

  def hint_text(); end

  def hint_text_from_options(); end
end

module Formtastic::Inputs::Base::Hints
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Html
  def dom_id(); end

  def dom_index(); end

  def input_html_options(); end

  def to_html(); end
end

module Formtastic::Inputs::Base::Html
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  def label_from_options(); end

  def label_html(); end

  def label_html_options(); end

  def label_text(); end

  def localized_label(); end

  def render_label?(); end

  def requirement_text(); end

  def requirement_text_or_proc(); end
end

module Formtastic::Inputs::Base::Labelling
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Naming
  def as(); end

  def attributized_method_name(); end

  def humanized_method_name(); end

  def input_name(); end

  def sanitized_method_name(); end

  def sanitized_object_name(); end
end

module Formtastic::Inputs::Base::Naming
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Numeric
  def in_option(); end

  def input_html_options(); end

  def max_option(); end

  def min_option(); end

  def step_option(); end

  def wrapper_html_options(); end
end

module Formtastic::Inputs::Base::Numeric
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Options
  def formtastic_options(); end

  def input_options(); end
end

module Formtastic::Inputs::Base::Options
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Placeholder
  def input_html_options(); end

  def placeholder_text(); end
end

module Formtastic::Inputs::Base::Placeholder
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Stringish
  def input_html_options(); end

  def maxlength(); end

  def size(); end

  def to_html(); end

  def wrapper_html_options(); end
end

module Formtastic::Inputs::Base::Stringish
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Timeish
  def date_fragments(); end

  def default_date_fragments(); end

  def fragment_id(fragment); end

  def fragment_input_html(fragment); end

  def fragment_label(fragment); end

  def fragment_label_html(fragment); end

  def fragment_name(fragment); end

  def fragment_prefix(); end

  def fragment_wrapping(&block); end

  def fragment_wrapping_html_options(); end

  def fragments(); end

  def fragments_inner_wrapping(&block); end

  def fragments_label(); end

  def fragments_wrapping(&block); end

  def fragments_wrapping_html_options(); end

  def hidden_field_name(fragment); end

  def hidden_fragments(); end

  def i18n_date_fragments(); end

  def include_blank?(); end

  def position(fragment); end

  def positions(); end

  def time_fragments(); end

  def to_html(); end

  def value(); end
end

module Formtastic::Inputs::Base::Timeish
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Validations
  def autofocus?(); end

  def column_limit(); end

  def limit(); end

  def not_required_through_negated_validation!(); end

  def not_required_through_negated_validation?(); end

  def optional?(); end

  def readonly?(); end

  def readonly_attribute?(); end

  def readonly_from_options?(); end

  def required?(); end

  def required_attribute?(); end

  def responds_to_global_required?(); end

  def validation_integer_only?(); end

  def validation_limit(); end

  def validation_max(); end

  def validation_min(); end

  def validation_step(); end

  def validations(); end

  def validations?(); end

  def validator_relevant?(validator); end
end

module Formtastic::Inputs::Base::Validations
  extend ::T::Sig
end

module Formtastic::Inputs::Base::Wrapping
  def input_wrapping(&block); end

  def wrapper_classes(); end

  def wrapper_classes_raw(); end

  def wrapper_dom_id(); end

  def wrapper_html_options(); end

  def wrapper_html_options_raw(); end
end

module Formtastic::Inputs::Base::Wrapping
  extend ::T::Sig
end

module Formtastic::Inputs::Base
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

class Formtastic::Inputs::BooleanInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  def check_box_html(); end

  def checked?(); end

  def checked_value(); end

  def hidden_field_html(); end

  def input_html_options_name(); end

  def label_text_with_embedded_checkbox(); end

  def label_with_nested_checkbox(); end

  def unchecked_value(); end
end

class Formtastic::Inputs::BooleanInput
end

class Formtastic::Inputs::CheckBoxesInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Collections
  include ::Formtastic::Inputs::Base::Choices
  def check_box_with_hidden_input(choice); end

  def check_box_without_hidden_input(choice); end

  def checkbox_input(choice); end

  def checked?(value); end

  def disabled?(value); end

  def disabled_values(); end

  def extra_html_options(choice); end

  def hidden_field_for_all(); end

  def hidden_fields?(); end

  def initialize(*args); end

  def make_selected_values(); end

  def selected_values(); end

  def unchecked_value(); end
end

class Formtastic::Inputs::CheckBoxesInput
end

class Formtastic::Inputs::ColorInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::ColorInput
end

class Formtastic::Inputs::CountryInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  def priority_countries(); end
end

class Formtastic::Inputs::CountryInput::CountrySelectPluginMissing
end

class Formtastic::Inputs::CountryInput::CountrySelectPluginMissing
end

class Formtastic::Inputs::CountryInput
end

class Formtastic::Inputs::DatalistInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Collections
  def data_list_html(); end

  def html_id_of_datalist(); end
end

class Formtastic::Inputs::DatalistInput
end

class Formtastic::Inputs::DatePickerInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::DatetimePickerish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::DatePickerInput
end

class Formtastic::Inputs::DateSelectInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Timeish
  def fragment_value(fragment); end

  def hidden_date_fragments(); end
end

class Formtastic::Inputs::DateSelectInput
end

class Formtastic::Inputs::DatetimePickerInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::DatetimePickerish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::DatetimePickerInput
end

class Formtastic::Inputs::DatetimeSelectInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Timeish
end

class Formtastic::Inputs::DatetimeSelectInput
end

class Formtastic::Inputs::EmailInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::EmailInput
end

class Formtastic::Inputs::FileInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
end

class Formtastic::Inputs::FileInput
end

class Formtastic::Inputs::HiddenInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
end

class Formtastic::Inputs::HiddenInput
end

class Formtastic::Inputs::NumberInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Numeric
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::NumberInput
end

class Formtastic::Inputs::PasswordInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::PasswordInput
end

class Formtastic::Inputs::PhoneInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::PhoneInput
end

class Formtastic::Inputs::RadioInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Collections
  include ::Formtastic::Inputs::Base::Choices
end

class Formtastic::Inputs::RadioInput
end

class Formtastic::Inputs::RangeInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Numeric
end

class Formtastic::Inputs::RangeInput
end

class Formtastic::Inputs::SearchInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::SearchInput
end

class Formtastic::Inputs::SelectInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Collections
  def extra_input_html_options(); end

  def include_blank(); end

  def initialize(*args); end

  def input_html_options_name(); end

  def input_html_options_name_multiple(); end

  def multiple?(); end

  def multiple_by_association?(); end

  def multiple_by_options?(); end

  def prompt?(); end

  def select_html(); end

  def single?(); end
end

class Formtastic::Inputs::SelectInput
end

class Formtastic::Inputs::StringInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::StringInput
end

class Formtastic::Inputs::TextInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::TextInput
end

class Formtastic::Inputs::TimePickerInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::DatetimePickerish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::TimePickerInput
end

class Formtastic::Inputs::TimeSelectInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Timeish
  def fragment_value(fragment); end

  def value_or_default_value(); end
end

class Formtastic::Inputs::TimeSelectInput
end

class Formtastic::Inputs::TimeZoneInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  def priority_zones(); end
end

class Formtastic::Inputs::TimeZoneInput
end

class Formtastic::Inputs::UrlInput
  include ::Formtastic::Inputs::Base
  include ::Formtastic::Inputs::Base::Html
  include ::Formtastic::Inputs::Base::Options
  include ::Formtastic::Inputs::Base::Database
  include ::Formtastic::Inputs::Base::Errors
  include ::Formtastic::Inputs::Base::Hints
  include ::Formtastic::Inputs::Base::Naming
  include ::Formtastic::Inputs::Base::Validations
  include ::Formtastic::Inputs::Base::Fileish
  include ::Formtastic::Inputs::Base::Associations
  include ::Formtastic::Helpers::Reflection
  include ::Formtastic::Inputs::Base::Labelling
  include ::Formtastic::LocalizedString
  include ::Formtastic::Inputs::Base::Wrapping
  include ::Formtastic::Inputs::Base::Stringish
  include ::Formtastic::Inputs::Base::Placeholder
end

class Formtastic::Inputs::UrlInput
end

module Formtastic::Inputs
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
end

module Formtastic::LocalizedString
  def localized_string(key, value, type, options=T.unsafe(nil)); end

  def model_name(); end
end

module Formtastic::LocalizedString
  extend ::T::Sig
end

class Formtastic::Localizer
  def builder(); end

  def builder=(builder); end

  def escape_html_entities(string); end

  def i18n_cache_lookups(); end

  def i18n_lookups_by_default(); end

  def initialize(current_builder); end

  def localize(key, value, type, options=T.unsafe(nil)); end

  def normalize_model_name(name); end
end

class Formtastic::Localizer::Cache
  def cache(); end

  def clear!(); end

  def get(key); end

  def has_key?(key); end

  def set(key, result); end
end

class Formtastic::Localizer::Cache
end

class Formtastic::Localizer
  def self.cache(); end
end

class Formtastic::NamespacedClassFinder
  def class_name(as); end

  def find(as); end

  def initialize(namespaces); end

  def namespaces(); end

  def resolve(as); end
end

class Formtastic::NamespacedClassFinder::NotFoundError
end

class Formtastic::NamespacedClassFinder::NotFoundError
end

class Formtastic::NamespacedClassFinder
  def self.use_const_defined?(); end
end

class Formtastic::PolymorphicInputWithoutCollectionError
end

class Formtastic::PolymorphicInputWithoutCollectionError
end

class Formtastic::UnknownActionError
end

class Formtastic::UnknownActionError
end

class Formtastic::UnknownInputError
end

class Formtastic::UnknownInputError
end

class Formtastic::UnsupportedEnumCollection
end

class Formtastic::UnsupportedEnumCollection
end

class Formtastic::UnsupportedMethodForAction
end

class Formtastic::UnsupportedMethodForAction
end

module Formtastic::Util
  def deprecated_version_of_rails?(); end

  def html_safe(text); end

  def match?(version, dependency); end

  def minimum_version_of_rails(); end

  def rails3?(); end

  def rails4?(); end

  def rails4_0?(); end

  def rails4_1?(); end

  def rails_version(); end
end

module Formtastic::Util
  extend ::Formtastic::Util
  extend ::T::Sig
end

module Formtastic
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.deprecation(); end

  def self.deprecation=(obj); end
end

module FormtasticI18n
  VERSION = ::T.let(nil, ::T.untyped)
end

class FormtasticI18n::Engine
end

class FormtasticI18n::Engine
end

module FormtasticI18n
  extend ::T::Sig
end

module Forwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_instance_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_instance_delegators(accessor, *methods); end

  def delegate(hash); end

  def instance_delegate(hash); end
end

module Forwardable
  extend ::T::Sig
  def self._compile_method(src, file, line); end

  def self._delegator_method(obj, accessor, method, ali); end

  def self._valid_method?(method); end

  def self.debug(); end

  def self.debug=(debug); end
end

class FrozenError
end

class FrozenError
end

class Fulfillment
  include ::Fulfillment::GeneratedAssociationMethods
  include ::PaperTrail::Model::InstanceMethods
  def after_add_for_line_item_fulfillments(); end

  def after_add_for_line_item_fulfillments=(val); end

  def after_add_for_line_item_fulfillments?(); end

  def after_add_for_line_items(); end

  def after_add_for_line_items=(val); end

  def after_add_for_line_items?(); end

  def after_add_for_versions(); end

  def after_add_for_versions=(val); end

  def after_add_for_versions?(); end

  def after_remove_for_line_item_fulfillments(); end

  def after_remove_for_line_item_fulfillments=(val); end

  def after_remove_for_line_item_fulfillments?(); end

  def after_remove_for_line_items(); end

  def after_remove_for_line_items=(val); end

  def after_remove_for_line_items?(); end

  def after_remove_for_versions(); end

  def after_remove_for_versions=(val); end

  def after_remove_for_versions?(); end

  def autosave_associated_records_for_line_item_fulfillments(*args); end

  def autosave_associated_records_for_line_items(*args); end

  def autosave_associated_records_for_versions(*args); end

  def before_add_for_line_item_fulfillments(); end

  def before_add_for_line_item_fulfillments=(val); end

  def before_add_for_line_item_fulfillments?(); end

  def before_add_for_line_items(); end

  def before_add_for_line_items=(val); end

  def before_add_for_line_items?(); end

  def before_add_for_versions(); end

  def before_add_for_versions=(val); end

  def before_add_for_versions?(); end

  def before_remove_for_line_item_fulfillments(); end

  def before_remove_for_line_item_fulfillments=(val); end

  def before_remove_for_line_item_fulfillments?(); end

  def before_remove_for_line_items(); end

  def before_remove_for_line_items=(val); end

  def before_remove_for_line_items?(); end

  def before_remove_for_versions(); end

  def before_remove_for_versions=(val); end

  def before_remove_for_versions?(); end

  def paper_trail_event(); end

  def paper_trail_event=(paper_trail_event); end

  def paper_trail_options(); end

  def paper_trail_options=(val); end

  def paper_trail_options?(); end

  def validate_associated_records_for_line_item_fulfillments(*args); end

  def validate_associated_records_for_line_items(*args); end

  def validate_associated_records_for_versions(*args); end

  def version(); end

  def version=(version); end

  def version_association_name(); end

  def version_association_name=(val); end

  def version_association_name?(); end

  def version_class_name(); end

  def version_class_name=(val); end

  def version_class_name?(); end

  def versions_association_name(); end

  def versions_association_name=(val); end

  def versions_association_name?(); end
end

module Fulfillment::GeneratedAssociationMethods
  def line_item_fulfillment_ids(); end

  def line_item_fulfillment_ids=(ids); end

  def line_item_fulfillments(); end

  def line_item_fulfillments=(value); end

  def line_item_ids(); end

  def line_item_ids=(ids); end

  def line_items(); end

  def line_items=(value); end

  def version_ids(); end

  def version_ids=(ids); end

  def versions(); end

  def versions=(value); end
end

module Fulfillment::GeneratedAssociationMethods
  extend ::T::Sig
end

class Fulfillment
  def self.after_add_for_line_item_fulfillments(); end

  def self.after_add_for_line_item_fulfillments=(val); end

  def self.after_add_for_line_item_fulfillments?(); end

  def self.after_add_for_line_items(); end

  def self.after_add_for_line_items=(val); end

  def self.after_add_for_line_items?(); end

  def self.after_add_for_versions(); end

  def self.after_add_for_versions=(val); end

  def self.after_add_for_versions?(); end

  def self.after_remove_for_line_item_fulfillments(); end

  def self.after_remove_for_line_item_fulfillments=(val); end

  def self.after_remove_for_line_item_fulfillments?(); end

  def self.after_remove_for_line_items(); end

  def self.after_remove_for_line_items=(val); end

  def self.after_remove_for_line_items?(); end

  def self.after_remove_for_versions(); end

  def self.after_remove_for_versions=(val); end

  def self.after_remove_for_versions?(); end

  def self.before_add_for_line_item_fulfillments(); end

  def self.before_add_for_line_item_fulfillments=(val); end

  def self.before_add_for_line_item_fulfillments?(); end

  def self.before_add_for_line_items(); end

  def self.before_add_for_line_items=(val); end

  def self.before_add_for_line_items?(); end

  def self.before_add_for_versions(); end

  def self.before_add_for_versions=(val); end

  def self.before_add_for_versions?(); end

  def self.before_remove_for_line_item_fulfillments(); end

  def self.before_remove_for_line_item_fulfillments=(val); end

  def self.before_remove_for_line_item_fulfillments?(); end

  def self.before_remove_for_line_items(); end

  def self.before_remove_for_line_items=(val); end

  def self.before_remove_for_line_items?(); end

  def self.before_remove_for_versions(); end

  def self.before_remove_for_versions=(val); end

  def self.before_remove_for_versions?(); end

  def self.paper_trail_options(); end

  def self.paper_trail_options=(val); end

  def self.paper_trail_options?(); end

  def self.version_association_name(); end

  def self.version_association_name=(val); end

  def self.version_association_name?(); end

  def self.version_class_name(); end

  def self.version_class_name=(val); end

  def self.version_class_name?(); end

  def self.versions_association_name(); end

  def self.versions_association_name=(val); end

  def self.versions_association_name?(); end
end

module GC
  def garbage_collect(*_); end
end

module GC::Profiler
  extend ::T::Sig
end

module GC
  extend ::T::Sig
  def self.latest_gc_info(*_); end

  def self.stress=(stress); end

  def self.verify_internal_consistency(); end
end

module Gem
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

class Gem::AvailableSet
  include ::Enumerable
  def <<(o); end

  def add(spec, source); end

  def all_specs(); end

  def each(); end

  def each_spec(); end

  def empty?(); end

  def find_all(req); end

  def inject_into_list(dep_list); end

  def match_platform!(); end

  def pick_best!(); end

  def prefetch(reqs); end

  def remote(); end

  def remote=(remote); end

  def remove_installed!(dep); end

  def set(); end

  def size(); end

  def sorted(); end

  def source_for(spec); end

  def to_request_set(development=T.unsafe(nil)); end
end

class Gem::AvailableSet::Tuple
  def source(); end

  def source=(_); end

  def spec(); end

  def spec=(_); end
end

class Gem::AvailableSet::Tuple
  def self.[](*_); end

  def self.members(); end
end

class Gem::AvailableSet
end

class Gem::BasicSpecification
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def activated?(); end

  def base_dir(); end

  def base_dir=(base_dir); end

  def contains_requirable_file?(file); end

  def datadir(); end

  def default_gem?(); end

  def extension_dir(); end

  def extension_dir=(extension_dir); end

  def extensions_dir(); end

  def full_gem_path(); end

  def full_gem_path=(full_gem_path); end

  def full_name(); end

  def full_require_paths(); end

  def gem_build_complete_path(); end

  def gem_dir(); end

  def gems_dir(); end

  def ignored=(ignored); end

  def internal_init(); end

  def lib_dirs_glob(); end

  def loaded_from(); end

  def loaded_from=(loaded_from); end

  def matches_for_glob(glob); end

  def name(); end

  def platform(); end

  def raw_require_paths(); end

  def require_paths(); end

  def source_paths(); end

  def stubbed?(); end

  def this(); end

  def to_fullpath(path); end

  def to_spec(); end

  def version(); end
end

class Gem::BasicSpecification
  extend ::T::Sig
  def self.default_specifications_dir(); end
end

module Gem::BundlerVersionFinder
end

module Gem::BundlerVersionFinder
  extend ::T::Sig
  def self.bundler_version(); end

  def self.bundler_version_with_reason(); end

  def self.compatible?(spec); end

  def self.filter!(specs); end

  def self.missing_version_message(); end
end

class Gem::Command
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def add_extra_args(args); end

  def add_option(*opts, &handler); end

  def arguments(); end

  def begins?(long, short); end

  def command(); end

  def defaults(); end

  def defaults=(defaults); end

  def defaults_str(); end

  def description(); end

  def execute(); end

  def get_all_gem_names(); end

  def get_all_gem_names_and_versions(); end

  def get_one_gem_name(); end

  def get_one_optional_argument(); end

  def handle_options(args); end

  def handles?(args); end

  def initialize(command, summary=T.unsafe(nil), defaults=T.unsafe(nil)); end

  def invoke(*args); end

  def invoke_with_build_args(args, build_args); end

  def merge_options(new_options); end

  def options(); end

  def program_name(); end

  def program_name=(program_name); end

  def remove_option(name); end

  def show_help(); end

  def show_lookup_failure(gem_name, version, errors, domain, required_by=T.unsafe(nil)); end

  def summary(); end

  def summary=(summary); end

  def usage(); end

  def when_invoked(&block); end
  HELP = ::T.let(nil, ::T.untyped)
end

class Gem::Command
  def self.add_common_option(*args, &handler); end

  def self.add_specific_extra_args(cmd, args); end

  def self.build_args(); end

  def self.build_args=(value); end

  def self.common_options(); end

  def self.extra_args(); end

  def self.extra_args=(value); end

  def self.specific_extra_args(cmd); end

  def self.specific_extra_args_hash(); end
end

class Gem::CommandLineError
  extend ::T::Sig
end

module Gem::Commands
end

module Gem::Commands
  extend ::T::Sig
end

class Gem::ConfigFile
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def api_keys(); end

  def args(); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def bulk_threshold(); end

  def bulk_threshold=(bulk_threshold); end

  def cert_expiration_length_days(); end

  def cert_expiration_length_days=(cert_expiration_length_days); end

  def check_credentials_permissions(); end

  def concurrent_downloads(); end

  def concurrent_downloads=(concurrent_downloads); end

  def config_file_name(); end

  def credentials_path(); end

  def disable_default_gem_server(); end

  def disable_default_gem_server=(disable_default_gem_server); end

  def each(&block); end

  def handle_arguments(arg_list); end

  def home(); end

  def home=(home); end

  def initialize(args); end

  def load_api_keys(); end

  def load_file(filename); end

  def path(); end

  def path=(path); end

  def really_verbose(); end

  def rubygems_api_key(); end

  def rubygems_api_key=(api_key); end

  def set_api_key(host, api_key); end

  def sources(); end

  def sources=(sources); end

  def ssl_ca_cert(); end

  def ssl_ca_cert=(ssl_ca_cert); end

  def ssl_client_cert(); end

  def ssl_verify_mode(); end

  def to_yaml(); end

  def unset_api_key!(); end

  def update_sources(); end

  def update_sources=(update_sources); end

  def verbose(); end

  def verbose=(verbose); end

  def write(); end
  DEFAULT_BACKTRACE = ::T.let(nil, ::T.untyped)
  DEFAULT_BULK_THRESHOLD = ::T.let(nil, ::T.untyped)
  DEFAULT_CERT_EXPIRATION_LENGTH_DAYS = ::T.let(nil, ::T.untyped)
  DEFAULT_CONCURRENT_DOWNLOADS = ::T.let(nil, ::T.untyped)
  DEFAULT_UPDATE_SOURCES = ::T.let(nil, ::T.untyped)
  DEFAULT_VERBOSITY = ::T.let(nil, ::T.untyped)
  OPERATING_SYSTEM_DEFAULTS = ::T.let(nil, ::T.untyped)
  PLATFORM_DEFAULTS = ::T.let(nil, ::T.untyped)
  SYSTEM_CONFIG_PATH = ::T.let(nil, ::T.untyped)
  SYSTEM_WIDE_CONFIG_FILE = ::T.let(nil, ::T.untyped)
end

class Gem::ConfigFile
end

class Gem::ConflictError
  def conflicts(); end

  def initialize(target, conflicts); end

  def target(); end
end

class Gem::ConflictError
  extend ::T::Sig
end

class Gem::ConsoleUI
  def initialize(); end
end

class Gem::ConsoleUI
end

module Gem::DefaultUserInteraction
  include ::Gem::Text
  def ui(); end

  def ui=(new_ui); end

  def use_ui(new_ui, &block); end
end

module Gem::DefaultUserInteraction
  extend ::T::Sig
  def self.ui(); end

  def self.ui=(new_ui); end

  def self.use_ui(new_ui); end
end

class Gem::Dependency
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def all_sources(); end

  def all_sources=(all_sources); end

  def encode_with(coder); end

  def eql?(other); end

  def groups(); end

  def groups=(groups); end

  def initialize(name, *requirements); end

  def latest_version?(); end

  def match?(obj, version=T.unsafe(nil), allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def matching_specs(platform_only=T.unsafe(nil)); end

  def merge(other); end

  def name(); end

  def name=(name); end

  def prerelease=(prerelease); end

  def prerelease?(); end

  def requirement(); end

  def requirements_list(); end

  def runtime?(); end

  def source(); end

  def source=(source); end

  def specific?(); end

  def to_lock(); end

  def to_spec(); end

  def to_specs(); end

  def to_yaml_properties(); end

  def type(); end
end

class Gem::Dependency
  extend ::T::Sig
end

class Gem::DependencyError
  extend ::T::Sig
end

class Gem::DependencyInstaller
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def _deprecated_add_found_dependencies(to_do, dependency_list); end

  def _deprecated_gather_dependencies(); end

  def add_found_dependencies(*args, &block); end

  def available_set_for(dep_or_name, version); end

  def consider_local?(); end

  def consider_remote?(); end

  def document(); end

  def errors(); end

  def find_gems_with_sources(dep, best_only=T.unsafe(nil)); end

  def find_spec_by_name_and_version(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def gather_dependencies(*args, &block); end

  def in_background(what); end

  def initialize(options=T.unsafe(nil)); end

  def install(dep_or_name, version=T.unsafe(nil)); end

  def install_development_deps(); end

  def installed_gems(); end

  def resolve_dependencies(dep_or_name, version); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Gem::DependencyInstaller
  extend ::Gem::Deprecate
end

class Gem::DependencyList
  include ::Enumerable
  include ::TSort
  def add(*gemspecs); end

  def clear(); end

  def dependency_order(); end

  def development(); end

  def development=(development); end

  def each(&block); end

  def find_name(full_name); end

  def initialize(development=T.unsafe(nil)); end

  def ok?(); end

  def ok_to_remove?(full_name, check_dev=T.unsafe(nil)); end

  def remove_by_name(full_name); end

  def remove_specs_unsatisfied_by(dependencies); end

  def spec_predecessors(); end

  def specs(); end

  def tsort_each_node(&block); end

  def why_not_ok?(quick=T.unsafe(nil)); end
end

class Gem::DependencyList
  def self.from_specs(); end
end

class Gem::DependencyRemovalException
  extend ::T::Sig
end

class Gem::DependencyResolutionError
  def conflict(); end

  def conflicting_dependencies(); end

  def initialize(conflict); end
end

class Gem::DependencyResolutionError
  extend ::T::Sig
end

module Gem::Deprecate
  extend ::T::Sig
  def self.deprecate(name, repl, year, month); end

  def self.skip(); end

  def self.skip=(v); end

  def self.skip_during(); end
end

class Gem::DocumentError
  extend ::T::Sig
end

class Gem::EndOfYAMLException
  extend ::T::Sig
end

class Gem::ErrorReason
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Gem::ErrorReason
  extend ::T::Sig
end

class Gem::Exception
  def _deprecated_source_exception(); end

  def source_exception(*args, &block); end

  def source_exception=(source_exception); end
end

class Gem::Exception
  extend ::T::Sig
  extend ::Gem::Deprecate
end

module Gem::Ext
end

class Gem::Ext::BuildError
end

class Gem::Ext::BuildError
end

class Gem::Ext::Builder
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def build_args(); end

  def build_args=(build_args); end

  def build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def build_extension(extension, dest_path); end

  def build_extensions(); end

  def builder_for(extension); end

  def initialize(spec, build_args=T.unsafe(nil)); end

  def write_gem_make_out(output); end
  CHDIR_MONITOR = ::T.let(nil, ::T.untyped)
  CHDIR_MUTEX = ::T.let(nil, ::T.untyped)
end

class Gem::Ext::Builder
  def self.class_name(); end

  def self.make(dest_path, results); end

  def self.redirector(); end

  def self.run(command, results, command_name=T.unsafe(nil)); end
end

class Gem::Ext::CmakeBuilder
end

class Gem::Ext::CmakeBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ConfigureBuilder
end

class Gem::Ext::ConfigureBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

class Gem::Ext::ExtConfBuilder
end

Gem::Ext::ExtConfBuilder::FileEntry = FileUtils::Entry_

class Gem::Ext::ExtConfBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end

  def self.get_relative_path(path); end
end

class Gem::Ext::RakeBuilder
end

class Gem::Ext::RakeBuilder
  def self.build(extension, dest_path, results, args=T.unsafe(nil), lib_dir=T.unsafe(nil)); end
end

module Gem::Ext
  extend ::T::Sig
end

class Gem::FilePermissionError
  def directory(); end

  def initialize(directory); end
end

class Gem::FilePermissionError
  extend ::T::Sig
end

class Gem::FormatException
  def file_path(); end

  def file_path=(file_path); end
end

class Gem::FormatException
  extend ::T::Sig
end

class Gem::GemNotFoundException
  extend ::T::Sig
end

class Gem::GemNotInHomeException
  def spec(); end

  def spec=(spec); end
end

class Gem::GemNotInHomeException
  extend ::T::Sig
end

class Gem::ImpossibleDependenciesError
  def build_message(); end

  def conflicts(); end

  def dependency(); end

  def initialize(request, conflicts); end

  def request(); end
end

class Gem::ImpossibleDependenciesError
  extend ::T::Sig
end

class Gem::InstallError
  extend ::T::Sig
end

class Gem::Installer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def _deprecated_extension_build_error(build_dir, output, backtrace=T.unsafe(nil)); end

  def app_script_text(bin_file_name); end

  def bin_dir(); end

  def build_extensions(); end

  def build_root(); end

  def check_executable_overwrite(filename); end

  def check_that_user_bin_dir_is_in_path(); end

  def default_spec_file(); end

  def dir(); end

  def ensure_dependencies_met(); end

  def ensure_dependency(spec, dependency); end

  def ensure_loadable_spec(); end

  def ensure_required_ruby_version_met(); end

  def ensure_required_rubygems_version_met(); end

  def extension_build_error(*args, &block); end

  def extract_bin(); end

  def extract_files(); end

  def formatted_program_filename(filename); end

  def gem(); end

  def gem_dir(); end

  def gem_home(); end

  def generate_bin(); end

  def generate_bin_script(filename, bindir); end

  def generate_bin_symlink(filename, bindir); end

  def generate_windows_script(filename, bindir); end

  def initialize(package, options=T.unsafe(nil)); end

  def install(); end

  def installation_satisfies_dependency?(dependency); end

  def installed_specs(); end

  def options(); end

  def pre_install_checks(); end

  def process_options(); end

  def run_post_build_hooks(); end

  def run_post_install_hooks(); end

  def run_pre_install_hooks(); end

  def shebang(bin_file_name); end

  def spec(); end

  def spec_file(); end

  def unpack(directory); end

  def verify_gem_home(unpack=T.unsafe(nil)); end

  def verify_spec(); end

  def windows_stub_script(bindir, bin_file_name); end

  def write_build_info_file(); end

  def write_cache_file(); end

  def write_default_spec(); end

  def write_spec(); end
  ENV_PATHS = ::T.let(nil, ::T.untyped)
end

class Gem::Installer
  extend ::Gem::Deprecate
  def self.at(path, options=T.unsafe(nil)); end

  def self.exec_format(); end

  def self.exec_format=(exec_format); end

  def self.for_spec(spec, options=T.unsafe(nil)); end

  def self.install_lock(); end

  def self.path_warning(); end

  def self.path_warning=(path_warning); end
end

class Gem::InvalidSpecificationException
  extend ::T::Sig
end

class Gem::Licenses
  EXCEPTION_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  LICENSE_IDENTIFIERS = ::T.let(nil, ::T.untyped)
  NONSTANDARD = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
end

class Gem::Licenses
  extend ::Gem::Text
  def self.match?(license); end

  def self.suggestions(license); end
end

class Gem::List
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def each(); end

  def initialize(value=T.unsafe(nil), tail=T.unsafe(nil)); end

  def prepend(value); end

  def tail(); end

  def tail=(tail); end

  def to_a(); end

  def value(); end

  def value=(value); end
end

class Gem::List
  extend ::T::Sig
  def self.prepend(list, value); end
end

class Gem::LoadError
  def name(); end

  def name=(name); end

  def requirement(); end

  def requirement=(requirement); end
end

class Gem::LoadError
  extend ::T::Sig
end

class Gem::MissingSpecError
  def initialize(name, requirement); end
end

class Gem::MissingSpecError
  extend ::T::Sig
end

class Gem::MissingSpecVersionError
  def initialize(name, requirement, specs); end

  def specs(); end
end

class Gem::MissingSpecVersionError
  extend ::T::Sig
end

class Gem::NameTuple
  include ::Comparable
  def ==(other); end

  def eql?(other); end

  def full_name(); end

  def initialize(name, version, platform=T.unsafe(nil)); end

  def match_platform?(); end

  def name(); end

  def platform(); end

  def prerelease?(); end

  def spec_name(); end

  def to_a(); end

  def version(); end
end

class Gem::NameTuple
  def self.from_list(list); end

  def self.null(); end

  def self.to_basic(list); end
end

class Gem::OperationNotSupportedError
  extend ::T::Sig
end

class Gem::Package
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def add_checksums(tar); end

  def add_contents(tar); end

  def add_files(tar); end

  def add_metadata(tar); end

  def build(skip_validation=T.unsafe(nil), strict_validation=T.unsafe(nil)); end

  def build_time(); end

  def build_time=(build_time); end

  def checksums(); end

  def contents(); end

  def copy_to(path); end

  def data_mode(); end

  def data_mode=(data_mode); end

  def digest(entry); end

  def dir_mode(); end

  def dir_mode=(dir_mode); end

  def extract_files(destination_dir, pattern=T.unsafe(nil)); end

  def extract_tar_gz(io, destination_dir, pattern=T.unsafe(nil)); end

  def file_mode(mode); end

  def files(); end

  def gzip_to(io); end

  def initialize(gem, security_policy); end

  def install_location(filename, destination_dir); end

  def load_spec(entry); end

  def mkdir_p_safe(mkdir, mkdir_options, destination_dir, file_name); end

  def normalize_path(pathname); end

  def open_tar_gz(io); end

  def prog_mode(); end

  def prog_mode=(prog_mode); end

  def read_checksums(gem); end

  def security_policy(); end

  def security_policy=(security_policy); end

  def setup_signer(signer_options: T.unsafe(nil)); end

  def spec(); end

  def spec=(spec); end

  def verify(); end

  def verify_checksums(digests, checksums); end

  def verify_entry(entry); end

  def verify_files(gem); end

  def verify_gz(entry); end
end

class Gem::Package::DigestIO
  def digests(); end

  def initialize(io, digests); end

  def write(data); end
end

class Gem::Package::DigestIO
  def self.wrap(io, digests); end
end

class Gem::Package::Error
end

class Gem::Package::Error
end

class Gem::Package::FileSource
  def initialize(path); end

  def path(); end

  def start(); end

  def with_read_io(&block); end

  def with_write_io(&block); end
end

class Gem::Package::FileSource
end

class Gem::Package::FormatError
  def initialize(message, source=T.unsafe(nil)); end

  def path(); end
end

class Gem::Package::FormatError
end

class Gem::Package::IOSource
  def initialize(io); end

  def io(); end

  def path(); end

  def start(); end

  def with_read_io(); end

  def with_write_io(); end
end

class Gem::Package::IOSource
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::NonSeekableIO
end

class Gem::Package::Old
  def extract_files(destination_dir); end

  def file_list(io); end

  def read_until_dashes(io); end

  def skip_ruby(io); end
end

class Gem::Package::Old
end

class Gem::Package::PathError
  def initialize(destination, destination_dir); end
end

class Gem::Package::PathError
end

class Gem::Package::Source
end

class Gem::Package::Source
end

class Gem::Package::TarHeader
  def ==(other); end

  def checksum(); end

  def devmajor(); end

  def devminor(); end

  def empty?(); end

  def gid(); end

  def gname(); end

  def initialize(vals); end

  def linkname(); end

  def magic(); end

  def mode(); end

  def mtime(); end

  def name(); end

  def prefix(); end

  def size(); end

  def typeflag(); end

  def uid(); end

  def uname(); end

  def update_checksum(); end

  def version(); end
  EMPTY_HEADER = ::T.let(nil, ::T.untyped)
  FIELDS = ::T.let(nil, ::T.untyped)
  PACK_FORMAT = ::T.let(nil, ::T.untyped)
  UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
end

class Gem::Package::TarHeader
  def self.from(stream); end

  def self.strict_oct(str); end
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarInvalidError
end

class Gem::Package::TarReader
  include ::Enumerable
  def close(); end

  def each(); end

  def each_entry(); end

  def initialize(io); end

  def rewind(); end

  def seek(name); end
end

class Gem::Package::TarReader::Entry
  def bytes_read(); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def directory?(); end

  def eof?(); end

  def file?(); end

  def full_name(); end

  def getc(); end

  def header(); end

  def initialize(header, io); end

  def length(); end

  def pos(); end

  def read(len=T.unsafe(nil)); end

  def readpartial(maxlen=T.unsafe(nil), outbuf=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def symlink?(); end
end

class Gem::Package::TarReader::Entry
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader::UnexpectedEOF
end

class Gem::Package::TarReader
  def self.new(io); end
end

class Gem::Package::TarWriter
  def add_file(name, mode); end

  def add_file_digest(name, mode, digest_algorithms); end

  def add_file_signed(name, mode, signer); end

  def add_file_simple(name, mode, size); end

  def add_symlink(name, target, mode); end

  def check_closed(); end

  def close(); end

  def closed?(); end

  def flush(); end

  def initialize(io); end

  def mkdir(name, mode); end

  def split_name(name); end
end

class Gem::Package::TarWriter::BoundedStream
  def initialize(io, limit); end

  def limit(); end

  def write(data); end

  def written(); end
end

class Gem::Package::TarWriter::BoundedStream
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::FileOverflow
end

class Gem::Package::TarWriter::RestrictedStream
  def initialize(io); end

  def write(data); end
end

class Gem::Package::TarWriter::RestrictedStream
end

class Gem::Package::TarWriter
  def self.new(io); end
end

class Gem::Package::TooLongFileName
end

class Gem::Package::TooLongFileName
end

class Gem::Package
  def self.build(spec, skip_validation=T.unsafe(nil), strict_validation=T.unsafe(nil), file_name=T.unsafe(nil)); end

  def self.new(gem, security_policy=T.unsafe(nil)); end
end

class Gem::PathSupport
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def home(); end

  def initialize(env); end

  def path(); end

  def spec_cache_dir(); end
end

class Gem::PathSupport
  extend ::T::Sig
end

class Gem::Platform
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def ===(other); end

  def =~(other); end

  def cpu(); end

  def cpu=(cpu); end

  def eql?(other); end

  def initialize(arch); end

  def os(); end

  def os=(os); end

  def to_a(); end

  def version(); end

  def version=(version); end
  JAVA = ::T.let(nil, ::T.untyped)
  MINGW = ::T.let(nil, ::T.untyped)
  MSWIN = ::T.let(nil, ::T.untyped)
  MSWIN64 = ::T.let(nil, ::T.untyped)
  X64_MINGW = ::T.let(nil, ::T.untyped)
end

class Gem::Platform
  extend ::T::Sig
  def self.installable?(spec); end

  def self.local(); end

  def self.match(platform); end

  def self.new(arch); end
end

class Gem::PlatformMismatch
  def add_platform(platform); end

  def initialize(name, version); end

  def name(); end

  def platforms(); end

  def version(); end

  def wordy(); end
end

class Gem::PlatformMismatch
  extend ::T::Sig
end

class Gem::RemoteError
  extend ::T::Sig
end

class Gem::RemoteFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cache_update_path(uri, path=T.unsafe(nil), update=T.unsafe(nil)); end

  def close_all(); end

  def correct_for_windows_path(path); end

  def download(spec, source_uri, install_dir=T.unsafe(nil)); end

  def download_to_cache(dependency); end

  def fetch_file(uri, *_); end

  def fetch_http(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_https(uri, last_modified=T.unsafe(nil), head=T.unsafe(nil), depth=T.unsafe(nil)); end

  def fetch_path(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_s3(uri, mtime=T.unsafe(nil), head=T.unsafe(nil)); end

  def fetch_size(uri); end

  def headers(); end

  def headers=(headers); end

  def https?(uri); end

  def initialize(proxy=T.unsafe(nil), dns=T.unsafe(nil), headers=T.unsafe(nil)); end

  def request(uri, request_class, last_modified=T.unsafe(nil)); end

  def s3_expiration(); end

  def sign_s3_url(uri, expiration=T.unsafe(nil)); end
  BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
end

class Gem::RemoteFetcher
  def self.fetcher(); end
end

class Gem::RemoteInstallationCancelled
  extend ::T::Sig
end

class Gem::RemoteInstallationSkipped
  extend ::T::Sig
end

class Gem::RemoteSourceException
  extend ::T::Sig
end

class Gem::Request
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_files(); end

  def connection_for(uri); end

  def fetch(); end

  def initialize(uri, request_class, last_modified, pool); end

  def perform_request(request); end

  def proxy_uri(); end

  def reset(connection); end

  def user_agent(); end
end

class Gem::Request::ConnectionPools
  def close_all(); end

  def initialize(proxy_uri, cert_files); end

  def pool_for(uri); end
end

class Gem::Request::ConnectionPools
  def self.client(); end

  def self.client=(client); end
end

class Gem::Request::HTTPPool
  def cert_files(); end

  def checkin(connection); end

  def checkout(); end

  def close_all(); end

  def initialize(http_args, cert_files, proxy_uri); end

  def proxy_uri(); end
end

class Gem::Request::HTTPPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request::HTTPSPool
end

class Gem::Request
  extend ::Gem::UserInteraction
  extend ::Gem::DefaultUserInteraction
  extend ::Gem::Text
  def self.configure_connection_for_https(connection, cert_files); end

  def self.create_with_proxy(uri, request_class, last_modified, proxy); end

  def self.get_cert_files(); end

  def self.get_proxy_from_env(scheme=T.unsafe(nil)); end

  def self.proxy_uri(proxy); end

  def self.verify_certificate(store_context); end

  def self.verify_certificate_message(error_number, cert); end
end

class Gem::RequestSet
  include ::TSort
  def always_install(); end

  def always_install=(always_install); end

  def dependencies(); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def errors(); end

  def gem(name, *reqs); end

  def git_set(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def import(deps); end

  def initialize(*deps); end

  def install(options, &block); end

  def install_dir(); end

  def install_from_gemdeps(options, &block); end

  def install_hooks(requests, options); end

  def install_into(dir, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def load_gemdeps(path, without_groups=T.unsafe(nil), installing=T.unsafe(nil)); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def resolve(set=T.unsafe(nil)); end

  def resolve_current(); end

  def resolver(); end

  def sets(); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def sorted_requests(); end

  def source_set(); end

  def specs(); end

  def specs_in(dir); end

  def tsort_each_node(&block); end

  def vendor_set(); end
end

class Gem::RequestSet::GemDependencyAPI
  def dependencies(); end

  def find_gemspec(name, path); end

  def gem(name, *requirements); end

  def gem_deps_file(); end

  def gem_git_reference(options); end

  def gemspec(options=T.unsafe(nil)); end

  def git(repository); end

  def git_set(); end

  def git_source(name, &callback); end

  def group(*groups); end

  def initialize(set, path); end

  def installing=(installing); end

  def load(); end

  def platform(*platforms); end

  def platforms(*platforms); end

  def requires(); end

  def ruby(version, options=T.unsafe(nil)); end

  def source(url); end

  def vendor_set(); end

  def without_groups(); end

  def without_groups=(without_groups); end
  ENGINE_MAP = ::T.let(nil, ::T.untyped)
  PLATFORM_MAP = ::T.let(nil, ::T.untyped)
  VERSION_MAP = ::T.let(nil, ::T.untyped)
  WINDOWS = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::GemDependencyAPI
end

class Gem::RequestSet::Lockfile
  def add_DEPENDENCIES(out); end

  def add_GEM(out, spec_groups); end

  def add_GIT(out, git_requests); end

  def add_PATH(out, path_requests); end

  def add_PLATFORMS(out); end

  def initialize(request_set, gem_deps_file, dependencies); end

  def platforms(); end

  def relative_path_from(dest, base); end

  def spec_groups(); end

  def write(); end
end

class Gem::RequestSet::Lockfile::ParseError
  def column(); end

  def initialize(message, column, line, path); end

  def line(); end

  def path(); end
end

class Gem::RequestSet::Lockfile::ParseError
end

class Gem::RequestSet::Lockfile::Parser
  def get(expected_types=T.unsafe(nil), expected_value=T.unsafe(nil)); end

  def initialize(tokenizer, set, platforms, filename=T.unsafe(nil)); end

  def parse(); end

  def parse_DEPENDENCIES(); end

  def parse_GEM(); end

  def parse_GIT(); end

  def parse_PATH(); end

  def parse_PLATFORMS(); end

  def parse_dependency(name, op); end
end

class Gem::RequestSet::Lockfile::Parser
end

class Gem::RequestSet::Lockfile::Tokenizer
  def empty?(); end

  def initialize(input, filename=T.unsafe(nil), line=T.unsafe(nil), pos=T.unsafe(nil)); end

  def make_parser(set, platforms); end

  def next_token(); end

  def peek(); end

  def shift(); end

  def skip(type); end

  def to_a(); end

  def token_pos(byte_offset); end

  def unshift(token); end
  EOF = ::T.let(nil, ::T.untyped)
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def column(); end

  def column=(_); end

  def line(); end

  def line=(_); end

  def type(); end

  def type=(_); end

  def value(); end

  def value=(_); end
end

class Gem::RequestSet::Lockfile::Tokenizer::Token
  def self.[](*_); end

  def self.members(); end
end

class Gem::RequestSet::Lockfile::Tokenizer
  def self.from_file(file); end
end

class Gem::RequestSet::Lockfile
  def self.build(request_set, gem_deps_file, dependencies=T.unsafe(nil)); end

  def self.requests_to_deps(requests); end
end

class Gem::RequestSet
end

class Gem::Requirement
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def ===(version); end

  def =~(version); end

  def _tilde_requirements(); end

  def as_list(); end

  def concat(new); end

  def encode_with(coder); end

  def exact?(); end

  def for_lockfile(); end

  def init_with(coder); end

  def initialize(*requirements); end

  def marshal_dump(); end

  def marshal_load(array); end

  def none?(); end

  def prerelease?(); end

  def requirements(); end

  def satisfied_by?(version); end

  def specific?(); end

  def to_yaml_properties(); end

  def yaml_initialize(tag, vals); end
  DefaultRequirement = ::T.let(nil, ::T.untyped)
end

class Gem::Requirement::BadRequirementError
  extend ::T::Sig
end

class Gem::Requirement
  extend ::T::Sig
  def self.create(*inputs); end

  def self.default(); end

  def self.parse(obj); end

  def self.source_set(); end
end

class Gem::Resolver
  include ::Gem::Resolver::Molinillo::UI
  include ::Gem::Resolver::Molinillo::SpecificationProvider
  def activation_request(dep, possible); end

  def development(); end

  def development=(development); end

  def development_shallow(); end

  def development_shallow=(development_shallow); end

  def explain(stage, *data); end

  def explain_list(stage); end

  def find_possible(dependency); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def initialize(needed, set=T.unsafe(nil)); end

  def missing(); end

  def requests(s, act, reqs=T.unsafe(nil)); end

  def resolve(); end

  def select_local_platforms(specs); end

  def skip_gems(); end

  def skip_gems=(skip_gems); end

  def soft_missing(); end

  def soft_missing=(soft_missing); end

  def stats(); end
  DEBUG_RESOLVER = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::APISet
  def dep_uri(); end

  def initialize(dep_uri=T.unsafe(nil)); end

  def prefetch_now(); end

  def source(); end

  def uri(); end

  def versions(name); end
end

class Gem::Resolver::APISet
end

class Gem::Resolver::APISpecification
  def ==(other); end

  def initialize(set, api_data); end
end

class Gem::Resolver::APISpecification
end

class Gem::Resolver::ActivationRequest
  def ==(other); end

  def development?(); end

  def download(path); end

  def full_name(); end

  def full_spec(); end

  def initialize(spec, request, others_possible=T.unsafe(nil)); end

  def installed?(); end

  def name(); end

  def others_possible?(); end

  def parent(); end

  def request(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::ActivationRequest
end

class Gem::Resolver::BestSet
  def initialize(sources=T.unsafe(nil)); end

  def pick_sets(); end

  def replace_failed_api_set(error); end
end

class Gem::Resolver::BestSet
end

class Gem::Resolver::ComposedSet
  def initialize(*sets); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def sets(); end
end

class Gem::Resolver::ComposedSet
end

class Gem::Resolver::Conflict
  def ==(other); end

  def activated(); end

  def conflicting_dependencies(); end

  def dependency(); end

  def explain(); end

  def explanation(); end

  def failed_dep(); end

  def for_spec?(spec); end

  def initialize(dependency, activated, failed_dep=T.unsafe(nil)); end

  def request_path(current); end

  def requester(); end
end

class Gem::Resolver::Conflict
end

class Gem::Resolver::CurrentSet
end

class Gem::Resolver::CurrentSet
end

Gem::Resolver::DependencyConflict = Gem::Resolver::Conflict

class Gem::Resolver::DependencyRequest
  def ==(other); end

  def dependency(); end

  def development?(); end

  def explicit?(); end

  def implicit?(); end

  def initialize(dependency, requester); end

  def match?(spec, allow_prerelease=T.unsafe(nil)); end

  def matches_spec?(spec); end

  def name(); end

  def request_context(); end

  def requester(); end

  def requirement(); end

  def type(); end
end

class Gem::Resolver::DependencyRequest
end

class Gem::Resolver::GitSet
  def add_git_gem(name, repository, reference, submodules); end

  def add_git_spec(name, version, repository, reference, submodules); end

  def need_submodules(); end

  def repositories(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end
end

class Gem::Resolver::GitSet
end

class Gem::Resolver::GitSpecification
  def ==(other); end

  def add_dependency(dependency); end
end

class Gem::Resolver::GitSpecification
end

class Gem::Resolver::IndexSet
  def initialize(source=T.unsafe(nil)); end
end

class Gem::Resolver::IndexSet
end

class Gem::Resolver::IndexSpecification
  def initialize(set, name, version, source, platform); end
end

class Gem::Resolver::IndexSpecification
end

class Gem::Resolver::InstalledSpecification
  def ==(other); end
end

class Gem::Resolver::InstalledSpecification
end

class Gem::Resolver::InstallerSet
  def add_always_install(dependency); end

  def add_local(dep_name, spec, source); end

  def always_install(); end

  def consider_local?(); end

  def consider_remote?(); end

  def ignore_dependencies(); end

  def ignore_dependencies=(ignore_dependencies); end

  def ignore_installed(); end

  def ignore_installed=(ignore_installed); end

  def initialize(domain); end

  def load_spec(name, ver, platform, source); end

  def local?(dep_name); end

  def prerelease=(allow_prerelease); end

  def remote=(remote); end

  def remote_set(); end
end

class Gem::Resolver::InstallerSet
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LocalSpecification
end

class Gem::Resolver::LockSet
  def add(name, version, platform); end

  def initialize(sources); end

  def load_spec(name, version, platform, source); end

  def specs(); end
end

class Gem::Resolver::LockSet
end

class Gem::Resolver::LockSpecification
  def add_dependency(dependency); end

  def initialize(set, name, version, sources, platform); end

  def sources(); end
end

class Gem::Resolver::LockSpecification
end

module Gem::Resolver::Molinillo
  VERSION = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Molinillo::CircularDependencyError
  def dependencies(); end

  def initialize(nodes); end
end

class Gem::Resolver::Molinillo::CircularDependencyError
end

module Gem::Resolver::Molinillo::Delegates
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  def activated(); end

  def conflicts(); end

  def depth(); end

  def name(); end

  def possibilities(); end

  def requirement(); end

  def requirements(); end
end

module Gem::Resolver::Molinillo::Delegates::ResolutionState
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::Delegates
  extend ::T::Sig
end

class Gem::Resolver::Molinillo::DependencyGraph
  include ::Enumerable
  include ::TSort
  def ==(other); end

  def add_child_vertex(name, payload, parent_names, requirement); end

  def add_edge(origin, destination, requirement); end

  def add_vertex(name, payload, root=T.unsafe(nil)); end

  def delete_edge(edge); end

  def detach_vertex_named(name); end

  def each(); end

  def log(); end

  def rewind_to(tag); end

  def root_vertex_named(name); end

  def set_payload(name, payload); end

  def tag(tag); end

  def to_dot(options=T.unsafe(nil)); end

  def tsort_each_child(vertex, &block); end

  def vertex_named(name); end

  def vertices(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def down(graph); end

  def next(); end

  def next=(_); end

  def previous(); end

  def previous=(previous); end

  def up(graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Action
  def self.action_name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
  def destination(); end

  def initialize(origin, destination, requirement); end

  def make_edge(graph); end

  def origin(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddEdgeNoCircular
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
  def initialize(name, payload, root); end

  def name(); end

  def payload(); end

  def root(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::AddVertex
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
  def destination_name(); end

  def initialize(origin_name, destination_name, requirement); end

  def make_edge(graph); end

  def origin_name(); end

  def requirement(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DeleteEdge
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
  def initialize(name); end

  def name(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::DetachVertexNamed
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def destination(); end

  def destination=(_); end

  def origin(); end

  def origin=(_); end

  def requirement(); end

  def requirement=(_); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Edge
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  def add_edge_no_circular(graph, origin, destination, requirement); end

  def add_vertex(graph, name, payload, root); end

  def delete_edge(graph, origin_name, destination_name, requirement); end

  def detach_vertex_named(graph, name); end

  def each(); end

  def pop!(graph); end

  def reverse_each(); end

  def rewind_to(graph, tag); end

  def set_payload(graph, name, payload); end

  def tag(graph, tag); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Log
  extend ::Enumerable
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
  def initialize(name, payload); end

  def name(); end

  def payload(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::SetPayload
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
  def down(_graph); end

  def initialize(tag); end

  def tag(); end

  def up(_graph); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Tag
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
  def ==(other); end

  def ancestor?(other); end

  def descendent?(other); end

  def eql?(other); end

  def explicit_requirements(); end

  def incoming_edges(); end

  def incoming_edges=(incoming_edges); end

  def initialize(name, payload); end

  def is_reachable_from?(other); end

  def name(); end

  def name=(name); end

  def outgoing_edges(); end

  def outgoing_edges=(outgoing_edges); end

  def path_to?(other); end

  def payload(); end

  def payload=(payload); end

  def predecessors(); end

  def recursive_predecessors(); end

  def recursive_successors(); end

  def requirements(); end

  def root(); end

  def root=(root); end

  def root?(); end

  def shallow_eql?(other); end

  def successors(); end
end

class Gem::Resolver::Molinillo::DependencyGraph::Vertex
end

class Gem::Resolver::Molinillo::DependencyGraph
  def self.tsort(vertices); end
end

class Gem::Resolver::Molinillo::DependencyState
  def pop_possibility_state(); end
end

class Gem::Resolver::Molinillo::DependencyState
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
  def dependency(); end

  def dependency=(dependency); end

  def initialize(dependency, required_by=T.unsafe(nil)); end

  def required_by(); end

  def required_by=(required_by); end
end

class Gem::Resolver::Molinillo::NoSuchDependencyError
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::PossibilityState
end

class Gem::Resolver::Molinillo::ResolutionState
  def activated(); end

  def activated=(_); end

  def conflicts(); end

  def conflicts=(_); end

  def depth(); end

  def depth=(_); end

  def name(); end

  def name=(_); end

  def possibilities(); end

  def possibilities=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::ResolutionState
  def self.[](*_); end

  def self.empty(); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver
  def initialize(specification_provider, resolver_ui); end

  def resolve(requested, base=T.unsafe(nil)); end

  def resolver_ui(); end

  def specification_provider(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
  include ::Gem::Resolver::Molinillo::Delegates::ResolutionState
  include ::Gem::Resolver::Molinillo::Delegates::SpecificationProvider
  def base(); end

  def initialize(specification_provider, resolver_ui, requested, base); end

  def iteration_rate=(iteration_rate); end

  def original_requested(); end

  def resolve(); end

  def resolver_ui(); end

  def specification_provider(); end

  def started_at=(started_at); end

  def states=(states); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def activated_by_name(); end

  def activated_by_name=(_); end

  def existing(); end

  def existing=(_); end

  def locked_requirement(); end

  def locked_requirement=(_); end

  def possibility(); end

  def possibility=(_); end

  def requirement(); end

  def requirement=(_); end

  def requirement_trees(); end

  def requirement_trees=(_); end

  def requirements(); end

  def requirements=(_); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution::Conflict
  def self.[](*_); end

  def self.members(); end
end

class Gem::Resolver::Molinillo::Resolver::Resolution
end

class Gem::Resolver::Molinillo::Resolver
end

class Gem::Resolver::Molinillo::ResolverError
end

class Gem::Resolver::Molinillo::ResolverError
end

module Gem::Resolver::Molinillo::SpecificationProvider
  def allow_missing?(dependency); end

  def dependencies_for(specification); end

  def name_for(dependency); end

  def name_for_explicit_dependency_source(); end

  def name_for_locking_dependency_source(); end

  def requirement_satisfied_by?(requirement, activated, spec); end

  def search_for(dependency); end

  def sort_dependencies(dependencies, activated, conflicts); end
end

module Gem::Resolver::Molinillo::SpecificationProvider
  extend ::T::Sig
end

module Gem::Resolver::Molinillo::UI
  def after_resolution(); end

  def before_resolution(); end

  def debug(depth=T.unsafe(nil)); end

  def debug?(); end

  def indicate_progress(); end

  def output(); end

  def progress_rate(); end
end

module Gem::Resolver::Molinillo::UI
  extend ::T::Sig
end

class Gem::Resolver::Molinillo::VersionConflict
  def conflicts(); end

  def initialize(conflicts); end
end

class Gem::Resolver::Molinillo::VersionConflict
end

module Gem::Resolver::Molinillo
  extend ::T::Sig
end

class Gem::Resolver::RequirementList
  include ::Enumerable
  def add(req); end

  def each(); end

  def empty?(); end

  def next5(); end

  def remove(); end

  def size(); end
end

class Gem::Resolver::RequirementList
end

class Gem::Resolver::Set
  def errors(); end

  def errors=(errors); end

  def find_all(req); end

  def prefetch(reqs); end

  def prerelease(); end

  def prerelease=(prerelease); end

  def remote(); end

  def remote=(remote); end

  def remote?(); end
end

class Gem::Resolver::Set
end

class Gem::Resolver::SourceSet
  def add_source_gem(name, source); end
end

class Gem::Resolver::SourceSet
end

class Gem::Resolver::SpecSpecification
  def initialize(set, spec, source=T.unsafe(nil)); end
end

class Gem::Resolver::SpecSpecification
end

class Gem::Resolver::Specification
  def dependencies(); end

  def download(options); end

  def fetch_development_dependencies(); end

  def full_name(); end

  def install(options=T.unsafe(nil)); end

  def installable_platform?(); end

  def local?(); end

  def name(); end

  def platform(); end

  def set(); end

  def source(); end

  def spec(); end

  def version(); end
end

class Gem::Resolver::Specification
end

class Gem::Resolver::Stats
  def backtracking!(); end

  def display(); end

  def iteration!(); end

  def record_depth(stack); end

  def record_requirements(reqs); end

  def requirement!(); end
  PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::Resolver::Stats
end

class Gem::Resolver::VendorSet
  def add_vendor_gem(name, directory); end

  def load_spec(name, version, platform, source); end

  def specs(); end
end

class Gem::Resolver::VendorSet
end

class Gem::Resolver::VendorSpecification
  def ==(other); end
end

class Gem::Resolver::VendorSpecification
end

class Gem::Resolver
  def self.compose_sets(*sets); end

  def self.for_current_gems(needed); end
end

class Gem::RubyVersionMismatch
  extend ::T::Sig
end

class Gem::RuntimeRequirementNotMetError
  def suggestion(); end

  def suggestion=(suggestion); end
end

class Gem::RuntimeRequirementNotMetError
end

module Gem::Security
  AlmostNoSecurity = ::T.let(nil, ::T.untyped)
  DIGEST_NAME = ::T.let(nil, ::T.untyped)
  EXTENSIONS = ::T.let(nil, ::T.untyped)
  HighSecurity = ::T.let(nil, ::T.untyped)
  KEY_CIPHER = ::T.let(nil, ::T.untyped)
  KEY_LENGTH = ::T.let(nil, ::T.untyped)
  LowSecurity = ::T.let(nil, ::T.untyped)
  MediumSecurity = ::T.let(nil, ::T.untyped)
  NoSecurity = ::T.let(nil, ::T.untyped)
  ONE_DAY = ::T.let(nil, ::T.untyped)
  ONE_YEAR = ::T.let(nil, ::T.untyped)
  Policies = ::T.let(nil, ::T.untyped)
  SigningPolicy = ::T.let(nil, ::T.untyped)
end

class Gem::Security::DIGEST_ALGORITHM
  def initialize(data=T.unsafe(nil)); end
end

class Gem::Security::DIGEST_ALGORITHM
  def self.digest(data); end

  def self.hexdigest(data); end
end

class Gem::Security::Exception
end

class Gem::Security::Exception
end

Gem::Security::KEY_ALGORITHM = OpenSSL::PKey::RSA

class Gem::Security::Policy
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def check_cert(signer, issuer, time); end

  def check_chain(chain, time); end

  def check_data(public_key, digest, signature, data); end

  def check_key(signer, key); end

  def check_root(chain, time); end

  def check_trust(chain, digester, trust_dir); end

  def initialize(name, policy=T.unsafe(nil), opt=T.unsafe(nil)); end

  def name(); end

  def only_signed(); end

  def only_signed=(only_signed); end

  def only_trusted(); end

  def only_trusted=(only_trusted); end

  def subject(certificate); end

  def verify(chain, key=T.unsafe(nil), digests=T.unsafe(nil), signatures=T.unsafe(nil), full_name=T.unsafe(nil)); end

  def verify_chain(); end

  def verify_chain=(verify_chain); end

  def verify_data(); end

  def verify_data=(verify_data); end

  def verify_root(); end

  def verify_root=(verify_root); end

  def verify_signatures(spec, digests, signatures); end

  def verify_signer(); end

  def verify_signer=(verify_signer); end
end

class Gem::Security::Policy
end

class Gem::Security::Signer
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def digest_algorithm(); end

  def digest_name(); end

  def extract_name(cert); end

  def initialize(key, cert_chain, passphrase=T.unsafe(nil), options=T.unsafe(nil)); end

  def key(); end

  def key=(key); end

  def load_cert_chain(); end

  def options(); end

  def re_sign_key(expiration_length: T.unsafe(nil)); end

  def sign(data); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Gem::Security::Signer
  def self.re_sign_cert(expired_cert, expired_cert_path, private_key); end
end

class Gem::Security::TrustDir
  def cert_path(certificate); end

  def dir(); end

  def each_certificate(); end

  def initialize(dir, permissions=T.unsafe(nil)); end

  def issuer_of(certificate); end

  def load_certificate(certificate_file); end

  def name_path(name); end

  def trust_cert(certificate); end

  def verify(); end
  DEFAULT_PERMISSIONS = ::T.let(nil, ::T.untyped)
end

class Gem::Security::TrustDir
end

module Gem::Security
  extend ::T::Sig
  def self.alt_name_or_x509_entry(certificate, x509_entry); end

  def self.create_cert(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_cert_email(email, key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.create_cert_self_signed(subject, key, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.create_key(length=T.unsafe(nil), algorithm=T.unsafe(nil)); end

  def self.email_to_name(email_address); end

  def self.re_sign(expired_certificate, private_key, age=T.unsafe(nil), extensions=T.unsafe(nil)); end

  def self.reset(); end

  def self.sign(certificate, signing_key, signing_cert, age=T.unsafe(nil), extensions=T.unsafe(nil), serial=T.unsafe(nil)); end

  def self.trust_dir(); end

  def self.trusted_certificates(&block); end

  def self.write(pemmable, path, permissions=T.unsafe(nil), passphrase=T.unsafe(nil), cipher=T.unsafe(nil)); end
end

class Gem::SilentUI
  def initialize(); end
end

class Gem::SilentUI
end

class Gem::Source
  include ::Comparable
  def ==(other); end

  def cache_dir(uri); end

  def dependency_resolver_set(); end

  def download(spec, dir=T.unsafe(nil)); end

  def eql?(other); end

  def fetch_spec(name_tuple); end

  def initialize(uri); end

  def load_specs(type); end

  def update_cache?(); end

  def uri(); end
  FILES = ::T.let(nil, ::T.untyped)
end

class Gem::Source::Git
  def base_dir(); end

  def cache(); end

  def checkout(); end

  def dir_shortref(); end

  def download(full_spec, path); end

  def initialize(name, repository, reference, submodules=T.unsafe(nil)); end

  def install_dir(); end

  def name(); end

  def need_submodules(); end

  def reference(); end

  def remote(); end

  def remote=(remote); end

  def repo_cache_dir(); end

  def repository(); end

  def rev_parse(); end

  def root_dir(); end

  def root_dir=(root_dir); end

  def specs(); end

  def uri_hash(); end
end

class Gem::Source::Git
end

class Gem::Source::Installed
  def download(spec, path); end

  def initialize(); end
end

class Gem::Source::Installed
end

class Gem::Source::Local
  def download(spec, cache_dir=T.unsafe(nil)); end

  def fetch_spec(name); end

  def find_gem(gem_name, version=T.unsafe(nil), prerelease=T.unsafe(nil)); end

  def initialize(); end
end

class Gem::Source::Local
end

class Gem::Source::Lock
  def initialize(source); end

  def wrapped(); end
end

class Gem::Source::Lock
end

class Gem::Source::SpecificFile
  def fetch_spec(name); end

  def initialize(file); end

  def load_specs(*a); end

  def path(); end

  def spec(); end
end

class Gem::Source::SpecificFile
end

class Gem::Source::Vendor
  def initialize(path); end
end

class Gem::Source::Vendor
end

class Gem::Source
end

class Gem::SourceFetchProblem
  def error(); end

  def exception(); end

  def initialize(source, error); end

  def source(); end

  def wordy(); end
end

class Gem::SourceFetchProblem
  extend ::T::Sig
end

class Gem::SourceList
  include ::Enumerable
  def <<(obj); end

  def ==(other); end

  def clear(); end

  def delete(source); end

  def each(); end

  def each_source(&b); end

  def empty?(); end

  def first(); end

  def include?(other); end

  def replace(other); end

  def sources(); end

  def to_a(); end

  def to_ary(); end
end

class Gem::SourceList
  def self.from(ary); end
end

class Gem::SpecFetcher
  include ::Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def available_specs(type); end

  def detect(type=T.unsafe(nil)); end

  def initialize(sources=T.unsafe(nil)); end

  def latest_specs(); end

  def prerelease_specs(); end

  def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def sources(); end

  def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

  def specs(); end

  def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

  def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
end

class Gem::SpecFetcher
  def self.fetcher(); end

  def self.fetcher=(fetcher); end
end

class Gem::SpecificGemNotFoundException
  def errors(); end

  def initialize(name, version, errors=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::SpecificGemNotFoundException
  extend ::T::Sig
end

class Gem::Specification
  include ::Bundler::MatchPlatform
  include ::Bundler::GemHelpers
  def ==(other); end

  def _deprecated_default_executable(); end

  def _deprecated_default_executable=(_deprecated_default_executable); end

  def _deprecated_has_rdoc(); end

  def _deprecated_has_rdoc=(ignored); end

  def _deprecated_has_rdoc?(*args, &block); end

  def _dump(limit); end

  def abbreviate(); end

  def activate(); end

  def activate_dependencies(); end

  def activated(); end

  def activated=(activated); end

  def add_bindir(executables); end

  def add_dependency(gem, *requirements); end

  def add_development_dependency(gem, *requirements); end

  def add_runtime_dependency(gem, *requirements); end

  def add_self_to_load_path(); end

  def author(); end

  def author=(o); end

  def authors(); end

  def authors=(value); end

  def autorequire(); end

  def autorequire=(autorequire); end

  def bin_dir(); end

  def bin_file(name); end

  def bindir(); end

  def bindir=(bindir); end

  def build_args(); end

  def build_extensions(); end

  def build_info_dir(); end

  def build_info_file(); end

  def cache_dir(); end

  def cache_file(); end

  def cert_chain(); end

  def cert_chain=(cert_chain); end

  def conficts_when_loaded_with?(list_of_specs); end

  def conflicts(); end

  def date(); end

  def date=(date); end

  def default_executable(*args, &block); end

  def default_executable=(*args, &block); end

  def default_value(name); end

  def dependencies(); end

  def dependent_gems(); end

  def dependent_specs(); end

  def description(); end

  def description=(str); end

  def development_dependencies(); end

  def doc_dir(type=T.unsafe(nil)); end

  def email(); end

  def email=(email); end

  def encode_with(coder); end

  def eql?(other); end

  def executable(); end

  def executable=(o); end

  def executables(); end

  def executables=(value); end

  def extensions(); end

  def extensions=(extensions); end

  def extra_rdoc_files(); end

  def extra_rdoc_files=(files); end

  def file_name(); end

  def files(); end

  def files=(files); end

  def for_cache(); end

  def git_version(); end

  def groups(); end

  def has_conflicts?(); end

  def has_rdoc(*args, &block); end

  def has_rdoc=(*args, &block); end

  def has_rdoc?(*args, &block); end

  def has_test_suite?(); end

  def has_unit_tests?(); end

  def homepage(); end

  def homepage=(homepage); end

  def init_with(coder); end

  def initialize(name=T.unsafe(nil), version=T.unsafe(nil)); end

  def installed_by_version(); end

  def installed_by_version=(version); end

  def keep_only_files_and_directories(); end

  def lib_files(); end

  def license(); end

  def license=(o); end

  def licenses(); end

  def licenses=(licenses); end

  def load_paths(); end

  def location(); end

  def location=(location); end

  def mark_version(); end

  def metadata(); end

  def metadata=(metadata); end

  def method_missing(sym, *a, &b); end

  def missing_extensions?(); end

  def name=(name); end

  def name_tuple(); end

  def nondevelopment_dependencies(); end

  def normalize(); end

  def original_name(); end

  def original_platform(); end

  def original_platform=(original_platform); end

  def platform=(platform); end

  def post_install_message(); end

  def post_install_message=(post_install_message); end

  def raise_if_conflicts(); end

  def rdoc_options(); end

  def rdoc_options=(options); end

  def relative_loaded_from(); end

  def relative_loaded_from=(relative_loaded_from); end

  def remote(); end

  def remote=(remote); end

  def require_path(); end

  def require_path=(path); end

  def require_paths=(val); end

  def required_ruby_version(); end

  def required_ruby_version=(req); end

  def required_rubygems_version(); end

  def required_rubygems_version=(req); end

  def requirements(); end

  def requirements=(req); end

  def reset_nil_attributes_to_default(); end

  def rg_extension_dir(); end

  def rg_full_gem_path(); end

  def rg_loaded_from(); end

  def ri_dir(); end

  def rubyforge_project=(rubyforge_project); end

  def rubygems_version(); end

  def rubygems_version=(rubygems_version); end

  def runtime_dependencies(); end

  def sanitize(); end

  def sanitize_string(string); end

  def satisfies_requirement?(dependency); end

  def signing_key(); end

  def signing_key=(signing_key); end

  def sort_obj(); end

  def source(); end

  def source=(source); end

  def spec_dir(); end

  def spec_file(); end

  def spec_name(); end

  def specification_version(); end

  def specification_version=(specification_version); end

  def summary(); end

  def summary=(str); end

  def test_file(); end

  def test_file=(file); end

  def test_files(); end

  def test_files=(files); end

  def to_gemfile(path=T.unsafe(nil)); end

  def to_ruby(); end

  def to_ruby_for_cache(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def traverse(trail=T.unsafe(nil), visited=T.unsafe(nil), &block); end

  def validate(packaging=T.unsafe(nil), strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end

  def version=(version); end

  def yaml_initialize(tag, vals); end
  DateLike = ::T.let(nil, ::T.untyped)
  DateTimeFormat = ::T.let(nil, ::T.untyped)
  INITIALIZE_CODE_FOR_DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Gem::Specification
  extend ::T::Sig
  extend ::Enumerable
  extend ::Gem::Deprecate
  def self._all(); end

  def self._clear_load_cache(); end

  def self._latest_specs(specs, prerelease=T.unsafe(nil)); end

  def self._load(str); end

  def self._resort!(specs); end

  def self.add_spec(spec); end

  def self.add_specs(*specs); end

  def self.all(); end

  def self.all=(specs); end

  def self.all_names(); end

  def self.array_attributes(); end

  def self.attribute_names(); end

  def self.dirs(); end

  def self.dirs=(dirs); end

  def self.each(); end

  def self.each_gemspec(dirs); end

  def self.each_spec(dirs); end

  def self.find_active_stub_by_path(path); end

  def self.find_all_by_full_name(full_name); end

  def self.find_all_by_name(name, *requirements); end

  def self.find_by_name(name, *requirements); end

  def self.find_by_path(path); end

  def self.find_in_unresolved(path); end

  def self.find_in_unresolved_tree(path); end

  def self.find_inactive_by_path(path); end

  def self.from_yaml(input); end

  def self.latest_specs(prerelease=T.unsafe(nil)); end

  def self.load(file); end

  def self.load_defaults(); end

  def self.non_nil_attributes(); end

  def self.normalize_yaml_input(input); end

  def self.outdated(); end

  def self.outdated_and_latest_version(); end

  def self.remove_spec(spec); end

  def self.required_attribute?(name); end

  def self.required_attributes(); end

  def self.reset(); end

  def self.stubs(); end

  def self.stubs_for(name); end

  def self.unresolved_deps(); end
end

class Gem::SpecificationPolicy
  def initialize(specification); end

  def packaging(); end

  def packaging=(packaging); end

  def validate(strict=T.unsafe(nil)); end

  def validate_dependencies(); end

  def validate_metadata(); end

  def validate_permissions(); end
  HOMEPAGE_URI_PATTERN = ::T.let(nil, ::T.untyped)
  LAZY = ::T.let(nil, ::T.untyped)
  LAZY_PATTERN = ::T.let(nil, ::T.untyped)
  METADATA_LINK_KEYS = ::T.let(nil, ::T.untyped)
  SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  VALID_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  VALID_URI_PATTERN = ::T.let(nil, ::T.untyped)
end

class Gem::SpecificationPolicy
end

class Gem::StreamUI
  def _deprecated_debug(statement); end

  def _gets_noecho(); end

  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(question); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def backtrace(exception); end

  def choose_from_list(question, list); end

  def close(); end

  def debug(*args, &block); end

  def download_reporter(*args); end

  def errs(); end

  def initialize(in_stream, out_stream, err_stream=T.unsafe(nil), usetty=T.unsafe(nil)); end

  def ins(); end

  def outs(); end

  def progress_reporter(*args); end

  def require_io_console(); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(status=T.unsafe(nil)); end

  def tty?(); end
end

class Gem::StreamUI
  extend ::Gem::Deprecate
end

class Gem::StubSpecification
  def build_extensions(); end

  def extensions(); end

  def initialize(filename, base_dir, gems_dir, default_gem); end

  def missing_extensions?(); end

  def valid?(); end
end

class Gem::StubSpecification::StubLine
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def extensions(); end

  def full_name(); end

  def initialize(data, extensions); end

  def name(); end

  def platform(); end

  def require_paths(); end

  def version(); end
end

class Gem::StubSpecification::StubLine
  extend ::T::Sig
end

class Gem::StubSpecification
  extend ::T::Sig
  def self.default_gemspec_stub(filename, base_dir, gems_dir); end

  def self.gemspec_stub(filename, base_dir, gems_dir); end
end

class Gem::SystemExitException
  def exit_code(); end

  def exit_code=(exit_code); end

  def initialize(exit_code); end
end

class Gem::SystemExitException
  extend ::T::Sig
end

module Gem::Text
  def clean_text(text); end

  def format_text(text, wrap, indent=T.unsafe(nil)); end

  def levenshtein_distance(str1, str2); end

  def min3(a, b, c); end

  def truncate_text(text, description, max_length=T.unsafe(nil)); end
end

module Gem::Text
  extend ::T::Sig
end

class Gem::UninstallError
  def spec(); end

  def spec=(spec); end
end

class Gem::UninstallError
end

Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

class Gem::UnsatisfiableDependencyError
  def dependency(); end

  def errors(); end

  def errors=(errors); end

  def initialize(dep, platform_mismatch=T.unsafe(nil)); end

  def name(); end

  def version(); end
end

class Gem::UnsatisfiableDependencyError
  extend ::T::Sig
end

class Gem::UriFormatter
  def escape(); end

  def initialize(uri); end

  def normalize(); end

  def unescape(); end

  def uri(); end
end

class Gem::UriFormatter
end

module Gem::UserInteraction
  include ::Gem::DefaultUserInteraction
  include ::Gem::Text
  def alert(statement, question=T.unsafe(nil)); end

  def alert_error(statement, question=T.unsafe(nil)); end

  def alert_warning(statement, question=T.unsafe(nil)); end

  def ask(question); end

  def ask_for_password(prompt); end

  def ask_yes_no(question, default=T.unsafe(nil)); end

  def choose_from_list(question, list); end

  def say(statement=T.unsafe(nil)); end

  def terminate_interaction(exit_code=T.unsafe(nil)); end

  def verbose(msg=T.unsafe(nil)); end
end

module Gem::UserInteraction
  extend ::T::Sig
end

module Gem::Util
end

module Gem::Util
  extend ::T::Sig
  def self.glob_files_in_dir(glob, base_path); end

  def self.gunzip(data); end

  def self.gzip(data); end

  def self.inflate(data); end

  def self.popen(*command); end

  def self.silent_system(*command); end

  def self.traverse_parents(directory, &block); end
end

class Gem::VerificationError
  extend ::T::Sig
end

class Gem::Version
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def _segments(); end

  def _split_segments(); end

  def _version(); end

  def approximate_recommendation(); end

  def bump(); end

  def canonical_segments(); end

  def encode_with(coder); end

  def eql?(other); end

  def init_with(coder); end

  def marshal_dump(); end

  def marshal_load(array); end

  def prerelease?(); end

  def release(); end

  def segments(); end

  def to_yaml_properties(); end

  def version(); end

  def yaml_initialize(tag, map); end
end

Gem::Version::Requirement = Gem::Requirement

class Gem::Version
  extend ::T::Sig
  def self.correct?(version); end

  def self.create(input); end

  def self.new(version); end
end

module Gem
  extend ::T::Sig
  def self._deprecated_detect_gemdeps(path=T.unsafe(nil)); end

  def self._deprecated_gunzip(data); end

  def self._deprecated_gzip(data); end

  def self._deprecated_inflate(data); end

  def self.activate_bin_path(name, *args); end

  def self.default_ext_dir_for(base_dir); end

  def self.default_gems_use_full_paths?(); end

  def self.default_spec_cache_dir(); end

  def self.deflate(data); end

  def self.detect_gemdeps(*args, &block); end

  def self.dir(); end

  def self.done_installing(&hook); end

  def self.done_installing_hooks(); end

  def self.ensure_default_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_gem_subdirectories(dir=T.unsafe(nil), mode=T.unsafe(nil)); end

  def self.ensure_subdirectories(dir, mode, subdirs); end

  def self.env_requirement(gem_name); end

  def self.extension_api_version(); end

  def self.find_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_files_from_load_path(glob); end

  def self.find_latest_files(glob, check_load_path=T.unsafe(nil)); end

  def self.find_unresolved_default_spec(path); end

  def self.finish_resolve(*_); end

  def self.gemdeps(); end

  def self.gunzip(*args, &block); end

  def self.gzip(*args, &block); end

  def self.host(); end

  def self.host=(host); end

  def self.inflate(*args, &block); end

  def self.install(name, version=T.unsafe(nil), *options); end

  def self.install_extension_in_lib(); end

  def self.latest_rubygems_version(); end

  def self.latest_spec_for(name); end

  def self.latest_version_for(name); end

  def self.load_env_plugins(); end

  def self.load_path_insert_index(); end

  def self.load_plugin_files(plugins); end

  def self.load_plugins(); end

  def self.load_yaml(); end

  def self.loaded_specs(); end

  def self.location_of_caller(depth=T.unsafe(nil)); end

  def self.marshal_version(); end

  def self.needs(); end

  def self.operating_system_defaults(); end

  def self.path(); end

  def self.path_separator(); end

  def self.paths(); end

  def self.paths=(env); end

  def self.platform_defaults(); end

  def self.platforms(); end

  def self.platforms=(platforms); end

  def self.post_build(&hook); end

  def self.post_build_hooks(); end

  def self.post_install(&hook); end

  def self.post_install_hooks(); end

  def self.post_reset(&hook); end

  def self.post_reset_hooks(); end

  def self.post_uninstall(&hook); end

  def self.post_uninstall_hooks(); end

  def self.pre_install(&hook); end

  def self.pre_install_hooks(); end

  def self.pre_reset(&hook); end

  def self.pre_reset_hooks(); end

  def self.pre_uninstall(&hook); end

  def self.pre_uninstall_hooks(); end

  def self.prefix(); end

  def self.read_binary(path); end

  def self.refresh(); end

  def self.register_default_spec(spec); end

  def self.remove_unresolved_default_spec(spec); end

  def self.ruby(); end

  def self.ruby_api_version(); end

  def self.ruby_engine(); end

  def self.ruby_version(); end

  def self.rubygems_version(); end

  def self.sources(); end

  def self.sources=(new_sources); end

  def self.spec_cache_dir(); end

  def self.suffix_pattern(); end

  def self.suffixes(); end

  def self.time(msg, width=T.unsafe(nil), display=T.unsafe(nil)); end

  def self.try_activate(path); end

  def self.ui(); end

  def self.use_gemdeps(path=T.unsafe(nil)); end

  def self.use_paths(home, *paths); end

  def self.user_dir(); end

  def self.user_home(); end

  def self.vendor_dir(); end

  def self.win_platform?(); end

  def self.write_binary(path, data); end
end

class GetIgnoredViolation
  def call(); end

  def initialize(body); end
  IGNORE_REGEXP = ::T.let(nil, ::T.untyped)
end

class GetIgnoredViolation
end

module Git
  def config(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def global_config(name=T.unsafe(nil), value=T.unsafe(nil)); end
end

class Git::Author
  def date(); end

  def date=(date); end

  def email(); end

  def email=(email); end

  def initialize(author_string); end

  def name(); end

  def name=(name); end
end

class Git::Author
end

class Git::Base
  include ::Git::Base::Factory
  def add(*args); end

  def add_remote(name, url, opts=T.unsafe(nil)); end

  def add_tag(name, *opts); end

  def apply(file); end

  def apply_mail(file); end

  def archive(treeish, file=T.unsafe(nil), opts=T.unsafe(nil)); end

  def cat_file(objectish); end

  def chdir(); end

  def checkout(branch=T.unsafe(nil), opts=T.unsafe(nil)); end

  def checkout_file(version, file); end

  def checkout_index(opts=T.unsafe(nil)); end

  def clean(opts=T.unsafe(nil)); end

  def commit(message, opts=T.unsafe(nil)); end

  def commit_all(message, opts=T.unsafe(nil)); end

  def config(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def current_branch(); end

  def delete_tag(name); end

  def describe(committish=T.unsafe(nil), opts=T.unsafe(nil)); end

  def dir(); end

  def each_conflict(&block); end

  def fetch(remote=T.unsafe(nil), opts=T.unsafe(nil)); end

  def gc(); end

  def grep(string, path_limiter=T.unsafe(nil), opts=T.unsafe(nil)); end

  def index(); end

  def initialize(options=T.unsafe(nil)); end

  def is_branch?(branch); end

  def is_local_branch?(branch); end

  def is_remote_branch?(branch); end

  def lib(); end

  def ls_files(location=T.unsafe(nil)); end

  def ls_tree(objectish); end

  def merge(branch, message=T.unsafe(nil)); end

  def merge_base(commit1, commit2, *other_commits); end

  def pull(remote=T.unsafe(nil), branch=T.unsafe(nil)); end

  def push(remote=T.unsafe(nil), branch=T.unsafe(nil), opts=T.unsafe(nil)); end

  def read_tree(treeish, opts=T.unsafe(nil)); end

  def remotes(); end

  def remove(path=T.unsafe(nil), opts=T.unsafe(nil)); end

  def remove_remote(name); end

  def repack(); end

  def repo(); end

  def repo_size(); end

  def reset(commitish=T.unsafe(nil), opts=T.unsafe(nil)); end

  def reset_hard(commitish=T.unsafe(nil), opts=T.unsafe(nil)); end

  def revert(commitish=T.unsafe(nil), opts=T.unsafe(nil)); end

  def revparse(objectish); end

  def set_index(index_file, check=T.unsafe(nil)); end

  def set_remote_url(name, url); end

  def set_working(work_dir, check=T.unsafe(nil)); end

  def show(objectish=T.unsafe(nil), path=T.unsafe(nil)); end

  def tags(); end

  def update_ref(branch, commit); end

  def with_index(new_index); end

  def with_temp_index(&blk); end

  def with_temp_working(&blk); end

  def with_working(work_dir); end

  def write_and_commit_tree(opts=T.unsafe(nil)); end

  def write_tree(); end
end

module Git::Base::Factory
  def branch(branch_name=T.unsafe(nil)); end

  def branches(); end

  def commit_tree(tree=T.unsafe(nil), opts=T.unsafe(nil)); end

  def diff(objectish=T.unsafe(nil), obj2=T.unsafe(nil)); end

  def gblob(objectish); end

  def gcommit(objectish); end

  def gtree(objectish); end

  def log(count=T.unsafe(nil)); end

  def object(objectish); end

  def remote(remote_name=T.unsafe(nil)); end

  def status(); end

  def tag(tag_name); end
end

module Git::Base::Factory
  extend ::T::Sig
end

class Git::Base
  def self.bare(git_dir, opts=T.unsafe(nil)); end

  def self.clone(repository, name, opts=T.unsafe(nil)); end

  def self.config(); end

  def self.init(working_dir, opts=T.unsafe(nil)); end

  def self.open(working_dir, opts=T.unsafe(nil)); end
end

class Git::Branch
  def archive(file, opts=T.unsafe(nil)); end

  def checkout(); end

  def contains?(commit); end

  def create(); end

  def current(); end

  def delete(); end

  def full(); end

  def full=(full); end

  def gcommit(); end

  def in_branch(message=T.unsafe(nil)); end

  def initialize(base, name); end

  def merge(branch=T.unsafe(nil), message=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def remote(); end

  def remote=(remote); end

  def stashes(); end

  def to_a(); end

  def update_ref(commit); end
end

class Git::Branch
end

class Git::Branches
  include ::Enumerable
  def [](branch_name); end

  def each(&block); end

  def initialize(base); end

  def local(); end

  def remote(); end

  def size(); end
end

class Git::Branches
end

class Git::Config
  def binary_path(); end

  def binary_path=(binary_path); end

  def git_ssh(); end

  def git_ssh=(git_ssh); end
end

class Git::Config
end

class Git::Diff
  include ::Enumerable
  def [](key); end

  def deletions(); end

  def each(&block); end

  def from(); end

  def initialize(base, from=T.unsafe(nil), to=T.unsafe(nil)); end

  def insertions(); end

  def lines(); end

  def name_status(); end

  def patch(file=T.unsafe(nil)); end

  def path(path); end

  def size(); end

  def stats(); end

  def to(); end

  def to_s(file=T.unsafe(nil)); end
end

class Git::Diff::DiffFile
  def binary?(); end

  def blob(type=T.unsafe(nil)); end

  def dst(); end

  def dst=(dst); end

  def initialize(base, hash); end

  def mode(); end

  def mode=(mode); end

  def patch(); end

  def patch=(patch); end

  def path(); end

  def path=(path); end

  def src(); end

  def src=(src); end

  def type(); end

  def type=(type); end
end

class Git::Diff::DiffFile
end

class Git::Diff
end

class Git::GitExecuteError
end

class Git::GitExecuteError
end

class Git::GitTagNameDoesNotExist
end

class Git::GitTagNameDoesNotExist
end

class Git::Index
end

class Git::Index
end

class Git::Lib
  def add(paths=T.unsafe(nil), options=T.unsafe(nil)); end

  def apply(patch_file); end

  def apply_mail(patch_file); end

  def archive(sha, file=T.unsafe(nil), opts=T.unsafe(nil)); end

  def branch_contains(commit, branch_name=T.unsafe(nil)); end

  def branch_current(); end

  def branch_delete(branch); end

  def branch_new(branch); end

  def branches_all(); end

  def change_head_branch(branch_name); end

  def checkout(branch, opts=T.unsafe(nil)); end

  def checkout_file(version, file); end

  def checkout_index(opts=T.unsafe(nil)); end

  def clean(opts=T.unsafe(nil)); end

  def clone(repository, name, opts=T.unsafe(nil)); end

  def commit(message, opts=T.unsafe(nil)); end

  def commit_data(sha); end

  def commit_tree(tree, opts=T.unsafe(nil)); end

  def config_get(name); end

  def config_list(); end

  def config_remote(name); end

  def config_set(name, value); end

  def conflicts(); end

  def current_command_version(); end

  def describe(committish=T.unsafe(nil), opts=T.unsafe(nil)); end

  def diff_files(); end

  def diff_full(obj1=T.unsafe(nil), obj2=T.unsafe(nil), opts=T.unsafe(nil)); end

  def diff_index(treeish); end

  def diff_name_status(reference1=T.unsafe(nil), reference2=T.unsafe(nil), opts=T.unsafe(nil)); end

  def diff_stats(obj1=T.unsafe(nil), obj2=T.unsafe(nil), opts=T.unsafe(nil)); end

  def fetch(remote, opts); end

  def full_log_commits(opts=T.unsafe(nil)); end

  def full_tree(sha); end

  def gc(); end

  def global_config_get(name); end

  def global_config_list(); end

  def global_config_set(name, value); end

  def grep(string, opts=T.unsafe(nil)); end

  def ignored_files(); end

  def init(opts=T.unsafe(nil)); end

  def initialize(base=T.unsafe(nil), logger=T.unsafe(nil)); end

  def list_files(ref_dir); end

  def log_commits(opts=T.unsafe(nil)); end

  def ls_files(location=T.unsafe(nil)); end

  def ls_remote(location=T.unsafe(nil)); end

  def ls_tree(sha); end

  def meets_required_version?(); end

  def merge(branch, message=T.unsafe(nil)); end

  def mv(file1, file2); end

  def namerev(string); end

  def object_contents(sha, &block); end

  def object_size(sha); end

  def object_type(sha); end

  def parse_config(file); end

  def parse_config_list(lines); end

  def process_commit_data(data, sha=T.unsafe(nil), indent=T.unsafe(nil)); end

  def process_commit_log_data(data); end

  def process_tag_data(data, name, indent=T.unsafe(nil)); end

  def pull(remote=T.unsafe(nil), branch=T.unsafe(nil)); end

  def push(remote, branch=T.unsafe(nil), opts=T.unsafe(nil)); end

  def read_tree(treeish, opts=T.unsafe(nil)); end

  def remote_add(name, url, opts=T.unsafe(nil)); end

  def remote_remove(name); end

  def remote_set_url(name, url); end

  def remotes(); end

  def remove(path=T.unsafe(nil), opts=T.unsafe(nil)); end

  def repack(); end

  def required_command_version(); end

  def reset(commit, opts=T.unsafe(nil)); end

  def revert(commitish, opts=T.unsafe(nil)); end

  def revparse(string); end

  def show(objectish=T.unsafe(nil), path=T.unsafe(nil)); end

  def stash_apply(id=T.unsafe(nil)); end

  def stash_clear(); end

  def stash_list(); end

  def stash_save(message); end

  def stashes_all(); end

  def tag(name, *opts); end

  def tag_data(name); end

  def tag_sha(tag_name); end

  def tags(); end

  def tree_depth(sha); end

  def unmerged(); end

  def update_ref(branch, commit); end

  def write_tree(); end
  ENV_VARIABLE_NAMES = ::T.let(nil, ::T.untyped)
end

class Git::Lib
end

class Git::Log
  include ::Enumerable
  def [](index); end

  def author(regex); end

  def between(sha1, sha2=T.unsafe(nil)); end

  def each(&block); end

  def first(); end

  def grep(regex); end

  def initialize(base, count=T.unsafe(nil)); end

  def last(); end

  def object(objectish); end

  def path(path); end

  def since(date); end

  def size(); end

  def skip(num); end

  def until(date); end
end

class Git::Log
end

class Git::Object
end

class Git::Object::AbstractObject
  def archive(file=T.unsafe(nil), opts=T.unsafe(nil)); end

  def blob?(); end

  def commit?(); end

  def contents(&block); end

  def contents_array(); end

  def diff(objectish); end

  def grep(string, path_limiter=T.unsafe(nil), opts=T.unsafe(nil)); end

  def initialize(base, objectish); end

  def log(count=T.unsafe(nil)); end

  def mode(); end

  def mode=(mode); end

  def objectish(); end

  def objectish=(objectish); end

  def sha(); end

  def size(); end

  def size=(size); end

  def tag?(); end

  def tree?(); end

  def type(); end

  def type=(type); end
end

class Git::Object::AbstractObject
end

class Git::Object::Blob
  def initialize(base, sha, mode=T.unsafe(nil)); end
end

class Git::Object::Blob
end

class Git::Object::Commit
  def author(); end

  def author_date(); end

  def committer(); end

  def committer_date(); end

  def date(); end

  def diff_parent(); end

  def gtree(); end

  def initialize(base, sha, init=T.unsafe(nil)); end

  def message(); end

  def name(); end

  def parent(); end

  def parents(); end

  def set_commit(data); end
end

class Git::Object::Commit
end

class Git::Object::Tag
  def annotated?(); end

  def initialize(base, sha, name); end

  def message(); end

  def name(); end

  def name=(name); end

  def tagger(); end
end

class Git::Object::Tag
end

class Git::Object::Tree
  def blobs(); end

  def children(); end

  def depth(); end

  def files(); end

  def full_tree(); end

  def initialize(base, sha, mode=T.unsafe(nil)); end

  def subdirectories(); end

  def subtrees(); end

  def trees(); end
end

class Git::Object::Tree
end

class Git::Object
  def self.new(base, objectish, type=T.unsafe(nil), is_tag=T.unsafe(nil)); end
end

class Git::Path
  def initialize(path, check_path=T.unsafe(nil)); end

  def path(); end

  def path=(path); end

  def readable?(); end

  def writable?(); end
end

class Git::Path
end

class Git::Remote
  def branch(branch=T.unsafe(nil)); end

  def fetch(opts=T.unsafe(nil)); end

  def fetch_opts(); end

  def fetch_opts=(fetch_opts); end

  def initialize(base, name); end

  def merge(branch=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def remove(); end

  def url(); end

  def url=(url); end
end

class Git::Remote
end

class Git::Repository
end

class Git::Repository
end

class Git::Stash
  def initialize(base, message, existing=T.unsafe(nil)); end

  def message(); end

  def save(); end

  def saved?(); end
end

class Git::Stash
end

class Git::Stashes
  include ::Enumerable
  def [](index); end

  def all(); end

  def apply(index=T.unsafe(nil)); end

  def clear(); end

  def each(&block); end

  def initialize(base); end

  def save(message); end

  def size(); end
end

class Git::Stashes
end

class Git::Status
  include ::Enumerable
  def [](file); end

  def added(); end

  def added?(file); end

  def changed(); end

  def changed?(file); end

  def deleted(); end

  def deleted?(file); end

  def each(&block); end

  def initialize(base); end

  def pretty(); end

  def pretty_file(file); end

  def untracked(); end

  def untracked?(file); end
end

class Git::Status::StatusFile
  def blob(type=T.unsafe(nil)); end

  def initialize(base, hash); end

  def mode_index(); end

  def mode_index=(mode_index); end

  def mode_repo(); end

  def mode_repo=(mode_repo); end

  def path(); end

  def path=(path); end

  def sha_index(); end

  def sha_index=(sha_index); end

  def sha_repo(); end

  def sha_repo=(sha_repo); end

  def stage(); end

  def stage=(stage); end

  def type(); end

  def type=(type); end

  def untracked(); end

  def untracked=(untracked); end
end

class Git::Status::StatusFile
end

class Git::Status
end

class Git::WorkingDirectory
end

class Git::WorkingDirectory
end

module Git
  extend ::T::Sig
  def self.bare(git_dir, options=T.unsafe(nil)); end

  def self.clone(repository, name, options=T.unsafe(nil)); end

  def self.config(); end

  def self.configure(); end

  def self.export(repository, name, options=T.unsafe(nil)); end

  def self.global_config(name=T.unsafe(nil), value=T.unsafe(nil)); end

  def self.init(working_dir=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.ls_remote(location=T.unsafe(nil)); end

  def self.open(working_dir, options=T.unsafe(nil)); end
end

class GlobalID
  def ==(other); end

  def app(*args, &block); end

  def find(options=T.unsafe(nil)); end

  def initialize(gid, options=T.unsafe(nil)); end

  def model_class(); end

  def model_id(*args, &block); end

  def model_name(*args, &block); end

  def params(*args, &block); end

  def to_s(*args, &block); end

  def uri(); end
end

module GlobalID::Identification
  def to_gid(options=T.unsafe(nil)); end

  def to_gid_param(options=T.unsafe(nil)); end

  def to_global_id(options=T.unsafe(nil)); end

  def to_sgid(options=T.unsafe(nil)); end

  def to_sgid_param(options=T.unsafe(nil)); end

  def to_signed_global_id(options=T.unsafe(nil)); end
end

module GlobalID::Identification
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module GlobalID::Locator
  DEFAULT_LOCATOR = ::T.let(nil, ::T.untyped)
end

class GlobalID::Locator::BaseLocator
  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BaseLocator
end

class GlobalID::Locator::BlockLocator
  def initialize(block); end

  def locate(gid); end

  def locate_many(gids, options=T.unsafe(nil)); end
end

class GlobalID::Locator::BlockLocator
end

class GlobalID::Locator::UnscopedLocator
end

class GlobalID::Locator::UnscopedLocator
end

module GlobalID::Locator
  extend ::T::Sig
  def self.locate(gid, options=T.unsafe(nil)); end

  def self.locate_many(gids, options=T.unsafe(nil)); end

  def self.locate_many_signed(sgids, options=T.unsafe(nil)); end

  def self.locate_signed(sgid, options=T.unsafe(nil)); end

  def self.use(app, locator=T.unsafe(nil), &locator_block); end
end

class GlobalID::Railtie
end

class GlobalID::Railtie
end

class GlobalID::Verifier
end

class GlobalID::Verifier
end

class GlobalID
  extend ::ActiveSupport::Autoload
  def self.app(); end

  def self.app=(app); end

  def self.create(model, options=T.unsafe(nil)); end

  def self.find(gid, options=T.unsafe(nil)); end

  def self.parse(gid, options=T.unsafe(nil)); end
end

module GraphQL
  BOOLEAN_TYPE = ::T.let(nil, ::T.untyped)
  FLOAT_TYPE = ::T.let(nil, ::T.untyped)
  ID_TYPE = ::T.let(nil, ::T.untyped)
  INT_TYPE = ::T.let(nil, ::T.untyped)
  STRING_TYPE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module GraphQL::Analysis
end

class GraphQL::Analysis::FieldUsage
  def call(memo, visit_type, irep_node); end

  def final_value(memo); end

  def initial_value(query); end

  def initialize(&block); end
end

class GraphQL::Analysis::FieldUsage
end

class GraphQL::Analysis::MaxQueryComplexity
  def initialize(max_complexity); end
end

class GraphQL::Analysis::MaxQueryComplexity
end

class GraphQL::Analysis::MaxQueryDepth
  def initialize(max_depth); end
end

class GraphQL::Analysis::MaxQueryDepth
end

class GraphQL::Analysis::QueryComplexity
  def call(memo, visit_type, irep_node); end

  def final_value(reduced_value); end

  def initial_value(target); end

  def initialize(&block); end
end

class GraphQL::Analysis::QueryComplexity::TypeComplexity
  def max_possible_complexity(); end

  def merge(type_defn, complexity); end
end

class GraphQL::Analysis::QueryComplexity::TypeComplexity
end

class GraphQL::Analysis::QueryComplexity
end

class GraphQL::Analysis::QueryDepth
  def call(memo, visit_type, irep_node); end

  def final_value(memo); end

  def initial_value(query); end

  def initialize(&block); end
end

class GraphQL::Analysis::QueryDepth
end

class GraphQL::Analysis::ReducerState
  def call(visit_type, irep_node); end

  def errors(); end

  def errors=(errors); end

  def finalize_reducer(); end

  def initialize(reducer, query); end

  def memo(); end

  def memo=(memo); end

  def reducer(); end
end

class GraphQL::Analysis::ReducerState
end

module GraphQL::Analysis
  extend ::T::Sig
  def self.analysis_errors(results); end

  def self.analyze_multiplex(multiplex, analyzers); end

  def self.analyze_query(query, analyzers, multiplex_states: T.unsafe(nil)); end

  def self.reduce_node(irep_node, reducer_states); end

  def self.visit_analyzers(visit_type, irep_node, reducer_states); end
end

class GraphQL::AnalysisError
end

class GraphQL::AnalysisError
end

class GraphQL::Argument
  include ::GraphQL::Define::InstanceDefinable
  def as(); end

  def as=(as); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def default_value(); end

  def default_value=(new_default_value); end

  def default_value?(); end

  def description(); end

  def description=(description); end

  def expose_as(); end

  def graphql_name(); end

  def name(); end

  def name=(name); end

  def prepare(value, ctx); end

  def prepare=(prepare_proc); end

  def type(); end

  def type=(new_input_type); end
  NO_DEFAULT_VALUE = ::T.let(nil, ::T.untyped)
end

module GraphQL::Argument::DefaultPrepare
end

module GraphQL::Argument::DefaultPrepare
  extend ::T::Sig
  def self.call(value, ctx); end
end

class GraphQL::Argument
  def self.deep_stringify(val); end

  def self.from_dsl(name, type_or_argument=T.unsafe(nil), description=T.unsafe(nil), default_value: T.unsafe(nil), as: T.unsafe(nil), prepare: T.unsafe(nil), **kwargs, &block); end
end

module GraphQL::Authorization
end

module GraphQL::Authorization::Analyzer
end

module GraphQL::Authorization::Analyzer
  extend ::T::Sig
  def self.call(memo, visit_type, irep_node); end

  def self.final_value(memo); end

  def self.initial_value(query); end
end

class GraphQL::Authorization::InaccessibleFieldsError
  def context(); end

  def fields(); end

  def initialize(fields:, irep_nodes:, context:); end

  def irep_nodes(); end
end

class GraphQL::Authorization::InaccessibleFieldsError
end

module GraphQL::Authorization
  extend ::T::Sig
end

class GraphQL::Backtrace
  include ::Enumerable
  def [](*args, &block); end

  def each(*args, &block); end

  def initialize(context, value: T.unsafe(nil)); end

  def to_a(); end
end

module GraphQL::Backtrace::InspectResult
end

module GraphQL::Backtrace::InspectResult
  extend ::T::Sig
  def self.inspect_result(obj); end

  def self.inspect_truncated(obj); end
end

class GraphQL::Backtrace::Table
  def initialize(context, value:); end

  def to_backtrace(); end

  def to_table(); end
  HEADERS = ::T.let(nil, ::T.untyped)
  MAX_COL_WIDTH = ::T.let(nil, ::T.untyped)
  MIN_COL_WIDTH = ::T.let(nil, ::T.untyped)
end

class GraphQL::Backtrace::Table
end

class GraphQL::Backtrace::TracedError
  def context(); end

  def graphql_backtrace(); end

  def initialize(err, current_ctx); end
  CAUSE_BACKTRACE_PREVIEW_LENGTH = ::T.let(nil, ::T.untyped)
  MESSAGE_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Backtrace::TracedError
end

module GraphQL::Backtrace::Tracer
end

module GraphQL::Backtrace::Tracer
  extend ::T::Sig
  def self.trace(key, metadata); end
end

class GraphQL::Backtrace
  extend ::Forwardable
  def self.disable(); end

  def self.enable(); end

  def self.use(schema_defn); end
end

module GraphQL::BackwardsCompatibility
end

class GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
  def call(*args); end

  def initialize(callable, old_arity); end
end

class GraphQL::BackwardsCompatibility::FirstArgumentsWrapper
end

class GraphQL::BackwardsCompatibility::LastArgumentsWrapper
end

class GraphQL::BackwardsCompatibility::LastArgumentsWrapper
end

module GraphQL::BackwardsCompatibility
  extend ::T::Sig
  def self.get_arity(callable); end

  def self.wrap_arity(callable, from:, to:, name:, last: T.unsafe(nil)); end
end

class GraphQL::BaseType
  include ::GraphQL::Define::NonNullWithBang
  include ::GraphQL::Define::InstanceDefinable
  include ::GraphQL::Relay::TypeExtensions
  def ==(other); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def coerce_input(value, ctx=T.unsafe(nil)); end

  def coerce_isolated_input(value); end

  def coerce_isolated_result(value); end

  def coerce_result(value, ctx); end

  def default_relay=(default_relay); end

  def default_relay?(); end

  def default_scalar=(default_scalar); end

  def default_scalar?(); end

  def description(); end

  def description=(description); end

  def get_field(name); end

  def graphql_definition(); end

  def graphql_name(); end

  def introspection=(introspection); end

  def introspection?(); end

  def list?(); end

  def name(); end

  def name=(name); end

  def non_null?(); end

  def resolve_type(value, ctx); end

  def to_definition(schema, printer: T.unsafe(nil), **args); end

  def to_list_type(); end

  def to_non_null_type(); end

  def to_type_signature(); end

  def unwrap(); end

  def valid_input?(value, ctx=T.unsafe(nil)); end

  def valid_isolated_input?(value); end

  def validate_input(value, ctx=T.unsafe(nil)); end

  def validate_isolated_input(value); end
end

module GraphQL::BaseType::ModifiesAnotherType
  def ==(other); end

  def unwrap(); end
end

module GraphQL::BaseType::ModifiesAnotherType
  extend ::T::Sig
end

class GraphQL::BaseType
  def self.resolve_related_type(type_arg); end
end

class GraphQL::Client
  def allow_dynamic_queries(); end

  def allow_dynamic_queries=(allow_dynamic_queries); end

  def create_operation(fragment, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def document(); end

  def document_tracking_enabled(); end

  def document_tracking_enabled=(document_tracking_enabled); end

  def enforce_collocated_callers(); end

  def execute(); end

  def initialize(schema:, execute: T.unsafe(nil), enforce_collocated_callers: T.unsafe(nil)); end

  def parse(str, filename=T.unsafe(nil), lineno=T.unsafe(nil)); end

  def query(definition, variables: T.unsafe(nil), context: T.unsafe(nil)); end

  def schema(); end

  def types(); end
  IntrospectionDocument = ::T.let(nil, ::T.untyped)
  WHITELISTED_GEM_NAMES = ::T.let(nil, ::T.untyped)
end

module GraphQL::Client::CollocatedEnforcement
  def allow_noncollocated_callers(); end

  def enforce_collocated_callers(mod, methods, path); end
end

module GraphQL::Client::CollocatedEnforcement
  extend ::T::Sig
end

class GraphQL::Client::Definition
  def client(); end

  def definition_name(); end

  def definition_node(); end

  def document(); end

  def indexes(); end

  def initialize(client:, document:, source_document:, irep_node:, source_location:); end

  def new(obj, errors=T.unsafe(nil)); end

  def schema_class(); end

  def source_document(); end

  def source_location(); end
end

class GraphQL::Client::Definition
  def self.for(irep_node:, **kargs); end
end

module GraphQL::Client::DefinitionVariables
end

module GraphQL::Client::DefinitionVariables
  extend ::T::Sig
  def self.operation_variables(schema, document, definition_name=T.unsafe(nil)); end

  def self.variable_node(type); end

  def self.variables(schema, document, definition_name=T.unsafe(nil)); end
end

module GraphQL::Client::DocumentTypes
end

module GraphQL::Client::DocumentTypes
  extend ::T::Sig
  def self.analyze_types(schema, document); end
end

class GraphQL::Client::DynamicQueryError
end

class GraphQL::Client::DynamicQueryError
end

class GraphQL::Client::Error
end

class GraphQL::Client::Error
end

class GraphQL::Client::Errors
  include ::Enumerable
  def [](key); end

  def all(); end

  def count(); end

  def details(); end

  def each(); end

  def empty?(); end

  def filter_by_path(field); end

  def has_key?(field); end

  def include?(field); end

  def initialize(errors=T.unsafe(nil), path=T.unsafe(nil), all=T.unsafe(nil)); end

  def key?(field); end

  def keys(); end

  def messages(); end

  def size(); end

  def values(); end
end

class GraphQL::Client::Errors
  def self.normalize_error_paths(data=T.unsafe(nil), errors=T.unsafe(nil)); end
end

class GraphQL::Client::FragmentDefinition
  def new(obj, *args); end
end

class GraphQL::Client::FragmentDefinition
end

class GraphQL::Client::HTTP
  def connection(); end

  def execute(document:, operation_name: T.unsafe(nil), variables: T.unsafe(nil), context: T.unsafe(nil)); end

  def headers(_context); end

  def initialize(uri, &block); end

  def uri(); end
end

class GraphQL::Client::HTTP
end

class GraphQL::Client::HashWithIndifferentAccess
  include ::Enumerable
  def [](key); end

  def each(*args, &block); end

  def each_key(&block); end

  def empty?(*args, &block); end

  def fetch(key, *args, &block); end

  def has_key?(key); end

  def include?(key); end

  def initialize(hash=T.unsafe(nil)); end

  def inspect(*args, &block); end

  def key?(key); end

  def keys(*args, &block); end

  def length(*args, &block); end

  def member?(key); end

  def size(*args, &block); end

  def to_h(*args, &block); end

  def to_hash(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Client::HashWithIndifferentAccess
  extend ::Forwardable
end

class GraphQL::Client::ImplicitlyFetchedFieldError
end

class GraphQL::Client::ImplicitlyFetchedFieldError
end

class GraphQL::Client::InvariantError
end

class GraphQL::Client::InvariantError
end

module GraphQL::Client::LazyName
  def name(); end
end

module GraphQL::Client::LazyName
  extend ::T::Sig
end

class GraphQL::Client::List
  def errors(); end

  def initialize(values, errors=T.unsafe(nil)); end
end

class GraphQL::Client::List
end

class GraphQL::Client::NonCollocatedCallerError
end

class GraphQL::Client::NonCollocatedCallerError
end

class GraphQL::Client::NotImplementedError
end

class GraphQL::Client::NotImplementedError
end

class GraphQL::Client::OperationDefinition
  def operation_name(); end
end

class GraphQL::Client::OperationDefinition
end

module GraphQL::Client::QueryTypename
end

module GraphQL::Client::QueryTypename
  extend ::T::Sig
  def self.insert_typename_fields(document, types: T.unsafe(nil)); end

  def self.node_flatten_selections(selections); end
end

class GraphQL::Client::RenameNodeHook
  def initialize(definitions); end

  def rename_node(node, _parent); end
end

class GraphQL::Client::RenameNodeHook
end

class GraphQL::Client::Response
  def data(); end

  def errors(); end

  def extensions(); end

  def initialize(hash, data: T.unsafe(nil), errors: T.unsafe(nil), extensions: T.unsafe(nil)); end

  def original_hash(); end

  def to_h(); end
end

class GraphQL::Client::Response
end

module GraphQL::Client::Schema
end

module GraphQL::Client::Schema::BaseType
  def cast(value, errors); end

  def schema_module(); end

  def schema_module=(schema_module); end

  def to_list_type(); end

  def to_non_null_type(); end

  def type(); end
end

module GraphQL::Client::Schema::BaseType
  extend ::T::Sig
end

module GraphQL::Client::Schema::ClassMethods
  def define_class(definition, irep_node, type); end

  def get_class(type_name); end

  def set_class(type_name, klass); end
end

module GraphQL::Client::Schema::ClassMethods
  extend ::T::Sig
end

class GraphQL::Client::Schema::EnumType
  include ::GraphQL::Client::Schema::BaseType
  def [](value); end

  def cast(value, _errors=T.unsafe(nil)); end

  def define_class(definition, irep_node); end

  def initialize(type); end
end

class GraphQL::Client::Schema::EnumType
end

class GraphQL::Client::Schema::IncludeDirective
  include ::GraphQL::Client::Schema::BaseType
  def initialize(of_klass); end

  def of_klass(); end
end

class GraphQL::Client::Schema::IncludeDirective
end

class GraphQL::Client::Schema::InterfaceType
  include ::GraphQL::Client::Schema::BaseType
  def define_class(definition, irep_node); end

  def initialize(type); end

  def new(types); end
end

class GraphQL::Client::Schema::InterfaceType
end

class GraphQL::Client::Schema::ListType
  include ::GraphQL::Client::Schema::BaseType
  def cast(values, errors); end

  def initialize(of_klass); end

  def of_klass(); end
end

class GraphQL::Client::Schema::ListType
end

class GraphQL::Client::Schema::NonNullType
  include ::GraphQL::Client::Schema::BaseType
  def initialize(of_klass); end

  def of_klass(); end
end

class GraphQL::Client::Schema::NonNullType
end

class GraphQL::Client::Schema::ObjectClass
  def errors(); end

  def initialize(data=T.unsafe(nil), errors=T.unsafe(nil)); end

  def method_missing(*args); end

  def to_h(); end
end

class GraphQL::Client::Schema::ObjectClass
end

module GraphQL::Client::Schema::ObjectType
  def cast(value, errors); end

  def define_class(definition, irep_node); end

  def define_field(name, type); end

  def define_fields(fields); end
end

module GraphQL::Client::Schema::ObjectType
  extend ::T::Sig
  def self.new(type, fields=T.unsafe(nil)); end
end

class GraphQL::Client::Schema::PossibleTypes
  include ::GraphQL::Client::Schema::BaseType
  def initialize(type, types); end

  def possible_types(); end
end

class GraphQL::Client::Schema::PossibleTypes
end

class GraphQL::Client::Schema::ScalarType
  include ::GraphQL::Client::Schema::BaseType
  def cast(value, _errors=T.unsafe(nil)); end

  def define_class(definition, irep_node); end

  def initialize(type); end
end

class GraphQL::Client::Schema::ScalarType
end

class GraphQL::Client::Schema::SkipDirective
  include ::GraphQL::Client::Schema::BaseType
  def initialize(of_klass); end

  def of_klass(); end
end

class GraphQL::Client::Schema::SkipDirective
end

class GraphQL::Client::Schema::UnionType
  include ::GraphQL::Client::Schema::BaseType
  def define_class(definition, irep_node); end

  def initialize(type); end

  def new(types); end
end

class GraphQL::Client::Schema::UnionType
end

module GraphQL::Client::Schema
  extend ::T::Sig
  def self.class_for(schema, type, cache); end

  def self.generate(schema); end
end

class GraphQL::Client::UnfetchedFieldError
end

class GraphQL::Client::UnfetchedFieldError
end

class GraphQL::Client::UnimplementedFieldError
end

class GraphQL::Client::UnimplementedFieldError
end

class GraphQL::Client::ValidationError
end

class GraphQL::Client::ValidationError
end

class GraphQL::Client
  extend ::GraphQL::Client::CollocatedEnforcement
  def self.dump_schema(schema, io=T.unsafe(nil)); end

  def self.load_schema(schema); end
end

class GraphQL::CoercionError
end

class GraphQL::CoercionError
end

module GraphQL::Compatibility
end

module GraphQL::Compatibility::ExecutionSpecification
end

module GraphQL::Compatibility::ExecutionSpecification::CounterSchema
end

module GraphQL::Compatibility::ExecutionSpecification::CounterSchema
  extend ::T::Sig
  def self.build(execution_strategy); end
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema
  BOGUS_NODE = ::T.let(nil, ::T.untyped)
  DATA = ::T.let(nil, ::T.untyped)
end

class GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::CustomCollection
  def each(); end

  def initialize(storage); end
end

class GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::CustomCollection
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::TestMiddleware
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema::TestMiddleware
  extend ::T::Sig
  def self.call(parent_type, parent_object, field_definition, field_args, query_context, &next_middleware); end
end

module GraphQL::Compatibility::ExecutionSpecification::SpecificationSchema
  extend ::T::Sig
  def self.build(execution_strategy); end
end

module GraphQL::Compatibility::ExecutionSpecification
  extend ::T::Sig
  def self.build_suite(execution_strategy); end
end

module GraphQL::Compatibility::LazyExecutionSpecification
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyInstrumentation
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyInstrumentation
  extend ::T::Sig
  def self.instrument(type, field); end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPush
  def initialize(ctx, value); end

  def push(); end

  def value(); end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPush
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPushCollection
  def initialize(ctx, values); end

  def push(); end

  def value(); end
end

class GraphQL::Compatibility::LazyExecutionSpecification::LazySchema::LazyPushCollection
end

module GraphQL::Compatibility::LazyExecutionSpecification::LazySchema
  extend ::T::Sig
  def self.build(execution_strategy); end
end

module GraphQL::Compatibility::LazyExecutionSpecification
  extend ::T::Sig
  def self.build_suite(execution_strategy); end
end

module GraphQL::Compatibility::QueryParserSpecification
  QUERY_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Compatibility::QueryParserSpecification::ParseErrorSpecification
  def assert_empty_document(query_string); end

  def assert_raises_parse_error(query_string); end

  def assert_rejects_character(char); end

  def test_it_includes_line_and_column(); end

  def test_it_parses_blank_queries(); end

  def test_it_rejects_bad_unicode(); end

  def test_it_rejects_empty_inline_fragments(); end

  def test_it_rejects_invalid_characters(); end

  def test_it_rejects_unexpected_ends(); end

  def test_it_rejects_unterminated_strings(); end

  def test_it_restricts_on(); end
end

module GraphQL::Compatibility::QueryParserSpecification::ParseErrorSpecification
  extend ::T::Sig
end

module GraphQL::Compatibility::QueryParserSpecification::QueryAssertions
  def assert_valid_directive(directive); end

  def assert_valid_field(field); end

  def assert_valid_fragment(fragment_def); end

  def assert_valid_fragment_spread(fragment_spread); end

  def assert_valid_literal_argument(argument); end

  def assert_valid_query(query); end

  def assert_valid_typed_inline_fragment(inline_fragment); end

  def assert_valid_typeless_inline_fragment(inline_fragment); end

  def assert_valid_variable(variable); end

  def assert_valid_variable_argument(argument); end
end

module GraphQL::Compatibility::QueryParserSpecification::QueryAssertions
  extend ::T::Sig
end

module GraphQL::Compatibility::QueryParserSpecification
  extend ::T::Sig
  def self.build_suite(&block); end
end

module GraphQL::Compatibility::SchemaParserSpecification
  SCHEMA_DEFINITION_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Compatibility::SchemaParserSpecification
  extend ::T::Sig
  def self.build_suite(&block); end
end

module GraphQL::Compatibility
  extend ::T::Sig
end

module GraphQL::Define
end

module GraphQL::Define::AssignArgument
end

module GraphQL::Define::AssignArgument
  extend ::T::Sig
  def self.call(target, *args, **kwargs, &block); end
end

module GraphQL::Define::AssignConnection
end

module GraphQL::Define::AssignConnection
  extend ::T::Sig
  def self.call(type_defn, *field_args, max_page_size: T.unsafe(nil), **field_kwargs, &field_block); end
end

module GraphQL::Define::AssignEnumValue
end

module GraphQL::Define::AssignEnumValue
  extend ::T::Sig
  def self.call(enum_type, name, desc=T.unsafe(nil), deprecation_reason: T.unsafe(nil), value: T.unsafe(nil), &block); end
end

module GraphQL::Define::AssignGlobalIdField
end

module GraphQL::Define::AssignGlobalIdField
  extend ::T::Sig
  def self.call(type_defn, field_name); end
end

module GraphQL::Define::AssignMutationFunction
end

class GraphQL::Define::AssignMutationFunction::ResultProxy
  def client_mutation_id(); end

  def initialize(target, client_mutation_id); end
end

class GraphQL::Define::AssignMutationFunction::ResultProxy
end

module GraphQL::Define::AssignMutationFunction
  extend ::T::Sig
  def self.call(target, function); end
end

module GraphQL::Define::AssignObjectField
end

module GraphQL::Define::AssignObjectField
  extend ::T::Sig
  def self.call(owner_type, name, type_or_field=T.unsafe(nil), desc=T.unsafe(nil), function: T.unsafe(nil), field: T.unsafe(nil), relay_mutation_function: T.unsafe(nil), **kwargs, &block); end
end

class GraphQL::Define::DefinedObjectProxy
  def initialize(target); end

  def method_missing(name, *args, &block); end

  def target(); end

  def types(); end

  def use(plugin, **kwargs); end
end

class GraphQL::Define::DefinedObjectProxy
end

module GraphQL::Define::InstanceDefinable
  def define(**kwargs, &block); end

  def metadata(); end

  def redefine(**kwargs, &block); end
end

module GraphQL::Define::InstanceDefinable
  extend ::T::Sig
  def self.included(base); end
end

class GraphQL::Define::NoDefinitionError
end

class GraphQL::Define::NoDefinitionError
end

module GraphQL::Define::NonNullWithBang
  def !(); end
end

module GraphQL::Define::NonNullWithBang
  extend ::T::Sig
end

class GraphQL::Define::TypeDefiner
  include ::Singleton
  def Boolean(); end

  def Float(); end

  def ID(); end

  def Int(); end

  def String(); end

  def [](type); end
end

class GraphQL::Define::TypeDefiner
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module GraphQL::Define
  extend ::T::Sig
  def self.assign_metadata_key(key); end
end

module GraphQL::DeprecatedDSL
  TYPE_CLASSES = ::T.let(nil, ::T.untyped)
end

module GraphQL::DeprecatedDSL::Methods
  def !(); end
end

module GraphQL::DeprecatedDSL::Methods
  extend ::T::Sig
end

module GraphQL::DeprecatedDSL
  extend ::T::Sig
  def self.activate(); end
end

class GraphQL::Directive
  include ::GraphQL::Define::InstanceDefinable
  def arguments(); end

  def arguments=(arguments); end

  def arguments_class(); end

  def arguments_class=(arguments_class); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def default_directive=(default_directive); end

  def default_directive?(); end

  def description(); end

  def description=(description); end

  def locations(); end

  def locations=(locations); end

  def name(); end

  def name=(name); end

  def on_field?(); end

  def on_fragment?(); end

  def on_operation?(); end
  ARGUMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  DEFAULT_DEPRECATION_REASON = ::T.let(nil, ::T.untyped)
  DeprecatedDirective = ::T.let(nil, ::T.untyped)
  ENUM = ::T.let(nil, ::T.untyped)
  ENUM_VALUE = ::T.let(nil, ::T.untyped)
  FIELD = ::T.let(nil, ::T.untyped)
  FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_DEFINITION = ::T.let(nil, ::T.untyped)
  FRAGMENT_SPREAD = ::T.let(nil, ::T.untyped)
  INLINE_FRAGMENT = ::T.let(nil, ::T.untyped)
  INPUT_FIELD_DEFINITION = ::T.let(nil, ::T.untyped)
  INPUT_OBJECT = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  IncludeDirective = ::T.let(nil, ::T.untyped)
  LOCATIONS = ::T.let(nil, ::T.untyped)
  LOCATION_DESCRIPTIONS = ::T.let(nil, ::T.untyped)
  MUTATION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  QUERY = ::T.let(nil, ::T.untyped)
  SCALAR = ::T.let(nil, ::T.untyped)
  SCHEMA = ::T.let(nil, ::T.untyped)
  SUBSCRIPTION = ::T.let(nil, ::T.untyped)
  SkipDirective = ::T.let(nil, ::T.untyped)
  UNION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Directive
end

class GraphQL::DoubleNonNullTypeError
end

class GraphQL::DoubleNonNullTypeError
end

class GraphQL::EnumType
  def add_value(enum_value); end

  def coerce_result(value, ctx=T.unsafe(nil)); end

  def kind(); end

  def values(); end

  def values=(new_values); end
end

class GraphQL::EnumType::EnumValue
  include ::GraphQL::Define::InstanceDefinable
  def ast_node(); end

  def ast_node=(ast_node); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(); end

  def description=(description); end

  def graphql_name(); end

  def name(); end

  def name=(new_name); end

  def value(); end

  def value=(value); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class GraphQL::EnumType::EnumValue
end

class GraphQL::EnumType::UnresolvedValueError
end

class GraphQL::EnumType::UnresolvedValueError
end

class GraphQL::EnumType
end

class GraphQL::Error
end

class GraphQL::Error
end

module GraphQL::Execution
end

module GraphQL::Execution::DirectiveChecks
  INCLUDE = ::T.let(nil, ::T.untyped)
  SKIP = ::T.let(nil, ::T.untyped)
end

module GraphQL::Execution::DirectiveChecks
  extend ::T::Sig
  def self.include?(directive_ast_nodes, query); end
end

class GraphQL::Execution::Execute
  include ::GraphQL::Execution::Execute::ExecutionFunctions
  def execute(ast_operation, root_type, query); end
  PROPAGATE_NULL = ::T.let(nil, ::T.untyped)
  SKIP = ::T.let(nil, ::T.untyped)
end

module GraphQL::Execution::Execute::ExecutionFunctions
end

module GraphQL::Execution::Execute::ExecutionFunctions
  extend ::T::Sig
  def self.continue_or_wait(raw_value, field_type, field_ctx); end

  def self.continue_resolve_field(raw_value, field_type, field_ctx); end

  def self.lazy_resolve_root_selection(result, query: T.unsafe(nil), multiplex: T.unsafe(nil)); end

  def self.resolve_field(object, field_ctx); end

  def self.resolve_root_selection(query); end

  def self.resolve_selection(object, current_type, current_ctx, mutation: T.unsafe(nil)); end

  def self.resolve_value(value, field_type, field_ctx); end
end

module GraphQL::Execution::Execute::FieldResolveStep
end

module GraphQL::Execution::Execute::FieldResolveStep
  extend ::T::Sig
  def self.call(_parent_type, parent_object, field_definition, field_args, context, _next=T.unsafe(nil)); end
end

class GraphQL::Execution::Execute::PropagateNull
end

class GraphQL::Execution::Execute::PropagateNull
end

class GraphQL::Execution::Execute::Skip
end

class GraphQL::Execution::Execute::Skip
end

class GraphQL::Execution::Execute
end

module GraphQL::Execution::Flatten
end

module GraphQL::Execution::Flatten
  extend ::T::Sig
  def self.call(ctx); end
end

module GraphQL::Execution::Instrumentation
end

module GraphQL::Execution::Instrumentation
  extend ::T::Sig
  def self.apply_instrumenters(multiplex); end
end

class GraphQL::Execution::Lazy
  def initialize(&get_value_func); end

  def then(); end

  def value(); end
  NullResult = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Lazy::LazyMethodMap
  def get(value); end

  def initialize(use_concurrent: T.unsafe(nil)); end

  def set(lazy_class, lazy_value_method); end

  def storage(); end
end

class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  def []=(key, value); end

  def compute_if_absent(key); end

  def copy_storage(); end

  def each_pair(*args, &block); end

  def size(*args, &block); end
end

class GraphQL::Execution::Lazy::LazyMethodMap::ConcurrentishMap
  extend ::Forwardable
end

class GraphQL::Execution::Lazy::LazyMethodMap
end

module GraphQL::Execution::Lazy::Resolve
end

module GraphQL::Execution::Lazy::Resolve::NullAccumulator
end

module GraphQL::Execution::Lazy::Resolve::NullAccumulator
  extend ::T::Sig
  def self.<<(item); end

  def self.empty?(); end
end

module GraphQL::Execution::Lazy::Resolve
  extend ::T::Sig
  def self.deep_sync(val); end

  def self.each_lazy(acc, value); end

  def self.resolve(value); end

  def self.resolve_in_place(value); end
end

class GraphQL::Execution::Lazy
  def self.all(lazies); end

  def self.resolve(val); end
end

class GraphQL::Execution::Lookahead
  def initialize(query:, ast_nodes:, field: T.unsafe(nil), root_type: T.unsafe(nil)); end

  def selected?(); end

  def selection(field_name, arguments: T.unsafe(nil)); end

  def selects?(field_name, arguments: T.unsafe(nil)); end
  NULL_LOOKAHEAD = ::T.let(nil, ::T.untyped)
end

module GraphQL::Execution::Lookahead::ArgumentHelpers
end

module GraphQL::Execution::Lookahead::ArgumentHelpers
  extend ::T::Sig
  def self.arg_to_value(query, graphql_object, arg_type, ast_value); end

  def self.arguments(query, graphql_object, arg_owner, ast_node); end

  def self.flatten_ast_value(query, v); end
end

module GraphQL::Execution::Lookahead::FieldHelpers
end

module GraphQL::Execution::Lookahead::FieldHelpers
  extend ::T::Sig
  def self.get_field(schema, owner_type, field_name); end
end

class GraphQL::Execution::Lookahead::NullLookahead
  def initialize(); end

  def selection(*_); end

  def selects?(*_); end
end

class GraphQL::Execution::Lookahead::NullLookahead
end

class GraphQL::Execution::Lookahead
end

class GraphQL::Execution::Multiplex
  include ::GraphQL::Tracing::Traceable
  def context(); end

  def initialize(schema:, queries:, context:); end

  def queries(); end

  def schema(); end
  NO_OPERATION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Execution::Multiplex
  def self.run_all(schema, query_options, *args); end

  def self.run_queries(schema, queries, context: T.unsafe(nil), max_complexity: T.unsafe(nil)); end
end

module GraphQL::Execution::Typecast
end

module GraphQL::Execution::Typecast
  extend ::T::Sig
  def self.subtype?(parent_type, child_type); end
end

module GraphQL::Execution
  extend ::T::Sig
end

class GraphQL::ExecutionError
  def ast_node(); end

  def ast_node=(ast_node); end

  def extensions(); end

  def extensions=(extensions); end

  def initialize(message, ast_node: T.unsafe(nil), options: T.unsafe(nil), extensions: T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def path(); end

  def path=(path); end

  def to_h(); end
end

class GraphQL::ExecutionError
end

class GraphQL::Field
  include ::GraphQL::Define::InstanceDefinable
  def arguments(); end

  def arguments=(arguments); end

  def arguments_class(); end

  def arguments_class=(arguments_class); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def complexity(); end

  def complexity=(complexity); end

  def connection=(connection); end

  def connection?(); end

  def connection_max_page_size(); end

  def connection_max_page_size=(connection_max_page_size); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(); end

  def description=(description); end

  def edge_class(); end

  def edge_class=(edge_class); end

  def edges?(); end

  def function(); end

  def function=(function); end

  def graphql_name(); end

  def hash_key(); end

  def hash_key=(new_hash_key); end

  def introspection=(introspection); end

  def introspection?(); end

  def lazy_resolve(obj, args, ctx); end

  def lazy_resolve=(new_lazy_resolve_proc); end

  def lazy_resolve_proc(); end

  def mutation(); end

  def mutation=(mutation); end

  def name(); end

  def name=(new_name); end

  def prepare_lazy(obj, args, ctx); end

  def property(); end

  def property=(new_property); end

  def relay_node_field(); end

  def relay_node_field=(relay_node_field); end

  def relay_nodes_field(); end

  def relay_nodes_field=(relay_nodes_field); end

  def resolve(object, arguments, context); end

  def resolve=(new_resolve_proc); end

  def resolve_proc(); end

  def subscription_scope(); end

  def subscription_scope=(subscription_scope); end

  def trace(); end

  def trace=(trace); end

  def type(); end

  def type=(new_return_type); end
end

module GraphQL::Field::DefaultLazyResolve
end

module GraphQL::Field::DefaultLazyResolve
  extend ::T::Sig
  def self.call(obj, args, ctx); end
end

module GraphQL::Field::Resolve
end

class GraphQL::Field::Resolve::BuiltInResolve
end

class GraphQL::Field::Resolve::BuiltInResolve
end

class GraphQL::Field::Resolve::HashKeyResolve
  def call(obj, args, ctx); end

  def initialize(hash_key); end
end

class GraphQL::Field::Resolve::HashKeyResolve
end

class GraphQL::Field::Resolve::MethodResolve
  def call(obj, args, ctx); end

  def initialize(field); end
end

class GraphQL::Field::Resolve::MethodResolve
end

class GraphQL::Field::Resolve::NameResolve
  def call(obj, args, ctx); end

  def initialize(field); end
end

class GraphQL::Field::Resolve::NameResolve
end

module GraphQL::Field::Resolve
  extend ::T::Sig
  def self.create_proc(field); end
end

class GraphQL::Field
end

class GraphQL::Filter
  def call(member, ctx); end

  def initialize(only: T.unsafe(nil), except: T.unsafe(nil)); end

  def merge(only: T.unsafe(nil), except: T.unsafe(nil)); end
end

class GraphQL::Filter::MergedExcept
end

class GraphQL::Filter::MergedExcept
end

class GraphQL::Filter::MergedOnly
  def call(member, ctx); end

  def initialize(first, second); end
end

class GraphQL::Filter::MergedOnly
  def self.build(onlies); end
end

class GraphQL::Filter
end

class GraphQL::Function
  def arguments(); end

  def call(obj, args, ctx); end

  def complexity(); end

  def deprecation_reason(); end

  def description(); end

  def type(); end
end

class GraphQL::Function
  def self.argument(*args, **kwargs, &block); end

  def self.arguments(); end

  def self.build_field(function); end

  def self.complexity(new_value=T.unsafe(nil)); end

  def self.deprecation_reason(new_value=T.unsafe(nil)); end

  def self.description(new_value=T.unsafe(nil)); end

  def self.type(premade_type=T.unsafe(nil), &block); end

  def self.types(); end
end

class GraphQL::InputObjectType
  def arguments(); end

  def arguments=(arguments); end

  def arguments_class(); end

  def arguments_class=(arguments_class); end

  def coerce_result(value, ctx=T.unsafe(nil)); end

  def input_fields(); end

  def kind(); end

  def mutation(); end

  def mutation=(mutation); end
  INVALID_OBJECT_MESSAGE = ::T.let(nil, ::T.untyped)
end

class GraphQL::InputObjectType
end

class GraphQL::InterfaceType
  def all_fields(); end

  def fields(); end

  def fields=(fields); end

  def get_field(field_name); end

  def get_possible_type(type_name, ctx); end

  def kind(); end

  def orphan_types(); end

  def orphan_types=(orphan_types); end

  def possible_type?(type, ctx); end

  def resolve_type=(resolve_type_callable); end

  def resolve_type_proc(); end

  def resolve_type_proc=(resolve_type_proc); end
end

class GraphQL::InterfaceType
end

module GraphQL::InternalRepresentation
end

class GraphQL::InternalRepresentation::Document
  def [](key); end

  def each(&block); end

  def fragment_definitions(); end

  def operation_definitions(); end
end

class GraphQL::InternalRepresentation::Document
end

class GraphQL::InternalRepresentation::Node
  def ==(other); end

  def arguments(); end

  def ast_node(); end

  def ast_nodes(); end

  def deep_merge_node(new_parent, scope: T.unsafe(nil), merge_self: T.unsafe(nil)); end

  def definition(); end

  def definition_name(); end

  def definitions(); end

  def initialize(name:, owner_type:, query:, return_type:, parent:, ast_nodes: T.unsafe(nil), definitions: T.unsafe(nil)); end

  def name(); end

  def owner_type(); end

  def owner_type=(owner_type); end

  def parent(); end

  def parent=(parent); end

  def query(); end

  def return_type(); end

  def scoped_children(); end

  def subscription_topic(); end

  def typed_children(); end
  DEFAULT_TYPED_CHILDREN = ::T.let(nil, ::T.untyped)
  NO_TYPED_CHILDREN = ::T.let(nil, ::T.untyped)
end

class GraphQL::InternalRepresentation::Node
end

module GraphQL::InternalRepresentation::Print
end

module GraphQL::InternalRepresentation::Print
  extend ::T::Sig
  def self.print(schema, query_string); end

  def self.print_node(node, indent: T.unsafe(nil)); end
end

class GraphQL::InternalRepresentation::Rewrite
  include ::GraphQL::Language
  def document(); end

  def operations(); end

  def skip?(ast_node, query); end

  def validate(context); end
  NO_DIRECTIVES = ::T.let(nil, ::T.untyped)
end

class GraphQL::InternalRepresentation::Rewrite::VisitDefinition
  def enter(ast_node, ast_parent); end

  def initialize(context, definitions, nodes_stack, scopes_stack); end

  def leave(ast_node, ast_parent); end
end

class GraphQL::InternalRepresentation::Rewrite::VisitDefinition
end

class GraphQL::InternalRepresentation::Rewrite
end

class GraphQL::InternalRepresentation::Scope
  def each(); end

  def enter(other_type_defn); end

  def initialize(query, type_defn); end
  NO_TYPES = ::T.let(nil, ::T.untyped)
end

class GraphQL::InternalRepresentation::Scope
end

module GraphQL::InternalRepresentation::Visit
end

module GraphQL::InternalRepresentation::Visit
  extend ::T::Sig
  def self.each_node(node); end

  def self.visit_each_node(operations, handlers); end
end

module GraphQL::InternalRepresentation
  extend ::T::Sig
end

module GraphQL::Introspection
  INTROSPECTION_QUERY = ::T.let(nil, ::T.untyped)
end

class GraphQL::Introspection::BaseObject
end

class GraphQL::Introspection::BaseObject
end

class GraphQL::Introspection::DirectiveLocationEnum
end

class GraphQL::Introspection::DirectiveLocationEnum
end

class GraphQL::Introspection::DirectiveType
  def args(); end
end

class GraphQL::Introspection::DirectiveType
end

class GraphQL::Introspection::DynamicFields
  def __typename(irep_node:); end
end

class GraphQL::Introspection::DynamicFields
end

class GraphQL::Introspection::EntryPoints
  def __schema(); end

  def __type(name:); end
end

class GraphQL::Introspection::EntryPoints
end

class GraphQL::Introspection::EnumValueType
  def is_deprecated(); end
end

class GraphQL::Introspection::EnumValueType
end

class GraphQL::Introspection::FieldType
  def args(); end

  def is_deprecated(); end
end

class GraphQL::Introspection::FieldType
end

class GraphQL::Introspection::InputValueType
  def default_value(); end
end

class GraphQL::Introspection::InputValueType
end

class GraphQL::Introspection::SchemaType
  def directives(); end

  def mutation_type(); end

  def query_type(); end

  def subscription_type(); end

  def types(); end
end

class GraphQL::Introspection::SchemaType
end

class GraphQL::Introspection::TypeKindEnum
end

class GraphQL::Introspection::TypeKindEnum
end

class GraphQL::Introspection::TypeType
  def enum_values(include_deprecated:); end

  def fields(include_deprecated:); end

  def input_fields(); end

  def interfaces(); end

  def kind(); end

  def of_type(); end

  def possible_types(); end
end

class GraphQL::Introspection::TypeType
end

module GraphQL::Introspection
  extend ::T::Sig
end

class GraphQL::InvalidNameError
  def initialize(name, valid_regex); end

  def name(); end

  def valid_regex(); end
end

class GraphQL::InvalidNameError
end

class GraphQL::InvalidNullError
  def field(); end

  def initialize(parent_type, field, value); end

  def parent_error?(); end

  def parent_type(); end

  def to_h(); end

  def value(); end
end

class GraphQL::InvalidNullError
end

module GraphQL::Language
end

module GraphQL::Language::BlockString
end

module GraphQL::Language::BlockString
  extend ::T::Sig
  def self.trim_whitespace(str); end
end

module GraphQL::Language::Comments
  def commentize(description, indent: T.unsafe(nil)); end
end

module GraphQL::Language::Comments
  extend ::GraphQL::Language::Comments
  extend ::T::Sig
end

module GraphQL::Language::DefinitionSlice
  def slice(document, name); end
end

module GraphQL::Language::DefinitionSlice
  extend ::GraphQL::Language::DefinitionSlice
  extend ::T::Sig
end

class GraphQL::Language::DocumentFromSchemaDefinition
  def build_argument_node(argument); end

  def build_argument_nodes(arguments); end

  def build_default_value(default_value, type); end

  def build_definition_nodes(); end

  def build_directive_location_node(location); end

  def build_directive_location_nodes(locations); end

  def build_directive_node(directive); end

  def build_directive_nodes(directives); end

  def build_enum_type_node(enum_type); end

  def build_enum_value_node(enum_value); end

  def build_field_node(field); end

  def build_field_nodes(fields); end

  def build_input_object_node(input_object); end

  def build_interface_type_node(interface_type); end

  def build_object_type_node(object_type); end

  def build_scalar_type_node(scalar_type); end

  def build_schema_node(); end

  def build_type_definition_node(type); end

  def build_type_definition_nodes(types); end

  def build_type_name_node(type); end

  def build_union_type_node(union_type); end

  def document(); end

  def initialize(schema, context: T.unsafe(nil), only: T.unsafe(nil), except: T.unsafe(nil), include_introspection_types: T.unsafe(nil), include_built_in_directives: T.unsafe(nil), include_built_in_scalars: T.unsafe(nil), always_include_schema: T.unsafe(nil)); end
end

class GraphQL::Language::DocumentFromSchemaDefinition
end

module GraphQL::Language::Generation
  def generate(node, indent: T.unsafe(nil), printer: T.unsafe(nil)); end
end

module GraphQL::Language::Generation
  extend ::GraphQL::Language::Generation
  extend ::T::Sig
end

module GraphQL::Language::Lexer
  ESCAPES = ::T.let(nil, ::T.untyped)
  ESCAPES_REPLACE = ::T.let(nil, ::T.untyped)
  PACK_DIRECTIVE = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
  UTF_8_ENCODING = ::T.let(nil, ::T.untyped)
  UTF_8_REPLACE = ::T.let(nil, ::T.untyped)
  VALID_STRING = ::T.let(nil, ::T.untyped)
end

module GraphQL::Language::Lexer
  extend ::T::Sig
  def self.emit(token_name, ts, te, meta); end

  def self.emit_string(ts, te, meta, block:); end

  def self.graphql_lexer_en_main(); end

  def self.graphql_lexer_en_main=(graphql_lexer_en_main); end

  def self.graphql_lexer_error(); end

  def self.graphql_lexer_error=(graphql_lexer_error); end

  def self.graphql_lexer_first_final(); end

  def self.graphql_lexer_first_final=(graphql_lexer_first_final); end

  def self.graphql_lexer_start(); end

  def self.graphql_lexer_start=(graphql_lexer_start); end

  def self.record_comment(ts, te, meta); end

  def self.replace_escaped_characters_in_place(raw_string); end

  def self.run_lexer(query_string); end

  def self.tokenize(query_string); end
end

module GraphQL::Language::Nodes
end

class GraphQL::Language::Nodes::AbstractNode
  def children(); end

  def col(); end

  def col=(col); end

  def deep_freeze(); end

  def eql?(other); end

  def filename(); end

  def filename=(filename); end

  def initialize(options=T.unsafe(nil)); end

  def initialize_node(options=T.unsafe(nil)); end

  def line(); end

  def line=(line); end

  def position(); end

  def scalars(); end

  def to_query_string(printer: T.unsafe(nil)); end
end

module GraphQL::Language::Nodes::AbstractNode::Scalars
end

module GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def scalars(); end
end

module GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  extend ::T::Sig
end

module GraphQL::Language::Nodes::AbstractNode::Scalars
  extend ::T::Sig
end

class GraphQL::Language::Nodes::AbstractNode
end

class GraphQL::Language::Nodes::Argument
  def initialize_node(name: T.unsafe(nil), value: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def value(); end

  def value=(value); end
end

class GraphQL::Language::Nodes::Argument
end

class GraphQL::Language::Nodes::Directive
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def arguments(); end

  def arguments=(arguments); end

  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::Directive
end

class GraphQL::Language::Nodes::DirectiveDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def arguments(); end

  def arguments=(arguments); end

  def description(); end

  def description=(description); end

  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil), locations: T.unsafe(nil), description: T.unsafe(nil)); end

  def locations(); end

  def locations=(locations); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::DirectiveDefinition
end

class GraphQL::Language::Nodes::DirectiveLocation
end

class GraphQL::Language::Nodes::DirectiveLocation
end

class GraphQL::Language::Nodes::Document
  def definitions(); end

  def definitions=(definitions); end

  def initialize_node(definitions: T.unsafe(nil)); end

  def slice_definition(name); end
end

class GraphQL::Language::Nodes::Document
end

class GraphQL::Language::Nodes::Enum
end

class GraphQL::Language::Nodes::Enum
end

class GraphQL::Language::Nodes::EnumTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def description(); end

  def description=(description); end

  def directives(); end

  def directives=(directives); end

  def initialize_node(name:, values:, directives: T.unsafe(nil), description: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def values(); end

  def values=(values); end
end

class GraphQL::Language::Nodes::EnumTypeDefinition
end

class GraphQL::Language::Nodes::EnumTypeExtension
  def directives(); end

  def directives=(directives); end

  def initialize_node(name:, values:, directives: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def values(); end

  def values=(values); end
end

class GraphQL::Language::Nodes::EnumTypeExtension
end

class GraphQL::Language::Nodes::EnumValueDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def description(); end

  def description=(description); end

  def directives(); end

  def directives=(directives); end

  def initialize_node(name:, directives: T.unsafe(nil), description: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::EnumValueDefinition
end

class GraphQL::Language::Nodes::Field
  def alias(); end

  def alias=(_); end

  def arguments(); end

  def arguments=(arguments); end

  def directives(); end

  def directives=(directives); end

  def initialize_node(name: T.unsafe(nil), arguments: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil), **kwargs); end

  def name(); end

  def name=(name); end

  def selections(); end

  def selections=(selections); end
end

class GraphQL::Language::Nodes::Field
end

class GraphQL::Language::Nodes::FieldDefinition
  def arguments(); end

  def arguments=(arguments); end

  def description(); end

  def description=(description); end

  def directives(); end

  def directives=(directives); end

  def initialize_node(name:, arguments:, type:, directives: T.unsafe(nil), description: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def type(); end

  def type=(type); end
end

class GraphQL::Language::Nodes::FieldDefinition
end

class GraphQL::Language::Nodes::FragmentDefinition
  def directives(); end

  def directives=(directives); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def selections(); end

  def selections=(selections); end

  def type(); end

  def type=(type); end
end

class GraphQL::Language::Nodes::FragmentDefinition
end

class GraphQL::Language::Nodes::FragmentSpread
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def directives(); end

  def directives=(directives); end

  def initialize_node(name: T.unsafe(nil), directives: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::FragmentSpread
end

class GraphQL::Language::Nodes::InlineFragment
  def directives(); end

  def directives=(directives); end

  def initialize_node(type: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil)); end

  def selections(); end

  def selections=(selections); end

  def type(); end

  def type=(type); end
end

class GraphQL::Language::Nodes::InlineFragment
end

class GraphQL::Language::Nodes::InputObject
  def arguments(); end

  def arguments=(arguments); end

  def initialize_node(arguments: T.unsafe(nil)); end

  def to_h(options=T.unsafe(nil)); end
end

class GraphQL::Language::Nodes::InputObject
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def description(); end

  def description=(description); end

  def directives(); end

  def directives=(directives); end

  def fields(); end

  def fields=(fields); end

  def initialize_node(name:, fields:, directives: T.unsafe(nil), description: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::InputObjectTypeDefinition
end

class GraphQL::Language::Nodes::InputObjectTypeExtension
  def directives(); end

  def directives=(directives); end

  def fields(); end

  def fields=(fields); end

  def initialize_node(name:, fields:, directives: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::InputObjectTypeExtension
end

class GraphQL::Language::Nodes::InputValueDefinition
  def default_value(); end

  def default_value=(default_value); end

  def description(); end

  def description=(description); end

  def directives(); end

  def directives=(directives); end

  def initialize_node(name:, type:, default_value: T.unsafe(nil), directives: T.unsafe(nil), description: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def type(); end

  def type=(type); end
end

class GraphQL::Language::Nodes::InputValueDefinition
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def description(); end

  def description=(description); end

  def directives(); end

  def directives=(directives); end

  def fields(); end

  def fields=(fields); end

  def initialize_node(name:, fields:, directives: T.unsafe(nil), description: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::InterfaceTypeDefinition
end

class GraphQL::Language::Nodes::InterfaceTypeExtension
  def directives(); end

  def directives=(directives); end

  def fields(); end

  def fields=(fields); end

  def initialize_node(name:, fields:, directives: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::InterfaceTypeExtension
end

class GraphQL::Language::Nodes::ListType
end

class GraphQL::Language::Nodes::ListType
end

class GraphQL::Language::Nodes::NameOnlyNode
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def initialize_node(name: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::NameOnlyNode
end

class GraphQL::Language::Nodes::NonNullType
end

class GraphQL::Language::Nodes::NonNullType
end

class GraphQL::Language::Nodes::NullValue
end

class GraphQL::Language::Nodes::NullValue
end

class GraphQL::Language::Nodes::ObjectTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def description(); end

  def description=(description); end

  def directives(); end

  def directives=(directives); end

  def fields(); end

  def fields=(fields); end

  def initialize_node(name:, interfaces:, fields:, directives: T.unsafe(nil), description: T.unsafe(nil)); end

  def interfaces(); end

  def interfaces=(interfaces); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::ObjectTypeDefinition
end

class GraphQL::Language::Nodes::ObjectTypeExtension
  def directives(); end

  def directives=(directives); end

  def fields(); end

  def fields=(fields); end

  def initialize_node(name:, interfaces:, fields:, directives: T.unsafe(nil)); end

  def interfaces(); end

  def interfaces=(interfaces); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::ObjectTypeExtension
end

class GraphQL::Language::Nodes::OperationDefinition
  def directives(); end

  def directives=(directives); end

  def initialize_node(operation_type: T.unsafe(nil), name: T.unsafe(nil), variables: T.unsafe(nil), directives: T.unsafe(nil), selections: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def operation_type(); end

  def operation_type=(operation_type); end

  def selections(); end

  def selections=(selections); end

  def variables(); end

  def variables=(variables); end
end

class GraphQL::Language::Nodes::OperationDefinition
end

class GraphQL::Language::Nodes::ScalarTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def description(); end

  def description=(description); end

  def directives(); end

  def directives=(directives); end

  def initialize_node(name:, directives: T.unsafe(nil), description: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::ScalarTypeDefinition
end

class GraphQL::Language::Nodes::ScalarTypeExtension
  def directives(); end

  def directives=(directives); end

  def initialize_node(name:, directives: T.unsafe(nil)); end

  def name(); end

  def name=(name); end
end

class GraphQL::Language::Nodes::ScalarTypeExtension
end

class GraphQL::Language::Nodes::SchemaDefinition
  def directives(); end

  def directives=(directives); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def mutation(); end

  def mutation=(mutation); end

  def query(); end

  def query=(query); end

  def subscription(); end

  def subscription=(subscription); end
end

class GraphQL::Language::Nodes::SchemaDefinition
end

class GraphQL::Language::Nodes::SchemaExtension
  def directives(); end

  def directives=(directives); end

  def initialize_node(query: T.unsafe(nil), mutation: T.unsafe(nil), subscription: T.unsafe(nil), directives: T.unsafe(nil)); end

  def mutation(); end

  def mutation=(mutation); end

  def query(); end

  def query=(query); end

  def subscription(); end

  def subscription=(subscription); end
end

class GraphQL::Language::Nodes::SchemaExtension
end

class GraphQL::Language::Nodes::TypeName
end

class GraphQL::Language::Nodes::TypeName
end

class GraphQL::Language::Nodes::UnionTypeDefinition
  include ::GraphQL::Language::Nodes::AbstractNode::Scalars::Name
  def description(); end

  def description=(description); end

  def directives(); end

  def directives=(directives); end

  def initialize_node(name:, types:, directives: T.unsafe(nil), description: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def types(); end

  def types=(types); end
end

class GraphQL::Language::Nodes::UnionTypeDefinition
end

class GraphQL::Language::Nodes::UnionTypeExtension
  def directives(); end

  def directives=(directives); end

  def initialize_node(name:, types:, directives: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def types(); end

  def types=(types); end
end

class GraphQL::Language::Nodes::UnionTypeExtension
end

class GraphQL::Language::Nodes::VariableDefinition
  def default_value(); end

  def default_value=(default_value); end

  def initialize_node(name: T.unsafe(nil), type: T.unsafe(nil), default_value: T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def type(); end

  def type=(type); end
end

class GraphQL::Language::Nodes::VariableDefinition
end

class GraphQL::Language::Nodes::VariableIdentifier
end

class GraphQL::Language::Nodes::VariableIdentifier
end

class GraphQL::Language::Nodes::WrapperType
  def initialize_node(of_type: T.unsafe(nil)); end

  def of_type(); end

  def of_type=(of_type); end
end

class GraphQL::Language::Nodes::WrapperType
end

module GraphQL::Language::Nodes
  extend ::T::Sig
end

class GraphQL::Language::Parser
  def _reduce_10(val, _values, result); end

  def _reduce_101(val, _values, result); end

  def _reduce_102(val, _values, result); end

  def _reduce_103(val, _values, result); end

  def _reduce_104(val, _values, result); end

  def _reduce_105(val, _values, result); end

  def _reduce_106(val, _values, result); end

  def _reduce_107(val, _values, result); end

  def _reduce_108(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_113(val, _values, result); end

  def _reduce_115(val, _values, result); end

  def _reduce_116(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_125(val, _values, result); end

  def _reduce_126(val, _values, result); end

  def _reduce_133(val, _values, result); end

  def _reduce_134(val, _values, result); end

  def _reduce_135(val, _values, result); end

  def _reduce_136(val, _values, result); end

  def _reduce_137(val, _values, result); end

  def _reduce_138(val, _values, result); end

  def _reduce_139(val, _values, result); end

  def _reduce_140(val, _values, result); end

  def _reduce_141(val, _values, result); end

  def _reduce_142(val, _values, result); end

  def _reduce_143(val, _values, result); end

  def _reduce_144(val, _values, result); end

  def _reduce_145(val, _values, result); end

  def _reduce_149(val, _values, result); end

  def _reduce_150(val, _values, result); end

  def _reduce_151(val, _values, result); end

  def _reduce_153(val, _values, result); end

  def _reduce_154(val, _values, result); end

  def _reduce_155(val, _values, result); end

  def _reduce_156(val, _values, result); end

  def _reduce_157(val, _values, result); end

  def _reduce_158(val, _values, result); end

  def _reduce_159(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_160(val, _values, result); end

  def _reduce_161(val, _values, result); end

  def _reduce_162(val, _values, result); end

  def _reduce_163(val, _values, result); end

  def _reduce_164(val, _values, result); end

  def _reduce_165(val, _values, result); end

  def _reduce_166(val, _values, result); end

  def _reduce_167(val, _values, result); end

  def _reduce_168(val, _values, result); end

  def _reduce_169(val, _values, result); end

  def _reduce_170(val, _values, result); end

  def _reduce_171(val, _values, result); end

  def _reduce_172(val, _values, result); end

  def _reduce_173(val, _values, result); end

  def _reduce_174(val, _values, result); end

  def _reduce_175(val, _values, result); end

  def _reduce_176(val, _values, result); end

  def _reduce_177(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_19(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_24(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_62(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_71(val, _values, result); end

  def _reduce_72(val, _values, result); end

  def _reduce_73(val, _values, result); end

  def _reduce_82(val, _values, result); end

  def _reduce_83(val, _values, result); end

  def _reduce_84(val, _values, result); end

  def _reduce_85(val, _values, result); end

  def _reduce_86(val, _values, result); end

  def _reduce_87(val, _values, result); end

  def _reduce_88(val, _values, result); end

  def _reduce_89(val, _values, result); end

  def _reduce_90(val, _values, result); end

  def _reduce_91(val, _values, result); end

  def _reduce_92(val, _values, result); end

  def _reduce_93(val, _values, result); end

  def _reduce_94(val, _values, result); end

  def _reduce_95(val, _values, result); end

  def _reduce_96(val, _values, result); end

  def _reduce_97(val, _values, result); end

  def _reduce_98(val, _values, result); end

  def _reduce_99(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(query_string, filename:, tracer: T.unsafe(nil)); end

  def parse_document(); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Parser
  def self.parse(query_string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end
end

class GraphQL::Language::Printer
  def print(node, indent: T.unsafe(nil)); end

  def print_argument(argument); end

  def print_arguments(arguments, indent: T.unsafe(nil)); end

  def print_description(node, indent: T.unsafe(nil), first_in_block: T.unsafe(nil)); end

  def print_directive(directive); end

  def print_directive_definition(directive); end

  def print_directives(directives); end

  def print_document(document); end

  def print_enum(enum); end

  def print_enum_type_definition(enum_type); end

  def print_enum_value_definition(enum_value); end

  def print_field(field, indent: T.unsafe(nil)); end

  def print_field_definition(field); end

  def print_field_definitions(fields); end

  def print_fragment_definition(fragment_def, indent: T.unsafe(nil)); end

  def print_fragment_spread(fragment_spread, indent: T.unsafe(nil)); end

  def print_inline_fragment(inline_fragment, indent: T.unsafe(nil)); end

  def print_input_object(input_object); end

  def print_input_object_type_definition(input_object_type); end

  def print_input_value_definition(input_value); end

  def print_interface_type_definition(interface_type); end

  def print_list_type(list_type); end

  def print_node(node, indent: T.unsafe(nil)); end

  def print_non_null_type(non_null_type); end

  def print_null_value(); end

  def print_object_type_definition(object_type); end

  def print_operation_definition(operation_definition, indent: T.unsafe(nil)); end

  def print_scalar_type_definition(scalar_type); end

  def print_schema_definition(schema); end

  def print_selections(selections, indent: T.unsafe(nil)); end

  def print_type_name(type_name); end

  def print_union_type_definition(union_type); end

  def print_variable_definition(variable_definition); end

  def print_variable_identifier(variable_identifier); end
end

class GraphQL::Language::Printer
end

class GraphQL::Language::Token
  def col(); end

  def initialize(value:, name:, line:, col:, prev_token:); end

  def line(); end

  def line_and_column(); end

  def name(); end

  def prev_token(); end

  def to_f(); end

  def to_i(); end

  def value(); end
end

class GraphQL::Language::Token
end

class GraphQL::Language::Visitor
  def [](node_class); end

  def initialize(document); end

  def visit(); end
  SKIP = ::T.let(nil, ::T.untyped)
end

class GraphQL::Language::Visitor::NodeVisitor
  def <<(hook); end

  def enter(); end

  def leave(); end
end

class GraphQL::Language::Visitor::NodeVisitor
end

class GraphQL::Language::Visitor
  def self.apply_hooks(hooks, node, parent); end
end

module GraphQL::Language
  extend ::T::Sig
  def self.serialize(value); end
end

class GraphQL::ListType
  include ::GraphQL::BaseType::ModifiesAnotherType
  def coerce_result(value, ctx=T.unsafe(nil)); end

  def initialize(of_type:); end

  def kind(); end

  def of_type(); end
end

class GraphQL::ListType
end

class GraphQL::NameValidator
  VALID_NAME_REGEX = ::T.let(nil, ::T.untyped)
end

class GraphQL::NameValidator
  def self.valid?(name); end

  def self.validate!(name); end
end

class GraphQL::NonNullType
  include ::GraphQL::BaseType::ModifiesAnotherType
  def coerce_input(*args, &block); end

  def coerce_result(*args, &block); end

  def initialize(of_type:); end

  def kind(); end

  def list?(*args, &block); end

  def of_type(); end

  def valid_input?(value, ctx); end

  def validate_input(value, ctx); end
end

class GraphQL::NonNullType
  extend ::Forwardable
end

class GraphQL::ObjectType
  def all_fields(); end

  def dirty_inherited_interfaces(); end

  def dirty_interfaces(); end

  def fields(); end

  def fields=(fields); end

  def get_field(field_name); end

  def implements(interfaces, inherit: T.unsafe(nil)); end

  def interfaces(); end

  def interfaces=(new_interfaces); end

  def kind(); end

  def mutation(); end

  def mutation=(mutation); end

  def relay_node_type(); end

  def relay_node_type=(relay_node_type); end

  def resolve_type_proc(); end
end

class GraphQL::ObjectType
end

class GraphQL::ParseError
  def col(); end

  def initialize(message, line, col, query, filename: T.unsafe(nil)); end

  def line(); end

  def query(); end

  def to_h(); end
end

class GraphQL::ParseError
end

class GraphQL::Query
  include ::GraphQL::Tracing::Traceable
  def analysis_errors(); end

  def analysis_errors=(analysis_errors); end

  def analyzers(*args, &block); end

  def arguments_for(irep_or_ast_node, definition); end

  def context(); end

  def document(); end

  def fragments(); end

  def get_field(*args, &block); end

  def get_type(*args, &block); end

  def initialize(schema, query_string=T.unsafe(nil), query: T.unsafe(nil), document: T.unsafe(nil), context: T.unsafe(nil), variables: T.unsafe(nil), validate: T.unsafe(nil), subscription_topic: T.unsafe(nil), operation_name: T.unsafe(nil), root_value: T.unsafe(nil), max_depth: T.unsafe(nil), max_complexity: T.unsafe(nil), except: T.unsafe(nil), only: T.unsafe(nil)); end

  def internal_representation(*args, &block); end

  def irep_selection(); end

  def merge_filters(only: T.unsafe(nil), except: T.unsafe(nil)); end

  def mutation?(); end

  def operation_name(); end

  def operation_name=(operation_name); end

  def operations(); end

  def possible_types(*args, &block); end

  def provided_variables(); end

  def query?(); end

  def query_string(); end

  def query_string=(query_string); end

  def resolve_type(abstract_type, value=T.unsafe(nil)); end

  def result(); end

  def result_values(); end

  def result_values=(result_hash); end

  def root_type_for_operation(*args, &block); end

  def root_value(); end

  def root_value=(root_value); end

  def schema(); end

  def selected_operation(); end

  def selected_operation_name(); end

  def static_errors(); end

  def subscription?(); end

  def subscription_topic(); end

  def subscription_update?(); end

  def tracers(); end

  def valid?(); end

  def validate(); end

  def validate=(validate); end

  def validation_errors(*args, &block); end

  def validation_pipeline(); end

  def variables(); end

  def warden(); end
end

class GraphQL::Query::Arguments
  def [](key); end

  def any?(*args, &block); end

  def argument_values(); end

  def default_used?(key); end

  def each(*args, &block); end

  def each_value(); end

  def initialize(values, context:, defaults_used:); end

  def key?(key); end

  def keys(*args, &block); end

  def to_h(); end

  def to_kwargs(); end

  def values(*args, &block); end
  NO_ARGS = ::T.let(nil, ::T.untyped)
  NULL_ARGUMENT_VALUE = ::T.let(nil, ::T.untyped)
end

class GraphQL::Query::Arguments::ArgumentValue
  def default_used=(default_used); end

  def default_used?(); end

  def definition(); end

  def initialize(key, value, definition, default_used); end

  def key(); end

  def value(); end
end

class GraphQL::Query::Arguments::ArgumentValue
end

class GraphQL::Query::Arguments::NoArguments
end

class GraphQL::Query::Arguments::NoArguments
end

class GraphQL::Query::Arguments
  extend ::Forwardable
  def self.argument_definitions(); end

  def self.argument_definitions=(argument_definitions); end

  def self.construct_arguments_class(argument_owner); end
end

module GraphQL::Query::ArgumentsCache
end

module GraphQL::Query::ArgumentsCache
  extend ::T::Sig
  def self.build(query); end
end

class GraphQL::Query::Context
  include ::GraphQL::Query::Context::SharedMethods
  def [](*args, &block); end

  def []=(*args, &block); end

  def ast_node(); end

  def dig(*args, &block); end

  def errors(); end

  def execution_strategy(); end

  def execution_strategy=(new_strategy); end

  def fetch(*args, &block); end

  def initialize(query:, values:, object:); end

  def irep_node(); end

  def key?(*args, &block); end

  def namespace(ns); end

  def path(); end

  def query(); end

  def received_null_child(); end

  def schema(); end

  def strategy(); end

  def to_h(*args, &block); end

  def trace(*args, &block); end

  def value=(value); end

  def warden(); end
end

class GraphQL::Query::Context::ExecutionErrors
  def >>(err_or_msg); end

  def add(err_or_msg); end

  def initialize(ctx); end

  def push(err_or_msg); end
end

class GraphQL::Query::Context::ExecutionErrors
end

class GraphQL::Query::Context::FieldResolutionContext
  include ::GraphQL::Query::Context::SharedMethods
  include ::GraphQL::Tracing::Traceable
  def [](*args, &block); end

  def []=(*args, &block); end

  def ast_node(); end

  def dig(*args, &block); end

  def errors(*args, &block); end

  def execution_strategy(*args, &block); end

  def fetch(*args, &block); end

  def field(); end

  def initialize(context:, key:, irep_node:, parent:, object:); end

  def irep_node(); end

  def key(); end

  def key?(*args, &block); end

  def namespace(*args, &block); end

  def parent(); end

  def parent_type(); end

  def path(); end

  def query(); end

  def received_null_child(); end

  def schema(); end

  def selection(); end

  def spawn(*args, &block); end

  def strategy(*args, &block); end

  def to_h(*args, &block); end

  def type(); end

  def value=(new_value); end

  def warden(*args, &block); end

  def wrapped_connection(); end

  def wrapped_connection=(wrapped_connection); end

  def wrapped_object(); end

  def wrapped_object=(wrapped_object); end
end

class GraphQL::Query::Context::FieldResolutionContext
  extend ::Forwardable
end

module GraphQL::Query::Context::SharedMethods
  def add_error(error); end

  def backtrace(); end

  def delete(child_ctx); end

  def execution_errors(); end

  def invalid_null?(); end

  def lookahead(); end

  def object(); end

  def object=(object); end

  def skip(); end

  def skipped(); end

  def skipped=(skipped); end

  def skipped?(); end

  def spawn_child(key:, irep_node:, object:); end

  def value(); end
end

module GraphQL::Query::Context::SharedMethods
  extend ::T::Sig
end

class GraphQL::Query::Context
  extend ::Forwardable
end

class GraphQL::Query::Executor
  def initialize(query); end

  def query(); end

  def result(); end
end

class GraphQL::Query::Executor::PropagateNull
end

class GraphQL::Query::Executor::PropagateNull
end

class GraphQL::Query::Executor
end

class GraphQL::Query::InputValidationResult
  def add_problem(explanation, path=T.unsafe(nil)); end

  def merge_result!(path, inner_result); end

  def problems(); end

  def problems=(problems); end

  def valid?(); end
end

class GraphQL::Query::InputValidationResult
end

class GraphQL::Query::LiteralInput
end

class GraphQL::Query::LiteralInput
  def self.coerce(type, ast_node, variables); end

  def self.from_arguments(ast_arguments, argument_owner, variables); end
end

class GraphQL::Query::NullContext
  def query(); end

  def schema(); end

  def warden(); end
end

class GraphQL::Query::NullContext::NullWarden
  def visible?(t); end

  def visible_field?(t); end

  def visible_type?(t); end
end

class GraphQL::Query::NullContext::NullWarden
end

class GraphQL::Query::NullContext
  def self.instance(); end

  def self.query(*args, &block); end

  def self.schema(*args, &block); end

  def self.warden(*args, &block); end
end

class GraphQL::Query::OperationNameMissingError
  def initialize(name); end
end

class GraphQL::Query::OperationNameMissingError
end

class GraphQL::Query::Result
  def ==(other); end

  def [](*args, &block); end

  def as_json(*args, &block); end

  def context(*args, &block); end

  def initialize(query:, values:); end

  def keys(*args, &block); end

  def method_missing(method_name, *args, &block); end

  def mutation?(*args, &block); end

  def query(); end

  def query?(*args, &block); end

  def subscription?(*args, &block); end

  def to_h(); end

  def to_json(*args, &block); end

  def values(*args, &block); end
end

class GraphQL::Query::Result
  extend ::Forwardable
end

class GraphQL::Query::SerialExecution
  def execute(ast_operation, root_type, query_object); end

  def field_resolution(); end

  def operation_resolution(); end

  def selection_resolution(); end
end

class GraphQL::Query::SerialExecution::FieldResolution
  def arguments(); end

  def execution_context(); end

  def field(); end

  def initialize(selection, parent_type, target, query_ctx); end

  def irep_node(); end

  def parent_type(); end

  def query(); end

  def result(); end

  def target(); end
end

class GraphQL::Query::SerialExecution::FieldResolution
end

module GraphQL::Query::SerialExecution::OperationResolution
end

module GraphQL::Query::SerialExecution::OperationResolution
  extend ::T::Sig
  def self.resolve(selection, target, query); end
end

module GraphQL::Query::SerialExecution::SelectionResolution
end

module GraphQL::Query::SerialExecution::SelectionResolution
  extend ::T::Sig
  def self.resolve(target, current_type, selection, query_ctx); end
end

module GraphQL::Query::SerialExecution::ValueResolution
end

module GraphQL::Query::SerialExecution::ValueResolution
  extend ::T::Sig
  def self.resolve(parent_type, field_defn, field_type, value, selection, query_ctx); end
end

class GraphQL::Query::SerialExecution
end

class GraphQL::Query::ValidationPipeline
  def analyzers(); end

  def initialize(query:, validate:, parse_error:, operation_name_error:, max_depth:, max_complexity:); end

  def internal_representation(); end

  def valid?(); end

  def validation_errors(); end
end

class GraphQL::Query::ValidationPipeline
end

class GraphQL::Query::VariableValidationError
  def initialize(variable_ast, type, value, validation_result); end

  def validation_result(); end

  def validation_result=(validation_result); end

  def value(); end

  def value=(value); end
end

class GraphQL::Query::VariableValidationError
end

class GraphQL::Query::Variables
  def [](*args, &block); end

  def context(); end

  def errors(); end

  def fetch(*args, &block); end

  def initialize(ctx, ast_variables, provided_variables); end

  def key?(*args, &block); end

  def length(*args, &block); end

  def to_h(*args, &block); end
end

class GraphQL::Query::Variables
  extend ::Forwardable
end

class GraphQL::Query
  extend ::Forwardable
end

class GraphQL::Railtie
end

class GraphQL::Railtie
end

module GraphQL::Relay
  PageInfo = ::T.let(nil, ::T.untyped)
end

class GraphQL::Relay::ArrayConnection
  def cursor_from_node(item); end
end

class GraphQL::Relay::ArrayConnection
end

class GraphQL::Relay::BaseConnection
  def after(); end

  def arguments(); end

  def before(); end

  def context(); end

  def cursor_from_node(object); end

  def decode(data); end

  def edge_nodes(); end

  def encode(data); end

  def end_cursor(); end

  def field(); end

  def first(); end

  def has_next_page(); end

  def has_previous_page(); end

  def initialize(nodes, arguments, field: T.unsafe(nil), max_page_size: T.unsafe(nil), parent: T.unsafe(nil), context: T.unsafe(nil)); end

  def last(); end

  def max_page_size(); end

  def nodes(); end

  def page_info(); end

  def parent(); end

  def start_cursor(); end
  CONNECTION_IMPLEMENTATIONS = ::T.let(nil, ::T.untyped)
  CURSOR_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class GraphQL::Relay::BaseConnection
  def self.connection_for_nodes(nodes); end

  def self.register_connection_implementation(nodes_class, connection_class); end
end

module GraphQL::Relay::ConnectionInstrumentation
end

module GraphQL::Relay::ConnectionInstrumentation
  extend ::T::Sig
  def self.default_arguments(); end

  def self.instrument(type, field); end
end

class GraphQL::Relay::ConnectionResolve
  def call(obj, args, ctx); end

  def initialize(field, underlying_resolve); end
end

class GraphQL::Relay::ConnectionResolve
end

module GraphQL::Relay::ConnectionType
end

module GraphQL::Relay::ConnectionType
  extend ::T::Sig
  def self.bidirectional_pagination(); end

  def self.bidirectional_pagination=(bidirectional_pagination); end

  def self.create_type(wrapped_type, edge_type: T.unsafe(nil), edge_class: T.unsafe(nil), nodes_field: T.unsafe(nil), &block); end

  def self.default_nodes_field(); end

  def self.default_nodes_field=(default_nodes_field); end
end

class GraphQL::Relay::Edge
  def connection(); end

  def cursor(); end

  def initialize(node, connection); end

  def node(); end

  def parent(); end
end

class GraphQL::Relay::Edge
end

module GraphQL::Relay::EdgeType
end

module GraphQL::Relay::EdgeType
  extend ::T::Sig
  def self.create_type(wrapped_type, name: T.unsafe(nil), &block); end
end

module GraphQL::Relay::EdgesInstrumentation
end

class GraphQL::Relay::EdgesInstrumentation::EdgesResolve
  def call(obj, args, ctx); end

  def initialize(edge_class:, resolve:); end
end

class GraphQL::Relay::EdgesInstrumentation::EdgesResolve
end

module GraphQL::Relay::EdgesInstrumentation
  extend ::T::Sig
  def self.instrument(type, field); end
end

class GraphQL::Relay::GlobalIdResolve
  def call(obj, args, ctx); end

  def initialize(type:); end
end

class GraphQL::Relay::GlobalIdResolve
end

class GraphQL::Relay::MongoRelationConnection
end

class GraphQL::Relay::MongoRelationConnection
end

class GraphQL::Relay::Mutation
  include ::GraphQL::Define::InstanceDefinable
  def arguments(); end

  def arguments=(arguments); end

  def description(); end

  def description=(description); end

  def field(); end

  def fields(); end

  def fields=(fields); end

  def has_generated_return_type?(); end

  def input_fields(); end

  def input_type(); end

  def name(); end

  def name=(name); end

  def resolve=(new_resolve_proc); end

  def result_class(); end

  def return_fields(); end

  def return_interfaces(); end

  def return_interfaces=(return_interfaces); end

  def return_type(); end

  def return_type=(return_type); end
end

module GraphQL::Relay::Mutation::Instrumentation
end

module GraphQL::Relay::Mutation::Instrumentation
  extend ::T::Sig
  def self.instrument(type, field); end
end

class GraphQL::Relay::Mutation::Resolve
  def call(obj, args, ctx); end

  def initialize(mutation, resolve); end
end

class GraphQL::Relay::Mutation::Resolve
end

class GraphQL::Relay::Mutation::Result
  def client_mutation_id(); end

  def initialize(client_mutation_id:, result:); end
end

class GraphQL::Relay::Mutation::Result
  def self.define_subclass(mutation_defn); end

  def self.mutation(); end

  def self.mutation=(mutation); end
end

class GraphQL::Relay::Mutation
end

module GraphQL::Relay::Node
end

module GraphQL::Relay::Node::FindNode
end

module GraphQL::Relay::Node::FindNode
  extend ::T::Sig
  def self.call(obj, args, ctx); end
end

module GraphQL::Relay::Node::FindNodes
end

module GraphQL::Relay::Node::FindNodes
  extend ::T::Sig
  def self.call(obj, args, ctx); end
end

module GraphQL::Relay::Node
  extend ::T::Sig
  def self.field(**kwargs, &block); end

  def self.interface(); end

  def self.plural_field(**kwargs, &block); end
end

class GraphQL::Relay::RangeAdd
  def connection(); end

  def edge(); end

  def initialize(collection:, item:, parent: T.unsafe(nil), context: T.unsafe(nil), edge_class: T.unsafe(nil)); end

  def parent(); end
end

class GraphQL::Relay::RangeAdd
end

class GraphQL::Relay::RelationConnection
  def cursor_from_node(item); end
end

class GraphQL::Relay::RelationConnection
end

module GraphQL::Relay::TypeExtensions
  def connection_type(); end

  def define_connection(**kwargs, &block); end

  def define_edge(**kwargs, &block); end

  def edge_type(); end
end

module GraphQL::Relay::TypeExtensions
  extend ::T::Sig
end

module GraphQL::Relay
  extend ::T::Sig
end

class GraphQL::RuntimeTypeError
end

class GraphQL::RuntimeTypeError
end

class GraphQL::ScalarType
  def coerce=(proc); end

  def coerce_input=(coerce_input_fn); end

  def coerce_result(value, ctx=T.unsafe(nil)); end

  def coerce_result=(coerce_result_fn); end

  def kind(); end
end

module GraphQL::ScalarType::NoOpCoerce
end

module GraphQL::ScalarType::NoOpCoerce
  extend ::T::Sig
  def self.call(val, ctx); end
end

class GraphQL::ScalarType
end

class GraphQL::Schema
  include ::GraphQL::Define::InstanceDefinable
  def _schema_class(); end

  def accessible?(*args, &block); end

  def after_lazy(value); end

  def as_json(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def ast_node(); end

  def ast_node=(ast_node); end

  def authorized?(*args, &block); end

  def check_resolved_type(type, object, ctx=T.unsafe(nil)); end

  def context_class(); end

  def context_class=(context_class); end

  def cursor_encoder(); end

  def cursor_encoder=(cursor_encoder); end

  def default_filter(); end

  def default_mask(); end

  def default_mask=(default_mask); end

  def default_max_page_size(); end

  def default_max_page_size=(default_max_page_size); end

  def directives(); end

  def directives=(directives); end

  def execute(query_str=T.unsafe(nil), **kwargs); end

  def execution_strategy_for_operation(operation); end

  def find(path); end

  def get_field(parent_type, field_name); end

  def get_fields(type); end

  def graphql_definition(); end

  def id_from_object(object, type, ctx); end

  def id_from_object=(new_proc); end

  def id_from_object_proc(); end

  def inaccessible_fields(*args, &block); end

  def instrument(instrumentation_type, instrumenter); end

  def instrumenters(); end

  def instrumenters=(instrumenters); end

  def introspection_namespace(); end

  def introspection_namespace=(introspection_namespace); end

  def introspection_system(); end

  def lazy?(obj); end

  def lazy_method_name(obj); end

  def lazy_methods(); end

  def lazy_methods=(lazy_methods); end

  def max_complexity(); end

  def max_complexity=(max_complexity); end

  def max_depth(); end

  def max_depth=(max_depth); end

  def middleware(); end

  def middleware=(middleware); end

  def multiplex(queries, **kwargs); end

  def multiplex_analyzers(); end

  def multiplex_analyzers=(multiplex_analyzers); end

  def mutation(); end

  def mutation=(mutation); end

  def mutation_execution_strategy(); end

  def mutation_execution_strategy=(mutation_execution_strategy); end

  def object_from_id(id, ctx); end

  def object_from_id=(new_proc); end

  def object_from_id_proc(); end

  def orphan_types(); end

  def orphan_types=(orphan_types); end

  def parse_error(err, ctx); end

  def parse_error=(new_proc); end

  def possible_types(type_defn); end

  def query(); end

  def query=(query); end

  def query_analyzers(); end

  def query_analyzers=(query_analyzers); end

  def query_execution_strategy(); end

  def query_execution_strategy=(query_execution_strategy); end

  def raise_definition_error(); end

  def raise_definition_error=(raise_definition_error); end

  def references_to(type_name); end

  def remove_handler(*args, &block); end

  def rescue_from(*args, &block); end

  def rescue_middleware(); end

  def rescues?(); end

  def resolve_type(type, object, ctx=T.unsafe(nil)); end

  def resolve_type=(new_resolve_type_proc); end

  def resolve_type_proc(); end

  def root_type_for_operation(operation); end

  def root_types(); end

  def static_validator(); end

  def subscription(); end

  def subscription=(subscription); end

  def subscription_execution_strategy(); end

  def subscription_execution_strategy=(subscription_execution_strategy); end

  def subscriptions(); end

  def subscriptions=(subscriptions); end

  def sync_lazy(value); end

  def to_definition(only: T.unsafe(nil), except: T.unsafe(nil), context: T.unsafe(nil)); end

  def to_document(); end

  def to_json(*args); end

  def tracers(); end

  def type_error(err, ctx); end

  def type_error=(new_proc); end

  def type_from_ast(ast_node); end

  def types(); end

  def unauthorized_object(*args, &block); end

  def union_memberships(type); end

  def validate(string_or_document, rules: T.unsafe(nil)); end

  def visible?(*args, &block); end
  BUILT_IN_TYPES = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  DYNAMIC_FIELDS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Enum
end

class GraphQL::Schema::Enum
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.coerce_input(*args, &block); end

  def self.coerce_isolated_input(*args, &block); end

  def self.coerce_isolated_result(*args, &block); end

  def self.coerce_result(*args, &block); end

  def self.enum_value_class(new_enum_value_class=T.unsafe(nil)); end

  def self.value(*args, **kwargs, &block); end

  def self.values(); end
end

class GraphQL::Schema::Field
  include ::GraphQL::Schema::Member::CachedGraphQLDefinition
  include ::GraphQL::Schema::Member::AcceptsDefinition
  include ::GraphQL::Schema::Member::HasArguments
  include ::GraphQL::Schema::Member::HasPath
  include ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  include ::GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accessible?(context); end

  def authorized?(object, context); end

  def complexity(new_complexity); end

  def connection?(); end

  def deprecation_reason(); end

  def deprecation_reason=(deprecation_reason); end

  def description(text=T.unsafe(nil)); end

  def description=(description); end

  def graphql_name(); end

  def method_str(); end

  def method_sym(); end

  def mutation(); end

  def name(); end

  def owner(); end

  def resolve_field(obj, args, ctx); end

  def resolve_field_method(obj, ruby_kwargs, ctx); end

  def resolver(); end

  def scoped?(); end

  def type(); end

  def visible?(context); end
  CONTEXT_EXTRAS = ::T.let(nil, ::T.untyped)
  NO_ARGS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Schema::Field
  def self.from_options(name=T.unsafe(nil), type=T.unsafe(nil), desc=T.unsafe(nil), resolver: T.unsafe(nil), mutation: T.unsafe(nil), **kwargs, &block); end
end

class GraphQL::Schema::InputObject
  def [](key); end

  def any?(*args, &block); end

  def arguments(); end

  def context(); end

  def each(*args, &block); end

  def empty?(*args, &block); end

  def initialize(values, context:, defaults_used:); end

  def key?(key); end

  def keys(*args, &block); end

  def map(*args, &block); end

  def to_h(); end

  def to_kwargs(); end

  def unwrap_value(value); end

  def values(*args, &block); end
end

class GraphQL::Schema::InputObject
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.argument(*args); end

  def self.arguments_class(); end

  def self.arguments_class=(arguments_class); end
end

module GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  def unwrap(); end
end

module GraphQL::Schema::Interface
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::T::Sig
end

class GraphQL::Schema::Member
  include ::GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Schema::Member::AcceptsDefinition
end

module GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  def accepts_definition_methods(); end

  def initialize(*args, **kwargs, &block); end
end

module GraphQL::Schema::Member::AcceptsDefinition::InitializeExtension
  extend ::T::Sig
end

module GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def to_graphql(); end
end

module GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::T::Sig
end

module GraphQL::Schema::Member::AcceptsDefinition
  extend ::T::Sig
  def self.extended(child); end

  def self.included(child); end
end

module GraphQL::Schema::Member::CachedGraphQLDefinition
  def graphql_definition(); end
end

module GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::T::Sig
end

module GraphQL::Schema::Member::GraphQLTypeNames
  Boolean = ::T.let(nil, ::T.untyped)
  ID = ::T.let(nil, ::T.untyped)
  Int = ::T.let(nil, ::T.untyped)
end

module GraphQL::Schema::Member::GraphQLTypeNames
  extend ::T::Sig
end

module GraphQL::Schema::Member::HasArguments
  def add_argument(arg_defn); end

  def argument(*args, **kwargs, &block); end

  def argument_class(new_arg_class=T.unsafe(nil)); end

  def arguments(); end

  def own_arguments(); end
end

module GraphQL::Schema::Member::HasArguments
  extend ::T::Sig
  def self.extended(cls); end

  def self.included(cls); end
end

module GraphQL::Schema::Member::HasPath
  def path(); end
end

module GraphQL::Schema::Member::HasPath
  extend ::T::Sig
end

class GraphQL::Schema::Member
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::HasPath
end

class GraphQL::Schema::Mutation
end

class GraphQL::Schema::Mutation
  def self.field(*args, &block); end

  def self.field_class(new_class=T.unsafe(nil)); end

  def self.object_class(new_class=T.unsafe(nil)); end

  def self.payload_type(new_payload_type=T.unsafe(nil)); end

  def self.type(new_payload_type=T.unsafe(nil)); end

  def self.type_expr(new_payload_type=T.unsafe(nil)); end
end

class GraphQL::Schema::Object
  def context(); end

  def initialize(object, context); end

  def object(); end
end

class GraphQL::Schema::Object
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.authorized_new(object, context); end

  def self.implements(*new_interfaces); end

  def self.interfaces(); end

  def self.own_interfaces(); end
end

class GraphQL::Schema::RelayClassicMutation
  def resolve_with_support(**kwargs); end
end

class GraphQL::Schema::RelayClassicMutation
  def self.input_object_class(new_class=T.unsafe(nil)); end

  def self.input_type(new_input_type=T.unsafe(nil)); end
end

class GraphQL::Schema::Resolver
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  include ::GraphQL::Schema::Member::HasPath
  def authorized?(**args); end

  def context(); end

  def initialize(object:, context:); end

  def object(); end

  def ready?(**args); end

  def resolve(**args); end

  def resolve_with_support(**args); end
end

class GraphQL::Schema::Resolver
  extend ::GraphQL::Schema::Member::HasArguments
  extend ::GraphQL::Schema::Member::HasPath
  def self.argument(name, type, *rest, loads: T.unsafe(nil), **kwargs, &block); end

  def self.arguments_loads_as_type(); end

  def self.complexity(new_complexity=T.unsafe(nil)); end

  def self.extras(new_extras=T.unsafe(nil)); end

  def self.field_options(); end

  def self.null(allow_null=T.unsafe(nil)); end

  def self.resolve_method(new_method=T.unsafe(nil)); end

  def self.type(new_type=T.unsafe(nil), null: T.unsafe(nil)); end

  def self.type_expr(); end
end

class GraphQL::Schema::Scalar
end

class GraphQL::Schema::Scalar
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.coerce_input(val, ctx); end

  def self.coerce_isolated_input(*args, &block); end

  def self.coerce_isolated_result(*args, &block); end

  def self.coerce_result(val, ctx); end

  def self.default_scalar(is_default=T.unsafe(nil)); end
end

class GraphQL::Schema::Union
end

class GraphQL::Schema::Union
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.possible_types(*types); end
end

class GraphQL::Schema::Warden
  def arguments(argument_owner); end

  def directives(); end

  def enum_values(enum_defn); end

  def fields(type_defn); end

  def get_field(parent_type, field_name); end

  def get_type(type_name); end

  def initialize(filter, context:, schema:); end

  def interfaces(obj_type); end

  def possible_types(type_defn); end

  def root_type_for_operation(op_name); end

  def types(); end
end

class GraphQL::Schema::Warden
end

class GraphQL::Schema
  extend ::Forwardable
  extend ::GraphQL::Schema::Member::AcceptsDefinition
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  def self.accessible?(member, context); end

  def self.after_lazy(*args, &block); end

  def self.as_json(*args, &block); end

  def self.context_class(new_context_class=T.unsafe(nil)); end

  def self.cursor_encoder(new_encoder=T.unsafe(nil)); end

  def self.default_execution_strategy(); end

  def self.default_execution_strategy=(default_execution_strategy); end

  def self.default_filter(*args, &block); end

  def self.default_mask(*args, &block); end

  def self.default_max_page_size(new_default_max_page_size=T.unsafe(nil)); end

  def self.directives(new_directives=T.unsafe(nil)); end

  def self.execute(*args, &block); end

  def self.find(*args, &block); end

  def self.from_definition(definition_or_path, default_resolve: T.unsafe(nil), parser: T.unsafe(nil)); end

  def self.from_introspection(introspection_result); end

  def self.get_field(*args, &block); end

  def self.get_fields(*args, &block); end

  def self.graphql_definition(); end

  def self.id_from_object(object, type, ctx); end

  def self.id_from_object=(*args, &block); end

  def self.id_from_object_proc(*args, &block); end

  def self.inaccessible_fields(error); end

  def self.inherited(child_class); end

  def self.instrument(instrument_step, instrumenter, options=T.unsafe(nil)); end

  def self.instrumenters(*args, &block); end

  def self.introspection(new_introspection_namespace=T.unsafe(nil)); end

  def self.introspection_system(*args, &block); end

  def self.lazy?(*args, &block); end

  def self.lazy_method_name(*args, &block); end

  def self.lazy_resolve(lazy_class, value_method); end

  def self.max_complexity(max_complexity=T.unsafe(nil)); end

  def self.max_complexity=(*args, &block); end

  def self.max_depth(new_max_depth=T.unsafe(nil)); end

  def self.max_depth=(*args, &block); end

  def self.metadata(*args, &block); end

  def self.middleware(new_middleware=T.unsafe(nil)); end

  def self.multiplex(*args, &block); end

  def self.multiplex_analyzer(new_analyzer); end

  def self.multiplex_analyzers(*args, &block); end

  def self.mutation(new_mutation_object=T.unsafe(nil)); end

  def self.mutation_execution_strategy(*args, &block); end

  def self.object_from_id(node_id, ctx); end

  def self.object_from_id=(*args, &block); end

  def self.object_from_id_proc(*args, &block); end

  def self.orphan_types(*new_orphan_types); end

  def self.plugins(); end

  def self.possible_types(*args, &block); end

  def self.query(new_query_object=T.unsafe(nil)); end

  def self.query_analyzer(new_analyzer); end

  def self.query_analyzers(*args, &block); end

  def self.query_execution_strategy(*args, &block); end

  def self.redefine(*args, &block); end

  def self.references_to(*args, &block); end

  def self.remove_handler(*args, &block); end

  def self.rescue_from(err_class, &handler_block); end

  def self.resolve_type(type, obj, ctx); end

  def self.root_type_for_operation(*args, &block); end

  def self.root_types(*args, &block); end

  def self.static_validator(*args, &block); end

  def self.subscription(new_subscription_object=T.unsafe(nil)); end

  def self.subscription_execution_strategy(*args, &block); end

  def self.subscriptions(*args, &block); end

  def self.sync_lazy(value); end

  def self.to_definition(*args, &block); end

  def self.to_document(*args, &block); end

  def self.to_json(*args, &block); end

  def self.tracer(new_tracer); end

  def self.tracers(*args, &block); end

  def self.type_error(type_err, ctx); end

  def self.type_from_ast(*args, &block); end

  def self.types(*args, &block); end

  def self.unauthorized_object(unauthorized_error); end

  def self.union_memberships(*args, &block); end

  def self.use(plugin, options=T.unsafe(nil)); end

  def self.validate(*args, &block); end

  def self.visible?(member, context); end
end

module GraphQL::StaticValidation
  ALL_RULES = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
  def validate_node(parent, node, defn, context); end
end

class GraphQL::StaticValidation::ArgumentLiteralsAreCompatible
end

class GraphQL::StaticValidation::ArgumentNamesAreUnique
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end

  def validate_arguments(node, context); end
end

class GraphQL::StaticValidation::ArgumentNamesAreUnique
end

class GraphQL::StaticValidation::ArgumentsAreDefined
  def validate_node(parent, node, defn, context); end
end

class GraphQL::StaticValidation::ArgumentsAreDefined
end

class GraphQL::StaticValidation::ArgumentsValidator
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::ArgumentsValidator
end

class GraphQL::StaticValidation::DefinitionDependencies
  def dependency_map(&block); end

  def mount(context); end
end

class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
  def [](definition_node); end

  def cyclical_definitions(); end

  def unmet_dependencies(); end

  def unused_dependencies(); end
end

class GraphQL::StaticValidation::DefinitionDependencies::DependencyMap
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  def eql?(*args, &block); end

  def hash(*args, &block); end

  def initialize(node, path); end

  def name(*args, &block); end

  def node(); end

  def path(); end
end

class GraphQL::StaticValidation::DefinitionDependencies::NodeWithPath
  extend ::Forwardable
end

class GraphQL::StaticValidation::DefinitionDependencies
  def self.mount(visitor); end
end

class GraphQL::StaticValidation::DirectivesAreDefined
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::DirectivesAreDefined
end

class GraphQL::StaticValidation::DirectivesAreInValidLocations
  include ::GraphQL::StaticValidation::Message::MessageHelper
  include ::GraphQL::Language
  def validate(context); end
  LOCATION_MESSAGE_NAMES = ::T.let(nil, ::T.untyped)
  SIMPLE_LOCATIONS = ::T.let(nil, ::T.untyped)
  SIMPLE_LOCATION_NODES = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::DirectivesAreInValidLocations
end

class GraphQL::StaticValidation::FieldsAreDefinedOnType
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::FieldsAreDefinedOnType
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelections
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::FieldsHaveAppropriateSelections
end

class GraphQL::StaticValidation::FieldsWillMerge
  def validate(context); end
  NO_ARGS = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::FieldsWillMerge
end

class GraphQL::StaticValidation::FragmentNamesAreUnique
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::FragmentNamesAreUnique
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
  def initialize(node:, parent_type:, path:); end

  def node(); end

  def parent_type(); end

  def path(); end
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible::FragmentSpread
end

class GraphQL::StaticValidation::FragmentSpreadsArePossible
end

class GraphQL::StaticValidation::FragmentTypesExist
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
  FRAGMENTS_ON_TYPES = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::FragmentTypesExist
end

class GraphQL::StaticValidation::FragmentsAreFinite
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::FragmentsAreFinite
end

class GraphQL::StaticValidation::FragmentsAreNamed
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::FragmentsAreNamed
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
  HAS_TYPE_CONDITION = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::FragmentsAreOnCompositeTypes
end

class GraphQL::StaticValidation::FragmentsAreUsed
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::FragmentsAreUsed
end

class GraphQL::StaticValidation::LiteralValidator
  def initialize(context:); end

  def validate(ast_value, type); end
end

class GraphQL::StaticValidation::LiteralValidator
end

class GraphQL::StaticValidation::Message
  def initialize(message, path: T.unsafe(nil), nodes: T.unsafe(nil)); end

  def message(); end

  def path(); end

  def to_h(); end
end

module GraphQL::StaticValidation::Message::MessageHelper
  def message(message, nodes, context: T.unsafe(nil), path: T.unsafe(nil)); end
end

module GraphQL::StaticValidation::Message::MessageHelper
  extend ::T::Sig
end

class GraphQL::StaticValidation::Message
end

class GraphQL::StaticValidation::MutationRootExists
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::MutationRootExists
end

class GraphQL::StaticValidation::NoDefinitionsArePresent
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::NoDefinitionsArePresent
end

class GraphQL::StaticValidation::OperationNamesAreValid
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::OperationNamesAreValid
end

class GraphQL::StaticValidation::RequiredArgumentsArePresent
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::RequiredArgumentsArePresent
end

class GraphQL::StaticValidation::SubscriptionRootExists
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::SubscriptionRootExists
end

class GraphQL::StaticValidation::TypeStack
  def argument_definitions(); end

  def directive_definitions(); end

  def field_definitions(); end

  def initialize(schema, visitor); end

  def object_types(); end

  def path(); end

  def schema(); end
  PUSH_STRATEGIES = ::T.let(nil, ::T.untyped)
  TYPE_INFERRENCE_ROOTS = ::T.let(nil, ::T.untyped)
end

module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
end

module GraphQL::StaticValidation::TypeStack::ArgumentStrategy
  extend ::T::Sig
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
end

module GraphQL::StaticValidation::TypeStack::DirectiveStrategy
  extend ::T::Sig
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
  def call(node, parent); end

  def initialize(stack, strategy); end
end

class GraphQL::StaticValidation::TypeStack::EnterWithStrategy
end

module GraphQL::StaticValidation::TypeStack::FieldStrategy
end

module GraphQL::StaticValidation::TypeStack::FieldStrategy
  extend ::T::Sig
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
end

module GraphQL::StaticValidation::TypeStack::FragmentDefinitionStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  extend ::T::Sig
  def self.push_path_member(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
end

module GraphQL::StaticValidation::TypeStack::FragmentSpreadStrategy
  extend ::T::Sig
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  def pop(stack, node); end

  def push(stack, node); end
end

module GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  extend ::T::Sig
end

module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
end

module GraphQL::StaticValidation::TypeStack::InlineFragmentStrategy
  extend ::GraphQL::StaticValidation::TypeStack::FragmentWithTypeStrategy
  extend ::T::Sig
  def self.push_path_member(stack, node); end
end

class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
  def call(node, parent); end

  def initialize(stack, strategy); end
end

class GraphQL::StaticValidation::TypeStack::LeaveWithStrategy
end

module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
end

module GraphQL::StaticValidation::TypeStack::OperationDefinitionStrategy
  extend ::T::Sig
  def self.pop(stack, node); end

  def self.push(stack, node); end
end

class GraphQL::StaticValidation::TypeStack
end

class GraphQL::StaticValidation::UniqueDirectivesPerLocation
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
  NODES_WITH_DIRECTIVES = ::T.let(nil, ::T.untyped)
end

class GraphQL::StaticValidation::UniqueDirectivesPerLocation
end

class GraphQL::StaticValidation::ValidationContext
  def argument_definition(); end

  def dependencies(); end

  def directive_definition(); end

  def document(*args, &block); end

  def each_irep_node(&handler); end

  def each_irep_node_handlers(); end

  def errors(); end

  def field_definition(); end

  def fragments(*args, &block); end

  def initialize(query); end

  def object_types(); end

  def on_dependency_resolve(&handler); end

  def operations(*args, &block); end

  def parent_type_definition(); end

  def path(); end

  def query(); end

  def schema(*args, &block); end

  def type_definition(); end

  def valid_literal?(ast_value, type); end

  def visitor(); end

  def warden(*args, &block); end
end

class GraphQL::StaticValidation::ValidationContext
  extend ::Forwardable
end

class GraphQL::StaticValidation::Validator
  def initialize(schema:, rules: T.unsafe(nil)); end

  def validate(query, validate: T.unsafe(nil)); end
end

class GraphQL::StaticValidation::Validator
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end

  def validate_default_value(node, context); end
end

class GraphQL::StaticValidation::VariableDefaultValuesAreCorrectlyTyped
end

class GraphQL::StaticValidation::VariableNamesAreUnique
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::VariableNamesAreUnique
end

class GraphQL::StaticValidation::VariableUsagesAreAllowed
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::VariableUsagesAreAllowed
end

class GraphQL::StaticValidation::VariablesAreInputTypes
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end
end

class GraphQL::StaticValidation::VariablesAreInputTypes
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined
  include ::GraphQL::StaticValidation::Message::MessageHelper
  def validate(context); end

  def variable_hash(); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
  def ast_node(); end

  def ast_node=(ast_node); end

  def declared?(); end

  def declared_by(); end

  def declared_by=(declared_by); end

  def path(); end

  def path=(path); end

  def used?(); end

  def used_by(); end

  def used_by=(used_by); end
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined::VariableUsage
end

class GraphQL::StaticValidation::VariablesAreUsedAndDefined
end

module GraphQL::StaticValidation
  extend ::T::Sig
end

class GraphQL::StringEncodingError
  def initialize(str); end

  def string(); end
end

class GraphQL::StringEncodingError
end

class GraphQL::Subscriptions
  def build_id(); end

  def deliver(subscription_id, result, context); end

  def each_subscription_id(event); end

  def execute(subscription_id, event, object); end

  def execute_all(event, object); end

  def initialize(schema:, **rest); end

  def normalize_name(event_or_arg_name); end

  def read_subscription(subscription_id); end

  def trigger(event_name, args, object, scope: T.unsafe(nil)); end

  def write_subscription(query, events); end
end

class GraphQL::Subscriptions::ActionCableSubscriptions
  def delete_subscription(subscription_id); end

  def deliver(subscription_id, result); end

  def initialize(serializer: T.unsafe(nil), **rest); end
  EVENT_PREFIX = ::T.let(nil, ::T.untyped)
  SUBSCRIPTION_PREFIX = ::T.let(nil, ::T.untyped)
end

class GraphQL::Subscriptions::ActionCableSubscriptions
end

class GraphQL::Subscriptions::Event
  def arguments(); end

  def context(); end

  def initialize(name:, arguments:, field: T.unsafe(nil), context: T.unsafe(nil), scope: T.unsafe(nil)); end

  def name(); end

  def topic(); end
end

class GraphQL::Subscriptions::Event
  def self.serialize(name, arguments, field, scope:); end
end

class GraphQL::Subscriptions::Instrumentation
  def after_query(query); end

  def before_query(query); end

  def initialize(schema:); end

  def instrument(type, field); end
end

class GraphQL::Subscriptions::Instrumentation::SubscriptionRegistrationResolve
  def call(obj, args, ctx); end

  def initialize(inner_proc); end
end

class GraphQL::Subscriptions::Instrumentation::SubscriptionRegistrationResolve
end

class GraphQL::Subscriptions::Instrumentation
end

class GraphQL::Subscriptions::InvalidTriggerError
end

class GraphQL::Subscriptions::InvalidTriggerError
end

module GraphQL::Subscriptions::Serialize
  GLOBALID_KEY = ::T.let(nil, ::T.untyped)
  SYMBOL_KEY = ::T.let(nil, ::T.untyped)
  SYMBOL_KEYS_KEY = ::T.let(nil, ::T.untyped)
end

module GraphQL::Subscriptions::Serialize
  extend ::T::Sig
  def self.dump(obj); end

  def self.dump_recursive(obj); end

  def self.load(str); end
end

class GraphQL::Subscriptions
  def self.use(defn, options=T.unsafe(nil)); end
end

module GraphQL::Tracing
end

module GraphQL::Tracing::ActiveSupportNotificationsTracing
  KEYS = ::T.let(nil, ::T.untyped)
end

module GraphQL::Tracing::ActiveSupportNotificationsTracing
  extend ::T::Sig
  def self.trace(key, metadata); end
end

class GraphQL::Tracing::AppsignalTracing
  def platform_field_key(type, field); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::AppsignalTracing
end

class GraphQL::Tracing::DataDogTracing
  def platform_field_key(type, field); end

  def platform_trace(platform_key, key, data); end

  def service_name(); end

  def tracer(); end
end

class GraphQL::Tracing::DataDogTracing
end

class GraphQL::Tracing::NewRelicTracing
  def initialize(set_transaction_name: T.unsafe(nil)); end

  def platform_field_key(type, field); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::NewRelicTracing
end

module GraphQL::Tracing::NullTracer
end

module GraphQL::Tracing::NullTracer
  extend ::T::Sig
  def self.trace(k, v); end
end

class GraphQL::Tracing::PlatformTracing
  def initialize(options=T.unsafe(nil)); end

  def instrument(type, field); end

  def trace(key, data); end

  def trace_field(type, field); end
end

class GraphQL::Tracing::PlatformTracing
  def self.platform_keys(); end

  def self.platform_keys=(platform_keys); end

  def self.use(schema_defn, options=T.unsafe(nil)); end
end

class GraphQL::Tracing::PrometheusTracing
  def initialize(opts=T.unsafe(nil)); end

  def platform_field_key(type, field); end

  def platform_trace(platform_key, key, data, &block); end
  DEFAULT_COLLECTOR_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_WHITELIST = ::T.let(nil, ::T.untyped)
end

class GraphQL::Tracing::PrometheusTracing
end

class GraphQL::Tracing::ScoutTracing
  def platform_field_key(type, field); end

  def platform_trace(platform_key, key, data); end
  INSTRUMENT_OPTS = ::T.let(nil, ::T.untyped)
end

class GraphQL::Tracing::ScoutTracing
end

class GraphQL::Tracing::SkylightTracing
  def initialize(set_endpoint_name: T.unsafe(nil)); end

  def platform_field_key(type, field); end

  def platform_trace(platform_key, key, data); end
end

class GraphQL::Tracing::SkylightTracing
end

module GraphQL::Tracing::Traceable
  def trace(key, metadata); end
end

module GraphQL::Tracing::Traceable
  extend ::T::Sig
end

module GraphQL::Tracing
  extend ::T::Sig
  def self.install(tracer); end

  def self.tracers(); end

  def self.uninstall(tracer); end
end

module GraphQL::TypeKinds
  ENUM = ::T.let(nil, ::T.untyped)
  INPUT_OBJECT = ::T.let(nil, ::T.untyped)
  INTERFACE = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  NON_NULL = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  SCALAR = ::T.let(nil, ::T.untyped)
  TYPE_KINDS = ::T.let(nil, ::T.untyped)
  UNION = ::T.let(nil, ::T.untyped)
end

class GraphQL::TypeKinds::TypeKind
  def abstract?(); end

  def composite?(); end

  def description(); end

  def enum?(); end

  def fields?(); end

  def initialize(name, abstract: T.unsafe(nil), fields: T.unsafe(nil), wraps: T.unsafe(nil), input: T.unsafe(nil), description: T.unsafe(nil)); end

  def input?(); end

  def input_object?(); end

  def interface?(); end

  def list?(); end

  def name(); end

  def non_null?(); end

  def object?(); end

  def resolves?(); end

  def scalar?(); end

  def union?(); end

  def wraps?(); end
end

class GraphQL::TypeKinds::TypeKind
end

module GraphQL::TypeKinds
  extend ::T::Sig
end

module GraphQL::Types
end

class GraphQL::Types::Boolean
end

class GraphQL::Types::Boolean
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::Float
end

class GraphQL::Types::Float
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::ID
end

class GraphQL::Types::ID
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

class GraphQL::Types::ISO8601DateTime
  DEFAULT_TIME_PRECISION = ::T.let(nil, ::T.untyped)
end

class GraphQL::Types::ISO8601DateTime
  def self.coerce_input(str_value, _ctx); end

  def self.coerce_result(value, _ctx); end

  def self.time_precision(); end

  def self.time_precision=(value); end
end

class GraphQL::Types::Int
end

class GraphQL::Types::Int
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, _ctx); end
end

module GraphQL::Types::Relay
end

class GraphQL::Types::Relay::BaseConnection
  def cursor_from_node(*args, &block); end

  def nodes(); end

  def parent(*args, &block); end
end

class GraphQL::Types::Relay::BaseConnection
  extend ::Forwardable
  def self.accessible?(ctx); end

  def self.authorized?(obj, ctx); end

  def self.edge_type(edge_type_class, edge_class: T.unsafe(nil), node_type: T.unsafe(nil), nodes_field: T.unsafe(nil)); end

  def self.node_type(); end

  def self.nodes_field(); end

  def self.visible?(ctx); end
end

class GraphQL::Types::Relay::BaseEdge
end

class GraphQL::Types::Relay::BaseEdge
  def self.accessible?(ctx); end

  def self.authorized?(obj, ctx); end

  def self.node_type(node_type=T.unsafe(nil)); end

  def self.visible?(ctx); end
end

class GraphQL::Types::Relay::BaseField
  def initialize(edge_class: T.unsafe(nil), **rest, &block); end
end

class GraphQL::Types::Relay::BaseField
end

module GraphQL::Types::Relay::BaseInterface
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  def default_relay(new_value); end

  def default_relay?(); end

  def to_graphql(); end
end

module GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  extend ::T::Sig
end

module GraphQL::Types::Relay::BaseInterface
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  extend ::T::Sig
end

class GraphQL::Types::Relay::BaseObject
end

class GraphQL::Types::Relay::BaseObject
  def self.default_relay(new_value); end

  def self.default_relay?(); end
end

module GraphQL::Types::Relay::Node
  include ::GraphQL::Types::Relay::BaseInterface
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  def id(**args); end
end

module GraphQL::Types::Relay::Node::DefinitionMethods
end

module GraphQL::Types::Relay::Node::DefinitionMethods
  extend ::T::Sig
end

module GraphQL::Types::Relay::Node
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::GraphQL::Types::Relay::BaseInterface::DefinitionMethods
  extend ::GraphQL::Types::Relay::Node::DefinitionMethods
  extend ::T::Sig
end

class GraphQL::Types::Relay::PageInfo
end

class GraphQL::Types::Relay::PageInfo
end

module GraphQL::Types::Relay
  extend ::T::Sig
end

class GraphQL::Types::String
end

class GraphQL::Types::String
  def self.coerce_input(value, _ctx); end

  def self.coerce_result(value, ctx); end
end

module GraphQL::Types
  extend ::T::Sig
end

class GraphQL::UnauthorizedError
  def context(); end

  def initialize(message=T.unsafe(nil), object: T.unsafe(nil), type: T.unsafe(nil), context: T.unsafe(nil)); end

  def object(); end

  def type(); end
end

class GraphQL::UnauthorizedError
end

class GraphQL::UnionType
  def dirty_possible_types(); end

  def get_possible_type(type_name, ctx); end

  def include?(child_type_defn); end

  def kind(); end

  def possible_type?(type, ctx); end

  def possible_types(); end

  def possible_types=(new_possible_types); end

  def resolve_type=(new_resolve_type_proc); end

  def resolve_type_proc(); end

  def resolve_type_proc=(resolve_type_proc); end
end

class GraphQL::UnionType
end

class GraphQL::UnresolvedTypeError
  def field(); end

  def initialize(value, field, parent_type, resolved_type, possible_types); end

  def parent_type(); end

  def possible_types(); end

  def resolved_type(); end

  def value(); end
end

class GraphQL::UnresolvedTypeError
end

module GraphQL
  extend ::T::Sig
  def self.parse(graphql_string, tracer: T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_with_racc(string, filename: T.unsafe(nil), tracer: T.unsafe(nil)); end

  def self.scan(graphql_string); end

  def self.scan_with_ragel(graphql_string); end
end

module Graphlient
  VERSION = ::T.let(nil, ::T.untyped)
end

module Graphlient::Adapters
end

module Graphlient::Adapters::HTTP
end

class Graphlient::Adapters::HTTP::Adapter
  def execute(*_); end

  def headers(); end

  def initialize(url, options=T.unsafe(nil), &_block); end

  def options(); end

  def options=(options); end

  def url(); end

  def url=(url); end
end

class Graphlient::Adapters::HTTP::Adapter
end

class Graphlient::Adapters::HTTP::FaradayAdapter
  def connection(); end

  def execute(document:, operation_name:, variables:, context:); end
end

class Graphlient::Adapters::HTTP::FaradayAdapter
end

class Graphlient::Adapters::HTTP::HTTPAdapter
  def connection(); end

  def execute(document:, operation_name: T.unsafe(nil), variables: T.unsafe(nil), context: T.unsafe(nil)); end

  def uri(); end
end

class Graphlient::Adapters::HTTP::HTTPAdapter
end

module Graphlient::Adapters::HTTP
  extend ::T::Sig
end

module Graphlient::Adapters
  extend ::T::Sig
end

class Graphlient::Client
  def execute(query, variables=T.unsafe(nil)); end

  def http(&block); end

  def http_adapter_class(); end

  def initialize(url, options=T.unsafe(nil), &_block); end

  def options(); end

  def options=(options); end

  def parse(&block); end

  def query(query_or_variables=T.unsafe(nil), variables=T.unsafe(nil), &block); end

  def schema(); end

  def uri(); end

  def uri=(uri); end
end

class Graphlient::Client
end

module Graphlient::Errors
end

class Graphlient::Errors::ClientError
end

class Graphlient::Errors::ClientError
end

class Graphlient::Errors::Error
  def initialize(message, inner_exception=T.unsafe(nil)); end

  def inner_exception(); end
end

class Graphlient::Errors::Error
end

class Graphlient::Errors::ExecutionError
  def errors(); end

  def initialize(response); end

  def response(); end
end

class Graphlient::Errors::ExecutionError
end

class Graphlient::Errors::FaradayServerError
  def initialize(inner_exception); end
end

class Graphlient::Errors::FaradayServerError
end

class Graphlient::Errors::GraphQLError
  def errors(); end

  def initialize(response); end

  def responsee(); end
end

class Graphlient::Errors::GraphQLError
end

class Graphlient::Errors::HttpServerError
  def initialize(message, response); end

  def response(); end

  def status_code(); end
end

class Graphlient::Errors::HttpServerError
end

class Graphlient::Errors::ServerError
  def response(); end

  def status_code(); end
end

class Graphlient::Errors::ServerError
end

module Graphlient::Errors
  extend ::T::Sig
end

module Graphlient::Extensions
end

module Graphlient::Extensions::Query
  def method_missing(method_name, *args, &block); end
end

module Graphlient::Extensions::Query
  extend ::T::Sig
end

module Graphlient::Extensions
  extend ::T::Sig
end

class Graphlient::Query
  def initialize(&block); end

  def method_missing(method_name, *args, &block); end

  def mutation(*args, &block); end

  def query(*args, &block); end

  def query_str(); end

  def query_str=(query_str); end

  def subscription(*args, &block); end
  ROOT_NODES = ::T.let(nil, ::T.untyped)
  SCALAR_TYPES = ::T.let(nil, ::T.untyped)
end

class Graphlient::Query
end

class Graphlient::Schema
  def dump!(); end

  def graphql_schema(); end

  def http(); end

  def initialize(http, path); end

  def path(); end
  PATH_ERROR_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Graphlient::Schema::MissingConfigurationError
end

class Graphlient::Schema::MissingConfigurationError
end

class Graphlient::Schema
end

module Graphlient
  extend ::T::Sig
end

module Gravity
  extend ::T::Sig
end

module HTTP
  CHARSET_RE = ::T.let(nil, ::T.untyped)
  MIME_TYPE_RE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module HTTP::Chainable
  def accept(type); end

  def auth(value); end

  def basic_auth(opts); end

  def connect(uri, options=T.unsafe(nil)); end

  def cookies(cookies); end

  def default_options(); end

  def default_options=(opts); end

  def delete(uri, options=T.unsafe(nil)); end

  def encoding(encoding); end

  def follow(opts=T.unsafe(nil)); end

  def get(uri, options=T.unsafe(nil)); end

  def head(uri, options=T.unsafe(nil)); end

  def headers(headers); end

  def nodelay(); end

  def options(uri, options=T.unsafe(nil)); end

  def patch(uri, options=T.unsafe(nil)); end

  def persistent(host, timeout: T.unsafe(nil)); end

  def post(uri, options=T.unsafe(nil)); end

  def put(uri, options=T.unsafe(nil)); end

  def request(verb, uri, options=T.unsafe(nil)); end

  def through(*proxy); end

  def timeout(klass, options=T.unsafe(nil)); end

  def trace(uri, options=T.unsafe(nil)); end

  def use(*features); end

  def via(*proxy); end
end

module HTTP::Chainable
  extend ::T::Sig
end

class HTTP::Client
  include ::HTTP::Chainable
  def __perform__(req, options); end

  def close(); end

  def initialize(default_options=T.unsafe(nil)); end

  def perform(request, options); end

  def persistent?(*args, &block); end

  def request(verb, uri, opts=T.unsafe(nil)); end

  def webmock_enabled?(); end
  HTTP_OR_HTTPS_RE = ::T.let(nil, ::T.untyped)
end

class HTTP::Client
  extend ::Forwardable
end

class HTTP::Connection
  def close(); end

  def expired?(); end

  def failed_proxy_connect?(); end

  def finish_response(); end

  def headers(*args, &block); end

  def http_version(*args, &block); end

  def initialize(req, options); end

  def keep_alive?(); end

  def proxy_response_headers(); end

  def read_headers!(); end

  def readpartial(size=T.unsafe(nil)); end

  def send_request(req); end

  def status_code(*args, &block); end
  BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  HTTP_1_0 = ::T.let(nil, ::T.untyped)
  HTTP_1_1 = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
end

class HTTP::Connection
  extend ::Forwardable
end

class HTTP::ConnectionError
end

class HTTP::ConnectionError
end

class HTTP::ContentType
  def charset(); end

  def charset=(_); end

  def mime_type(); end

  def mime_type=(_); end
end

class HTTP::ContentType
  def self.[](*_); end

  def self.members(); end

  def self.parse(str); end
end

class HTTP::Cookie
  include ::Comparable
  def acceptable?(); end

  def acceptable_from_uri?(uri); end

  def accessed_at(); end

  def accessed_at=(accessed_at); end

  def cookie_value(); end

  def created_at(); end

  def created_at=(created_at); end

  def domain(); end

  def domain=(domain); end

  def domain_name(); end

  def dot_domain(); end

  def encode_with(coder); end

  def expire!(); end

  def expired?(time=T.unsafe(nil)); end

  def expires(); end

  def expires=(t); end

  def expires_at(); end

  def expires_at=(t); end

  def for_domain(); end

  def for_domain=(for_domain); end

  def for_domain?(); end

  def httponly(); end

  def httponly=(httponly); end

  def httponly?(); end

  def init_with(coder); end

  def initialize(*args); end

  def max_age(); end

  def max_age=(sec); end

  def name(); end

  def name=(name); end

  def origin(); end

  def origin=(origin); end

  def path(); end

  def path=(path); end

  def secure(); end

  def secure=(secure); end

  def secure?(); end

  def session(); end

  def session?(); end

  def set_cookie_value(); end

  def to_yaml_properties(); end

  def valid_for_uri?(uri); end

  def value(); end

  def value=(value); end

  def yaml_initialize(tag, map); end
  MAX_COOKIES_PER_DOMAIN = ::T.let(nil, ::T.untyped)
  MAX_COOKIES_TOTAL = ::T.let(nil, ::T.untyped)
  MAX_LENGTH = ::T.let(nil, ::T.untyped)
  PERSISTENT_PROPERTIES = ::T.let(nil, ::T.untyped)
  UNIX_EPOCH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class HTTP::Cookie::Scanner
  def initialize(string, logger=T.unsafe(nil)); end

  def parse_cookie_date(s); end

  def scan_cookie(); end

  def scan_dquoted(); end

  def scan_name(); end

  def scan_name_value(comma_as_separator=T.unsafe(nil)); end

  def scan_set_cookie(); end

  def scan_value(comma_as_separator=T.unsafe(nil)); end

  def skip_wsp(); end
  RE_BAD_CHAR = ::T.let(nil, ::T.untyped)
  RE_COOKIE_COMMA = ::T.let(nil, ::T.untyped)
  RE_NAME = ::T.let(nil, ::T.untyped)
  RE_WSP = ::T.let(nil, ::T.untyped)
end

class HTTP::Cookie::Scanner
  def self.quote(s); end
end

class HTTP::Cookie
  def self.cookie_value(cookies); end

  def self.cookie_value_to_hash(cookie_value); end

  def self.parse(set_cookie, origin, options=T.unsafe(nil), &block); end

  def self.path_match?(base_path, target_path); end
end

class HTTP::CookieJar
  include ::Enumerable
  def <<(cookie); end

  def add(cookie); end

  def cleanup(session=T.unsafe(nil)); end

  def clear(); end

  def cookies(url=T.unsafe(nil)); end

  def delete(cookie); end

  def each(uri=T.unsafe(nil), &block); end

  def empty?(url=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def load(readable, *options); end

  def parse(set_cookie, origin, options=T.unsafe(nil)); end

  def save(writable, *options); end

  def store(); end
end

class HTTP::CookieJar
  def self.const_missing(name); end
end

class HTTP::Error
end

class HTTP::Error
end

class HTTP::Feature
  def initialize(opts=T.unsafe(nil)); end
end

class HTTP::Feature
end

module HTTP::Features
end

class HTTP::Features::AutoDeflate
  def deflate(headers, body); end

  def initialize(*_); end

  def method(); end
end

class HTTP::Features::AutoDeflate
end

class HTTP::Features::AutoInflate
  def stream_for(connection, response); end
end

class HTTP::Features::AutoInflate
end

module HTTP::Features
  extend ::T::Sig
end

module HTTP::FormData
  CRLF = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class HTTP::FormData::Error
end

class HTTP::FormData::Error
end

class HTTP::FormData::File
  def initialize(file_or_io, opts=T.unsafe(nil)); end

  def mime_type(); end
  DEFAULT_MIME = ::T.let(nil, ::T.untyped)
end

class HTTP::FormData::File
end

class HTTP::FormData::Multipart
  def content_length(); end

  def content_type(); end

  def initialize(data); end
end

class HTTP::FormData::Multipart::Param
  def initialize(name, value); end

  def size(); end
end

class HTTP::FormData::Multipart::Param
  def self.coerce(data); end
end

class HTTP::FormData::Multipart
end

class HTTP::FormData::Part
  def content_type(); end

  def filename(); end

  def initialize(body, opts=T.unsafe(nil)); end

  def size(); end
end

class HTTP::FormData::Part
end

class HTTP::FormData::Urlencoded
  def content_length(); end

  def content_type(); end

  def initialize(data); end
end

class HTTP::FormData::Urlencoded
end

module HTTP::FormData
  extend ::T::Sig
  def self.create(data); end

  def self.ensure_hash(obj); end
end

class HTTP::Headers
  include ::Enumerable
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def add(name, value); end

  def delete(name); end

  def each(); end

  def empty?(*args, &block); end

  def get(name); end

  def hash(*args, &block); end

  def include?(name); end

  def keys(); end

  def merge(other); end

  def merge!(other); end

  def set(name, value); end

  def to_a(); end

  def to_h(); end

  def to_hash(); end
  ACCEPT = ::T.let(nil, ::T.untyped)
  AGE = ::T.let(nil, ::T.untyped)
  AUTHORIZATION = ::T.let(nil, ::T.untyped)
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CANONICAL_NAME_RE = ::T.let(nil, ::T.untyped)
  COMPLIANT_NAME_RE = ::T.let(nil, ::T.untyped)
  CONNECTION = ::T.let(nil, ::T.untyped)
  CONTENT_ENCODING = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  COOKIE = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  EXPIRES = ::T.let(nil, ::T.untyped)
  HOST = ::T.let(nil, ::T.untyped)
  IF_MODIFIED_SINCE = ::T.let(nil, ::T.untyped)
  IF_NONE_MATCH = ::T.let(nil, ::T.untyped)
  LAST_MODIFIED = ::T.let(nil, ::T.untyped)
  LOCATION = ::T.let(nil, ::T.untyped)
  PROXY_AUTHORIZATION = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
  VARY = ::T.let(nil, ::T.untyped)
end

module HTTP::Headers::Mixin
  def [](*args, &block); end

  def []=(*args, &block); end

  def headers(); end
end

module HTTP::Headers::Mixin
  extend ::Forwardable
  extend ::T::Sig
end

class HTTP::Headers
  extend ::Forwardable
  def self.[](object); end

  def self.coerce(object); end
end

class HTTP::InvalidHeaderNameError
end

class HTTP::InvalidHeaderNameError
end

module HTTP::MimeType
end

class HTTP::MimeType::Adapter
  include ::Singleton
  def decode(*_); end

  def encode(*_); end
end

class HTTP::MimeType::Adapter
  extend ::Singleton::SingletonClassMethods
  def self.decode(*args, &block); end

  def self.encode(*args, &block); end

  def self.instance(); end
end

class HTTP::MimeType::JSON
  def decode(str); end

  def encode(obj); end
end

class HTTP::MimeType::JSON
end

module HTTP::MimeType
  extend ::T::Sig
  def self.[](type); end

  def self.normalize(type); end

  def self.register_adapter(type, adapter); end

  def self.register_alias(type, shortcut); end
end

class HTTP::Options
  def []=(option, val); end

  def body(); end

  def body=(body); end

  def cookies(); end

  def cookies=(cookies); end

  def encoding(); end

  def encoding=(encoding); end

  def feature(name); end

  def features(); end

  def features=(features); end

  def follow(); end

  def follow=(value); end

  def form(); end

  def form=(form); end

  def headers(); end

  def headers=(headers); end

  def initialize(options=T.unsafe(nil)); end

  def json(); end

  def json=(json); end

  def keep_alive_timeout(); end

  def keep_alive_timeout=(keep_alive_timeout); end

  def merge(other); end

  def nodelay(); end

  def nodelay=(nodelay); end

  def params(); end

  def params=(params); end

  def persistent(); end

  def persistent=(value); end

  def persistent?(); end

  def proxy(); end

  def proxy=(proxy); end

  def response(); end

  def response=(response); end

  def socket_class(); end

  def socket_class=(socket_class); end

  def ssl(); end

  def ssl=(ssl); end

  def ssl_context(); end

  def ssl_context=(ssl_context); end

  def ssl_socket_class(); end

  def ssl_socket_class=(ssl_socket_class); end

  def timeout_class(); end

  def timeout_class=(timeout_class); end

  def timeout_options(); end

  def timeout_options=(timeout_options); end

  def to_hash(); end

  def with_body(value); end

  def with_cookies(value); end

  def with_encoding(value); end

  def with_features(value); end

  def with_follow(value); end

  def with_form(value); end

  def with_headers(value); end

  def with_json(value); end

  def with_keep_alive_timeout(value); end

  def with_nodelay(value); end

  def with_params(value); end

  def with_persistent(value); end

  def with_proxy(value); end

  def with_response(value); end

  def with_socket_class(value); end

  def with_ssl(value); end

  def with_ssl_context(value); end

  def with_ssl_socket_class(value); end

  def with_timeout_class(value); end

  def with_timeout_options(value); end
end

class HTTP::Options
  def self.available_features(); end

  def self.def_option(name, &interpreter); end

  def self.default_socket_class(); end

  def self.default_socket_class=(default_socket_class); end

  def self.default_ssl_socket_class(); end

  def self.default_ssl_socket_class=(default_ssl_socket_class); end

  def self.default_timeout_class(); end

  def self.default_timeout_class=(default_timeout_class); end

  def self.defined_options(); end

  def self.new(options=T.unsafe(nil)); end
end

class HTTP::Parser
  def <<(_); end

  def header_value_type(); end

  def header_value_type=(header_value_type); end

  def headers(); end

  def http_major(); end

  def http_method(); end

  def http_minor(); end

  def http_version(); end

  def initialize(*_); end

  def keep_alive?(); end

  def on_body=(on_body); end

  def on_headers_complete=(on_headers_complete); end

  def on_message_begin=(on_message_begin); end

  def on_message_complete=(on_message_complete); end

  def request_url(); end

  def reset!(); end

  def status_code(); end

  def upgrade?(); end

  def upgrade_data(); end
end

class HTTP::Parser::Error
end

class HTTP::Parser::Error
end

class HTTP::Parser
  def self.default_header_value_type(); end

  def self.default_header_value_type=(val); end

  def self.strict?(); end
end

class HTTP::Redirector
  def initialize(opts=T.unsafe(nil)); end

  def max_hops(); end

  def perform(request, response); end

  def strict(); end
  REDIRECT_CODES = ::T.let(nil, ::T.untyped)
  SEE_OTHER_ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  STRICT_SENSITIVE_CODES = ::T.let(nil, ::T.untyped)
  UNSAFE_VERBS = ::T.let(nil, ::T.untyped)
end

class HTTP::Redirector::EndlessRedirectError
end

class HTTP::Redirector::EndlessRedirectError
end

class HTTP::Redirector::TooManyRedirectsError
end

class HTTP::Redirector::TooManyRedirectsError
end

class HTTP::Redirector
end

class HTTP::Request
  include ::HTTP::Headers::Mixin
  def body(); end

  def connect_using_proxy(socket); end

  def headline(); end

  def host(*args, &block); end

  def include_proxy_authorization_header(); end

  def include_proxy_headers(); end

  def initialize(opts); end

  def proxy(); end

  def proxy_authorization_header(); end

  def proxy_connect_header(); end

  def proxy_connect_headers(); end

  def redirect(uri, verb=T.unsafe(nil)); end

  def scheme(); end

  def socket_host(); end

  def socket_port(); end

  def stream(socket); end

  def uri(); end

  def using_authenticated_proxy?(); end

  def using_proxy?(); end

  def verb(); end

  def version(); end

  def webmock_signature(); end
  METHODS = ::T.let(nil, ::T.untyped)
  PORTS = ::T.let(nil, ::T.untyped)
  SCHEMES = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
end

class HTTP::Request::UnsupportedMethodError
end

class HTTP::Request::UnsupportedMethodError
end

class HTTP::Request::UnsupportedSchemeError
end

class HTTP::Request::UnsupportedSchemeError
end

class HTTP::Request::Writer
  def add_body_type_headers(); end

  def add_headers(); end

  def connect_through_proxy(); end

  def initialize(socket, body, headers, headline); end

  def join_headers(); end

  def send_request(); end

  def stream(); end
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNKED_END = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  VALID_BODY_TYPES = ::T.let(nil, ::T.untyped)
  ZERO = ::T.let(nil, ::T.untyped)
end

class HTTP::Request::Writer
end

class HTTP::Request
  extend ::Forwardable
end

class HTTP::RequestError
end

class HTTP::RequestError
end

class HTTP::RequestParser
end

class HTTP::RequestParser
end

class HTTP::Response
  include ::HTTP::Headers::Mixin
  def body(); end

  def charset(*args, &block); end

  def code(*args, &block); end

  def connection(*args, &block); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def flush(); end

  def initialize(opts); end

  def mime_type(*args, &block); end

  def parse(as=T.unsafe(nil)); end

  def proxy_headers(); end

  def readpartial(*args, &block); end

  def reason(*args, &block); end

  def status(); end

  def to_a(); end

  def to_s(*args, &block); end

  def to_str(*args, &block); end

  def to_webmock(); end

  def uri(); end
end

class HTTP::Response::Body
  include ::Enumerable
  def connection(); end

  def each(); end

  def empty?(*args, &block); end

  def initialize(stream, encoding=T.unsafe(nil)); end

  def readpartial(*args); end

  def stream!(); end

  def to_str(); end
end

class HTTP::Response::Body
  extend ::Forwardable
end

class HTTP::Response::Inflater
  def connection(); end

  def initialize(connection); end

  def readpartial(*args); end
end

class HTTP::Response::Inflater
end

class HTTP::Response::Parser
  def <<(data); end

  def add(data); end

  def chunk(); end

  def finished?(); end

  def headers(); end

  def headers?(); end

  def http_version(); end

  def on_body(chunk); end

  def on_headers_complete(headers); end

  def on_message_complete(); end

  def reset(); end

  def status_code(); end
end

class HTTP::Response::Parser
end

class HTTP::Response::Status
  def accepted?(); end

  def already_reported?(); end

  def bad_gateway?(); end

  def bad_request?(); end

  def client_error?(); end

  def code(); end

  def conflict?(); end

  def continue?(); end

  def created?(); end

  def expectation_failed?(); end

  def failed_dependency?(); end

  def forbidden?(); end

  def found?(); end

  def gateway_timeout?(); end

  def gone?(); end

  def http_version_not_supported?(); end

  def im_used?(); end

  def informational?(); end

  def inspect(); end

  def insufficient_storage?(); end

  def internal_server_error?(); end

  def length_required?(); end

  def locked?(); end

  def loop_detected?(); end

  def method_not_allowed?(); end

  def misdirected_request?(); end

  def moved_permanently?(); end

  def multi_status?(); end

  def multiple_choices?(); end

  def network_authentication_required?(); end

  def no_content?(); end

  def non_authoritative_information?(); end

  def not_acceptable?(); end

  def not_extended?(); end

  def not_found?(); end

  def not_implemented?(); end

  def not_modified?(); end

  def ok?(); end

  def partial_content?(); end

  def payload_too_large?(); end

  def payment_required?(); end

  def permanent_redirect?(); end

  def precondition_failed?(); end

  def precondition_required?(); end

  def processing?(); end

  def proxy_authentication_required?(); end

  def range_not_satisfiable?(); end

  def reason(); end

  def redirect?(); end

  def request_header_fields_too_large?(); end

  def request_timeout?(); end

  def reset_content?(); end

  def see_other?(); end

  def server_error?(); end

  def service_unavailable?(); end

  def success?(); end

  def switching_protocols?(); end

  def temporary_redirect?(); end

  def to_s(); end

  def to_sym(); end

  def too_many_requests?(); end

  def unauthorized?(); end

  def unavailable_for_legal_reasons?(); end

  def unprocessable_entity?(); end

  def unsupported_media_type?(); end

  def upgrade_required?(); end

  def uri_too_long?(); end

  def use_proxy?(); end

  def variant_also_negotiates?(); end
  REASONS = ::T.let(nil, ::T.untyped)
  SYMBOLS = ::T.let(nil, ::T.untyped)
  SYMBOL_CODES = ::T.let(nil, ::T.untyped)
end

class HTTP::Response::Status
  def self.[](object); end

  def self.coerce(object); end
end

class HTTP::Response::Streamer
  def close(); end

  def initialize(str); end

  def readpartial(size=T.unsafe(nil)); end

  def sequence_id(); end
end

class HTTP::Response::Streamer
end

class HTTP::Response
  extend ::Forwardable
  def self.from_webmock(webmock_response, request_signature=T.unsafe(nil)); end
end

class HTTP::ResponseError
end

class HTTP::ResponseError
end

class HTTP::ResponseParser
end

class HTTP::ResponseParser
end

class HTTP::StateError
end

class HTTP::StateError
end

module HTTP::Timeout
end

class HTTP::Timeout::Global
  def reset_counter(); end

  def time_left(); end

  def total_timeout(); end
end

class HTTP::Timeout::Global
end

class HTTP::Timeout::Null
  def <<(data); end

  def close(*args, &block); end

  def closed?(*args, &block); end

  def connect(socket_class, host, port, nodelay=T.unsafe(nil)); end

  def connect_ssl(); end

  def initialize(options=T.unsafe(nil)); end

  def options(); end

  def readpartial(size); end

  def socket(); end

  def start_tls(host, ssl_socket_class, ssl_context); end

  def write(data); end
end

class HTTP::Timeout::Null
  extend ::Forwardable
end

class HTTP::Timeout::PerOperation
  def connect_timeout(); end

  def initialize(*args); end

  def read_timeout(); end

  def write_timeout(); end
  CONNECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  READ_TIMEOUT = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class HTTP::Timeout::PerOperation
end

module HTTP::Timeout
  extend ::T::Sig
end

class HTTP::TimeoutError
end

class HTTP::TimeoutError
end

class HTTP::URI
  def ==(other); end

  def authority(*args, &block); end

  def authority=(*args, &block); end

  def eql?(other); end

  def fragment(*args, &block); end

  def fragment=(*args, &block); end

  def host(*args, &block); end

  def host=(*args, &block); end

  def http?(); end

  def https?(); end

  def initialize(options_or_uri=T.unsafe(nil)); end

  def join(*args, &block); end

  def normalize(*args, &block); end

  def normalized_authority(*args, &block); end

  def normalized_fragment(*args, &block); end

  def normalized_host(*args, &block); end

  def normalized_password(*args, &block); end

  def normalized_path(*args, &block); end

  def normalized_port(*args, &block); end

  def normalized_query(*args, &block); end

  def normalized_scheme(*args, &block); end

  def normalized_user(*args, &block); end

  def omit(*args, &block); end

  def origin(*args, &block); end

  def origin=(*args, &block); end

  def password(*args, &block); end

  def password=(*args, &block); end

  def path(*args, &block); end

  def path=(*args, &block); end

  def port(); end

  def port=(*args, &block); end

  def query(*args, &block); end

  def query=(*args, &block); end

  def request_uri(*args, &block); end

  def request_uri=(*args, &block); end

  def scheme(*args, &block); end

  def scheme=(*args, &block); end

  def to_str(); end

  def user(*args, &block); end

  def user=(*args, &block); end
  HTTPS_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_SCHEME = ::T.let(nil, ::T.untyped)
end

class HTTP::URI
  extend ::Forwardable
  def self.form_encode(form_values, sort=T.unsafe(nil)); end

  def self.parse(uri); end
end

class HTTP::WebMockPerform
  def exec(); end

  def halt(); end

  def initialize(request, &perform); end

  def invoke_callbacks(webmock_response, options=T.unsafe(nil)); end

  def perform(); end

  def raise_timeout_error(); end

  def register_request(signature); end

  def replay(); end

  def request_signature(); end

  def response_for_request(signature); end
end

class HTTP::WebMockPerform
end

module HTTP
  extend ::HTTP::Chainable
  extend ::T::Sig
  def self.[](headers); end
end

class Hash
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <(_); end

  def <=(_); end

  def >(_); end

  def >=(_); end

  def assert_valid_keys(*valid_keys); end

  def compact(); end

  def compact!(); end

  def deep_merge(other_hash, &block); end

  def deep_merge!(other_hash, &block); end

  def deep_stringify_keys(); end

  def deep_stringify_keys!(); end

  def deep_symbolize_keys(); end

  def deep_symbolize_keys!(); end

  def deep_transform_keys(&block); end

  def deep_transform_keys!(&block); end

  def default_proc(); end

  def default_proc=(default_proc); end

  def dig(*_); end

  def except(*keys); end

  def except!(*keys); end

  def extract!(*keys); end

  def extractable_options?(); end

  def fetch_values(*_); end

  def flatten(*_); end

  def index(_); end

  def merge!(_); end

  def nested_under_indifferent_access(); end

  def replace(_); end

  def reverse_merge(other_hash); end

  def reverse_merge!(other_hash); end

  def reverse_update(other_hash); end

  def slice(*_); end

  def slice!(*keys); end

  def stringify_keys(); end

  def stringify_keys!(); end

  def symbolize_keys(); end

  def symbolize_keys!(); end

  def to_h(); end

  def to_options(); end

  def to_options!(); end

  def to_param(namespace=T.unsafe(nil)); end

  def to_proc(); end

  def to_query(namespace=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def transform_keys(); end

  def transform_keys!(); end

  def transform_values(); end

  def transform_values!(); end

  def update(_); end

  def with_defaults(other_hash); end

  def with_defaults!(other_hash); end

  def with_indifferent_access(); end
end

class Hash
  extend ::T::Sig
  def self.from_trusted_xml(xml); end

  def self.from_xml(xml, disallowed_types=T.unsafe(nil)); end

  def self.try_convert(_); end
end

module HashDiff
  VERSION = ::T.let(nil, ::T.untyped)
end

class HashDiff::LinearCompareArray
  def call(); end

  def initialize(old_array, new_array, options); end
end

class HashDiff::LinearCompareArray
  def self.call(old_array, new_array, options=T.unsafe(nil)); end
end

module HashDiff
  extend ::T::Sig
  def self.best_diff(obj1, obj2, options=T.unsafe(nil), &block); end

  def self.comparable?(obj1, obj2, strict=T.unsafe(nil)); end

  def self.compare_values(obj1, obj2, options=T.unsafe(nil)); end

  def self.count_diff(diffs); end

  def self.count_nodes(obj); end

  def self.custom_compare(method, key, obj1, obj2); end

  def self.decode_property_path(path, delimiter=T.unsafe(nil)); end

  def self.diff(obj1, obj2, options=T.unsafe(nil), &block); end

  def self.diff_array_lcs(a, b, options=T.unsafe(nil)); end

  def self.lcs(a, b, options=T.unsafe(nil)); end

  def self.node(hash, parts); end

  def self.patch!(obj, changes, options=T.unsafe(nil)); end

  def self.prefix_append_array_index(prefix, array_index, opts); end

  def self.prefix_append_key(prefix, key, opts); end

  def self.similar?(a, b, options=T.unsafe(nil)); end

  def self.unpatch!(obj, changes, options=T.unsafe(nil)); end
end

HashWithIndifferentAccess = ActiveSupport::HashWithIndifferentAccess

module Hashie
  VERSION = ::T.let(nil, ::T.untyped)
end

class Hashie::Array
  include ::Hashie::Extensions::Array::PrettyInspect
  include ::Hashie::Extensions::RubyVersionCheck
  def array_inspect(); end

  def dig(*indexes); end
end

class Hashie::Array
end

module Hashie::Extensions
end

module Hashie::Extensions::Array
end

module Hashie::Extensions::Array::PrettyInspect
  def hashie_inspect(); end
end

module Hashie::Extensions::Array::PrettyInspect
  extend ::T::Sig
  def self.included(base); end
end

module Hashie::Extensions::Array
  extend ::T::Sig
end

module Hashie::Extensions::PrettyInspect
  def hashie_inspect(); end
end

module Hashie::Extensions::PrettyInspect
  extend ::T::Sig
  def self.included(base); end
end

class Hashie::Extensions::RubyVersion
  include ::Comparable
  def initialize(version); end

  def segments(); end

  def segments=(segments); end
end

class Hashie::Extensions::RubyVersion
end

module Hashie::Extensions::RubyVersionCheck
end

module Hashie::Extensions::RubyVersionCheck
  extend ::T::Sig
  def self.included(base); end
end

module Hashie::Extensions::StringifyKeys
  def stringify_keys(); end

  def stringify_keys!(); end
end

module Hashie::Extensions::StringifyKeys::ClassMethods
  def stringify_keys(hash); end

  def stringify_keys!(hash); end

  def stringify_keys_recursively!(object); end
end

module Hashie::Extensions::StringifyKeys::ClassMethods
  extend ::T::Sig
end

module Hashie::Extensions::StringifyKeys
  extend ::Hashie::Extensions::StringifyKeys::ClassMethods
  extend ::T::Sig
end

module Hashie::Extensions
  extend ::T::Sig
end

class Hashie::Hash
  include ::Hashie::Extensions::PrettyInspect
  include ::Hashie::Extensions::StringifyKeys
  def hash_inspect(); end

  def to_hash(options=T.unsafe(nil)); end

  def to_json(*args); end

  def to_mash(); end
end

class Hashie::Hash
end

class Hashie::Mash
  include ::Hashie::Extensions::RubyVersionCheck
  def [](key); end

  def []=(key, value, convert=T.unsafe(nil)); end

  def assign_property(name, value); end

  def convert_key(key); end

  def convert_value(val, duping=T.unsafe(nil)); end

  def custom_reader(key); end

  def custom_writer(key, value, convert=T.unsafe(nil)); end

  def deep_merge(other_hash, &blk); end

  def deep_merge!(other_hash, &blk); end

  def deep_update(other_hash, &blk); end

  def delete(key); end

  def dig(*keys); end

  def fetch(key, *args); end

  def has_key?(key); end

  def include?(key); end

  def initialize(source_hash=T.unsafe(nil), default=T.unsafe(nil), &blk); end

  def initializing_reader(key); end

  def key?(key); end

  def member?(key); end

  def merge(other_hash, &blk); end

  def merge!(other_hash, &blk); end

  def method_missing(method_name, *args, &blk); end

  def method_name_and_suffix(method_name); end

  def method_suffix(method_name); end

  def prefix_method?(method_name); end

  def regular_dup(); end

  def regular_key?(_); end

  def regular_reader(_); end

  def regular_writer(_, _1); end

  def replace(other_hash); end

  def shallow_merge(other_hash); end

  def shallow_update(other_hash); end

  def to_module(mash_method_name=T.unsafe(nil)); end

  def underbang_reader(key); end

  def update(other_hash, &blk); end

  def values_at(*keys); end
  ALLOWED_SUFFIXES = ::T.let(nil, ::T.untyped)
end

class Hashie::Mash::CannotDisableMashWarnings
  def initialize(message=T.unsafe(nil)); end
end

class Hashie::Mash::CannotDisableMashWarnings
end

class Hashie::Mash
  def self.disable_warnings(); end

  def self.disable_warnings?(); end

  def self.inherited(subclass); end

  def self.load(path, options=T.unsafe(nil)); end
end

module Hashie::Utils
end

module Hashie::Utils
  extend ::T::Sig
  def self.method_information(bound_method); end
end

module Hashie
  extend ::T::Sig
  def self.logger(); end

  def self.logger=(logger); end
end

Http = HTTP

module I18n
  DEFAULT_INTERPOLATION_PATTERNS = ::T.let(nil, ::T.untyped)
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
  INTERPOLATION_PATTERN = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
  RESERVED_KEYS_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class I18n::ArgumentError
end

class I18n::ArgumentError
end

module I18n::Backend
end

module I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def deep_interpolate(locale, data, values=T.unsafe(nil)); end

  def default(locale, object, subject, options=T.unsafe(nil)); end

  def eager_load!(); end

  def eager_loaded?(); end

  def exists?(locale, key); end

  def interpolate(locale, subject, values=T.unsafe(nil)); end

  def load_file(filename); end

  def load_json(filename); end

  def load_rb(filename); end

  def load_translations(*filenames); end

  def load_yaml(filename); end

  def load_yml(filename); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralization_key(entry, count); end

  def pluralize(locale, entry, count); end

  def reload!(); end

  def resolve(locale, object, subject, options=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def translate_localization_format(locale, object, format, options); end
end

module I18n::Backend::Base
  extend ::T::Sig
end

module I18n::Backend::Cache
  def _fetch(cache_key, &block); end

  def cache_key(locale, key, options); end

  def fetch(cache_key, &block); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Cache
  extend ::T::Sig
end

module I18n::Backend::CacheFile
  def load_file(filename); end

  def normalized_path(file); end

  def path_roots(); end

  def path_roots=(path_roots); end
end

module I18n::Backend::CacheFile
  extend ::T::Sig
end

module I18n::Backend::Cascade
  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end
end

module I18n::Backend::Cascade
  extend ::T::Sig
end

class I18n::Backend::Chain
  include ::I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Chain::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def backends(); end

  def backends=(backends); end

  def eager_load!(); end

  def exists?(locale, key); end

  def init_translations(); end

  def initialize(*backends); end

  def initialized?(); end

  def localize(locale, object, format=T.unsafe(nil), options=T.unsafe(nil)); end

  def namespace_lookup?(result, options); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translate(locale, key, default_options=T.unsafe(nil)); end

  def translations(); end
end

module I18n::Backend::Chain::Implementation
  extend ::T::Sig
end

class I18n::Backend::Chain
end

module I18n::Backend::Fallbacks
  def exists?(locale, key); end

  def extract_non_symbol_default!(options); end

  def translate(locale, key, options=T.unsafe(nil)); end
end

module I18n::Backend::Fallbacks
  extend ::T::Sig
end

module I18n::Backend::Flatten
  def escape_default_separator(key); end

  def find_link(locale, key); end

  def flatten_keys(hash, escape, prev_key=T.unsafe(nil), &block); end

  def flatten_translations(locale, data, escape, subtree); end

  def links(); end

  def normalize_flat_keys(locale, key, scope, separator); end

  def resolve_link(locale, key); end

  def store_link(locale, key, link); end
  FLATTEN_SEPARATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR_ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::Flatten
  extend ::T::Sig
  def self.escape_default_separator(key); end

  def self.normalize_flat_keys(locale, key, scope, separator); end
end

module I18n::Backend::Gettext
  def load_po(filename); end

  def normalize(locale, data); end

  def normalize_pluralization(locale, key, value); end

  def parse(filename); end
end

class I18n::Backend::Gettext::PoData
  def set_comment(msgid_or_sym, comment); end
end

class I18n::Backend::Gettext::PoData
end

module I18n::Backend::Gettext
  extend ::T::Sig
end

module I18n::Backend::InterpolationCompiler
  def compile_all_strings_in(data); end

  def interpolate(locale, string, values); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::InterpolationCompiler::Compiler
  def compile_if_an_interpolation(string); end

  def compile_interpolation_token(key); end

  def compiled_interpolation_body(str); end

  def direct_key(key); end

  def escape_key_sym(key); end

  def escape_plain_str(str); end

  def handle_interpolation_token(interpolation, matchdata); end

  def interpolate_key(key); end

  def interpolate_or_raise_missing(key); end

  def interpolated_str?(str); end

  def missing_key(key); end

  def nil_key(key); end

  def reserved_key(key); end

  def tokenize(str); end
  INTERPOLATION_SYNTAX_PATTERN = ::T.let(nil, ::T.untyped)
  TOKENIZER = ::T.let(nil, ::T.untyped)
end

module I18n::Backend::InterpolationCompiler::Compiler
  extend ::I18n::Backend::InterpolationCompiler::Compiler
  extend ::T::Sig
end

module I18n::Backend::InterpolationCompiler
  extend ::T::Sig
end

class I18n::Backend::KeyValue
  include ::I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::KeyValue::Implementation
  include ::I18n::Backend::Flatten
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def init_translations(); end

  def initialize(store, subtrees=T.unsafe(nil)); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def store(); end

  def store=(store); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def subtrees?(); end

  def translations(); end
end

module I18n::Backend::KeyValue::Implementation
  extend ::T::Sig
end

class I18n::Backend::KeyValue::SubtreeProxy
  def [](key); end

  def has_key?(key); end

  def initialize(master_key, store); end

  def instance_of?(klass); end

  def is_a?(klass); end

  def kind_of?(klass); end
end

class I18n::Backend::KeyValue::SubtreeProxy
end

class I18n::Backend::KeyValue
end

module I18n::Backend::Memoize
  def available_locales(); end

  def eager_load!(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def memoized_lookup(); end

  def reload!(); end

  def reset_memoizations!(locale=T.unsafe(nil)); end

  def store_translations(locale, data, options=T.unsafe(nil)); end
end

module I18n::Backend::Memoize
  extend ::T::Sig
end

module I18n::Backend::Metadata
  def interpolate(locale, entry, values=T.unsafe(nil)); end

  def pluralize(locale, entry, count); end

  def translate(locale, key, options=T.unsafe(nil)); end

  def with_metadata(metadata, &block); end
end

module I18n::Backend::Metadata
  extend ::T::Sig
  def self.included(base); end
end

module I18n::Backend::Pluralization
  def pluralize(locale, entry, count); end

  def pluralizer(locale); end

  def pluralizers(); end
end

module I18n::Backend::Pluralization
  extend ::T::Sig
end

class I18n::Backend::Simple
  include ::I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
end

module I18n::Backend::Simple::Implementation
  include ::I18n::Backend::Base
  include ::I18n::Backend::Transliterator
  def available_locales(); end

  def eager_load!(); end

  def init_translations(); end

  def initialized?(); end

  def lookup(locale, key, scope=T.unsafe(nil), options=T.unsafe(nil)); end

  def reload!(); end

  def store_translations(locale, data, options=T.unsafe(nil)); end

  def translations(do_init: T.unsafe(nil)); end
end

module I18n::Backend::Simple::Implementation
  extend ::T::Sig
end

class I18n::Backend::Simple
end

module I18n::Backend::Transliterator
  def transliterate(locale, string, replacement=T.unsafe(nil)); end
  DEFAULT_REPLACEMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
  def initialize(rule=T.unsafe(nil)); end

  def transliterate(string, replacement=T.unsafe(nil)); end
  DEFAULT_APPROXIMATIONS = ::T.let(nil, ::T.untyped)
end

class I18n::Backend::Transliterator::HashTransliterator
end

class I18n::Backend::Transliterator::ProcTransliterator
  def initialize(rule); end

  def transliterate(string, replacement=T.unsafe(nil)); end
end

class I18n::Backend::Transliterator::ProcTransliterator
end

module I18n::Backend::Transliterator
  extend ::T::Sig
  def self.get(rule=T.unsafe(nil)); end
end

module I18n::Backend
  extend ::T::Sig
end

module I18n::Base
  def available_locales(); end

  def available_locales=(value); end

  def available_locales_initialized?(); end

  def backend(); end

  def backend=(value); end

  def config(); end

  def config=(value); end

  def default_locale(); end

  def default_locale=(value); end

  def default_separator(); end

  def default_separator=(value); end

  def eager_load!(); end

  def enforce_available_locales(); end

  def enforce_available_locales!(locale); end

  def enforce_available_locales=(value); end

  def exception_handler(); end

  def exception_handler=(value); end

  def exists?(key, _locale=T.unsafe(nil), locale: T.unsafe(nil)); end

  def l(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def load_path(); end

  def load_path=(value); end

  def locale(); end

  def locale=(value); end

  def locale_available?(locale); end

  def localize(object, locale: T.unsafe(nil), format: T.unsafe(nil), **options); end

  def normalize_keys(locale, key, scope, separator=T.unsafe(nil)); end

  def reload!(); end

  def t(key=T.unsafe(nil), *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def t!(key, options=T.unsafe(nil)); end

  def translate(key=T.unsafe(nil), *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), **options); end

  def translate!(key, options=T.unsafe(nil)); end

  def transliterate(key, *_, throw: T.unsafe(nil), raise: T.unsafe(nil), locale: T.unsafe(nil), replacement: T.unsafe(nil), **options); end

  def with_locale(tmp_locale=T.unsafe(nil)); end
end

module I18n::Base
  extend ::T::Sig
end

class I18n::Config
  def available_locales(); end

  def available_locales=(locales); end

  def available_locales_initialized?(); end

  def available_locales_set(); end

  def backend(); end

  def backend=(backend); end

  def clear_available_locales_set(); end

  def default_locale(); end

  def default_locale=(locale); end

  def default_separator(); end

  def default_separator=(separator); end

  def enforce_available_locales(); end

  def enforce_available_locales=(enforce_available_locales); end

  def exception_handler(); end

  def exception_handler=(exception_handler); end

  def interpolation_patterns(); end

  def interpolation_patterns=(interpolation_patterns); end

  def load_path(); end

  def load_path=(load_path); end

  def locale(); end

  def locale=(locale); end

  def missing_interpolation_argument_handler(); end

  def missing_interpolation_argument_handler=(exception_handler); end
end

class I18n::Config
end

class I18n::Disabled
  def initialize(method); end
end

class I18n::Disabled
end

class I18n::ExceptionHandler
  def call(exception, _locale, _key, _options); end
end

class I18n::ExceptionHandler
end

module I18n::Gettext
  CONTEXT_SEPARATOR = ::T.let(nil, ::T.untyped)
  PLURAL_SEPARATOR = ::T.let(nil, ::T.untyped)
end

module I18n::Gettext::Helpers
  def N_(msgsid); end

  def _(msgid, options=T.unsafe(nil)); end

  def gettext(msgid, options=T.unsafe(nil)); end

  def n_(msgid, msgid_plural, n=T.unsafe(nil)); end

  def ngettext(msgid, msgid_plural, n=T.unsafe(nil)); end

  def np_(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def npgettext(msgctxt, msgid, msgid_plural, n=T.unsafe(nil)); end

  def ns_(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def nsgettext(msgid, msgid_plural, n=T.unsafe(nil), separator=T.unsafe(nil)); end

  def p_(msgctxt, msgid); end

  def pgettext(msgctxt, msgid); end

  def s_(msgid, separator=T.unsafe(nil)); end

  def sgettext(msgid, separator=T.unsafe(nil)); end
end

module I18n::Gettext::Helpers
  extend ::T::Sig
end

module I18n::Gettext
  extend ::T::Sig
  def self.extract_scope(msgid, separator); end

  def self.plural_keys(*args); end
end

module I18n::HashRefinements
end

module I18n::HashRefinements
  extend ::T::Sig
end

class I18n::InvalidLocale
  def initialize(locale); end

  def locale(); end
end

class I18n::InvalidLocale
end

class I18n::InvalidLocaleData
  def filename(); end

  def initialize(filename, exception_message); end
end

class I18n::InvalidLocaleData
end

class I18n::InvalidPluralizationData
  def count(); end

  def entry(); end

  def initialize(entry, count, key); end

  def key(); end
end

class I18n::InvalidPluralizationData
end

module I18n::Locale
end

class I18n::Locale::Fallbacks
  def [](locale); end

  def compute(tags, include_defaults=T.unsafe(nil), exclude=T.unsafe(nil)); end

  def defaults(); end

  def defaults=(defaults); end

  def initialize(*mappings); end

  def map(mappings); end
end

class I18n::Locale::Fallbacks
end

module I18n::Locale::Tag
  RFC4646_FORMATS = ::T.let(nil, ::T.untyped)
  RFC4646_SUBTAGS = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Parents
  def parent(); end

  def parents(); end

  def self_and_parents(); end
end

module I18n::Locale::Tag::Parents
  extend ::T::Sig
end

class I18n::Locale::Tag::Rfc4646
  include ::I18n::Locale::Tag::Parents
  def to_sym(); end
end

module I18n::Locale::Tag::Rfc4646::Parser
  PATTERN = ::T.let(nil, ::T.untyped)
end

module I18n::Locale::Tag::Rfc4646::Parser
  extend ::T::Sig
  def self.match(tag); end
end

class I18n::Locale::Tag::Rfc4646
  def self.parser(); end

  def self.parser=(parser); end

  def self.tag(tag); end
end

class I18n::Locale::Tag::Simple
  include ::I18n::Locale::Tag::Parents
  def initialize(*tag); end

  def subtags(); end

  def tag(); end

  def to_a(); end

  def to_sym(); end
end

class I18n::Locale::Tag::Simple
  def self.tag(tag); end
end

module I18n::Locale::Tag
  extend ::T::Sig
  def self.implementation(); end

  def self.implementation=(implementation); end

  def self.tag(tag); end
end

module I18n::Locale
  extend ::T::Sig
end

class I18n::Middleware
  def call(env); end

  def initialize(app); end
end

class I18n::Middleware
end

class I18n::MissingInterpolationArgument
  def initialize(key, values, string); end

  def key(); end

  def string(); end

  def values(); end
end

class I18n::MissingInterpolationArgument
end

class I18n::MissingTranslation
  include ::I18n::MissingTranslation::Base
end

module I18n::MissingTranslation::Base
  def initialize(locale, key, options=T.unsafe(nil)); end

  def key(); end

  def keys(); end

  def locale(); end

  def message(); end

  def options(); end

  def to_exception(); end

  def to_s(); end
end

module I18n::MissingTranslation::Base
  extend ::T::Sig
end

class I18n::MissingTranslation
end

class I18n::MissingTranslationData
  include ::I18n::MissingTranslation::Base
end

class I18n::MissingTranslationData
end

class I18n::Railtie
end

class I18n::Railtie
  def self.include_fallbacks_module(); end

  def self.init_fallbacks(fallbacks); end

  def self.initialize_i18n(app); end

  def self.validate_fallbacks(fallbacks); end

  def self.watched_dirs_with_extensions(paths); end
end

class I18n::ReservedInterpolationKey
  def initialize(key, string); end

  def key(); end

  def string(); end
end

class I18n::ReservedInterpolationKey
end

module I18n::Tests
end

module I18n::Tests::Localization
end

module I18n::Tests::Localization
  extend ::T::Sig
  def self.included(base); end
end

module I18n::Tests
  extend ::T::Sig
end

class I18n::UnknownFileType
  def filename(); end

  def initialize(type, filename); end

  def type(); end
end

class I18n::UnknownFileType
end

module I18n
  extend ::I18n::Base
  extend ::T::Sig
  def self.cache_key_digest(); end

  def self.cache_key_digest=(key_digest); end

  def self.cache_namespace(); end

  def self.cache_namespace=(namespace); end

  def self.cache_store(); end

  def self.cache_store=(store); end

  def self.fallbacks(); end

  def self.fallbacks=(fallbacks); end

  def self.interpolate(string, values); end

  def self.interpolate_hash(string, values); end

  def self.new_double_nested_cache(); end

  def self.perform_caching?(); end
end

class IO
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def beep(); end

  def cooked(); end

  def cooked!(); end

  def cursor(); end

  def cursor=(); end

  def echo=(echo); end

  def echo?(); end

  def external_encoding(); end

  def getch(*_); end

  def getpass(*_); end

  def goto(); end

  def iflush(); end

  def ioflush(); end

  def noecho(); end

  def nonblock(*_); end

  def nonblock=(nonblock); end

  def nonblock?(); end

  def nread(); end

  def oflush(); end

  def pathconf(_); end

  def pread(*_); end

  def pressed?(); end

  def pwrite(_, _1); end

  def raw(*_); end

  def raw!(*_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end

  def winsize(); end

  def winsize=(winsize); end

  def write_nonblock(buf, exception: T.unsafe(nil)); end
end

class IO::EAGAINWaitReadable
  extend ::T::Sig
end

class IO::EAGAINWaitWritable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitReadable
  extend ::T::Sig
end

class IO::EINPROGRESSWaitWritable
  extend ::T::Sig
end

IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable

module IO::WaitReadable
  extend ::T::Sig
end

module IO::WaitWritable
  extend ::T::Sig
end

class IO
  extend ::T::Sig
  def self.console(*_); end

  def self.foreach(*_); end

  def self.open(*_); end

  def self.pipe(*_); end

end

class IOError
  extend ::T::Sig
end

class IPAddr
  include ::Comparable
  def &(other); end

  def <<(num); end

  def ==(other); end

  def ===(other); end

  def >>(num); end

  def eql?(other); end

  def family(); end

  def hton(); end

  def include?(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end

  def ip6_arpa(); end

  def ip6_int(); end

  def ipv4?(); end

  def ipv4_compat(); end

  def ipv4_compat?(); end

  def ipv4_mapped(); end

  def ipv4_mapped?(); end

  def ipv6?(); end

  def link_local?(); end

  def loopback?(); end

  def mask(prefixlen); end

  def mask!(mask); end

  def native(); end

  def prefix(); end

  def prefix=(prefix); end

  def private?(); end

  def reverse(); end

  def set(addr, *family); end

  def succ(); end

  def to_i(); end

  def to_range(); end

  def to_string(); end

  def |(other); end

  def ~(); end
  IN4MASK = ::T.let(nil, ::T.untyped)
  IN6FORMAT = ::T.let(nil, ::T.untyped)
  IN6MASK = ::T.let(nil, ::T.untyped)
  RE_IPV4ADDRLIKE = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_COMPRESSED = ::T.let(nil, ::T.untyped)
  RE_IPV6ADDRLIKE_FULL = ::T.let(nil, ::T.untyped)
end

class IPAddr::AddressFamilyError
end

class IPAddr::AddressFamilyError
end

class IPAddr::Error
end

class IPAddr::Error
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidAddressError
end

class IPAddr::InvalidPrefixError
end

class IPAddr::InvalidPrefixError
end

class IPAddr
  def self.new_ntoh(addr); end

  def self.ntop(addr); end
end

class IPSocket
  extend ::T::Sig
end

module IRB
  IRBRC_EXT = ::T.let(nil, ::T.untyped)
  MagicFile = ::T.let(nil, ::T.untyped)
  STDIN_FILE_NAME = ::T.let(nil, ::T.untyped)
end

class IRB::Abort
end

class IRB::Abort
end

class IRB::Context
  def __exit__(*_); end

  def __inspect__(); end

  def __to_s__(); end

  def ap_name(); end

  def ap_name=(ap_name); end

  def auto_indent_mode(); end

  def auto_indent_mode=(auto_indent_mode); end

  def back_trace_limit(); end

  def back_trace_limit=(back_trace_limit); end

  def debug?(); end

  def debug_level(); end

  def debug_level=(value); end

  def echo(); end

  def echo=(echo); end

  def echo?(); end

  def eval_history=(*opts, &b); end

  def evaluate(line, line_no); end

  def exit(ret=T.unsafe(nil)); end

  def file_input?(); end

  def ignore_eof(); end

  def ignore_eof=(ignore_eof); end

  def ignore_eof?(); end

  def ignore_sigint(); end

  def ignore_sigint=(ignore_sigint); end

  def ignore_sigint?(); end

  def initialize(irb, workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def inspect?(); end

  def inspect_last_value(); end

  def inspect_mode(); end

  def inspect_mode=(opt); end

  def io(); end

  def io=(io); end

  def irb(); end

  def irb=(irb); end

  def irb_name(); end

  def irb_name=(irb_name); end

  def irb_path(); end

  def irb_path=(irb_path); end

  def last_value(); end

  def load_modules(); end

  def load_modules=(load_modules); end

  def main(); end

  def prompt_c(); end

  def prompt_c=(prompt_c); end

  def prompt_i(); end

  def prompt_i=(prompt_i); end

  def prompt_mode(); end

  def prompt_mode=(mode); end

  def prompt_n(); end

  def prompt_n=(prompt_n); end

  def prompt_s(); end

  def prompt_s=(prompt_s); end

  def prompting?(); end

  def rc(); end

  def rc=(rc); end

  def rc?(); end

  def return_format(); end

  def return_format=(return_format); end

  def save_history=(*opts, &b); end

  def set_last_value(value); end

  def thread(); end

  def use_loader=(*opts, &b); end

  def use_readline(); end

  def use_readline=(opt); end

  def use_readline?(); end

  def use_tracer=(*opts, &b); end

  def verbose(); end

  def verbose=(verbose); end

  def verbose?(); end

  def workspace(); end

  def workspace=(workspace); end

  def workspace_home(); end
  IDNAME_IVARS = ::T.let(nil, ::T.untyped)
  NOPRINTING_IVARS = ::T.let(nil, ::T.untyped)
  NO_INSPECTING_IVARS = ::T.let(nil, ::T.untyped)
end

class IRB::Context
end

module IRB::ContextExtender
end

IRB::ContextExtender::CE = IRB::ContextExtender

module IRB::ContextExtender
  extend ::T::Sig
  def self.def_extend_command(cmd_name, load_file, *aliases); end

  def self.install_extend_commands(); end
end

class IRB::DefaultEncodings
  def external(); end

  def external=(_); end

  def internal(); end

  def internal=(_); end
end

class IRB::DefaultEncodings
  def self.[](*_); end

  def self.members(); end
end

module IRB::ExtendCommandBundle
  def install_alias_method(to, from, override=T.unsafe(nil)); end

  def irb(*opts, &b); end

  def irb_change_workspace(*opts, &b); end

  def irb_context(); end

  def irb_current_working_workspace(*opts, &b); end

  def irb_exit(ret=T.unsafe(nil)); end

  def irb_fg(*opts, &b); end

  def irb_help(*opts, &b); end

  def irb_jobs(*opts, &b); end

  def irb_kill(*opts, &b); end

  def irb_load(*opts, &b); end

  def irb_pop_workspace(*opts, &b); end

  def irb_push_workspace(*opts, &b); end

  def irb_require(*opts, &b); end

  def irb_source(*opts, &b); end

  def irb_workspaces(*opts, &b); end
  NO_OVERRIDE = ::T.let(nil, ::T.untyped)
  OVERRIDE_ALL = ::T.let(nil, ::T.untyped)
  OVERRIDE_PRIVATE_ONLY = ::T.let(nil, ::T.untyped)
end

IRB::ExtendCommandBundle::EXCB = IRB::ExtendCommandBundle

module IRB::ExtendCommandBundle
  extend ::T::Sig
  def self.def_extend_command(cmd_name, cmd_class, load_file=T.unsafe(nil), *aliases); end

  def self.extend_object(obj); end

  def self.install_extend_commands(); end

  def self.irb_original_method_name(method_name); end
end

class IRB::FileInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(file); end
end

class IRB::FileInputMethod
end

class IRB::InputMethod
  def file_name(); end

  def gets(); end

  def initialize(file=T.unsafe(nil)); end

  def prompt(); end

  def prompt=(prompt); end

  def readable_after_eof?(); end
end

class IRB::InputMethod
end

class IRB::Inspector
  def init(); end

  def initialize(inspect_proc, init_proc=T.unsafe(nil)); end

  def inspect_value(v); end
  INSPECTORS = ::T.let(nil, ::T.untyped)
end

class IRB::Inspector
  def self.def_inspector(key, arg=T.unsafe(nil), &block); end

  def self.keys_with_inspector(inspector); end
end

class IRB::Irb
  def context(); end

  def eval_input(); end

  def initialize(workspace=T.unsafe(nil), input_method=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def output_value(); end

  def prompt(prompt, ltype, indent, line_no); end

  def run(conf=T.unsafe(nil)); end

  def scanner(); end

  def scanner=(scanner); end

  def signal_handle(); end

  def signal_status(status); end

  def suspend_context(context); end

  def suspend_input_method(input_method); end

  def suspend_name(path=T.unsafe(nil), name=T.unsafe(nil)); end

  def suspend_workspace(workspace); end
  ATTR_PLAIN = ::T.let(nil, ::T.untyped)
  ATTR_TTY = ::T.let(nil, ::T.untyped)
end

class IRB::Irb
end

class IRB::Locale
  def String(mes); end

  def encoding(); end

  def find(file, paths=T.unsafe(nil)); end

  def format(*opts); end

  def gets(*rs); end

  def initialize(locale=T.unsafe(nil)); end

  def lang(); end

  def load(file, priv=T.unsafe(nil)); end

  def modifier(); end

  def print(*opts); end

  def printf(*opts); end

  def puts(*opts); end

  def readline(*rs); end

  def require(file, priv=T.unsafe(nil)); end

  def territory(); end
  LOCALE_DIR = ::T.let(nil, ::T.untyped)
  LOCALE_NAME_RE = ::T.let(nil, ::T.untyped)
end

class IRB::Locale
end

module IRB::MethodExtender
  def def_post_proc(base_method, extend_method); end

  def def_pre_proc(base_method, extend_method); end

  def new_alias_name(name, prefix=T.unsafe(nil), postfix=T.unsafe(nil)); end
end

module IRB::MethodExtender
  extend ::T::Sig
end

module IRB::Notifier
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end
  D_NOMSG = ::T.let(nil, ::T.untyped)
end

class IRB::Notifier::AbstractNotifier
  def exec_if(); end

  def initialize(prefix, base_notifier); end

  def notify?(); end

  def ppx(prefix, *objs); end

  def prefix(); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::Notifier::AbstractNotifier
end

class IRB::Notifier::CompositeNotifier
  def def_notifier(level, prefix=T.unsafe(nil)); end

  def level(); end

  def level=(value); end

  def level_notifier(); end

  def level_notifier=(value); end

  def notifiers(); end
end

class IRB::Notifier::CompositeNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUndefinedNotifier
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::ErrUnrecognizedLevel
end

class IRB::Notifier::LeveledNotifier
  include ::Comparable
  def initialize(base, level, prefix); end

  def level(); end
end

class IRB::Notifier::LeveledNotifier
end

class IRB::Notifier::NoMsgNotifier
  def initialize(); end
end

class IRB::Notifier::NoMsgNotifier
end

module IRB::Notifier
  extend ::Exception2MessageMapper
  extend ::T::Sig
  def self.def_notifier(prefix=T.unsafe(nil), output_method=T.unsafe(nil)); end

  def self.included(mod); end
end

class IRB::OutputMethod
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def parse_printf_format(format, opts); end

  def ppx(prefix, *objs); end

  def print(*opts); end

  def printf(format, *opts); end

  def printn(*opts); end

  def puts(*objs); end
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod::NotImplementedError
end

class IRB::OutputMethod
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::ReadlineInputMethod
  include ::Readline
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::ReadlineInputMethod
end

class IRB::SLex
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def create(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def def_rule(token, preproc=T.unsafe(nil), postproc=T.unsafe(nil), &block); end

  def def_rules(*tokens, &block); end

  def match(token); end

  def postproc(token); end

  def preproc(token, proc); end

  def search(token); end
  DOUT = ::T.let(nil, ::T.untyped)
  D_DEBUG = ::T.let(nil, ::T.untyped)
  D_DETAIL = ::T.let(nil, ::T.untyped)
  D_WARN = ::T.let(nil, ::T.untyped)
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeAlreadyExists
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::ErrNodeNothing
end

class IRB::SLex::Node
  def create_subnode(chrs, preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def initialize(preproc=T.unsafe(nil), postproc=T.unsafe(nil)); end

  def match(chrs, op=T.unsafe(nil)); end

  def match_io(io, op=T.unsafe(nil)); end

  def postproc(); end

  def postproc=(postproc); end

  def preproc(); end

  def preproc=(preproc); end

  def search(chrs, opt=T.unsafe(nil)); end
end

class IRB::SLex::Node
end

class IRB::SLex
  extend ::Exception2MessageMapper
  def self.included(mod); end
end

class IRB::StdioInputMethod
  def encoding(); end

  def eof?(); end

  def initialize(); end

  def line(line_no); end
end

class IRB::StdioInputMethod
end

class IRB::StdioOutputMethod
end

class IRB::StdioOutputMethod
end

class IRB::WorkSpace
  def code_around_binding(); end

  def evaluate(context, statements, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def filter_backtrace(bt); end

  def initialize(*main); end

  def main(); end
end

class IRB::WorkSpace
end

module IRB
  extend ::T::Sig
  def self.CurrentContext(); end

  def self.Inspector(inspect, init=T.unsafe(nil)); end

  def self.conf(); end

  def self.default_src_encoding(); end

  def self.delete_caller(); end

  def self.init_config(ap_path); end

  def self.init_error(); end

  def self.irb_abort(irb, exception=T.unsafe(nil)); end

  def self.irb_at_exit(); end

  def self.irb_exit(irb, ret); end

  def self.load_modules(); end

  def self.parse_opts(argv: T.unsafe(nil)); end

  def self.rc_file(ext=T.unsafe(nil)); end

  def self.rc_file_generators(); end

  def self.run_config(); end

  def self.setup(ap_path, argv: T.unsafe(nil)); end

  def self.start(ap_path=T.unsafe(nil)); end

  def self.version(); end
end

class IndexError
  extend ::T::Sig
end

module InheritedResources
  ACTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module InheritedResources::Actions
  def create(options=T.unsafe(nil), &block); end

  def create!(options=T.unsafe(nil), &block); end

  def destroy(options=T.unsafe(nil), &block); end

  def destroy!(options=T.unsafe(nil), &block); end

  def edit(options=T.unsafe(nil), &block); end

  def edit!(options=T.unsafe(nil), &block); end

  def index(options=T.unsafe(nil), &block); end

  def index!(options=T.unsafe(nil), &block); end

  def new(options=T.unsafe(nil), &block); end

  def new!(options=T.unsafe(nil), &block); end

  def show(options=T.unsafe(nil), &block); end

  def show!(options=T.unsafe(nil), &block); end

  def update(options=T.unsafe(nil), &block); end

  def update!(options=T.unsafe(nil), &block); end
end

module InheritedResources::Actions
  extend ::T::Sig
end

class InheritedResources::Base
  include ::InheritedResources::Actions
  include ::InheritedResources::BaseHelpers
  def parents_symbols(); end

  def parents_symbols?(); end

  def resource_class(); end

  def resource_class?(); end

  def resources_configuration(); end

  def resources_configuration?(); end
end

class InheritedResources::Base
  extend ::InheritedResources::ClassMethods
  extend ::InheritedResources::UrlHelpers
  def self.inherit_resources(base); end

  def self.parents_symbols(); end

  def self.parents_symbols=(val); end

  def self.parents_symbols?(); end

  def self.resource_class(); end

  def self.resource_class=(val); end

  def self.resource_class?(); end

  def self.resources_configuration(); end

  def self.resources_configuration=(val); end

  def self.resources_configuration?(); end
end

module InheritedResources::BaseHelpers
  def association_chain(); end

  def begin_of_association_chain(); end

  def build_resource(); end

  def collection(); end

  def create_resource(object); end

  def destroy_resource(object); end

  def parent?(); end

  def resource(); end

  def update_resource(object, attributes); end
end

module InheritedResources::BaseHelpers
  extend ::T::Sig
end

module InheritedResources::BelongsToHelpers
  def parent(); end

  def parent?(); end

  def parent_type(); end
end

module InheritedResources::BelongsToHelpers
  extend ::T::Sig
end

class InheritedResources::BlankSlate
  def method_missing(*args); end
end

class InheritedResources::BlankSlate
end

module InheritedResources::ClassMethods
  def actions(*actions_to_keep); end

  def belongs_to(*symbols, &block); end

  def custom_actions(options); end

  def defaults(options); end

  def nested_belongs_to(*symbols, &block); end

  def optional_belongs_to(*symbols, &block); end

  def polymorphic_belongs_to(*symbols, &block); end

  def singleton_belongs_to(*symbols, &block); end

  def with_role(role); end

  def without_protection(flag); end
end

module InheritedResources::ClassMethods
  extend ::T::Sig
end

module InheritedResources::DSL
end

module InheritedResources::DSL
  extend ::T::Sig
  def self.included(base); end
end

module InheritedResources::PolymorphicHelpers
  def parent(); end

  def parent?(); end

  def parent_class(); end

  def parent_type(); end
end

module InheritedResources::PolymorphicHelpers
  extend ::T::Sig
end

class InheritedResources::Railtie
end

class InheritedResources::Railtie
end

class InheritedResources::Responder
  include ::Responders::FlashResponder
end

class InheritedResources::Responder
end

module InheritedResources::ShallowHelpers
end

module InheritedResources::ShallowHelpers
  extend ::T::Sig
end

module InheritedResources::SingletonHelpers
  def collection(); end

  def resource(); end
end

module InheritedResources::SingletonHelpers
  extend ::T::Sig
end

module InheritedResources::UrlHelpers
  def create_resources_url_helpers!(); end

  def generate_url_and_path_helpers(prefix, name, resource_segments, resource_ivars); end

  def handle_shallow_resource(prefix, name, segments, ivars); end
end

module InheritedResources::UrlHelpers
  extend ::T::Sig
end

module InheritedResources
  extend ::T::Sig
  def self.flash_keys=(array); end
end

class Inputs::FulfillmentAttributes
  def courier(); end

  def estimated_delivery(); end

  def notes(); end

  def tracking_id(); end
end

class Inputs::ShippingAttributes
  def address_line1(); end

  def address_line2(); end

  def city(); end

  def country(); end

  def name(); end

  def phone_number(); end

  def postal_code(); end

  def region(); end
end

module Inputs
  extend ::T::Sig
end

class Integer
  include ::ActiveSupport::NumericWithFormat
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
  def allbits?(_); end

  def anybits?(_); end

  def digits(*_); end

  def month(); end

  def months(); end

  def multiple_of?(number); end

  def nobits?(_); end

  def ordinal(); end

  def ordinalize(); end

  def pow(*_); end

  def to_bn(); end

  def to_d(); end

  def year(); end

  def years(); end
  GMP_VERSION = ::T.let(nil, ::T.untyped)
end

class Integer
  extend ::T::Sig
  def self.sqrt(_); end
end

class Interrupt
  extend ::T::Sig
end

class JSON::CircularDatastructure
  extend ::T::Sig
end

module JSON::Ext
end

module JSON::Ext::Generator
end

module JSON::Ext::Generator::GeneratorMethods
end

module JSON::Ext::Generator::GeneratorMethods::Array
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Array
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::FalseClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Float
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Float
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Hash
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Integer
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Integer
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::NilClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::Object
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::Object
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::String
  def to_json(*_); end

  def to_json_raw(*_); end

  def to_json_raw_object(); end
end

module JSON::Ext::Generator::GeneratorMethods::String
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  def to_json(*_); end
end

module JSON::Ext::Generator::GeneratorMethods::TrueClass
  extend ::T::Sig
end

module JSON::Ext::Generator::GeneratorMethods
  extend ::T::Sig
end

class JSON::Ext::Generator::State
  def [](_); end

  def []=(_, _1); end

  def allow_nan?(); end

  def array_nl(); end

  def array_nl=(array_nl); end

  def ascii_only?(); end

  def buffer_initial_length(); end

  def buffer_initial_length=(buffer_initial_length); end

  def check_circular?(); end

  def configure(_); end

  def depth(); end

  def depth=(depth); end

  def generate(_); end

  def indent(); end

  def indent=(indent); end

  def initialize(*_); end

  def max_nesting(); end

  def max_nesting=(max_nesting); end

  def merge(_); end

  def object_nl(); end

  def object_nl=(object_nl); end

  def space(); end

  def space=(space); end

  def space_before(); end

  def space_before=(space_before); end

  def to_h(); end

  def to_hash(); end
end

class JSON::Ext::Generator::State
  def self.from_state(_); end
end

module JSON::Ext::Generator
  extend ::T::Sig
end

class JSON::Ext::Parser
  def initialize(*_); end

  def parse(); end

  def source(); end
end

class JSON::Ext::Parser
end

module JSON::Ext
  extend ::T::Sig
end

class JSON::GeneratorError
  extend ::T::Sig
end

class JSON::GenericObject
  extend ::T::Sig
end

class JSON::JSONError
  extend ::T::Sig
end

class JSON::MissingUnicodeSupport
  extend ::T::Sig
end

class JSON::NestingError
  extend ::T::Sig
end

JSON::Parser = JSON::Ext::Parser

class JSON::ParserError
  extend ::T::Sig
end

JSON::State = JSON::Ext::Generator::State

JSON::UnparserError = JSON::GeneratorError

module JSON
  extend ::T::Sig
end

JSONTree = Psych::Visitors::JSONTree

module JWT
  include ::JWT::DefaultOptions
end

module JWT::Algos
end

module JWT::Algos::Ecdsa
  NAMED_CURVES = ::T.let(nil, ::T.untyped)
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Ecdsa
  extend ::T::Sig
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Eddsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Eddsa
  extend ::T::Sig
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Hmac
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Hmac
  extend ::T::Sig
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Rsa
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Rsa
  extend ::T::Sig
  def self.sign(to_sign); end

  def self.verify(to_verify); end
end

module JWT::Algos::Unsupported
  SUPPORTED = ::T.let(nil, ::T.untyped)
end

module JWT::Algos::Unsupported
  extend ::T::Sig
  def self.sign(*_); end

  def self.verify(*_); end
end

module JWT::Algos
  extend ::T::Sig
end

class JWT::Decode
  def decode_segments(); end

  def header(); end

  def initialize(jwt, verify); end

  def payload(); end

  def signature(); end
end

class JWT::Decode
  def self.base64url_decode(str); end
end

class JWT::DecodeError
end

class JWT::DecodeError
end

module JWT::DefaultOptions
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module JWT::DefaultOptions
  extend ::T::Sig
end

class JWT::Encode
  def algorithm(); end

  def header_fields(); end

  def initialize(payload, key, algorithm, header_fields); end

  def key(); end

  def payload(); end

  def segments(); end
end

class JWT::Encode
  def self.base64url_encode(str); end
end

class JWT::EncodeError
end

class JWT::EncodeError
end

class JWT::ExpiredSignature
end

class JWT::ExpiredSignature
end

class JWT::ImmatureSignature
end

class JWT::ImmatureSignature
end

class JWT::IncorrectAlgorithm
end

class JWT::IncorrectAlgorithm
end

class JWT::InvalidAudError
end

class JWT::InvalidAudError
end

class JWT::InvalidIatError
end

class JWT::InvalidIatError
end

class JWT::InvalidIssuerError
end

class JWT::InvalidIssuerError
end

class JWT::InvalidJtiError
end

class JWT::InvalidJtiError
end

class JWT::InvalidPayload
end

class JWT::InvalidPayload
end

class JWT::InvalidSubError
end

class JWT::InvalidSubError
end

module JWT::SecurityUtils
end

module JWT::SecurityUtils
  extend ::T::Sig
  def self.asn1_to_raw(signature, public_key); end

  def self.raw_to_asn1(signature, private_key); end

  def self.rbnacl_fixup(algorithm, key); end

  def self.secure_compare(left, right); end

  def self.verify_rsa(algorithm, public_key, signing_input, signature); end
end

module JWT::Signature
  def sign(algorithm, msg, key); end

  def verify(algorithm, key, signing_input, signature); end
  ALGOS = ::T.let(nil, ::T.untyped)
end

class JWT::Signature::ToSign
  def algorithm(); end

  def algorithm=(_); end

  def key(); end

  def key=(_); end

  def msg(); end

  def msg=(_); end
end

class JWT::Signature::ToSign
  def self.[](*_); end

  def self.members(); end
end

class JWT::Signature::ToVerify
  def algorithm(); end

  def algorithm=(_); end

  def public_key(); end

  def public_key=(_); end

  def signature(); end

  def signature=(_); end

  def signing_input(); end

  def signing_input=(_); end
end

class JWT::Signature::ToVerify
  def self.[](*_); end

  def self.members(); end
end

module JWT::Signature
  extend ::JWT::Signature
  extend ::T::Sig
end

class JWT::VerificationError
end

class JWT::VerificationError
end

class JWT::Verify
  def initialize(payload, options); end

  def verify_aud(); end

  def verify_expiration(); end

  def verify_iat(); end

  def verify_iss(); end

  def verify_jti(); end

  def verify_not_before(); end

  def verify_sub(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class JWT::Verify
  def self.verify_aud(payload, options); end

  def self.verify_claims(payload, options); end

  def self.verify_expiration(payload, options); end

  def self.verify_iat(payload, options); end

  def self.verify_iss(payload, options); end

  def self.verify_jti(payload, options); end

  def self.verify_not_before(payload, options); end

  def self.verify_sub(payload, options); end
end

module JWT
  extend ::T::Sig
  def self.allowed_algorithms(options); end

  def self.decode(jwt, key=T.unsafe(nil), verify=T.unsafe(nil), custom_options=T.unsafe(nil), &keyfinder); end

  def self.decode_verify_signature(key, header, payload, signature, signing_input, options, &keyfinder); end

  def self.encode(payload, key, algorithm=T.unsafe(nil), header_fields=T.unsafe(nil)); end

  def self.signature_algorithm_and_key(header, payload, key, &keyfinder); end
end

module JaroWinkler
  VERSION = ::T.let(nil, ::T.untyped)
end

class JaroWinkler::Error
end

class JaroWinkler::Error
end

class JaroWinkler::InvalidWeightError
end

class JaroWinkler::InvalidWeightError
end

module JaroWinkler
  extend ::T::Sig
  def self.distance(*_); end

  def self.jaro_distance(*_); end
end

module Jquery
end

module Jquery::Rails
  JQUERY_2_VERSION = ::T.let(nil, ::T.untyped)
  JQUERY_3_VERSION = ::T.let(nil, ::T.untyped)
  JQUERY_UJS_VERSION = ::T.let(nil, ::T.untyped)
  JQUERY_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Jquery::Rails::Engine
end

class Jquery::Rails::Engine
end

module Jquery::Rails
  extend ::T::Sig
end

module Jquery
  extend ::T::Sig
end

module Kaminari
end

module Kaminari::ActionViewExtension
end

module Kaminari::ActionViewExtension::LogSubscriberSilencer
  def render_partial(*_); end
end

module Kaminari::ActionViewExtension::LogSubscriberSilencer
  extend ::T::Sig
end

module Kaminari::ActionViewExtension
  extend ::T::Sig
end

module Kaminari::Actionview
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kaminari::Actionview
  extend ::T::Sig
end

module Kaminari::ActiveRecordExtension
end

module Kaminari::ActiveRecordExtension
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Kaminari::ActiveRecordModelExtension
end

module Kaminari::ActiveRecordModelExtension
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Kaminari::ActiveRecordRelationMethods
  def entry_name(options=T.unsafe(nil)); end

  def reset(); end

  def total_count(column_name=T.unsafe(nil), _options=T.unsafe(nil)); end

  def without_count(); end
end

module Kaminari::ActiveRecordRelationMethods
  extend ::T::Sig
end

module Kaminari::Activerecord
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kaminari::Activerecord
  extend ::T::Sig
end

class Kaminari::Config
  def default_per_page(); end

  def default_per_page=(default_per_page); end

  def left(); end

  def left=(left); end

  def max_pages(); end

  def max_pages=(max_pages); end

  def max_per_page(); end

  def max_per_page=(max_per_page); end

  def outer_window(); end

  def outer_window=(outer_window); end

  def page_method_name(); end

  def page_method_name=(page_method_name); end

  def param_name(); end

  def param_name=(param_name); end

  def params_on_first_page(); end

  def params_on_first_page=(params_on_first_page); end

  def right(); end

  def right=(right); end

  def window(); end

  def window=(window); end
end

class Kaminari::Config
end

module Kaminari::ConfigurationMethods
end

module Kaminari::ConfigurationMethods::ClassMethods
  def default_per_page(); end

  def max_pages(val=T.unsafe(nil)); end

  def max_pages_per(val); end

  def max_paginates_per(val); end

  def max_per_page(); end

  def paginates_per(val); end
end

module Kaminari::ConfigurationMethods::ClassMethods
  extend ::T::Sig
end

module Kaminari::ConfigurationMethods
  extend ::T::Sig
  def self.included(base); end
end

class Kaminari::Engine
end

class Kaminari::Engine
end

module Kaminari::Helpers
  PARAM_KEY_BLACKLIST = ::T.let(nil, ::T.untyped)
end

class Kaminari::Helpers::FirstPage
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::FirstPage
end

class Kaminari::Helpers::Gap
end

class Kaminari::Helpers::Gap
end

module Kaminari::Helpers::HelperMethods
  def link_to_next_page(scope, name, **options); end

  def link_to_prev_page(scope, name, **options); end

  def link_to_previous_page(scope, name, **options); end

  def page_entries_info(collection, entry_name: T.unsafe(nil)); end

  def paginate(scope, paginator_class: T.unsafe(nil), template: T.unsafe(nil), **options); end

  def path_to_next_page(scope, options=T.unsafe(nil)); end

  def path_to_prev_page(scope, options=T.unsafe(nil)); end

  def rel_next_prev_link_tags(scope, options=T.unsafe(nil)); end
end

module Kaminari::Helpers::HelperMethods
  extend ::T::Sig
end

class Kaminari::Helpers::LastPage
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::LastPage
end

module Kaminari::Helpers::Link
  def page(); end

  def to_s(locals=T.unsafe(nil)); end

  def url(); end
end

module Kaminari::Helpers::Link
  extend ::T::Sig
end

class Kaminari::Helpers::NextPage
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::NextPage
end

class Kaminari::Helpers::Page
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::Page
end

class Kaminari::Helpers::Paginator
  include ::ActionView::Context
  include ::ActionView::CompiledTemplates
  def each_page(); end

  def each_relevant_page(); end

  def first_page_tag(); end

  def gap_tag(); end

  def initialize(template, window: T.unsafe(nil), outer_window: T.unsafe(nil), left: T.unsafe(nil), right: T.unsafe(nil), inner_window: T.unsafe(nil), **options); end

  def last_page_tag(); end

  def next_page_tag(); end

  def page_tag(page); end

  def prev_page_tag(); end

  def render(&block); end

  def to_s(); end
end

class Kaminari::Helpers::Paginator::PageProxy
  include ::Comparable
  def +(other); end

  def -(other); end

  def current?(); end

  def display_tag?(); end

  def first?(); end

  def initialize(options, page, last); end

  def inside_window?(); end

  def last?(); end

  def left_outer?(); end

  def next?(); end

  def number(); end

  def out_of_range?(); end

  def prev?(); end

  def rel(); end

  def right_outer?(); end

  def single_gap?(); end

  def to_i(); end

  def was_truncated?(); end
end

class Kaminari::Helpers::Paginator::PageProxy
end

class Kaminari::Helpers::Paginator
end

class Kaminari::Helpers::PrevPage
  include ::Kaminari::Helpers::Link
end

class Kaminari::Helpers::PrevPage
end

class Kaminari::Helpers::Tag
  def initialize(template, params: T.unsafe(nil), param_name: T.unsafe(nil), theme: T.unsafe(nil), views_prefix: T.unsafe(nil), **options); end

  def page_url_for(page); end

  def to_s(locals=T.unsafe(nil)); end
end

class Kaminari::Helpers::Tag
end

module Kaminari::Helpers
  extend ::T::Sig
end

module Kaminari::PageScopeMethods
  def current_page(); end

  def current_per_page(); end

  def first_page?(); end

  def last_page?(); end

  def max_paginates_per(new_max_per_page); end

  def next_page(); end

  def out_of_range?(); end

  def padding(num); end

  def per(num, max_per_page: T.unsafe(nil)); end

  def prev_page(); end

  def total_pages(); end
end

module Kaminari::PageScopeMethods
  extend ::T::Sig
end

class Kaminari::PaginatableArray
  include ::Kaminari::ConfigurationMethods::ClassMethods
  def entry_name(options=T.unsafe(nil)); end

  def initialize(original_array=T.unsafe(nil), limit: T.unsafe(nil), offset: T.unsafe(nil), total_count: T.unsafe(nil), padding: T.unsafe(nil)); end

  def limit(num); end

  def limit_value(); end

  def limit_value=(limit_value); end

  def offset(num); end

  def offset_value(); end

  def offset_value=(offset_value); end

  def page(num=T.unsafe(nil)); end

  def total_count(); end
  ENTRY = ::T.let(nil, ::T.untyped)
end

class Kaminari::PaginatableArray
end

module Kaminari::PaginatableWithoutCount
  def last_page?(); end

  def load(); end

  def out_of_range?(); end

  def total_count(); end
end

module Kaminari::PaginatableWithoutCount
  extend ::T::Sig
end

class Kaminari::Railtie
end

class Kaminari::Railtie
end

class Kaminari::ZeroPerPageOperation
end

class Kaminari::ZeroPerPageOperation
end

module Kaminari
  extend ::T::Sig
  def self.config(); end

  def self.configure(); end

  def self.paginate_array(array, limit: T.unsafe(nil), offset: T.unsafe(nil), total_count: T.unsafe(nil), padding: T.unsafe(nil)); end
end

module Kernel
  def byebug(); end

  def class(); end

  def class_eval(*args, &block); end

  def debugger(); end

  def gem(dep, *reqs); end

  def itself(); end

  def object_id(); end

  def pretty_inspect(); end

  def remote_byebug(host=T.unsafe(nil), port=T.unsafe(nil)); end

  def respond_to?(*_); end

  def yield_self(); end
end

module Kernel
  extend ::T::Sig
  def self.`(_); end

  def self.at_exit(); end

  def self.load(*_); end

  def self.require(_); end
end

class KeyError
  include ::DidYouMean::Correctable
  def key(); end

  def receiver(); end
end

class KeyError
  extend ::T::Sig
end

module Kramdown
  VERSION = ::T.let(nil, ::T.untyped)
end

module Kramdown::Converter
end

class Kramdown::Converter::Base
  def apply_template_after?(); end

  def apply_template_before?(); end

  def basic_generate_id(str); end

  def convert(el); end

  def data(); end

  def extract_code_language(attr); end

  def extract_code_language!(attr); end

  def format_math(el, opts=T.unsafe(nil)); end

  def generate_id(str); end

  def highlight_code(text, lang, type, opts=T.unsafe(nil)); end

  def in_toc?(el); end

  def initialize(root, options); end

  def options(); end

  def output_header_level(level); end

  def root(); end

  def smart_quote_entity(el); end

  def warning(text); end

  def warnings(); end
  SMART_QUOTE_INDICES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Base
  def self.apply_template(converter, body); end

  def self.convert(tree, options=T.unsafe(nil)); end

  def self.get_template(template); end

  def self.get_template_new(template); end
end

class Kramdown::Converter::HashAST
end

class Kramdown::Converter::HashAST
end

Kramdown::Converter::HashAst = Kramdown::Converter::HashAST

class Kramdown::Converter::Html
  include ::Kramdown::Utils::Html
  include ::Kramdown::Parser::Html::Constants
  def add_syntax_highlighter_to_class_attr(attr, lang=T.unsafe(nil)); end

  def convert(el, indent=T.unsafe(nil)); end

  def convert_a(el, indent); end

  def convert_abbreviation(el, indent); end

  def convert_blank(el, indent); end

  def convert_blockquote(el, indent); end

  def convert_br(el, indent); end

  def convert_codeblock(el, indent); end

  def convert_codespan(el, indent); end

  def convert_comment(el, indent); end

  def convert_dd(el, indent); end

  def convert_dl(el, indent); end

  def convert_dt(el, indent); end

  def convert_em(el, indent); end

  def convert_entity(el, indent); end

  def convert_footnote(el, indent); end

  def convert_header(el, indent); end

  def convert_hr(el, indent); end

  def convert_html_element(el, indent); end

  def convert_img(el, indent); end

  def convert_li(el, indent); end

  def convert_math(el, indent); end

  def convert_ol(el, indent); end

  def convert_p(el, indent); end

  def convert_raw(el, indent); end

  def convert_root(el, indent); end

  def convert_smart_quote(el, indent); end

  def convert_strong(el, indent); end

  def convert_table(el, indent); end

  def convert_tbody(el, indent); end

  def convert_td(el, indent); end

  def convert_text(el, indent); end

  def convert_tfoot(el, indent); end

  def convert_thead(el, indent); end

  def convert_tr(el, indent); end

  def convert_typographic_sym(el, indent); end

  def convert_ul(el, indent); end

  def convert_xml_comment(el, indent); end

  def convert_xml_pi(el, indent); end

  def fix_for_toc_entry(elements); end

  def footnote_content(); end

  def format_as_block_html(name, attr, body, indent); end

  def format_as_indented_block_html(name, attr, body, indent); end

  def format_as_span_html(name, attr, body); end

  def generate_toc_tree(toc, type, attr); end

  def indent(); end

  def indent=(indent); end

  def inner(el, indent); end

  def obfuscate(text); end

  def remove_footnotes(elements); end

  def unwrap_links(elements); end
  DISPATCHER = ::T.let(nil, ::T.untyped)
  ENTITY_NBSP = ::T.let(nil, ::T.untyped)
  FOOTNOTE_BACKLINK_FMT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Html
end

class Kramdown::Converter::Kramdown
  include ::Kramdown::Utils::Html
  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, opts); end

  def convert_blank(el, opts); end

  def convert_blockquote(el, opts); end

  def convert_br(el, opts); end

  def convert_codeblock(el, opts); end

  def convert_codespan(el, opts); end

  def convert_comment(el, opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, opts); end

  def convert_footnote(el, opts); end

  def convert_header(el, opts); end

  def convert_hr(el, opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, opts); end

  def convert_li(el, opts); end

  def convert_math(el, opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, opts); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, opts); end

  def convert_xml_pi(el, opts); end

  def create_abbrev_defs(); end

  def create_footnote_defs(); end

  def create_link_defs(); end

  def ial_for_element(el); end

  def inner(el, opts=T.unsafe(nil)); end

  def parse_title(attr); end
  ESCAPED_CHAR_RE = ::T.let(nil, ::T.untyped)
  HTML_TAGS_WITH_BODY = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Kramdown
end

class Kramdown::Converter::Latex
  def attribute_list(el); end

  def convert(el, opts=T.unsafe(nil)); end

  def convert_a(el, opts); end

  def convert_abbreviation(el, opts); end

  def convert_blank(el, opts); end

  def convert_blockquote(el, opts); end

  def convert_br(el, opts); end

  def convert_codeblock(el, opts); end

  def convert_codespan(el, opts); end

  def convert_comment(el, opts); end

  def convert_dd(el, opts); end

  def convert_dl(el, opts); end

  def convert_dt(el, opts); end

  def convert_em(el, opts); end

  def convert_entity(el, opts); end

  def convert_footnote(el, opts); end

  def convert_header(el, opts); end

  def convert_hr(el, opts); end

  def convert_html_element(el, opts); end

  def convert_img(el, opts); end

  def convert_li(el, opts); end

  def convert_math(el, opts); end

  def convert_ol(el, opts); end

  def convert_p(el, opts); end

  def convert_raw(el, opts); end

  def convert_root(el, opts); end

  def convert_smart_quote(el, opts); end

  def convert_standalone_image(el, opts, img); end

  def convert_strong(el, opts); end

  def convert_table(el, opts); end

  def convert_tbody(el, opts); end

  def convert_td(el, opts); end

  def convert_text(el, opts); end

  def convert_tfoot(el, opts); end

  def convert_thead(el, opts); end

  def convert_tr(el, opts); end

  def convert_typographic_sym(el, opts); end

  def convert_ul(el, opts); end

  def convert_xml_comment(el, opts); end

  def convert_xml_pi(el, opts); end

  def entity_to_latex(entity); end

  def escape(str); end

  def inner(el, opts); end

  def latex_environment(type, el, text); end

  def latex_link_target(el, add_label=T.unsafe(nil)); end

  def normalize_abbreviation_key(key); end
  ENTITY_CONV_TABLE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE = ::T.let(nil, ::T.untyped)
  TABLE_ALIGNMENT_CHAR = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Latex
end

class Kramdown::Converter::Man
  def convert(el, opts=T.unsafe(nil)); end
  TABLE_CELL_ALIGNMENT = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_MAP = ::T.let(nil, ::T.untyped)
end

class Kramdown::Converter::Man
end

class Kramdown::Converter::RemoveHtmlTags
end

class Kramdown::Converter::RemoveHtmlTags
end

class Kramdown::Converter::Toc
end

class Kramdown::Converter::Toc
end

module Kramdown::Converter
  extend ::Kramdown::Utils::Configurable
  extend ::T::Sig
  def self.add_math_engine(data, *args, &block); end

  def self.add_syntax_highlighter(data, *args, &block); end

  def self.configurables(); end

  def self.math_engine(data); end

  def self.syntax_highlighter(data); end
end

class Kramdown::Document
  def initialize(source, options=T.unsafe(nil)); end

  def method_missing(id, *attr, &block); end

  def options(); end

  def root(); end

  def root=(root); end

  def try_require(type, name); end

  def warnings(); end
end

class Kramdown::Document
end

class Kramdown::Element
  def attr(); end

  def children(); end

  def children=(children); end

  def initialize(type, value=T.unsafe(nil), attr=T.unsafe(nil), options=T.unsafe(nil)); end

  def options(); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  CATEGORY = ::T.let(nil, ::T.untyped)
end

class Kramdown::Element
  def self.category(el); end
end

class Kramdown::Error
end

class Kramdown::Error
end

module Kramdown::Options
  ALLOWED_TYPES = ::T.let(nil, ::T.untyped)
end

class Kramdown::Options::Boolean
end

class Kramdown::Options::Boolean
  def self.===(other); end
end

class Kramdown::Options::Definition
  def default(); end

  def default=(_); end

  def desc(); end

  def desc=(_); end

  def name(); end

  def name=(_); end

  def type(); end

  def type=(_); end

  def validator(); end

  def validator=(_); end
end

class Kramdown::Options::Definition
  def self.[](*_); end

  def self.members(); end
end

module Kramdown::Options
  extend ::T::Sig
  def self.defaults(); end

  def self.define(name, type, default, desc, &block); end

  def self.defined?(name); end

  def self.definitions(); end

  def self.merge(hash); end

  def self.parse(name, data); end

  def self.simple_array_validator(val, name, size=T.unsafe(nil)); end

  def self.simple_hash_validator(val, name); end

  def self.str_to_sym(data); end
end

module Kramdown::Parser
end

class Kramdown::Parser::Base
  def adapt_source(source); end

  def add_text(text, tree=T.unsafe(nil), type=T.unsafe(nil)); end

  def extract_string(range, strscan); end

  def initialize(source, options); end

  def options(); end

  def parse(); end

  def root(); end

  def source(); end

  def warning(text); end

  def warnings(); end
end

class Kramdown::Parser::Base
  def self.parse(source, options=T.unsafe(nil)); end
end

class Kramdown::Parser::GFM
  def generate_gfm_header_id(text); end

  def parse_atx_header_gfm_quirk(); end

  def parse_strikethrough_gfm(); end

  def update_elements(element); end
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS_GFM = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  NON_WORD_RE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END_GFM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_DELIM = ::T.let(nil, ::T.untyped)
  STRIKETHROUGH_MATCH = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::GFM
end

class Kramdown::Parser::Html
  include ::Kramdown::Parser::Html::Parser
  include ::Kramdown::Parser::Html::Constants
end

module Kramdown::Parser::Html::Constants
  HTML_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_COMMENT_RE = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_BLOCK = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_RAW = ::T.let(nil, ::T.untyped)
  HTML_CONTENT_MODEL_SPAN = ::T.let(nil, ::T.untyped)
  HTML_DOCTYPE_RE = ::T.let(nil, ::T.untyped)
  HTML_ELEMENT = ::T.let(nil, ::T.untyped)
  HTML_ELEMENTS_WITHOUT_BODY = ::T.let(nil, ::T.untyped)
  HTML_ENTITY_RE = ::T.let(nil, ::T.untyped)
  HTML_INSTRUCTION_RE = ::T.let(nil, ::T.untyped)
  HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  HTML_TAG_CLOSE_RE = ::T.let(nil, ::T.untyped)
  HTML_TAG_RE = ::T.let(nil, ::T.untyped)
end

module Kramdown::Parser::Html::Constants
  extend ::T::Sig
end

class Kramdown::Parser::Html::ElementConverter
  include ::Kramdown::Parser::Html::Constants
  include ::Kramdown::Utils::Entities
  def convert_a(el); end

  def convert_b(el); end

  def convert_code(el); end

  def convert_em(el); end

  def convert_h1(el); end

  def convert_h2(el); end

  def convert_h3(el); end

  def convert_h4(el); end

  def convert_h5(el); end

  def convert_h6(el); end

  def convert_i(el); end

  def convert_pre(el); end

  def convert_script(el); end

  def convert_strong(el); end

  def convert_table(el); end

  def convert_textarea(el); end

  def extract_text(el, raw); end

  def handle_math_tag(el); end

  def initialize(root); end

  def is_math_tag?(el); end

  def is_simple_table?(el); end

  def process(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil), parent=T.unsafe(nil)); end

  def process_children(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil)); end

  def process_html_element(el, do_conversion=T.unsafe(nil), preserve_text=T.unsafe(nil)); end

  def process_text(raw, preserve=T.unsafe(nil)); end

  def remove_text_children(el); end

  def remove_whitespace_children(el); end

  def set_basics(el, type, opts=T.unsafe(nil)); end

  def strip_whitespace(el); end

  def wrap_text_children(el); end
  EMPHASIS_TYPE_MAP = ::T.let(nil, ::T.untyped)
  REMOVE_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
  REMOVE_WHITESPACE_CHILDREN = ::T.let(nil, ::T.untyped)
  SIMPLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  STRIP_WHITESPACE = ::T.let(nil, ::T.untyped)
  WRAP_TEXT_CHILDREN = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Html::ElementConverter
  def self.convert(root, el=T.unsafe(nil)); end
end

module Kramdown::Parser::Html::Parser
  include ::Kramdown::Parser::Html::Constants
  def handle_html_start_tag(line=T.unsafe(nil)); end

  def handle_raw_html_tag(name); end

  def parse_html_attributes(str, line=T.unsafe(nil), in_html_tag=T.unsafe(nil)); end

  def parse_raw_html(el, &block); end
  HTML_RAW_START = ::T.let(nil, ::T.untyped)
end

module Kramdown::Parser::Html::Parser
  extend ::T::Sig
end

class Kramdown::Parser::Html
end

class Kramdown::Parser::Kramdown
  include ::Kramdown
  include ::Kramdown::Parser::Html::Parser
  include ::Kramdown::Parser::Html::Constants
  def add_header(level, text, id); end

  def add_link(el, href, title, alt_text=T.unsafe(nil), ial=T.unsafe(nil)); end

  def after_block_boundary?(); end

  def before_block_boundary?(); end

  def configure_parser(); end

  def correct_abbreviations_attributes(); end

  def handle_extension(name, opts, body, type, line_no=T.unsafe(nil)); end

  def handle_kramdown_html_tag(el, closed, handle_body); end

  def new_block_el(*args); end

  def normalize_link_id(id); end

  def paragraph_end(); end

  def parse_abbrev_definition(); end

  def parse_attribute_list(str, opts); end

  def parse_atx_header(); end

  def parse_autolink(); end

  def parse_blank_line(); end

  def parse_block_extensions(); end

  def parse_block_html(); end

  def parse_block_math(); end

  def parse_blockquote(); end

  def parse_blocks(el, text=T.unsafe(nil)); end

  def parse_codeblock(); end

  def parse_codeblock_fenced(); end

  def parse_codespan(); end

  def parse_definition_list(); end

  def parse_emphasis(); end

  def parse_eob_marker(); end

  def parse_escaped_chars(); end

  def parse_extension_start_tag(type); end

  def parse_first_list_line(indentation, content); end

  def parse_footnote_definition(); end

  def parse_footnote_marker(); end

  def parse_header_contents(); end

  def parse_horizontal_rule(); end

  def parse_html_entity(); end

  def parse_inline_math(); end

  def parse_line_break(); end

  def parse_link(); end

  def parse_link_definition(); end

  def parse_list(); end

  def parse_paragraph(); end

  def parse_setext_header(); end

  def parse_smart_quotes(); end

  def parse_span_extensions(); end

  def parse_span_html(); end

  def parse_spans(el, stop_re=T.unsafe(nil), parsers=T.unsafe(nil), text_type=T.unsafe(nil)); end

  def parse_table(); end

  def parse_typographic_syms(); end

  def replace_abbreviations(el, regexps=T.unsafe(nil)); end

  def reset_env(opts=T.unsafe(nil)); end

  def restore_env(env); end

  def save_env(); end

  def span_parser_regexps(parsers=T.unsafe(nil)); end

  def update_attr_with_ial(attr, ial); end

  def update_ial_with_ial(ial, opts); end

  def update_link_definitions(link_defs); end

  def update_raw_text(item); end

  def update_tree(element); end
  ABBREV_DEFINITION_START = ::T.let(nil, ::T.untyped)
  ACHARS = ::T.let(nil, ::T.untyped)
  ALD_ANY_CHARS = ::T.let(nil, ::T.untyped)
  ALD_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_ID_CHARS = ::T.let(nil, ::T.untyped)
  ALD_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_START = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ANY = ::T.let(nil, ::T.untyped)
  ALD_TYPE_CLASS_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_NAME = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS = ::T.let(nil, ::T.untyped)
  ALD_TYPE_ID_OR_CLASS_MULTI = ::T.let(nil, ::T.untyped)
  ALD_TYPE_KEY_VALUE_PAIR = ::T.let(nil, ::T.untyped)
  ALD_TYPE_REF = ::T.let(nil, ::T.untyped)
  ATX_HEADER_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START = ::T.let(nil, ::T.untyped)
  AUTOLINK_START_STR = ::T.let(nil, ::T.untyped)
  BLANK_LINE = ::T.let(nil, ::T.untyped)
  BLOCKQUOTE_START = ::T.let(nil, ::T.untyped)
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  BLOCK_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  BLOCK_MATH_START = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  CODESPAN_DELIMITER = ::T.let(nil, ::T.untyped)
  DEFINITION_LIST_START = ::T.let(nil, ::T.untyped)
  EMPHASIS_START = ::T.let(nil, ::T.untyped)
  EOB_MARKER = ::T.let(nil, ::T.untyped)
  ESCAPED_CHARS = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_START = ::T.let(nil, ::T.untyped)
  EXT_BLOCK_STOP_STR = ::T.let(nil, ::T.untyped)
  EXT_SPAN_START = ::T.let(nil, ::T.untyped)
  EXT_START_STR = ::T.let(nil, ::T.untyped)
  EXT_STOP_STR = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  FENCED_CODEBLOCK_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_DEFINITION_START = ::T.let(nil, ::T.untyped)
  FOOTNOTE_MARKER_START = ::T.let(nil, ::T.untyped)
  HEADER_ID = ::T.let(nil, ::T.untyped)
  HR_START = ::T.let(nil, ::T.untyped)
  HTML_BLOCK_START = ::T.let(nil, ::T.untyped)
  HTML_MARKDOWN_ATTR_MAP = ::T.let(nil, ::T.untyped)
  HTML_SPAN_START = ::T.let(nil, ::T.untyped)
  IAL_BLOCK = ::T.let(nil, ::T.untyped)
  IAL_BLOCK_START = ::T.let(nil, ::T.untyped)
  IAL_CLASS_ATTR = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  INDENT = ::T.let(nil, ::T.untyped)
  INLINE_MATH_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_SPAN_ELEMENTS = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_START = ::T.let(nil, ::T.untyped)
  LAZY_END_HTML_STOP = ::T.let(nil, ::T.untyped)
  LINE_BREAK = ::T.let(nil, ::T.untyped)
  LINK_BRACKET_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_DEFINITION_START = ::T.let(nil, ::T.untyped)
  LINK_INLINE_ID_RE = ::T.let(nil, ::T.untyped)
  LINK_INLINE_TITLE_RE = ::T.let(nil, ::T.untyped)
  LINK_PAREN_STOP_RE = ::T.let(nil, ::T.untyped)
  LINK_START = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL_CHECK = ::T.let(nil, ::T.untyped)
  LIST_START = ::T.let(nil, ::T.untyped)
  LIST_START_OL = ::T.let(nil, ::T.untyped)
  LIST_START_UL = ::T.let(nil, ::T.untyped)
  OPT_SPACE = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
  PARAGRAPH_MATCH = ::T.let(nil, ::T.untyped)
  PARAGRAPH_START = ::T.let(nil, ::T.untyped)
  PARSE_FIRST_LIST_LINE_REGEXP_CACHE = ::T.let(nil, ::T.untyped)
  SETEXT_HEADER_START = ::T.let(nil, ::T.untyped)
  SMART_QUOTES_RE = ::T.let(nil, ::T.untyped)
  SPAN_EXTENSIONS_START = ::T.let(nil, ::T.untyped)
  SQ_CLOSE = ::T.let(nil, ::T.untyped)
  SQ_PUNCT = ::T.let(nil, ::T.untyped)
  SQ_RULES = ::T.let(nil, ::T.untyped)
  SQ_SUBSTS = ::T.let(nil, ::T.untyped)
  TABLE_FSEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_HSEP_ALIGN = ::T.let(nil, ::T.untyped)
  TABLE_LINE = ::T.let(nil, ::T.untyped)
  TABLE_PIPE_CHECK = ::T.let(nil, ::T.untyped)
  TABLE_ROW_LINE = ::T.let(nil, ::T.untyped)
  TABLE_SEP_LINE = ::T.let(nil, ::T.untyped)
  TABLE_START = ::T.let(nil, ::T.untyped)
  TRAILING_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_RE = ::T.let(nil, ::T.untyped)
  TYPOGRAPHIC_SYMS_SUBST = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Kramdown::Data
  def method(); end

  def method=(_); end

  def name(); end

  def name=(_); end

  def span_start(); end

  def span_start=(_); end

  def start_re(); end

  def start_re=(_); end
end

class Kramdown::Parser::Kramdown::Data
  def self.[](*_); end

  def self.members(); end
end

class Kramdown::Parser::Kramdown
  def self.define_parser(name, start_re, span_start=T.unsafe(nil), meth_name=T.unsafe(nil)); end

  def self.has_parser?(name); end

  def self.parser(name=T.unsafe(nil)); end
end

class Kramdown::Parser::Markdown
  BLOCK_BOUNDARY = ::T.let(nil, ::T.untyped)
  CODEBLOCK_MATCH = ::T.let(nil, ::T.untyped)
  EXTENDED = ::T.let(nil, ::T.untyped)
  IAL_RAND_CHARS = ::T.let(nil, ::T.untyped)
  IAL_RAND_STRING = ::T.let(nil, ::T.untyped)
  IAL_SPAN_START = ::T.let(nil, ::T.untyped)
  LAZY_END = ::T.let(nil, ::T.untyped)
  LIST_ITEM_IAL = ::T.let(nil, ::T.untyped)
  PARAGRAPH_END = ::T.let(nil, ::T.untyped)
end

class Kramdown::Parser::Markdown
end

module Kramdown::Parser
  extend ::T::Sig
end

module Kramdown::Utils
end

module Kramdown::Utils::Configurable
  def configurable(name); end
end

module Kramdown::Utils::Configurable
  extend ::T::Sig
end

module Kramdown::Utils::Entities
  ENTITY_MAP = ::T.let(nil, ::T.untyped)
  ENTITY_TABLE = ::T.let(nil, ::T.untyped)
end

module Kramdown::Utils::Entities
  extend ::T::Sig
  def self.entity(point_or_name); end
end

module Kramdown::Utils::Html
  def entity_to_str(e, original=T.unsafe(nil)); end

  def escape_html(str, type=T.unsafe(nil)); end

  def html_attributes(attr); end
  ESCAPE_ALL_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_ATTRIBUTE_RE = ::T.let(nil, ::T.untyped)
  ESCAPE_MAP = ::T.let(nil, ::T.untyped)
  ESCAPE_RE_FROM_TYPE = ::T.let(nil, ::T.untyped)
  ESCAPE_TEXT_RE = ::T.let(nil, ::T.untyped)
end

module Kramdown::Utils::Html
  extend ::T::Sig
end

class Kramdown::Utils::LRUCache
  def [](key); end

  def []=(key, value); end

  def initialize(size); end
end

class Kramdown::Utils::LRUCache
end

Kramdown::Utils::OrderedHash = Hash

class Kramdown::Utils::StringScanner
  def current_line_number(); end

  def initialize(string, start_line_number=T.unsafe(nil)); end

  def pos=(pos); end

  def revert_pos(data); end

  def save_pos(); end

  def start_line_number(); end
end

class Kramdown::Utils::StringScanner
end

module Kramdown::Utils
  extend ::T::Sig
  def self.camelize(name); end

  def self.deep_const_get(str); end

  def self.snake_case(name); end
end

module Kramdown
  extend ::T::Sig
  def self.data_dir(); end
end

class LineItem
  include ::LineItem::GeneratedAssociationMethods
  include ::PaperTrail::Model::InstanceMethods
  def after_add_for_fulfillments(); end

  def after_add_for_fulfillments=(val); end

  def after_add_for_fulfillments?(); end

  def after_add_for_line_item_fulfillments(); end

  def after_add_for_line_item_fulfillments=(val); end

  def after_add_for_line_item_fulfillments?(); end

  def after_add_for_versions(); end

  def after_add_for_versions=(val); end

  def after_add_for_versions?(); end

  def after_remove_for_fulfillments(); end

  def after_remove_for_fulfillments=(val); end

  def after_remove_for_fulfillments?(); end

  def after_remove_for_line_item_fulfillments(); end

  def after_remove_for_line_item_fulfillments=(val); end

  def after_remove_for_line_item_fulfillments?(); end

  def after_remove_for_versions(); end

  def after_remove_for_versions=(val); end

  def after_remove_for_versions?(); end

  def autosave_associated_records_for_fulfillments(*args); end

  def autosave_associated_records_for_line_item_fulfillments(*args); end

  def autosave_associated_records_for_order(*args); end

  def autosave_associated_records_for_versions(*args); end

  def before_add_for_fulfillments(); end

  def before_add_for_fulfillments=(val); end

  def before_add_for_fulfillments?(); end

  def before_add_for_line_item_fulfillments(); end

  def before_add_for_line_item_fulfillments=(val); end

  def before_add_for_line_item_fulfillments?(); end

  def before_add_for_versions(); end

  def before_add_for_versions=(val); end

  def before_add_for_versions?(); end

  def before_remove_for_fulfillments(); end

  def before_remove_for_fulfillments=(val); end

  def before_remove_for_fulfillments?(); end

  def before_remove_for_line_item_fulfillments(); end

  def before_remove_for_line_item_fulfillments=(val); end

  def before_remove_for_line_item_fulfillments?(); end

  def before_remove_for_versions(); end

  def before_remove_for_versions=(val); end

  def before_remove_for_versions?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def paper_trail_event(); end

  def paper_trail_event=(paper_trail_event); end

  def paper_trail_options(); end

  def paper_trail_options=(val); end

  def paper_trail_options?(); end

  def validate_associated_records_for_fulfillments(*args); end

  def validate_associated_records_for_line_item_fulfillments(*args); end

  def validate_associated_records_for_versions(*args); end

  def version(); end

  def version=(version); end

  def version_association_name(); end

  def version_association_name=(val); end

  def version_association_name?(); end

  def version_class_name(); end

  def version_class_name=(val); end

  def version_class_name?(); end

  def versions_association_name(); end

  def versions_association_name=(val); end

  def versions_association_name?(); end
end

module LineItem::GeneratedAssociationMethods
  def build_order(*args, &block); end

  def create_order(*args, &block); end

  def create_order!(*args, &block); end

  def fulfillment_ids(); end

  def fulfillment_ids=(ids); end

  def fulfillments(); end

  def fulfillments=(value); end

  def line_item_fulfillment_ids(); end

  def line_item_fulfillment_ids=(ids); end

  def line_item_fulfillments(); end

  def line_item_fulfillments=(value); end

  def order(); end

  def order=(value); end

  def reload_order(); end

  def version_ids(); end

  def version_ids=(ids); end

  def versions(); end

  def versions=(value); end
end

module LineItem::GeneratedAssociationMethods
  extend ::T::Sig
end

class LineItem
  def self.after_add_for_fulfillments(); end

  def self.after_add_for_fulfillments=(val); end

  def self.after_add_for_fulfillments?(); end

  def self.after_add_for_line_item_fulfillments(); end

  def self.after_add_for_line_item_fulfillments=(val); end

  def self.after_add_for_line_item_fulfillments?(); end

  def self.after_add_for_versions(); end

  def self.after_add_for_versions=(val); end

  def self.after_add_for_versions?(); end

  def self.after_remove_for_fulfillments(); end

  def self.after_remove_for_fulfillments=(val); end

  def self.after_remove_for_fulfillments?(); end

  def self.after_remove_for_line_item_fulfillments(); end

  def self.after_remove_for_line_item_fulfillments=(val); end

  def self.after_remove_for_line_item_fulfillments?(); end

  def self.after_remove_for_versions(); end

  def self.after_remove_for_versions=(val); end

  def self.after_remove_for_versions?(); end

  def self.before_add_for_fulfillments(); end

  def self.before_add_for_fulfillments=(val); end

  def self.before_add_for_fulfillments?(); end

  def self.before_add_for_line_item_fulfillments(); end

  def self.before_add_for_line_item_fulfillments=(val); end

  def self.before_add_for_line_item_fulfillments?(); end

  def self.before_add_for_versions(); end

  def self.before_add_for_versions=(val); end

  def self.before_add_for_versions?(); end

  def self.before_remove_for_fulfillments(); end

  def self.before_remove_for_fulfillments=(val); end

  def self.before_remove_for_fulfillments?(); end

  def self.before_remove_for_line_item_fulfillments(); end

  def self.before_remove_for_line_item_fulfillments=(val); end

  def self.before_remove_for_line_item_fulfillments?(); end

  def self.before_remove_for_versions(); end

  def self.before_remove_for_versions=(val); end

  def self.before_remove_for_versions?(); end

  def self.paper_trail_options(); end

  def self.paper_trail_options=(val); end

  def self.paper_trail_options?(); end

  def self.version_association_name(); end

  def self.version_association_name=(val); end

  def self.version_association_name?(); end

  def self.version_class_name(); end

  def self.version_class_name=(val); end

  def self.version_class_name?(); end

  def self.versions_association_name(); end

  def self.versions_association_name=(val); end

  def self.versions_association_name?(); end
end

class LineItemFulfillment
  include ::LineItemFulfillment::GeneratedAssociationMethods
  def autosave_associated_records_for_fulfillment(*args); end

  def autosave_associated_records_for_line_item(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

module LineItemFulfillment::GeneratedAssociationMethods
  def build_fulfillment(*args, &block); end

  def build_line_item(*args, &block); end

  def create_fulfillment(*args, &block); end

  def create_fulfillment!(*args, &block); end

  def create_line_item(*args, &block); end

  def create_line_item!(*args, &block); end

  def fulfillment(); end

  def fulfillment=(value); end

  def line_item(); end

  def line_item=(value); end

  def reload_fulfillment(); end

  def reload_line_item(); end
end

module LineItemFulfillment::GeneratedAssociationMethods
  extend ::T::Sig
end

module LineItemHelper
  extend ::T::Sig
end

module Listen
  VERSION = ::T.let(nil, ::T.untyped)
end

module Listen::Adapter
  OPTIMIZED_ADAPTERS = ::T.let(nil, ::T.untyped)
  POLLING_FALLBACK_MESSAGE = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::BSD
end

class Listen::Adapter::Base
  def config(); end

  def configure(); end

  def initialize(config); end

  def options(); end

  def start(); end

  def started?(); end

  def stop(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Base
  def self.usable?(); end
end

class Listen::Adapter::Config
  def adapter_options(); end

  def directories(); end

  def initialize(directories, queue, silencer, adapter_options); end

  def queue(); end

  def silencer(); end
end

class Listen::Adapter::Config
end

class Listen::Adapter::Darwin
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INCOMPATIBLE_GEM_VERSION = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Darwin
end

class Listen::Adapter::Linux
  DEFAULTS = ::T.let(nil, ::T.untyped)
  INOTIFY_LIMIT_MESSAGE = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
  WIKI_URL = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Linux
end

class Listen::Adapter::Polling
  DEFAULTS = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Polling
end

class Listen::Adapter::Windows
  BUNDLER_DECLARE_GEM = ::T.let(nil, ::T.untyped)
  OS_REGEXP = ::T.let(nil, ::T.untyped)
end

class Listen::Adapter::Windows
end

module Listen::Adapter
  extend ::T::Sig
  def self.select(options=T.unsafe(nil)); end
end

class Listen::Backend
  def initialize(directories, queue, silencer, config); end

  def min_delay_between_events(); end

  def start(*args, &block); end

  def stop(*args, &block); end
end

class Listen::Backend
  extend ::Forwardable
end

class Listen::Change
  def initialize(config, record); end

  def invalidate(type, rel_path, options); end

  def record(); end
end

class Listen::Change::Config
  def initialize(queue, silencer); end

  def queue(*args); end

  def silenced?(path, type); end
end

class Listen::Change::Config
end

class Listen::Change
end

class Listen::Directory
end

class Listen::Directory
  def self._async_changes(snapshot, path, previous, options); end

  def self._change(snapshot, type, path, options); end

  def self._children(path); end

  def self.scan(snapshot, rel_path, options); end
end

module Listen::Event
end

class Listen::Event::Config
  def call(*args); end

  def callable?(); end

  def event_queue(); end

  def initialize(listener, event_queue, queue_optimizer, wait_for_delay, &block); end

  def min_delay_between_events(); end

  def optimize_changes(changes); end

  def paused?(); end

  def sleep(*args); end

  def stopped?(); end

  def timestamp(); end
end

class Listen::Event::Config
end

class Listen::Event::Loop
  def initialize(config); end

  def pause(); end

  def paused?(); end

  def processing?(); end

  def resume(); end

  def setup(); end

  def stopped?(); end

  def teardown(); end

  def wakeup_on_event(); end
end

class Listen::Event::Loop::Error
end

class Listen::Event::Loop::Error::NotStarted
end

class Listen::Event::Loop::Error::NotStarted
end

class Listen::Event::Loop::Error
end

class Listen::Event::Loop
end

class Listen::Event::Processor
  def initialize(config, reasons); end

  def loop_for(latency); end
end

class Listen::Event::Processor::Stopped
end

class Listen::Event::Processor::Stopped
end

class Listen::Event::Processor
end

class Listen::Event::Queue
  def <<(args); end

  def empty?(*args, &block); end

  def initialize(config, &block); end

  def pop(*args, &block); end
end

class Listen::Event::Queue::Config
  def initialize(relative); end

  def relative?(); end
end

class Listen::Event::Queue::Config
end

class Listen::Event::Queue
  extend ::Forwardable
end

module Listen::Event
  extend ::T::Sig
end

module Listen::FSM
  def current_state(); end

  def current_state_name(); end

  def default_state(); end

  def initialize(); end

  def state(); end

  def states(); end

  def transition(state_name); end

  def transition!(state_name); end

  def transition_with_callbacks!(state_name); end

  def validate_and_sanitize_new_state(state_name); end
  DEFAULT_STATE = ::T.let(nil, ::T.untyped)
end

module Listen::FSM::ClassMethods
  def default_state(new_default=T.unsafe(nil)); end

  def state(*args, &block); end

  def states(); end
end

module Listen::FSM::ClassMethods
  extend ::T::Sig
end

class Listen::FSM::State
  def call(obj); end

  def initialize(name, transitions=T.unsafe(nil), &block); end

  def name(); end

  def transitions(); end

  def valid_transition?(new_state); end
end

class Listen::FSM::State
end

module Listen::FSM
  extend ::T::Sig
  def self.included(klass); end
end

class Listen::File
end

class Listen::File
  def self.change(record, rel_path); end

  def self.inaccurate_mac_time?(stat); end
end

module Listen::Internals
end

module Listen::Internals::ThreadPool
end

module Listen::Internals::ThreadPool
  extend ::T::Sig
  def self.add(&block); end

  def self.stop(); end
end

module Listen::Internals
  extend ::T::Sig
end

class Listen::Listener
  include ::Listen::FSM
  def ignore(regexps); end

  def ignore!(regexps); end

  def initialize(*dirs, &block); end

  def only(regexps); end

  def pause(); end

  def paused?(); end

  def processing?(); end

  def start(); end

  def stop(); end
end

class Listen::Listener::Config
  def adapter_instance_options(klass); end

  def adapter_select_options(); end

  def initialize(opts); end

  def min_delay_between_events(); end

  def relative?(); end

  def silencer_rules(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Listen::Listener::Config
end

class Listen::Listener
  extend ::Listen::FSM::ClassMethods
end

class Listen::Logger
end

class Listen::Logger
  def self.debug(*args, &block); end

  def self.error(*args, &block); end

  def self.fatal(*args, &block); end

  def self.info(*args, &block); end

  def self.warn(*args, &block); end
end

class Listen::Options
  def initialize(opts, defaults); end

  def method_missing(name, *_); end
end

class Listen::Options
end

class Listen::QueueOptimizer
  def initialize(config); end

  def smoosh_changes(changes); end
end

class Listen::QueueOptimizer::Config
  def debug(*args, &block); end

  def exist?(path); end

  def initialize(adapter_class, silencer); end

  def silenced?(path, type); end
end

class Listen::QueueOptimizer::Config
end

class Listen::QueueOptimizer
end

class Listen::Record
  def add_dir(rel_path); end

  def build(); end

  def dir_entries(rel_path); end

  def file_data(rel_path); end

  def initialize(directory); end

  def root(); end

  def unset_path(rel_path); end

  def update_file(rel_path, data); end
end

class Listen::Record::Entry
  def children(); end

  def initialize(root, relative, name=T.unsafe(nil)); end

  def meta(); end

  def name(); end

  def real_path(); end

  def record_dir_key(); end

  def relative(); end

  def root(); end

  def sys_path(); end
end

class Listen::Record::Entry
end

class Listen::Record::SymlinkDetector
  def verify_unwatched!(entry); end
  SYMLINK_LOOP_ERROR = ::T.let(nil, ::T.untyped)
  WIKI = ::T.let(nil, ::T.untyped)
end

class Listen::Record::SymlinkDetector::Error
end

class Listen::Record::SymlinkDetector::Error
end

class Listen::Record::SymlinkDetector
end

class Listen::Record
end

class Listen::Silencer
  def configure(options); end

  def ignore_patterns(); end

  def ignore_patterns=(ignore_patterns); end

  def only_patterns(); end

  def only_patterns=(only_patterns); end

  def silenced?(relative_path, type); end
  DEFAULT_IGNORED_DIRECTORIES = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORED_EXTENSIONS = ::T.let(nil, ::T.untyped)
end

class Listen::Silencer::Controller
  def append_ignores(*regexps); end

  def initialize(silencer, default_options); end

  def replace_with_bang_ignores(regexps); end

  def replace_with_only(regexps); end
end

class Listen::Silencer::Controller
end

class Listen::Silencer
end

module Listen
  extend ::T::Sig
  def self.logger(); end

  def self.logger=(logger); end

  def self.setup_default_logger_if_unset(); end

  def self.stop(); end

  def self.to(*args, &block); end
end

class LoadError
  def is_missing?(location); end

  def path(); end
end

class LoadError
  extend ::T::Sig
end

class LocalJumpError
  def exit_value(); end

  def reason(); end
end

class LocalJumpError
  extend ::T::Sig
end

class Logger
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  SEV_LABEL = ::T.let(nil, ::T.untyped)
end

class Logger::Error
  extend ::T::Sig
end

class Logger::Formatter
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  Format = ::T.let(nil, ::T.untyped)
end

class Logger::Formatter
  extend ::T::Sig
end

class Logger::LogDevice
  include ::MonitorMixin
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Logger::LogDevice
  extend ::T::Sig
end

module Logger::Period
  SiD = ::T.let(nil, ::T.untyped)
end

module Logger::Period
  extend ::T::Sig
end

module Logger::Severity
  extend ::T::Sig
end

class Logger::ShiftingError
  extend ::T::Sig
end

class Logger
  extend ::T::Sig
end

module LoggerSilence
  def silence(temporary_level=T.unsafe(nil)); end
end

module LoggerSilence
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Loofah
  VERSION = ::T.let(nil, ::T.untyped)
end

module Loofah::DocumentDecorator
  def initialize(*args, &block); end
end

module Loofah::DocumentDecorator
  extend ::T::Sig
end

module Loofah::Elements
  BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  LOOSE_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML4 = ::T.let(nil, ::T.untyped)
  STRICT_BLOCK_LEVEL_HTML5 = ::T.let(nil, ::T.untyped)
end

module Loofah::Elements
  extend ::T::Sig
end

module Loofah::HTML
end

class Loofah::HTML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::Document
end

class Loofah::HTML::DocumentFragment
  include ::Loofah::TextBehavior
  def serialize_root(); end
end

class Loofah::HTML::DocumentFragment
end

module Loofah::HTML
  extend ::T::Sig
end

module Loofah::HTML5
end

module Loofah::HTML5::Scrub
  CONTROL_CHARACTERS = ::T.let(nil, ::T.untyped)
  CRASS_SEMICOLON = ::T.let(nil, ::T.untyped)
  CSS_KEYWORDISH = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::Scrub
  extend ::T::Sig
  def self.allowed_element?(element_name); end

  def self.force_correct_attribute_escaping!(node); end

  def self.scrub_attributes(node); end

  def self.scrub_css(style); end

  def self.scrub_css_attribute(node); end
end

module Loofah::HTML5::WhiteList
  ACCEPTABLE_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_ELEMENTS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ACCEPTABLE_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ALLOWED_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_FUNCTIONS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_KEYWORDS = ::T.let(nil, ::T.untyped)
  ALLOWED_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS = ::T.let(nil, ::T.untyped)
  ALLOWED_ELEMENTS_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  ALLOWED_PROTOCOLS = ::T.let(nil, ::T.untyped)
  ALLOWED_SVG_PROPERTIES = ::T.let(nil, ::T.untyped)
  ALLOWED_URI_DATA_MEDIATYPES = ::T.let(nil, ::T.untyped)
  ATTR_VAL_IS_URI = ::T.let(nil, ::T.untyped)
  MATHML_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  MATHML_ELEMENTS = ::T.let(nil, ::T.untyped)
  PROTOCOL_SEPARATOR = ::T.let(nil, ::T.untyped)
  SHORTHAND_CSS_PROPERTIES = ::T.let(nil, ::T.untyped)
  SVG_ALLOW_LOCAL_HREF = ::T.let(nil, ::T.untyped)
  SVG_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SVG_ATTR_VAL_ALLOWS_REF = ::T.let(nil, ::T.untyped)
  SVG_ELEMENTS = ::T.let(nil, ::T.untyped)
  TAGS_SAFE_WITH_LIBXML2 = ::T.let(nil, ::T.untyped)
  VOID_ELEMENTS = ::T.let(nil, ::T.untyped)
end

module Loofah::HTML5::WhiteList
  extend ::T::Sig
end

module Loofah::HTML5
  extend ::T::Sig
end

module Loofah::LibxmlWorkarounds
  BROKEN_ESCAPING_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  BROKEN_ESCAPING_ATTRIBUTES_QUALIFYING_TAG = ::T.let(nil, ::T.untyped)
end

module Loofah::LibxmlWorkarounds
  extend ::T::Sig
end

module Loofah::MetaHelpers
end

module Loofah::MetaHelpers
  extend ::T::Sig
  def self.add_downcased_set_members_to_all_set_constants(mojule); end
end

module Loofah::ScrubBehavior
end

module Loofah::ScrubBehavior::Node
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::Node
  extend ::T::Sig
end

module Loofah::ScrubBehavior::NodeSet
  def scrub!(scrubber); end
end

module Loofah::ScrubBehavior::NodeSet
  extend ::T::Sig
end

module Loofah::ScrubBehavior
  extend ::T::Sig
  def self.resolve_scrubber(scrubber); end
end

class Loofah::Scrubber
  def append_attribute(node, attribute, value); end

  def block(); end

  def direction(); end

  def initialize(options=T.unsafe(nil), &block); end

  def scrub(node); end

  def traverse(node); end
  CONTINUE = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubber
end

class Loofah::ScrubberNotFound
end

class Loofah::ScrubberNotFound
end

module Loofah::Scrubbers
  MAP = ::T.let(nil, ::T.untyped)
end

class Loofah::Scrubbers::Escape
  def initialize(); end
end

class Loofah::Scrubbers::Escape
end

class Loofah::Scrubbers::NewlineBlockElements
  def initialize(); end
end

class Loofah::Scrubbers::NewlineBlockElements
end

class Loofah::Scrubbers::NoFollow
  def initialize(); end
end

class Loofah::Scrubbers::NoFollow
end

class Loofah::Scrubbers::NoOpener
  def initialize(); end
end

class Loofah::Scrubbers::NoOpener
end

class Loofah::Scrubbers::Prune
  def initialize(); end
end

class Loofah::Scrubbers::Prune
end

class Loofah::Scrubbers::Strip
  def initialize(); end
end

class Loofah::Scrubbers::Strip
end

class Loofah::Scrubbers::Unprintable
  def initialize(); end
end

class Loofah::Scrubbers::Unprintable
end

class Loofah::Scrubbers::Whitewash
  def initialize(); end
end

class Loofah::Scrubbers::Whitewash
end

module Loofah::Scrubbers
  extend ::T::Sig
  def self.scrubber_symbols(); end
end

module Loofah::TextBehavior
  def inner_text(options=T.unsafe(nil)); end

  def text(options=T.unsafe(nil)); end

  def to_str(options=T.unsafe(nil)); end

  def to_text(options=T.unsafe(nil)); end
end

module Loofah::TextBehavior
  extend ::T::Sig
end

module Loofah::XML
end

class Loofah::XML::Document
  include ::Loofah::ScrubBehavior::Node
  include ::Loofah::DocumentDecorator
end

class Loofah::XML::Document
end

class Loofah::XML::DocumentFragment
end

class Loofah::XML::DocumentFragment
end

module Loofah::XML
  extend ::T::Sig
end

module Loofah
  extend ::T::Sig
  def self.document(*args, &block); end

  def self.fragment(*args, &block); end

  def self.remove_extraneous_whitespace(string); end

  def self.scrub_document(string_or_io, method); end

  def self.scrub_fragment(string_or_io, method); end

  def self.scrub_xml_document(string_or_io, method); end

  def self.scrub_xml_fragment(string_or_io, method); end

  def self.xml_document(*args, &block); end

  def self.xml_fragment(*args, &block); end
end

module Mail
  RANDOM_TAG = ::T.let(nil, ::T.untyped)
end

class Mail::Address
  include ::Mail::Utilities
  include ::Mail::Constants
  def address(output_type=T.unsafe(nil)); end

  def address=(value); end

  def comments(); end

  def decoded(); end

  def display_name(output_type=T.unsafe(nil)); end

  def display_name=(str); end

  def domain(output_type=T.unsafe(nil)); end

  def encoded(); end

  def format(output_type=T.unsafe(nil)); end

  def group(); end

  def initialize(value=T.unsafe(nil)); end

  def local(output_type=T.unsafe(nil)); end

  def name(); end

  def raw(); end
end

class Mail::Address
end

class Mail::AddressContainer
  def <<(address); end

  def initialize(field, list=T.unsafe(nil)); end
end

class Mail::AddressContainer
end

class Mail::AddressList
  def addresses(); end

  def addresses_grouped_by_group(); end

  def group_names(); end

  def initialize(string); end
end

class Mail::AddressList
end

class Mail::AttachmentsList
  def [](index_value); end

  def []=(name, value); end

  def guess_encoding(); end

  def initialize(parts_list); end

  def inline(); end

  def set_mime_type(filename); end
end

class Mail::AttachmentsList
end

class Mail::BccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def include_in_headers(); end

  def include_in_headers=(include_in_headers); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::BccField
end

class Mail::Body
  def <<(val); end

  def ==(other); end

  def =~(regexp); end

  def ascii_only?(); end

  def boundary(); end

  def boundary=(val); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def default_encoding(); end

  def empty?(); end

  def encoded(transfer_encoding=T.unsafe(nil)); end

  def encoding(val=T.unsafe(nil)); end

  def encoding=(val); end

  def epilogue(); end

  def epilogue=(val); end

  def include?(other); end

  def initialize(string=T.unsafe(nil)); end

  def match(regexp); end

  def multipart?(); end

  def negotiate_best_encoding(message_encoding, allowed_encodings=T.unsafe(nil)); end

  def parts(); end

  def preamble(); end

  def preamble=(val); end

  def raw_source(); end

  def set_sort_order(order); end

  def sort_parts!(); end

  def split!(boundary); end
end

class Mail::Body
end

class Mail::CcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CcField
end

module Mail::CheckDeliveryParams
end

module Mail::CheckDeliveryParams
  extend ::T::Sig
  def self.check(mail); end

  def self.check_addr(addr_name, addr); end

  def self.check_from(addr); end

  def self.check_message(message); end

  def self.check_to(addrs); end

  def self.validate_smtp_addr(addr); end
end

class Mail::CommentsField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::CommentsField
end

module Mail::CommonAddress
  def <<(val); end

  def addresses(); end

  def addrs(); end

  def charset(); end

  def decoded_group_addresses(); end

  def default(); end

  def display_names(); end

  def each(); end

  def encode_if_needed(val); end

  def encoded_group_addresses(); end

  def formatted(); end

  def group_addresses(); end

  def group_names(); end

  def groups(); end

  def parse(val=T.unsafe(nil)); end

  def value=(val); end
end

module Mail::CommonAddress
  extend ::T::Sig
end

module Mail::CommonDate
  def date_time(); end

  def default(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonDate
  extend ::T::Sig
end

module Mail::CommonField
  include ::Mail::Constants
  def default(); end

  def field_length(); end

  def name(); end

  def name=(value); end

  def responsible_for?(val); end

  def to_s(); end

  def value(); end

  def value=(value); end
  FILENAME_RE = ::T.let(nil, ::T.untyped)
end

module Mail::CommonField
  extend ::T::Sig
end

module Mail::CommonMessageId
  def default(); end

  def element(); end

  def message_id(); end

  def message_ids(); end

  def parse(val=T.unsafe(nil)); end
end

module Mail::CommonMessageId
  extend ::T::Sig
end

class Mail::Configuration
  include ::Singleton
  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def lookup_delivery_method(method); end

  def lookup_retriever_method(method); end

  def param_encode_language(value=T.unsafe(nil)); end

  def retriever_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end
end

class Mail::Configuration
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module Mail::Constants
  ASTERISK = ::T.let(nil, ::T.untyped)
  ATOM_UNSAFE = ::T.let(nil, ::T.untyped)
  B_VALUES = ::T.let(nil, ::T.untyped)
  CAPITAL_M = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONTROL_CHAR = ::T.let(nil, ::T.untyped)
  CR = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  CR_ENCODED = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  EQUAL_LF = ::T.let(nil, ::T.untyped)
  FIELD_BODY = ::T.let(nil, ::T.untyped)
  FIELD_LINE = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
  FIELD_PREFIX = ::T.let(nil, ::T.untyped)
  FIELD_SPLIT = ::T.let(nil, ::T.untyped)
  FULL_ENCODED_VALUE = ::T.let(nil, ::T.untyped)
  FWS = ::T.let(nil, ::T.untyped)
  HEADER_LINE = ::T.let(nil, ::T.untyped)
  HEADER_SPLIT = ::T.let(nil, ::T.untyped)
  HYPHEN = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  LF_ENCODED = ::T.let(nil, ::T.untyped)
  NULL_SENDER = ::T.let(nil, ::T.untyped)
  PHRASE_UNSAFE = ::T.let(nil, ::T.untyped)
  QP_SAFE = ::T.let(nil, ::T.untyped)
  QP_UNSAFE = ::T.let(nil, ::T.untyped)
  Q_VALUES = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  TOKEN_UNSAFE = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
  WSP = ::T.let(nil, ::T.untyped)
end

module Mail::Constants
  extend ::T::Sig
end

class Mail::ContentDescriptionField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDescriptionField
end

class Mail::ContentDispositionElement
  def disposition_type(); end

  def initialize(string); end

  def parameters(); end
end

class Mail::ContentDispositionElement
end

class Mail::ContentDispositionField
  def decoded(); end

  def disposition_type(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentDispositionField
end

class Mail::ContentIdField
  def content_id(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentIdField
end

class Mail::ContentLocationElement
  def initialize(string); end

  def location(); end

  def to_s(*args); end
end

class Mail::ContentLocationElement
end

class Mail::ContentLocationField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def location(); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentLocationField
end

class Mail::ContentTransferEncodingElement
  def encoding(); end

  def initialize(string); end
end

class Mail::ContentTransferEncodingElement
end

class Mail::ContentTransferEncodingField
  def decoded(); end

  def element(); end

  def encoded(); end

  def encoding(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTransferEncodingField
end

class Mail::ContentTypeElement
  def initialize(string); end

  def main_type(); end

  def parameters(); end

  def sub_type(); end
end

class Mail::ContentTypeElement
end

class Mail::ContentTypeField
  def attempt_to_clean(); end

  def content_type(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def filename(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def main_type(); end

  def parameters(); end

  def parse(val=T.unsafe(nil)); end

  def string(); end

  def stringify(params); end

  def sub_type(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ContentTypeField
  def self.generate_boundary(); end

  def self.with_boundary(type); end
end

class Mail::DateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::DateField
end

class Mail::DateTimeElement
  def date_string(); end

  def initialize(string); end

  def time_string(); end
end

class Mail::DateTimeElement
end

module Mail::Encodings
  include ::Mail::Constants
end

class Mail::Encodings::Base64
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Base64
end

class Mail::Encodings::Binary
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::Binary
end

class Mail::Encodings::EightBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::EightBit
end

class Mail::Encodings::Identity
end

class Mail::Encodings::Identity
  def self.decode(str); end

  def self.encode(str); end
end

class Mail::Encodings::QuotedPrintable
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::QuotedPrintable
end

class Mail::Encodings::SevenBit
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::SevenBit
end

class Mail::Encodings::TransferEncoding
  NAME = ::T.let(nil, ::T.untyped)
  PRIORITY = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::TransferEncoding
  def self.can_encode?(enc); end

  def self.can_transport?(enc); end

  def self.compatible_input?(str); end

  def self.cost(str); end

  def self.lowest_cost(str, encodings); end

  def self.negotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end

  def self.renegotiate(message_encoding, source_encoding, str, allowed_encodings=T.unsafe(nil)); end
end

class Mail::Encodings::UnixToUnix
  NAME = ::T.let(nil, ::T.untyped)
end

class Mail::Encodings::UnixToUnix
  def self.decode(str); end

  def self.encode(str); end
end

module Mail::Encodings
  extend ::Mail::Utilities
  extend ::Mail::Constants
  extend ::T::Sig
  def self.address_encode(address, charset=T.unsafe(nil)); end

  def self.b_value_decode(str); end

  def self.b_value_encode(string, encoding=T.unsafe(nil)); end

  def self.collapse_adjacent_encodings(str); end

  def self.decode_encode(str, output_type); end

  def self.defined?(name); end

  def self.each_base64_chunk_byterange(str, max_bytesize_per_base64_chunk, &block); end

  def self.each_chunk_byterange(str, max_bytesize_per_chunk); end

  def self.encode_non_usascii(address, charset); end

  def self.find_encoding(str); end

  def self.get_all(); end

  def self.get_encoding(name); end

  def self.get_name(name); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.q_value_decode(str); end

  def self.q_value_encode(encoded_str, encoding=T.unsafe(nil)); end

  def self.register(name, cls); end

  def self.transcode_charset(str, from_charset, to_charset=T.unsafe(nil)); end

  def self.unquote_and_convert_to(str, to_encoding); end

  def self.value_decode(str); end

  def self.value_encoding_from_string(str); end

  def self.with_ascii_kcode(); end
end

class Mail::Envelope
  def date(); end

  def element(); end

  def from(); end

  def initialize(*args); end
end

class Mail::Envelope
end

class Mail::EnvelopeFromElement
  def address(); end

  def date_time(); end

  def formatted_date_time(); end

  def initialize(string); end
end

class Mail::EnvelopeFromElement
end

class Mail::Exim
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Exim
end

class Mail::Field
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Comparable
  def ==(other); end

  def field(); end

  def field=(value); end

  def field_order_id(); end

  def initialize(name, value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def method_missing(name, *args, &block); end

  def name(); end

  def responsible_for?(val); end

  def same(other); end

  def unparsed_value(); end

  def update(name, value); end

  def value(); end

  def value=(val); end
  FIELDS_MAP = ::T.let(nil, ::T.untyped)
  FIELD_NAME_MAP = ::T.let(nil, ::T.untyped)
  FIELD_ORDER = ::T.let(nil, ::T.untyped)
  FIELD_ORDER_LOOKUP = ::T.let(nil, ::T.untyped)
  KNOWN_FIELDS = ::T.let(nil, ::T.untyped)
  STRUCTURED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Field::FieldError
end

class Mail::Field::FieldError
end

class Mail::Field::IncompleteParseError
  def initialize(element, original_text, unparsed_index); end
end

class Mail::Field::IncompleteParseError
end

class Mail::Field::NilParseError
  def initialize(element); end
end

class Mail::Field::NilParseError
end

class Mail::Field::ParseError
  def element(); end

  def element=(element); end

  def initialize(element, value, reason); end

  def reason(); end

  def reason=(reason); end

  def value(); end

  def value=(value); end
end

class Mail::Field::ParseError
end

class Mail::Field::SyntaxError
end

class Mail::Field::SyntaxError
end

class Mail::Field
  def self.parse(field, charset=T.unsafe(nil)); end

  def self.split(raw_field); end
end

class Mail::FieldList
  def <<(new_field); end
end

class Mail::FieldList
end

class Mail::FileDelivery
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::FileDelivery
end

class Mail::FromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::FromField
end

class Mail::Header
  include ::Mail::Utilities
  include ::Mail::Constants
  include ::Enumerable
  def [](name); end

  def []=(name, value); end

  def charset(); end

  def charset=(val); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def field_summary(); end

  def fields(); end

  def fields=(unfolded_fields); end

  def has_content_id?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def initialize(header_text=T.unsafe(nil), charset=T.unsafe(nil)); end

  def raw_source(); end
  LIMITED_FIELDS = ::T.let(nil, ::T.untyped)
end

class Mail::Header
  def self.maximum_amount(); end

  def self.maximum_amount=(value); end
end

class Mail::IMAP
  def connection(&block); end

  def delete_all(mailbox=T.unsafe(nil)); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::IMAP
end

class Mail::InReplyToField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::InReplyToField
end

class Mail::IndifferentHash
  def []=(key, value); end

  def convert_key(key); end

  def convert_value(value); end

  def default(key=T.unsafe(nil)); end

  def delete(key); end

  def fetch(key, *extras); end

  def has_key?(key); end

  def include?(key); end

  def initialize(constructor=T.unsafe(nil)); end

  def key?(key); end

  def member?(key); end

  def merge(hash); end

  def merge!(other_hash); end

  def regular_update(_); end

  def regular_writer(_, _1); end

  def store(key, value); end

  def update(other_hash); end

  def values_at(*indices); end
end

class Mail::IndifferentHash
  def self.new_from_hash_copying_default(hash); end
end

class Mail::KeywordsField
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def keywords(); end

  def parse(val=T.unsafe(nil)); end

  def phrase_list(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::KeywordsField
end

class Mail::LoggerDelivery
  include ::Mail::CheckDeliveryParams
  def deliver!(mail); end

  def initialize(settings); end

  def logger(); end

  def settings(); end

  def severity(); end
end

class Mail::LoggerDelivery
end

module Mail::Matchers
  def an_attachment_with_filename(filename); end

  def any_attachment(); end

  def have_sent_email(); end
end

class Mail::Matchers::AnyAttachmentMatcher
  def ===(other); end
end

class Mail::Matchers::AnyAttachmentMatcher
end

class Mail::Matchers::AttachmentFilenameMatcher
  def ===(other); end

  def filename(); end

  def initialize(filename); end
end

class Mail::Matchers::AttachmentFilenameMatcher
end

class Mail::Matchers::HasSentEmailMatcher
  def bcc(recipient_or_list); end

  def cc(recipient_or_list); end

  def description(); end

  def dump_deliveries(); end

  def explain_expectations(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def filter_matched_deliveries(deliveries); end

  def from(sender); end

  def initialize(_context); end

  def matches?(subject); end

  def matches_on_attachments?(delivery); end

  def matches_on_blind_copy_recipients?(delivery); end

  def matches_on_body?(delivery); end

  def matches_on_body_matcher?(delivery); end

  def matches_on_copy_recipients?(delivery); end

  def matches_on_having_attachments?(delivery); end

  def matches_on_html_part_body?(delivery); end

  def matches_on_recipients?(delivery); end

  def matches_on_sender?(delivery); end

  def matches_on_subject?(delivery); end

  def matches_on_subject_matcher?(delivery); end

  def matches_on_text_part_body?(delivery); end

  def matching_body(body_matcher); end

  def matching_subject(subject_matcher); end

  def to(recipient_or_list); end

  def with_any_attachments(); end

  def with_attachments(attachments); end

  def with_body(body); end

  def with_html(body); end

  def with_no_attachments(); end

  def with_subject(subject); end

  def with_text(body); end
end

class Mail::Matchers::HasSentEmailMatcher
end

module Mail::Matchers
  extend ::T::Sig
end

class Mail::Message
  include ::Mail::Utilities
  include ::Mail::Constants
  def ==(other); end

  def [](name); end

  def []=(name, value); end

  def action(); end

  def add_charset(); end

  def add_content_transfer_encoding(); end

  def add_content_type(); end

  def add_date(date_val=T.unsafe(nil)); end

  def add_file(values); end

  def add_message_id(msg_id_val=T.unsafe(nil)); end

  def add_mime_version(ver_val=T.unsafe(nil)); end

  def add_part(part); end

  def add_transfer_encoding(); end

  def all_parts(); end

  def attachment(); end

  def attachment?(); end

  def attachments(); end

  def bcc(val=T.unsafe(nil)); end

  def bcc=(val); end

  def bcc_addrs(); end

  def body(value=T.unsafe(nil)); end

  def body=(value); end

  def body_encoding(value=T.unsafe(nil)); end

  def body_encoding=(value); end

  def bounced?(); end

  def boundary(); end

  def cc(val=T.unsafe(nil)); end

  def cc=(val); end

  def cc_addrs(); end

  def charset(); end

  def charset=(value); end

  def comments(val=T.unsafe(nil)); end

  def comments=(val); end

  def content_description(val=T.unsafe(nil)); end

  def content_description=(val); end

  def content_disposition(val=T.unsafe(nil)); end

  def content_disposition=(val); end

  def content_id(val=T.unsafe(nil)); end

  def content_id=(val); end

  def content_location(val=T.unsafe(nil)); end

  def content_location=(val); end

  def content_transfer_encoding(val=T.unsafe(nil)); end

  def content_transfer_encoding=(val); end

  def content_type(val=T.unsafe(nil)); end

  def content_type=(val); end

  def content_type_parameters(); end

  def convert_to_multipart(); end

  def date(val=T.unsafe(nil)); end

  def date=(val); end

  def decode_body(); end

  def decoded(); end

  def default(sym, val=T.unsafe(nil)); end

  def deliver(); end

  def deliver!(); end

  def delivery_handler(); end

  def delivery_handler=(delivery_handler); end

  def delivery_method(method=T.unsafe(nil), settings=T.unsafe(nil)); end

  def delivery_status_part(); end

  def delivery_status_report?(); end

  def destinations(); end

  def diagnostic_code(); end

  def encode!(); end

  def encoded(); end

  def envelope_date(); end

  def envelope_from(); end

  def error_status(); end

  def errors(); end

  def filename(); end

  def final_recipient(); end

  def find_first_mime_type(mt); end

  def from(val=T.unsafe(nil)); end

  def from=(val); end

  def from_addrs(); end

  def has_attachments?(); end

  def has_charset?(); end

  def has_content_transfer_encoding?(); end

  def has_content_type?(); end

  def has_date?(); end

  def has_message_id?(); end

  def has_mime_version?(); end

  def has_transfer_encoding?(); end

  def header(value=T.unsafe(nil)); end

  def header=(value); end

  def header_fields(); end

  def headers(hash=T.unsafe(nil)); end

  def html_part(&block); end

  def html_part=(msg); end

  def in_reply_to(val=T.unsafe(nil)); end

  def in_reply_to=(val); end

  def inform_interceptors(); end

  def inform_observers(); end

  def initialize(*args, &block); end

  def is_marked_for_delete?(); end

  def keywords(val=T.unsafe(nil)); end

  def keywords=(val); end

  def main_type(); end

  def mark_for_delete=(value=T.unsafe(nil)); end

  def message_content_type(); end

  def message_id(val=T.unsafe(nil)); end

  def message_id=(val); end

  def method_missing(name, *args, &block); end

  def mime_parameters(); end

  def mime_type(); end

  def mime_version(val=T.unsafe(nil)); end

  def mime_version=(val); end

  def multipart?(); end

  def multipart_report?(); end

  def part(params=T.unsafe(nil)); end

  def parts(); end

  def perform_deliveries(); end

  def perform_deliveries=(perform_deliveries); end

  def raise_delivery_errors(); end

  def raise_delivery_errors=(raise_delivery_errors); end

  def raw_envelope(); end

  def raw_source(); end

  def read(); end

  def ready_to_send!(); end

  def received(val=T.unsafe(nil)); end

  def received=(val); end

  def references(val=T.unsafe(nil)); end

  def references=(val); end

  def register_for_delivery_notification(observer); end

  def remote_mta(); end

  def reply(*args, &block); end

  def reply_to(val=T.unsafe(nil)); end

  def reply_to=(val); end

  def resent_bcc(val=T.unsafe(nil)); end

  def resent_bcc=(val); end

  def resent_cc(val=T.unsafe(nil)); end

  def resent_cc=(val); end

  def resent_date(val=T.unsafe(nil)); end

  def resent_date=(val); end

  def resent_from(val=T.unsafe(nil)); end

  def resent_from=(val); end

  def resent_message_id(val=T.unsafe(nil)); end

  def resent_message_id=(val); end

  def resent_sender(val=T.unsafe(nil)); end

  def resent_sender=(val); end

  def resent_to(val=T.unsafe(nil)); end

  def resent_to=(val); end

  def retryable?(); end

  def return_path(val=T.unsafe(nil)); end

  def return_path=(val); end

  def sender(val=T.unsafe(nil)); end

  def sender=(val); end

  def set_envelope(val); end

  def skip_deletion(); end

  def smtp_envelope_from(val=T.unsafe(nil)); end

  def smtp_envelope_from=(val); end

  def smtp_envelope_to(val=T.unsafe(nil)); end

  def smtp_envelope_to=(val); end

  def sub_type(); end

  def subject(val=T.unsafe(nil)); end

  def subject=(val); end

  def text?(); end

  def text_part(&block); end

  def text_part=(msg); end

  def to(val=T.unsafe(nil)); end

  def to=(val); end

  def to_addrs(); end

  def to_yaml(opts=T.unsafe(nil)); end

  def transfer_encoding(); end

  def transport_encoding(val=T.unsafe(nil)); end

  def transport_encoding=(val); end

  def without_attachments!(); end
  HEADER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Mail::Message
  def self.default_charset(); end

  def self.default_charset=(charset); end

  def self.from_hash(hash); end

  def self.from_yaml(str); end
end

class Mail::MessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MessageIdField
end

class Mail::MessageIdsElement
  def initialize(string); end

  def message_id(); end

  def message_ids(); end
end

class Mail::MessageIdsElement
end

class Mail::MimeVersionElement
  def initialize(string); end

  def major(); end

  def minor(); end
end

class Mail::MimeVersionElement
end

class Mail::MimeVersionField
  def decoded(); end

  def element(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def major(); end

  def minor(); end

  def parse(val=T.unsafe(nil)); end

  def version(); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::MimeVersionField
end

module Mail::Multibyte
  VALID_CHARACTER = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Chars
  include ::Comparable
  def =~(other); end

  def [](*args); end

  def []=(*args); end

  def acts_like_string?(); end

  def capitalize(); end

  def capitalize!(*args); end

  def chars(string); end

  def compose(); end

  def decompose(); end

  def downcase(); end

  def downcase!(*args); end

  def g_length(); end

  def initialize(string); end

  def justify(integer, way, padstr=T.unsafe(nil)); end

  def limit(limit); end

  def method_missing(method, *args, &block); end

  def normalize(form=T.unsafe(nil)); end

  def padding(padsize, padstr=T.unsafe(nil)); end

  def respond_to?(method, include_private=T.unsafe(nil)); end

  def reverse(); end

  def reverse!(*args); end

  def slice(*args); end

  def slice!(*args); end

  def split(*args); end

  def tidy_bytes(force=T.unsafe(nil)); end

  def tidy_bytes!(*args); end

  def titlecase(); end

  def titleize(); end

  def to_str(); end

  def translate_offset(byte_offset); end

  def upcase(); end

  def upcase!(*args); end

  def wrapped_string(); end
end

class Mail::Multibyte::Chars
  def self.consumes?(string); end
end

class Mail::Multibyte::EncodingError
end

class Mail::Multibyte::EncodingError
end

module Mail::Multibyte::Unicode
  def apply_mapping(string, mapping); end

  def compose_codepoints(codepoints); end

  def decompose_codepoints(type, codepoints); end

  def default_normalization_form(); end

  def default_normalization_form=(default_normalization_form); end

  def g_pack(unpacked); end

  def g_unpack(string); end

  def in_char_class?(codepoint, classes); end

  def normalize(string, form=T.unsafe(nil)); end

  def reorder_characters(codepoints); end

  def tidy_bytes(string, force=T.unsafe(nil)); end

  def u_unpack(string); end
  HANGUL_JAMO_FIRST = ::T.let(nil, ::T.untyped)
  HANGUL_JAMO_LAST = ::T.let(nil, ::T.untyped)
  HANGUL_LBASE = ::T.let(nil, ::T.untyped)
  HANGUL_LCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_NCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SBASE = ::T.let(nil, ::T.untyped)
  HANGUL_SCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_SLAST = ::T.let(nil, ::T.untyped)
  HANGUL_TBASE = ::T.let(nil, ::T.untyped)
  HANGUL_TCOUNT = ::T.let(nil, ::T.untyped)
  HANGUL_VBASE = ::T.let(nil, ::T.untyped)
  HANGUL_VCOUNT = ::T.let(nil, ::T.untyped)
  LEADERS_AND_TRAILERS = ::T.let(nil, ::T.untyped)
  LEADERS_PAT = ::T.let(nil, ::T.untyped)
  NORMALIZATION_FORMS = ::T.let(nil, ::T.untyped)
  TRAILERS_PAT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  WHITESPACE = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::Codepoint
  def code(); end

  def code=(code); end

  def combining_class(); end

  def combining_class=(combining_class); end

  def decomp_mapping(); end

  def decomp_mapping=(decomp_mapping); end

  def decomp_type(); end

  def decomp_type=(decomp_type); end

  def lowercase_mapping(); end

  def lowercase_mapping=(lowercase_mapping); end

  def swapcase_mapping(); end

  def uppercase_mapping(); end

  def uppercase_mapping=(uppercase_mapping); end
end

class Mail::Multibyte::Unicode::Codepoint
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def boundary(); end

  def boundary=(boundary); end

  def codepoints(); end

  def codepoints=(codepoints); end

  def composition_exclusion(); end

  def composition_exclusion=(composition_exclusion); end

  def composition_map(); end

  def composition_map=(composition_map); end

  def cp1252(); end

  def cp1252=(cp1252); end

  def load(); end
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class Mail::Multibyte::Unicode::UnicodeDatabase
  def self.dirname(); end

  def self.filename(); end
end

module Mail::Multibyte::Unicode
  extend ::Mail::Multibyte::Unicode
  extend ::T::Sig
  def self.codepoints_to_pattern(array_of_codepoints); end
end

module Mail::Multibyte
  extend ::T::Sig
  def self.clean(string); end

  def self.mb_chars(str); end

  def self.proxy_class(); end

  def self.proxy_class=(proxy_class); end

  def self.valid_character(); end

  def self.verify(string); end

  def self.verify!(string); end
end

class Mail::OptionalField
end

class Mail::OptionalField
end

class Mail::POP3
  def connection(&block); end

  def delete_all(); end

  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::POP3
end

class Mail::ParameterHash
  include ::Mail::Utilities
  include ::Mail::Constants
  def [](key_name); end

  def decoded(); end

  def encoded(); end
end

class Mail::ParameterHash
end

module Mail::Parsers
end

module Mail::Parsers::AddressListsParser
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def addresses(); end

  def addresses=(_); end

  def error(); end

  def error=(_); end

  def group_names(); end

  def group_names=(_); end
end

class Mail::Parsers::AddressListsParser::AddressListStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def comments(); end

  def comments=(_); end

  def display_name(); end

  def display_name=(_); end

  def domain(); end

  def domain=(_); end

  def error(); end

  def error=(_); end

  def group(); end

  def group=(_); end

  def local(); end

  def local=(_); end

  def obs_domain_list(); end

  def obs_domain_list=(_); end

  def raw(); end

  def raw=(_); end
end

class Mail::Parsers::AddressListsParser::AddressStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::AddressListsParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentDispositionParser
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def disposition_type(); end

  def disposition_type=(_); end

  def error(); end

  def error=(_); end

  def parameters(); end

  def parameters=(_); end
end

class Mail::Parsers::ContentDispositionParser::ContentDispositionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentDispositionParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentLocationParser
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def error(); end

  def error=(_); end

  def location(); end

  def location=(_); end
end

class Mail::Parsers::ContentLocationParser::ContentLocationStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentLocationParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTransferEncodingParser
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def encoding(); end

  def encoding=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::ContentTransferEncodingParser::ContentTransferEncodingStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTransferEncodingParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ContentTypeParser
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def error(); end

  def error=(_); end

  def main_type(); end

  def main_type=(_); end

  def parameters(); end

  def parameters=(_); end

  def sub_type(); end

  def sub_type=(_); end
end

class Mail::Parsers::ContentTypeParser::ContentTypeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ContentTypeParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::DateTimeParser
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def date_string(); end

  def date_string=(_); end

  def error(); end

  def error=(_); end

  def time_string(); end

  def time_string=(_); end
end

class Mail::Parsers::DateTimeParser::DateTimeStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::DateTimeParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::EnvelopeFromParser
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def address(); end

  def address=(_); end

  def ctime_date(); end

  def ctime_date=(_); end

  def error(); end

  def error=(_); end
end

class Mail::Parsers::EnvelopeFromParser::EnvelopeFromStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::EnvelopeFromParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MessageIdsParser
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def error(); end

  def error=(_); end

  def message_ids(); end

  def message_ids=(_); end
end

class Mail::Parsers::MessageIdsParser::MessageIdsStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MessageIdsParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::MimeVersionParser
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def error(); end

  def error=(_); end

  def major(); end

  def major=(_); end

  def minor(); end

  def minor=(_); end
end

class Mail::Parsers::MimeVersionParser::MimeVersionStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::MimeVersionParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

class Mail::Parsers::PhraseListsParser
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def error(); end

  def error=(_); end

  def phrases(); end

  def phrases=(_); end
end

class Mail::Parsers::PhraseListsParser::PhraseListsStruct
  def self.[](*_); end

  def self.members(); end
end

class Mail::Parsers::PhraseListsParser
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers::ReceivedParser
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def date(); end

  def date=(_); end

  def error(); end

  def error=(_); end

  def info(); end

  def info=(_); end

  def time(); end

  def time=(_); end
end

class Mail::Parsers::ReceivedParser::ReceivedStruct
  def self.[](*_); end

  def self.members(); end
end

module Mail::Parsers::ReceivedParser
  extend ::T::Sig
  def self.en_comment_tail(); end

  def self.en_comment_tail=(en_comment_tail); end

  def self.en_main(); end

  def self.en_main=(en_main); end

  def self.error(); end

  def self.error=(error); end

  def self.first_final(); end

  def self.first_final=(first_final); end

  def self.parse(data); end

  def self.start(); end

  def self.start=(start); end
end

module Mail::Parsers
  extend ::T::Sig
end

class Mail::Part
  def add_content_id(content_id_val=T.unsafe(nil)); end

  def cid(); end

  def delivery_status_data(); end

  def delivery_status_report_part?(); end

  def has_content_id?(); end

  def inline?(); end

  def inline_content_id(); end

  def url(); end
end

class Mail::Part
end

class Mail::PartsList
  def attachments(); end

  def collect(); end

  def collect!(); end

  def encode_with(coder); end

  def initialize(*args); end

  def map(); end

  def map!(); end

  def parts(); end

  def sort(); end

  def sort!(order); end

  def to_yaml(options=T.unsafe(nil)); end
end

class Mail::PartsList
end

class Mail::PhraseList
  def initialize(string); end

  def phrases(); end
end

class Mail::PhraseList
end

class Mail::ReceivedElement
  include ::Mail::Utilities
  include ::Mail::Constants
  def date_time(); end

  def info(); end

  def initialize(string); end

  def to_s(*args); end
end

class Mail::ReceivedElement
end

class Mail::ReceivedField
  def date_time(); end

  def decoded(); end

  def element(); end

  def encoded(); end

  def formatted_date(); end

  def info(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end

  def parse(val=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReceivedField
end

class Mail::ReferencesField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReferencesField
end

class Mail::ReplyToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReplyToField
end

class Mail::ResentBccField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentBccField
end

class Mail::ResentCcField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentCcField
end

class Mail::ResentDateField
  include ::Mail::CommonDate
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentDateField
end

class Mail::ResentFromField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentFromField
end

class Mail::ResentMessageIdField
  include ::Mail::CommonMessageId
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentMessageIdField
end

class Mail::ResentSenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentSenderField
end

class Mail::ResentToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ResentToField
end

class Mail::Retriever
  def all(options=T.unsafe(nil), &block); end

  def find_and_delete(options=T.unsafe(nil), &block); end

  def first(options=T.unsafe(nil), &block); end

  def last(options=T.unsafe(nil), &block); end
end

class Mail::Retriever
end

class Mail::ReturnPathField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ReturnPathField
end

class Mail::Ruby19
end

class Mail::Ruby19::BestEffortCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::BestEffortCharsetEncoder
end

class Mail::Ruby19::StrictCharsetEncoder
  def encode(string, charset); end
end

class Mail::Ruby19::StrictCharsetEncoder
end

class Mail::Ruby19
  def self.b_value_decode(str); end

  def self.b_value_encode(str, encoding=T.unsafe(nil)); end

  def self.bracket(str); end

  def self.charset_encoder(); end

  def self.charset_encoder=(charset_encoder); end

  def self.decode_base64(str); end

  def self.decode_utf7(utf7); end

  def self.encode_base64(str); end

  def self.encode_utf7(string); end

  def self.escape_bracket(str); end

  def self.escape_paren(str); end

  def self.get_constant(klass, string); end

  def self.has_constant?(klass, string); end

  def self.param_decode(str, encoding); end

  def self.param_encode(str); end

  def self.paren(str); end

  def self.pick_encoding(charset); end

  def self.q_value_decode(str); end

  def self.q_value_encode(str, encoding=T.unsafe(nil)); end

  def self.string_byteslice(str, *args); end

  def self.transcode_charset(str, from_encoding, to_encoding=T.unsafe(nil)); end

  def self.uri_parser(); end
end

Mail::RubyVer = Mail::Ruby19

class Mail::SMTP
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::SMTP
end

class Mail::SMTPConnection
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end

  def smtp(); end

  def smtp=(smtp); end
end

class Mail::SMTPConnection
end

class Mail::SenderField
  include ::Mail::CommonAddress
  def address(); end

  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SenderField
end

class Mail::Sendmail
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Mail::Sendmail
  def self.call(path, arguments, destinations, encoded_message); end

  def self.popen(command, &block); end

  def self.shellquote(address); end
end

class Mail::StructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(val); end

  def errors(); end

  def initialize(name=T.unsafe(nil), value=T.unsafe(nil), charset=T.unsafe(nil)); end
end

class Mail::StructuredField
end

class Mail::SubjectField
  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::SubjectField
end

class Mail::TestMailer
  def deliver!(mail); end

  def initialize(values); end

  def settings(); end

  def settings=(settings); end
end

class Mail::TestMailer
  def self.deliveries(); end

  def self.deliveries=(val); end
end

class Mail::TestRetriever
  def find(options=T.unsafe(nil), &block); end

  def initialize(values); end
end

class Mail::TestRetriever
  def self.emails(); end

  def self.emails=(val); end
end

class Mail::ToField
  include ::Mail::CommonAddress
  def decoded(); end

  def encoded(); end

  def initialize(value=T.unsafe(nil), charset=T.unsafe(nil)); end
  CAPITALIZED_FIELD = ::T.let(nil, ::T.untyped)
  FIELD_NAME = ::T.let(nil, ::T.untyped)
end

class Mail::ToField
end

class Mail::UnknownEncodingType
end

class Mail::UnknownEncodingType
end

class Mail::UnstructuredField
  include ::Mail::CommonField
  include ::Mail::Utilities
  include ::Mail::Constants
  def charset(); end

  def charset=(charset); end

  def decoded(); end

  def encoded(); end

  def errors(); end

  def initialize(name, value, charset=T.unsafe(nil)); end

  def parse(); end
end

class Mail::UnstructuredField
end

module Mail::Utilities
  include ::Mail::Constants
  def atom_safe?(str); end

  def bracket(str); end

  def capitalize_field(str); end

  def constantize(str); end

  def dasherize(str); end

  def dquote(str); end

  def escape_paren(str); end

  def map_lines(str, &block); end

  def map_with_index(enum, &block); end

  def match_to_s(obj1, obj2); end

  def paren(str); end

  def quote_atom(str); end

  def quote_phrase(str); end

  def quote_token(str); end

  def token_safe?(str); end

  def unbracket(str); end

  def underscoreize(str); end

  def unparen(str); end

  def uri_escape(str); end

  def uri_parser(); end

  def uri_unescape(str); end
  CRLF = ::T.let(nil, ::T.untyped)
  LF = ::T.let(nil, ::T.untyped)
  TO_CRLF_REGEX = ::T.let(nil, ::T.untyped)
end

module Mail::Utilities
  extend ::T::Sig
  def self.binary_unsafe_to_crlf(string); end

  def self.binary_unsafe_to_lf(string); end

  def self.blank?(value); end

  def self.safe_for_line_ending_conversion?(string); end

  def self.to_crlf(string); end

  def self.to_lf(string); end

  def self.unescape(str); end

  def self.unquote(str); end
end

module Mail::VERSION
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module Mail::VERSION
  extend ::T::Sig
  def self.version(); end
end

module Mail
  extend ::T::Sig
  def self.all(*args, &block); end

  def self.connection(&block); end

  def self.defaults(&block); end

  def self.delete_all(*args, &block); end

  def self.deliver(*args, &block); end

  def self.delivery_method(); end

  def self.eager_autoload!(); end

  def self.find(*args, &block); end

  def self.find_and_delete(*args, &block); end

  def self.first(*args, &block); end

  def self.inform_interceptors(mail); end

  def self.inform_observers(mail); end

  def self.last(*args, &block); end

  def self.new(*args, &block); end

  def self.random_tag(); end

  def self.read(filename); end

  def self.read_from_string(mail_as_string); end

  def self.register_autoload(name, path); end

  def self.register_interceptor(interceptor); end

  def self.register_observer(observer); end

  def self.retriever_method(); end

  def self.something_random(); end

  def self.uniq(); end

  def self.unregister_interceptor(interceptor); end

  def self.unregister_observer(observer); end
end

module Marcel
  VERSION = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  BINARY = ::T.let(nil, ::T.untyped)
end

class Marcel::MimeType
  def self.extend(type, extensions: T.unsafe(nil), parents: T.unsafe(nil), magic: T.unsafe(nil)); end

  def self.for(pathname_or_io=T.unsafe(nil), name: T.unsafe(nil), extension: T.unsafe(nil), declared_type: T.unsafe(nil)); end
end

module Marcel
  extend ::T::Sig
end

module Marshal
  extend ::T::Sig
  extend ::ActiveSupport::MarshalWithAutoloading
  def self.restore(*_); end
end

class MatchData
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def named_captures(); end
end

class MatchData
  extend ::T::Sig
end

class Math::DomainError
  extend ::T::Sig
end

module Math
  extend ::T::Sig
end

module Memoizable
  include ::Memoizable::InstanceMethods
  Freezer = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Memoizable::InstanceMethods
  def freeze(); end

  def memoize(data); end
end

module Memoizable::InstanceMethods
  extend ::T::Sig
end

class Memoizable::Memory
  def [](name); end

  def []=(name, value); end

  def fetch(name); end

  def key?(name); end

  def marshal_dump(); end

  def marshal_load(hash); end
end

class Memoizable::Memory
end

class Memoizable::MethodBuilder
  def call(); end

  def initialize(descendant, method_name, freezer); end

  def original_method(); end
end

class Memoizable::MethodBuilder::BlockNotAllowedError
  def initialize(descendant, method); end
end

class Memoizable::MethodBuilder::BlockNotAllowedError
end

class Memoizable::MethodBuilder::InvalidArityError
  def initialize(descendant, method, arity); end
end

class Memoizable::MethodBuilder::InvalidArityError
end

class Memoizable::MethodBuilder
end

module Memoizable::ModuleMethods
  def freezer(); end

  def memoize(*methods); end

  def memoized?(name); end

  def unmemoized_instance_method(name); end
end

module Memoizable::ModuleMethods
  extend ::T::Sig
end

module Memoizable
  extend ::T::Sig
end

class MessagePack::Buffer
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class MessagePack::Buffer
  extend ::T::Sig
end

module MessagePack::CoreExt
  extend ::T::Sig
end

class MessagePack::ExtensionValue
  extend ::T::Sig
end

class MessagePack::Factory
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class MessagePack::Factory
  extend ::T::Sig
end

class MessagePack::MalformedFormatError
  extend ::T::Sig
end

class MessagePack::Packer
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class MessagePack::Packer
  extend ::T::Sig
end

class MessagePack::StackError
  extend ::T::Sig
end

module MessagePack::TypeError
  extend ::T::Sig
end

class MessagePack::UnexpectedTypeError
  extend ::T::Sig
end

class MessagePack::UnknownExtTypeError
  extend ::T::Sig
end

class MessagePack::UnpackError
  extend ::T::Sig
end

class MessagePack::Unpacker
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class MessagePack::Unpacker
  extend ::T::Sig
end

module MessagePack
  extend ::T::Sig
end

class Method
  include ::MethodSource::MethodExtensions
  include ::MethodSource::SourceLocation::MethodExtensions
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ===(*_); end

  def [](*_); end

  def arity(); end

  def clone(); end

  def curry(*_); end

  def name(); end

  def original_name(); end

  def owner(); end

  def parameters(); end

  def receiver(); end

  def super_method(); end

  def unbind(); end
end

class Method
  extend ::T::Sig
end

module MethodOrProcHelper
  def call_method_or_exec_proc(symbol_or_proc, *args); end

  def call_method_or_proc_on(receiver, *args); end

  def render_in_context(context, obj, *args); end

  def render_or_call_method_or_proc_on(obj, string_symbol_or_proc, options=T.unsafe(nil)); end
end

module MethodOrProcHelper
  extend ::T::Sig
end

module MethodSource
  VERSION = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers
  def comment_describing(file, line_number); end

  def complete_expression?(str); end

  def expression_at(file, line_number, options=T.unsafe(nil)); end
end

module MethodSource::CodeHelpers::IncompleteExpression
  GENERIC_REGEXPS = ::T.let(nil, ::T.untyped)
  RBX_ONLY_REGEXPS = ::T.let(nil, ::T.untyped)
end

module MethodSource::CodeHelpers::IncompleteExpression
  extend ::T::Sig
  def self.===(ex); end

  def self.rbx?(); end
end

module MethodSource::CodeHelpers
  extend ::T::Sig
end

module MethodSource::MethodExtensions
  def comment(); end

  def source(); end
end

module MethodSource::MethodExtensions
  extend ::T::Sig
  def self.included(klass); end
end

module MethodSource::ReeSourceLocation
  def source_location(); end
end

module MethodSource::ReeSourceLocation
  extend ::T::Sig
end

module MethodSource::SourceLocation
end

module MethodSource::SourceLocation::MethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::MethodExtensions
  extend ::T::Sig
end

module MethodSource::SourceLocation::ProcExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::ProcExtensions
  extend ::T::Sig
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  def source_location(); end
end

module MethodSource::SourceLocation::UnboundMethodExtensions
  extend ::T::Sig
end

module MethodSource::SourceLocation
  extend ::T::Sig
end

class MethodSource::SourceNotFoundError
end

class MethodSource::SourceNotFoundError
end

module MethodSource
  extend ::MethodSource::CodeHelpers
  extend ::T::Sig
  def self.comment_helper(source_location, name=T.unsafe(nil)); end

  def self.extract_code(source_location); end

  def self.lines_for(file_name, name=T.unsafe(nil)); end

  def self.source_helper(source_location, name=T.unsafe(nil)); end

  def self.valid_expression?(str); end
end

Methods = T::Private::Methods

class MicroMachine
  def events(); end

  def initialize(initial_state); end

  def on(key, &block); end

  def state(); end

  def states(); end

  def transitions_for(); end

  def trigger(event, payload=T.unsafe(nil)); end

  def trigger!(event, payload=T.unsafe(nil)); end

  def trigger?(event); end

  def triggerable_events(); end

  def when(event, transitions); end
end

class MicroMachine::InvalidEvent
end

class MicroMachine::InvalidEvent
end

class MicroMachine::InvalidState
end

class MicroMachine::InvalidState
end

class MicroMachine
end

module Mime
  ALL = ::T.let(nil, ::T.untyped)
  EXTENSION_LOOKUP = ::T.let(nil, ::T.untyped)
  LOOKUP = ::T.let(nil, ::T.untyped)
  SET = ::T.let(nil, ::T.untyped)
end

class Mime::AllType
  include ::Singleton
  def initialize(); end
end

class Mime::AllType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Mimes
  include ::Enumerable
  def <<(type); end

  def delete_if(); end

  def each(); end

  def symbols(); end
end

class Mime::Mimes
end

class Mime::NullType
  include ::Singleton
  def ref(); end
end

class Mime::NullType
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Mime::Type
  def ==(mime_type); end

  def ===(list); end

  def =~(mime_type); end

  def all?(); end

  def eql?(other); end

  def html?(); end

  def initialize(string, symbol=T.unsafe(nil), synonyms=T.unsafe(nil)); end

  def ref(); end

  def string(); end

  def symbol(); end

  def synonyms(); end

  def to_str(); end

  def to_sym(); end
end

class Mime::Type::AcceptItem
  def index(); end

  def index=(index); end

  def initialize(index, name, q=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def q(); end

  def q=(q); end
end

class Mime::Type::AcceptItem
end

class Mime::Type::AcceptList
end

class Mime::Type::AcceptList
  def self.find_item_by_name(array, name); end

  def self.sort!(list); end
end

class Mime::Type
  def self.lookup(string); end

  def self.lookup_by_extension(extension); end

  def self.parse(accept_header); end

  def self.parse_data_with_trailing_star(type); end

  def self.parse_trailing_star(accept_header); end

  def self.register(string, symbol, mime_type_synonyms=T.unsafe(nil), extension_synonyms=T.unsafe(nil), skip_lookup=T.unsafe(nil)); end

  def self.register_alias(string, symbol, extension_synonyms=T.unsafe(nil)); end

  def self.register_callback(&block); end

  def self.unregister(symbol); end
end

module Mime
  extend ::T::Sig
  def self.[](type); end

  def self.fetch(type); end
end

module MiniMime
  VERSION = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db
  def lookup_by_content_type(content_type); end

  def lookup_by_extension(extension); end
  LOCK = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::Cache
  def []=(key, val); end

  def fetch(key, &blk); end

  def initialize(size); end
end

class MiniMime::Db::Cache
end

class MiniMime::Db::RandomAccessDb
  def initialize(name, sort_order); end

  def lookup(val); end

  def lookup_uncached(val); end

  def resolve(row); end
  MAX_CACHED = ::T.let(nil, ::T.untyped)
end

class MiniMime::Db::RandomAccessDb
end

class MiniMime::Db
  def self.lookup_by_content_type(content_type); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

class MiniMime::Info
  def [](idx); end

  def binary?(); end

  def content_type(); end

  def content_type=(content_type); end

  def encoding(); end

  def encoding=(encoding); end

  def extension(); end

  def extension=(extension); end

  def initialize(buffer); end
  BINARY_ENCODINGS = ::T.let(nil, ::T.untyped)
end

class MiniMime::Info
end

module MiniMime
  extend ::T::Sig
  def self.lookup_by_content_type(mime); end

  def self.lookup_by_extension(extension); end

  def self.lookup_by_filename(filename); end
end

module Minitest::Assertions
  def _synchronize(); end

  def assert(test, msg=T.unsafe(nil)); end

  def assert_empty(obj, msg=T.unsafe(nil)); end

  def assert_equal(exp, act, msg=T.unsafe(nil)); end

  def assert_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_in_epsilon(exp, act, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_includes(collection, obj, msg=T.unsafe(nil)); end

  def assert_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def assert_match(matcher, obj, msg=T.unsafe(nil)); end

  def assert_nil(obj, msg=T.unsafe(nil)); end

  def assert_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def assert_output(stdout=T.unsafe(nil), stderr=T.unsafe(nil)); end

  def assert_predicate(o1, op, msg=T.unsafe(nil)); end

  def assert_raises(*exp); end

  def assert_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def assert_same(exp, act, msg=T.unsafe(nil)); end

  def assert_send(send_ary, m=T.unsafe(nil)); end

  def assert_silent(); end

  def assert_throws(sym, msg=T.unsafe(nil)); end

  def capture_io(); end

  def capture_subprocess_io(); end

  def diff(exp, act); end

  def exception_details(e, msg); end

  def flunk(msg=T.unsafe(nil)); end

  def message(msg=T.unsafe(nil), ending=T.unsafe(nil), &default); end

  def mu_pp(obj); end

  def mu_pp_for_diff(obj); end

  def pass(_msg=T.unsafe(nil)); end

  def refute(test, msg=T.unsafe(nil)); end

  def refute_empty(obj, msg=T.unsafe(nil)); end

  def refute_equal(exp, act, msg=T.unsafe(nil)); end

  def refute_in_delta(exp, act, delta=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_in_epsilon(a, b, epsilon=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_includes(collection, obj, msg=T.unsafe(nil)); end

  def refute_instance_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_kind_of(cls, obj, msg=T.unsafe(nil)); end

  def refute_match(matcher, obj, msg=T.unsafe(nil)); end

  def refute_nil(obj, msg=T.unsafe(nil)); end

  def refute_operator(o1, op, o2=T.unsafe(nil), msg=T.unsafe(nil)); end

  def refute_predicate(o1, op, msg=T.unsafe(nil)); end

  def refute_respond_to(obj, meth, msg=T.unsafe(nil)); end

  def refute_same(exp, act, msg=T.unsafe(nil)); end

  def skip(msg=T.unsafe(nil), bt=T.unsafe(nil)); end

  def skipped?(); end
  E = ::T.let(nil, ::T.untyped)
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module Minitest::Assertions
  extend ::T::Sig
  def self.diff(); end

  def self.diff=(o); end
end

module Minitest::Guard
  def jruby?(platform=T.unsafe(nil)); end

  def maglev?(platform=T.unsafe(nil)); end

  def mri?(platform=T.unsafe(nil)); end

  def rubinius?(platform=T.unsafe(nil)); end

  def windows?(platform=T.unsafe(nil)); end
end

module Minitest::Guard
  extend ::T::Sig
end

module Minitest::Reportable
  def class_name(); end

  def error?(); end

  def location(); end

  def passed?(); end

  def result_code(); end

  def skipped?(); end
end

module Minitest::Reportable
  extend ::T::Sig
end

class Minitest::Runnable
  def assertions(); end

  def assertions=(assertions); end

  def failure(); end

  def failures(); end

  def failures=(failures); end

  def initialize(name); end

  def marshal_dump(); end

  def marshal_load(ary); end

  def name(); end

  def name=(o); end

  def passed?(); end

  def result_code(); end

  def run(); end

  def skipped?(); end

  def time(); end

  def time=(time); end

  def time_it(); end
  SIGNALS = ::T.let(nil, ::T.untyped)
end

class Minitest::Runnable
  def self.inherited(klass); end

  def self.methods_matching(re); end

  def self.on_signal(name, action); end

  def self.reset(); end

  def self.run(reporter, options=T.unsafe(nil)); end

  def self.run_one_method(klass, method_name, reporter); end

  def self.runnable_methods(); end

  def self.runnables(); end

  def self.with_info_handler(reporter, &block); end
end

class Minitest::Test
  include ::Minitest::Assertions
  include ::Minitest::Reportable
  include ::Minitest::Test::LifecycleHooks
  include ::Minitest::Guard
  def capture_exceptions(); end

  def with_info_handler(&block); end
  PASSTHROUGH_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  TEARDOWN_METHODS = ::T.let(nil, ::T.untyped)
end

module Minitest::Test::LifecycleHooks
  def after_setup(); end

  def after_teardown(); end

  def before_setup(); end

  def before_teardown(); end

  def setup(); end

  def teardown(); end
end

module Minitest::Test::LifecycleHooks
  extend ::T::Sig
end

class Minitest::Test
  extend ::Minitest::Guard
  def self.i_suck_and_my_tests_are_order_dependent!(); end

  def self.io_lock(); end

  def self.io_lock=(io_lock); end

  def self.make_my_diffs_pretty!(); end

  def self.parallelize_me!(); end

  def self.test_order(); end
end

module ModelAttribute
  def attribute(name, type, opts=T.unsafe(nil)); end

  def attribute_defaults(); end

  def attributes(); end
  SUPPORTED_TYPES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module ModelAttribute::Casts
end

module ModelAttribute::Casts
  extend ::T::Sig
  def self.cast(value, type); end
end

module ModelAttribute::InstanceMethods
  def ==(other); end

  def attributes(); end

  def attributes_for_json(); end

  def changes(); end

  def changes_for_json(); end

  def eql?(other); end

  def inspect(); end

  def read_attribute(name); end

  def set_attributes(attributes, can_set_private_attrs=T.unsafe(nil)); end

  def write_attribute(name, value, type=T.unsafe(nil)); end
end

module ModelAttribute::InstanceMethods
  extend ::T::Sig
end

class ModelAttribute::InvalidAttributeNameError
  def initialize(attribute_name); end
end

class ModelAttribute::InvalidAttributeNameError
end

class ModelAttribute::UnsupportedTypeError
  def initialize(type); end
end

class ModelAttribute::UnsupportedTypeError
end

module ModelAttribute
  extend ::T::Sig
  def self.extended(base); end
end

class Module
  include ::ActiveSupport::Dependencies::ModuleConstMissing
  include ::Module::Concerning
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def alias_attribute(new_name, old_name); end

  def anonymous?(); end

  def attr_internal(*attrs); end

  def attr_internal_accessor(*attrs); end

  def attr_internal_reader(*attrs); end

  def attr_internal_writer(*attrs); end

  def cattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def cattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def cattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def context(*a, &b); end

  def delegate(*methods, to: T.unsafe(nil), prefix: T.unsafe(nil), allow_nil: T.unsafe(nil)); end

  def delegate_missing_to(target); end

  def deprecate(*method_names); end

  def deprecate_constant(*_); end

  def describe(*a, &b); end

  def example_group(*a, &b); end

  def fcontext(*a, &b); end

  def fdescribe(*a, &b); end

  def mattr_accessor(*syms, instance_reader: T.unsafe(nil), instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil), &blk); end

  def mattr_reader(*syms, instance_reader: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def mattr_writer(*syms, instance_writer: T.unsafe(nil), instance_accessor: T.unsafe(nil), default: T.unsafe(nil)); end

  def method_visibility(method); end

  def parent(); end

  def parent_name(); end

  def parents(); end

  def rake_extension(method); end

  def redefine_method(method, &block); end

  def redefine_singleton_method(method, &block); end

  def remove_possible_method(method); end

  def remove_possible_singleton_method(method); end

  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end

  def silence_redefinition_of_method(method); end

  def thread_cattr_accessor(*syms); end

  def thread_cattr_reader(*syms); end

  def thread_cattr_writer(*syms); end

  def thread_mattr_accessor(*syms); end

  def thread_mattr_reader(*syms); end

  def thread_mattr_writer(*syms); end

  def undef_method(*_); end

  def xcontext(*a, &b); end

  def xdescribe(*a, &b); end
  DELEGATION_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
  DELEGATION_RESERVED_METHOD_NAMES = ::T.let(nil, ::T.untyped)
  RUBY_RESERVED_KEYWORDS = ::T.let(nil, ::T.untyped)
end

module Module::Concerning
  def concern(topic, &module_definition); end

  def concerning(topic, &block); end
end

module Module::Concerning
  extend ::T::Sig
end

class Module::DelegationError
end

class Module::DelegationError
end

class Module
  extend ::T::Sig
  def self.attr_internal_naming_format(); end

  def self.attr_internal_naming_format=(attr_internal_naming_format); end

  def self.used_modules(); end
end

class Money
  include ::Comparable
  include ::Money::Arithmetic
  def allocate(parts); end

  def amount(); end

  def as_ca_dollar(); end

  def as_euro(); end

  def as_us_dollar(); end

  def bank(); end

  def cents(); end

  def currency(); end

  def currency_as_string(); end

  def currency_as_string=(val); end

  def decimal_mark(); end

  def dollars(); end

  def exchange_to(other_currency, &rounding_method); end

  def format(*rules); end

  def fractional(); end

  def initialize(obj, currency=T.unsafe(nil), bank=T.unsafe(nil)); end

  def round(rounding_mode=T.unsafe(nil), rounding_precision=T.unsafe(nil)); end

  def round_to_nearest_cash_value(); end

  def split(parts); end

  def symbol(); end

  def thousands_separator(); end

  def to_d(); end

  def to_f(); end

  def to_i(); end

  def to_money(given_currency=T.unsafe(nil)); end

  def with_currency(new_currency); end
end

class Money::Allocation
end

class Money::Allocation
  def self.generate(amount, parts, whole_amounts=T.unsafe(nil)); end
end

module Money::Arithmetic
  def %(val); end

  def *(value); end

  def +(other); end

  def -(other); end

  def -@(); end

  def /(value); end

  def ==(other); end

  def abs(); end

  def coerce(other); end

  def div(value); end

  def divmod(val); end

  def eql?(other_money); end

  def modulo(val); end

  def negative?(); end

  def nonzero?(); end

  def positive?(); end

  def remainder(val); end

  def zero?(); end
end

class Money::Arithmetic::CoercedNumeric
  def value(); end

  def value=(_); end

  def zero?(); end
end

class Money::Arithmetic::CoercedNumeric
  def self.[](*_); end

  def self.members(); end
end

module Money::Arithmetic
  extend ::T::Sig
end

module Money::Bank
end

class Money::Bank::Base
  def exchange_with(from, to_currency, &block); end

  def initialize(&block); end

  def rounding_method(); end

  def same_currency?(currency1, currency2); end

  def setup(); end
end

class Money::Bank::Base
  def self.instance(); end
end

class Money::Bank::DifferentCurrencyError
end

class Money::Bank::DifferentCurrencyError
end

class Money::Bank::Error
end

class Money::Bank::Error
end

class Money::Bank::SingleCurrency
end

class Money::Bank::SingleCurrency
end

class Money::Bank::UnknownRate
end

class Money::Bank::UnknownRate
end

class Money::Bank::UnknownRateFormat
end

class Money::Bank::UnknownRateFormat
end

class Money::Bank::VariableExchange
  def add_rate(from, to, rate); end

  def calculate_fractional(from, to_currency); end

  def exchange(fractional, rate, &block); end

  def export_rates(format, file=T.unsafe(nil), opts=T.unsafe(nil)); end

  def get_rate(from, to, opts=T.unsafe(nil)); end

  def import_rates(format, s, opts=T.unsafe(nil)); end

  def initialize(st=T.unsafe(nil), &block); end

  def marshal_dump(); end

  def marshal_load(arr); end

  def mutex(); end

  def rates(); end

  def set_rate(from, to, rate, opts=T.unsafe(nil)); end

  def store(); end
  FORMAT_SERIALIZERS = ::T.let(nil, ::T.untyped)
  RATE_FORMATS = ::T.let(nil, ::T.untyped)
  SERIALIZER_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Money::Bank::VariableExchange
end

module Money::Bank
  extend ::T::Sig
end

module Money::Constructors
  def ca_dollar(cents); end

  def cad(cents); end

  def empty(currency=T.unsafe(nil)); end

  def eur(cents); end

  def euro(cents); end

  def gbp(pence); end

  def pound_sterling(pence); end

  def us_dollar(cents); end

  def usd(cents); end

  def zero(currency=T.unsafe(nil)); end
end

module Money::Constructors
  extend ::T::Sig
end

class Money::Currency
  include ::Comparable
  def ==(other_currency); end

  def code(); end

  def decimal_mark(); end

  def decimal_places(); end

  def delimiter(); end

  def disambiguate_symbol(); end

  def exponent(); end

  def html_entity(); end

  def id(); end

  def initialize(id); end

  def iso?(); end

  def iso_code(); end

  def iso_numeric(); end

  def name(); end

  def priority(); end

  def separator(); end

  def smallest_denomination(); end

  def subunit(); end

  def subunit_to_unit(); end

  def symbol(); end

  def symbol_first(); end

  def symbol_first?(); end

  def thousands_separator(); end

  def to_currency(); end

  def to_str(); end

  def to_sym(); end
end

module Money::Currency::Heuristics
  def analyze(str); end
end

module Money::Currency::Heuristics
  extend ::T::Sig
end

module Money::Currency::Loader
  def load_currencies(); end
  DATA_PATH = ::T.let(nil, ::T.untyped)
end

module Money::Currency::Loader
  extend ::T::Sig
end

class Money::Currency::MissingAttributeError
  def initialize(method, currency, attribute); end
end

class Money::Currency::MissingAttributeError
end

class Money::Currency::UnknownCurrency
end

class Money::Currency::UnknownCurrency
end

class Money::Currency
  extend ::Enumerable
  extend ::Money::Currency::Loader
  extend ::Money::Currency::Heuristics
  def self._instances(); end

  def self.all(); end

  def self.each(); end

  def self.find(id); end

  def self.find_by_iso_numeric(num); end

  def self.inherit(parent_iso_code, curr); end

  def self.new(id); end

  def self.register(curr); end

  def self.stringified_keys(); end

  def self.table(); end

  def self.unregister(curr); end

  def self.wrap(object); end
end

class Money::Formatter
  def decimal_mark(); end

  def delimiter(); end

  def initialize(money, *rules); end

  def separator(); end

  def thousands_separator(); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Money::Formatter
end

class Money::FormattingRules
  def [](key); end

  def has_key?(key); end

  def initialize(currency, *raw_rules); end
end

class Money::FormattingRules
end

module Money::LocaleBackend
  BACKENDS = ::T.let(nil, ::T.untyped)
end

class Money::LocaleBackend::Base
end

class Money::LocaleBackend::Base
end

class Money::LocaleBackend::I18n
  def lookup(key, _); end
  KEY_MAP = ::T.let(nil, ::T.untyped)
end

class Money::LocaleBackend::I18n
end

class Money::LocaleBackend::Legacy
  def lookup(key, currency); end
end

class Money::LocaleBackend::Legacy
end

class Money::LocaleBackend::NotSupported
end

class Money::LocaleBackend::NotSupported
end

class Money::LocaleBackend::Unknown
end

class Money::LocaleBackend::Unknown
end

module Money::LocaleBackend
  extend ::T::Sig
  def self.find(name); end
end

module Money::RatesStore
end

class Money::RatesStore::Memory
  def add_rate(currency_iso_from, currency_iso_to, rate); end

  def each_rate(&block); end

  def get_rate(currency_iso_from, currency_iso_to); end

  def initialize(opts=T.unsafe(nil), rt=T.unsafe(nil)); end

  def marshal_dump(); end

  def transaction(&block); end
  INDEX_KEY_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Money::RatesStore::Memory
end

module Money::RatesStore
  extend ::T::Sig
end

class Money::UndefinedSmallestDenomination
end

class Money::UndefinedSmallestDenomination
end

class Money
  extend ::Money::Constructors
  def self.add_rate(from_currency, to_currency, rate); end

  def self.conversion_precision(); end

  def self.conversion_precision=(conversion_precision); end

  def self.default_bank(); end

  def self.default_bank=(default_bank); end

  def self.default_currency(); end

  def self.default_currency=(default_currency); end

  def self.default_formatting_rules(); end

  def self.default_formatting_rules=(default_formatting_rules); end

  def self.disallow_currency_conversion!(); end

  def self.from_amount(amount, currency=T.unsafe(nil), bank=T.unsafe(nil)); end

  def self.infinite_precision(); end

  def self.infinite_precision=(infinite_precision); end

  def self.inherited(base); end

  def self.locale_backend(); end

  def self.locale_backend=(value); end

  def self.rounding_mode(mode=T.unsafe(nil)); end

  def self.rounding_mode=(rounding_mode); end

  def self.setup_defaults(); end

  def self.use_i18n(); end

  def self.use_i18n=(value); end
end

class Monitor
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def enter(); end

  def exit(); end

  def try_enter(); end
end

class Monitor
  extend ::T::Sig
end

module MonitorMixin
  def initialize(*args); end

  def mon_enter(); end

  def mon_exit(); end

  def mon_locked?(); end

  def mon_owned?(); end

  def mon_synchronize(); end

  def mon_try_enter(); end

  def new_cond(); end

  def synchronize(); end

  def try_mon_enter(); end
end

class MonitorMixin::ConditionVariable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def broadcast(); end

  def initialize(monitor); end

  def signal(); end

  def wait(timeout=T.unsafe(nil)); end

  def wait_until(); end

  def wait_while(); end
end

class MonitorMixin::ConditionVariable::Timeout
  extend ::T::Sig
end

class MonitorMixin::ConditionVariable
  extend ::T::Sig
end

module MonitorMixin
  extend ::T::Sig
  def self.extend_object(obj); end
end

module MultiJson
  include ::MultiJson::Options
  def adapter(); end

  def adapter=(new_adapter); end

  def cached_options(*_); end

  def current_adapter(options=T.unsafe(nil)); end

  def decode(string, options=T.unsafe(nil)); end

  def default_adapter(); end

  def default_engine(); end

  def default_options(); end

  def default_options=(value); end

  def dump(object, options=T.unsafe(nil)); end

  def encode(object, options=T.unsafe(nil)); end

  def engine(); end

  def engine=(new_adapter); end

  def load(string, options=T.unsafe(nil)); end

  def load_adapter(new_adapter); end

  def reset_cached_options!(*_); end

  def use(new_adapter); end

  def with_adapter(new_adapter); end

  def with_engine(new_adapter); end
  ALIASES = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class MultiJson::AdapterError
end

class MultiJson::AdapterError
  def self.build(original_exception); end
end

MultiJson::DecodeError = MultiJson::ParseError

MultiJson::LoadError = MultiJson::ParseError

module MultiJson::Options
  def default_dump_options(); end

  def default_load_options(); end

  def dump_options(*args); end

  def dump_options=(options); end

  def load_options(*args); end

  def load_options=(options); end
end

module MultiJson::Options
  extend ::T::Sig
end

module MultiJson::OptionsCache
  def fetch(type, key); end

  def reset(); end
  MAX_CACHE_SIZE = ::T.let(nil, ::T.untyped)
end

module MultiJson::OptionsCache
  extend ::MultiJson::OptionsCache
  extend ::T::Sig
end

class MultiJson::ParseError
  def data(); end
end

class MultiJson::ParseError
  def self.build(original_exception, data); end
end

class MultiJson::Version
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
end

class MultiJson::Version
end

module MultiJson
  extend ::MultiJson
  extend ::MultiJson::Options
  extend ::T::Sig
end

module MultiXml
  CONTENT_ROOT = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DISALLOWED_XML_TYPES = ::T.let(nil, ::T.untyped)
  PARSING = ::T.let(nil, ::T.untyped)
  REQUIREMENT_MAP = ::T.let(nil, ::T.untyped)
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class MultiXml::DisallowedTypeError
  def initialize(type); end
end

class MultiXml::DisallowedTypeError
end

class MultiXml::NoParserError
end

class MultiXml::NoParserError
end

class MultiXml::ParseError
end

class MultiXml::ParseError
end

module MultiXml
  extend ::T::Sig
  def self.default_parser(); end

  def self.parse(xml, options=T.unsafe(nil)); end

  def self.parser(); end

  def self.parser=(new_parser); end
end

class Mutations::AddInitialOfferToOrder
  def load_amount_cents(value); end

  def load_note(value); end

  def load_order_id(value); end
end

class Mutations::ApproveOrder
  def load_id(value); end
end

class Mutations::BaseAcceptOffer
  def load_offer_id(value); end
end

class Mutations::BaseMutation
end

class Mutations::BaseRejectOffer
  def load_offer_id(value); end

  def load_reject_reason(value); end
end

class Mutations::BuyerCounterOffer
  def load_amount_cents(value); end

  def load_note(value); end

  def load_offer_id(value); end
end

class Mutations::ConfirmFulfillment
  def load_id(value); end
end

class Mutations::ConfirmPickup
  def load_id(value); end
end

class Mutations::CreateOfferOrderWithArtwork
  def load_artwork_id(value); end

  def load_edition_set_id(value); end

  def load_find_active_or_create(value); end

  def load_quantity(value); end
end

class Mutations::CreateOrderWithArtwork
  def load_artwork_id(value); end

  def load_edition_set_id(value); end

  def load_quantity(value); end
end

class Mutations::FixFailedPayment
  def load_credit_card_id(value); end

  def load_offer_id(value); end
end

class Mutations::FulfillAtOnce
  def load_fulfillment(value); end

  def load_id(value); end
end

class Mutations::RejectOrder
  def load_id(value); end
end

class Mutations::SellerCounterOffer
  def load_amount_cents(value); end

  def load_note(value); end

  def load_offer_id(value); end
end

class Mutations::SetPayment
  def load_credit_card_id(value); end

  def load_id(value); end
end

class Mutations::SetShipping
  def load_fulfillment_type(value); end

  def load_id(value); end

  def load_shipping(value); end
end

class Mutations::SubmitOrder
  def load_id(value); end
end

class Mutations::SubmitOrderWithOffer
  def load_offer_id(value); end
end

class Mutations::SubmitPendingOffer
  def load_offer_id(value); end
end

module Mutations
  extend ::T::Sig
end

Mutex = Thread::Mutex

module Mutex_m
  extend ::T::Sig
end

class NameError
  include ::DidYouMean::Correctable
  def missing_name(); end

  def missing_name?(name); end

  def name(); end

  def receiver(); end
end

class NameError
  extend ::T::Sig
end

class Net::APOP
end

class Net::APOP
end

Net::APOPSession = Net::APOP

class Net::BufferedIO
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::BufferedIO
  extend ::T::Sig
end

class Net::HTTP
  def datadog_pin(); end

  def max_retries(); end

  def max_retries=(retries); end

  def max_version(); end

  def max_version=(max_version); end

  def min_version(); end

  def min_version=(min_version); end

  def request_without_datadog(req, body=T.unsafe(nil), &block); end
  ENVIRONMENT_VARIABLE_IS_MULTIUSER_SAFE = ::T.let(nil, ::T.untyped)
end

class Net::HTTP::Copy
  extend ::T::Sig
end

class Net::HTTP::Delete
  extend ::T::Sig
end

class Net::HTTP::Get
  extend ::T::Sig
end

class Net::HTTP::Head
  extend ::T::Sig
end

class Net::HTTP::Lock
  extend ::T::Sig
end

class Net::HTTP::Mkcol
  extend ::T::Sig
end

class Net::HTTP::Move
  extend ::T::Sig
end

class Net::HTTP::Options
  extend ::T::Sig
end

class Net::HTTP::Patch
  extend ::T::Sig
end

class Net::HTTP::Post
  extend ::T::Sig
end

class Net::HTTP::Propfind
  extend ::T::Sig
end

class Net::HTTP::Proppatch
  extend ::T::Sig
end

module Net::HTTP::ProxyDelta
  extend ::T::Sig
end

Net::HTTP::ProxyMod = Net::HTTP::ProxyDelta

class Net::HTTP::Put
  extend ::T::Sig
end

class Net::HTTP::Trace
  extend ::T::Sig
end

class Net::HTTP::Unlock
  extend ::T::Sig
end

class Net::HTTP
  extend ::T::Sig
end

class Net::HTTPAccepted
  extend ::T::Sig
end

class Net::HTTPAlreadyReported
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPAlreadyReported
end

class Net::HTTPBadGateway
  extend ::T::Sig
end

class Net::HTTPBadRequest
  extend ::T::Sig
end

class Net::HTTPBadResponse
  include ::REST::Error::Protocol
  include ::REST::Error
end

class Net::HTTPBadResponse
  extend ::T::Sig
end

Net::HTTPClientError::EXCEPTION_TYPE = Net::HTTPServerException

class Net::HTTPClientError
  extend ::T::Sig
end

Net::HTTPClientErrorCode = Net::HTTPClientError

class Net::HTTPConflict
  extend ::T::Sig
end

class Net::HTTPContinue
  extend ::T::Sig
end

class Net::HTTPCreated
  extend ::T::Sig
end

class Net::HTTPError
  extend ::T::Sig
end

module Net::HTTPExceptions
  extend ::T::Sig
end

class Net::HTTPExpectationFailed
  extend ::T::Sig
end

class Net::HTTPFailedDependency
  extend ::T::Sig
end

class Net::HTTPFatalError
  extend ::T::Sig
end

Net::HTTPFatalErrorCode = Net::HTTPClientError

class Net::HTTPForbidden
  extend ::T::Sig
end

class Net::HTTPFound
  extend ::T::Sig
end

class Net::HTTPGatewayTimeOut
  extend ::T::Sig
end

class Net::HTTPGenericRequest
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::HTTPGenericRequest::Chunker
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::HTTPGenericRequest::Chunker
  extend ::T::Sig
end

class Net::HTTPGenericRequest
  extend ::T::Sig
end

class Net::HTTPGone
  extend ::T::Sig
end

module Net::HTTPHeader
  extend ::T::Sig
end

class Net::HTTPHeaderSyntaxError
  include ::REST::Error::Protocol
  include ::REST::Error
end

class Net::HTTPHeaderSyntaxError
  extend ::T::Sig
end

class Net::HTTPIMUsed
  extend ::T::Sig
end

class Net::HTTPInformation
  extend ::T::Sig
end

Net::HTTPInformationCode = Net::HTTPInformation

class Net::HTTPInsufficientStorage
  extend ::T::Sig
end

class Net::HTTPInternalServerError
  extend ::T::Sig
end

class Net::HTTPLengthRequired
  extend ::T::Sig
end

class Net::HTTPLocked
  extend ::T::Sig
end

class Net::HTTPLoopDetected
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPLoopDetected
end

class Net::HTTPMethodNotAllowed
  extend ::T::Sig
end

class Net::HTTPMisdirectedRequest
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPMisdirectedRequest
end

class Net::HTTPMovedPermanently
  extend ::T::Sig
end

Net::HTTPMovedTemporarily = Net::HTTPFound

class Net::HTTPMultiStatus
  extend ::T::Sig
end

Net::HTTPMultipleChoice = Net::HTTPMultipleChoices

class Net::HTTPMultipleChoices
  extend ::T::Sig
end

class Net::HTTPNetworkAuthenticationRequired
  extend ::T::Sig
end

class Net::HTTPNoContent
  extend ::T::Sig
end

class Net::HTTPNonAuthoritativeInformation
  extend ::T::Sig
end

class Net::HTTPNotAcceptable
  extend ::T::Sig
end

class Net::HTTPNotExtended
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPNotExtended
end

class Net::HTTPNotFound
  extend ::T::Sig
end

class Net::HTTPNotImplemented
  extend ::T::Sig
end

class Net::HTTPNotModified
  extend ::T::Sig
end

class Net::HTTPOK
  extend ::T::Sig
end

class Net::HTTPPartialContent
  extend ::T::Sig
end

class Net::HTTPPaymentRequired
  extend ::T::Sig
end

class Net::HTTPPermanentRedirect
  extend ::T::Sig
end

class Net::HTTPPreconditionFailed
  extend ::T::Sig
end

class Net::HTTPPreconditionRequired
  extend ::T::Sig
end

class Net::HTTPProcessing
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPProcessing
end

class Net::HTTPProxyAuthenticationRequired
  extend ::T::Sig
end

Net::HTTPRedirection::EXCEPTION_TYPE = Net::HTTPRetriableError

class Net::HTTPRedirection
  extend ::T::Sig
end

Net::HTTPRedirectionCode = Net::HTTPRedirection

class Net::HTTPRequest
  extend ::T::Sig
end

class Net::HTTPRequestEntityTooLarge
  extend ::T::Sig
end

class Net::HTTPRequestHeaderFieldsTooLarge
  extend ::T::Sig
end

class Net::HTTPRequestTimeOut
  extend ::T::Sig
end

Net::HTTPRequestURITooLarge = Net::HTTPRequestURITooLong

class Net::HTTPRequestURITooLong
  extend ::T::Sig
end

class Net::HTTPRequestedRangeNotSatisfiable
  extend ::T::Sig
end

class Net::HTTPResetContent
  extend ::T::Sig
end

Net::HTTPResponceReceiver = Net::HTTPResponse

class Net::HTTPResponse
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::HTTPResponse::Inflater
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::HTTPResponse::Inflater
  extend ::T::Sig
end

class Net::HTTPResponse
  extend ::T::Sig
end

Net::HTTPRetriableCode = Net::HTTPRedirection

class Net::HTTPRetriableError
  extend ::T::Sig
end

class Net::HTTPSeeOther
  extend ::T::Sig
end

Net::HTTPServerError::EXCEPTION_TYPE = Net::HTTPFatalError

class Net::HTTPServerError
  extend ::T::Sig
end

Net::HTTPServerErrorCode = Net::HTTPServerError

class Net::HTTPServerException
  extend ::T::Sig
end

class Net::HTTPServiceUnavailable
  extend ::T::Sig
end

Net::HTTPSession = Net::HTTP

Net::HTTPSuccess::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPSuccess
  extend ::T::Sig
end

Net::HTTPSuccessCode = Net::HTTPSuccess

class Net::HTTPSwitchProtocol
  extend ::T::Sig
end

class Net::HTTPTemporaryRedirect
  extend ::T::Sig
end

class Net::HTTPTooManyRequests
  extend ::T::Sig
end

class Net::HTTPUnauthorized
  extend ::T::Sig
end

class Net::HTTPUnavailableForLegalReasons
  extend ::T::Sig
end

Net::HTTPUnknownResponse::EXCEPTION_TYPE = Net::HTTPError

class Net::HTTPUnknownResponse
  extend ::T::Sig
end

class Net::HTTPUnprocessableEntity
  extend ::T::Sig
end

class Net::HTTPUnsupportedMediaType
  extend ::T::Sig
end

class Net::HTTPUpgradeRequired
  extend ::T::Sig
end

class Net::HTTPUseProxy
  extend ::T::Sig
end

class Net::HTTPVariantAlsoNegotiates
  HAS_BODY = ::T.let(nil, ::T.untyped)
end

class Net::HTTPVariantAlsoNegotiates
end

class Net::HTTPVersionNotSupported
  extend ::T::Sig
end

class Net::IMAP
  def open_timeout(); end

  RESPONSE_ERRORS = ::T.let(nil, ::T.untyped)
end

class Net::IMAP::Address
  extend ::T::Sig
end

class Net::IMAP::Atom
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::Atom
  extend ::T::Sig
end

class Net::IMAP::BadResponseError
  extend ::T::Sig
end

class Net::IMAP::BodyTypeAttachment
  extend ::T::Sig
end

class Net::IMAP::BodyTypeBasic
  extend ::T::Sig
end

class Net::IMAP::BodyTypeExtension
  extend ::T::Sig
end

class Net::IMAP::BodyTypeMessage
  extend ::T::Sig
end

class Net::IMAP::BodyTypeMultipart
  extend ::T::Sig
end

class Net::IMAP::BodyTypeText
  extend ::T::Sig
end

class Net::IMAP::ByeResponseError
  extend ::T::Sig
end

class Net::IMAP::ContentDisposition
  extend ::T::Sig
end

class Net::IMAP::ContinuationRequest
  extend ::T::Sig
end

class Net::IMAP::CramMD5Authenticator
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::CramMD5Authenticator
  extend ::T::Sig
end

class Net::IMAP::DataFormatError
  extend ::T::Sig
end

class Net::IMAP::DigestMD5Authenticator
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::DigestMD5Authenticator
  extend ::T::Sig
end

class Net::IMAP::Envelope
  extend ::T::Sig
end

class Net::IMAP::Error
  extend ::T::Sig
end

class Net::IMAP::FetchData
  extend ::T::Sig
end

class Net::IMAP::FlagCountError
  extend ::T::Sig
end

class Net::IMAP::Literal
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::Literal
  extend ::T::Sig
end

class Net::IMAP::LoginAuthenticator
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::LoginAuthenticator
  extend ::T::Sig
end

class Net::IMAP::MailboxACLItem
  extend ::T::Sig
end

class Net::IMAP::MailboxList
  extend ::T::Sig
end

class Net::IMAP::MailboxQuota
  extend ::T::Sig
end

class Net::IMAP::MailboxQuotaRoot
  extend ::T::Sig
end

class Net::IMAP::MessageSet
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::MessageSet
  extend ::T::Sig
end

class Net::IMAP::NoResponseError
  extend ::T::Sig
end

module Net::IMAP::NumValidator
  extend ::T::Sig
  def self.ensure_mod_sequence_value(num); end

  def self.valid_mod_sequence_value?(num); end
end

class Net::IMAP::PlainAuthenticator
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::PlainAuthenticator
  extend ::T::Sig
end

class Net::IMAP::QuotedString
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::QuotedString
  extend ::T::Sig
end

class Net::IMAP::RawData
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::RawData
  extend ::T::Sig
end

class Net::IMAP::ResponseCode
  extend ::T::Sig
end

class Net::IMAP::ResponseError
  extend ::T::Sig
end

class Net::IMAP::ResponseParseError
  extend ::T::Sig
end

class Net::IMAP::ResponseParser
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::IMAP::ResponseParser::Token
  extend ::T::Sig
end

class Net::IMAP::ResponseParser
  extend ::T::Sig
end

class Net::IMAP::ResponseText
  extend ::T::Sig
end

class Net::IMAP::StatusData
  extend ::T::Sig
end

class Net::IMAP::TaggedResponse
  extend ::T::Sig
end

class Net::IMAP::ThreadMember
  extend ::T::Sig
end

class Net::IMAP::UntaggedResponse
  extend ::T::Sig
end

class Net::IMAP
  extend ::T::Sig
end

class Net::InternetMessageIO
  extend ::T::Sig
end

Net::NetPrivate::HTTPRequest = Net::HTTPRequest

Net::NetPrivate::Socket = Net::InternetMessageIO

module Net::NetPrivate
  extend ::T::Sig
end

class Net::OpenTimeout
  extend ::T::Sig
end

Net::POP = Net::POP3

class Net::POP3
  def active?(); end

  def address(); end

  def apop?(); end

  def auth_only(account, password); end

  def delete_all(); end

  def disable_ssl(); end

  def each(&block); end

  def each_mail(&block); end

  def enable_ssl(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil), port=T.unsafe(nil)); end

  def finish(); end

  def initialize(addr, port=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def logging(msg); end

  def mails(); end

  def n_bytes(); end

  def n_mails(); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def port(); end

  def read_timeout(); end

  def read_timeout=(sec); end

  def reset(); end

  def set_all_uids(); end

  def set_debug_output(arg); end

  def start(account, password); end

  def started?(); end

  def use_ssl?(); end
  Revision = ::T.let(nil, ::T.untyped)
end

class Net::POP3
  def self.APOP(isapop); end

  def self.auth_only(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil)); end

  def self.certs(); end

  def self.create_ssl_params(verify_or_params=T.unsafe(nil), certs=T.unsafe(nil)); end

  def self.default_pop3_port(); end

  def self.default_pop3s_port(); end

  def self.default_port(); end

  def self.delete_all(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.disable_ssl(); end

  def self.enable_ssl(*args); end

  def self.foreach(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.socket_type(); end

  def self.ssl_params(); end

  def self.start(address, port=T.unsafe(nil), account=T.unsafe(nil), password=T.unsafe(nil), isapop=T.unsafe(nil), &block); end

  def self.use_ssl?(); end

  def self.verify(); end
end

class Net::POP3Command
  def apop(account, password); end

  def auth(account, password); end

  def dele(num); end

  def initialize(sock); end

  def list(); end

  def quit(); end

  def retr(num, &block); end

  def rset(); end

  def socket(); end

  def stat(); end

  def top(num, lines=T.unsafe(nil), &block); end

  def uidl(num=T.unsafe(nil)); end
end

class Net::POP3Command
end

Net::POP3Session = Net::POP3

class Net::POPAuthenticationError
end

class Net::POPAuthenticationError
end

class Net::POPBadResponse
end

class Net::POPBadResponse
end

class Net::POPError
end

class Net::POPError
end

class Net::POPMail
  def all(dest=T.unsafe(nil), &block); end

  def delete(); end

  def delete!(); end

  def deleted?(); end

  def header(dest=T.unsafe(nil)); end

  def initialize(num, len, pop, cmd); end

  def length(); end

  def mail(dest=T.unsafe(nil), &block); end

  def number(); end

  def pop(dest=T.unsafe(nil), &block); end

  def size(); end

  def top(lines, dest=T.unsafe(nil)); end

  def uid=(uid); end

  def uidl(); end

  def unique_id(); end
end

class Net::POPMail
end

Net::POPSession = Net::POP3

class Net::ProtoAuthError
  extend ::T::Sig
end

class Net::ProtoCommandError
  extend ::T::Sig
end

class Net::ProtoFatalError
  extend ::T::Sig
end

class Net::ProtoRetriableError
  extend ::T::Sig
end

class Net::ProtoServerError
  extend ::T::Sig
end

class Net::ProtoSyntaxError
  extend ::T::Sig
end

class Net::ProtoUnknownError
  extend ::T::Sig
end

Net::ProtocRetryError = Net::ProtoRetriableError

class Net::Protocol
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::Protocol
  extend ::T::Sig
end

class Net::ProtocolError
  include ::REST::Error::Protocol
  include ::REST::Error
end

class Net::ProtocolError
  extend ::T::Sig
end

class Net::ReadAdapter
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::ReadAdapter
  extend ::T::Sig
end

class Net::ReadTimeout
  extend ::T::Sig
end

class Net::SMTP::Response
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::SMTP::Response
  extend ::T::Sig
end

class Net::SMTP
  extend ::T::Sig
end

class Net::SMTPAuthenticationError
  extend ::T::Sig
end

module Net::SMTPError
  extend ::T::Sig
end

class Net::SMTPFatalError
  extend ::T::Sig
end

class Net::SMTPServerBusy
  extend ::T::Sig
end

Net::SMTPSession = Net::SMTP

class Net::SMTPSyntaxError
  extend ::T::Sig
end

class Net::SMTPUnknownError
  extend ::T::Sig
end

class Net::SMTPUnsupportedCommand
  extend ::T::Sig
end

module Net::WebMockHTTPResponse
  def read_body(dest=T.unsafe(nil), &block); end
end

module Net::WebMockHTTPResponse
  extend ::T::Sig
end

class Net::WebMockNetBufferedIO
end

class Net::WebMockNetBufferedIO
end

class Net::WriteAdapter
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Net::WriteAdapter
  extend ::T::Sig
end

module Net
  extend ::T::Sig
end

class NilClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_i(); end
end

class NilClass
  extend ::T::Sig
end

class NoMemoryError
  extend ::T::Sig
end

class NoMethodError
  include ::DidYouMean::Correctable
  def args(); end

  def private_call?(); end
end

class NoMethodError
  extend ::T::Sig
end

module NoProxyFix
  VERSION = ::T.let(nil, ::T.untyped)
end

module NoProxyFix
  extend ::T::Sig
end

module Nokogiri
  LIBXML_ICONV_ENABLED = ::T.let(nil, ::T.untyped)
  LIBXML_PARSER_VERSION = ::T.let(nil, ::T.untyped)
  LIBXML_VERSION = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXML2_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATCHES = ::T.let(nil, ::T.untyped)
  NOKOGIRI_LIBXSLT_PATH = ::T.let(nil, ::T.untyped)
  NOKOGIRI_USE_PACKAGED_LIBRARIES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

module Nokogiri::CSS
end

class Nokogiri::CSS::Node
  def accept(visitor); end

  def find_by_type(types); end

  def initialize(type, value); end

  def to_a(); end

  def to_type(); end

  def to_xpath(prefix=T.unsafe(nil), visitor=T.unsafe(nil)); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
  ALLOW_COMBINATOR_ON_SELF = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Node
end

class Nokogiri::CSS::Parser
  def _reduce_1(val, _values, result); end

  def _reduce_11(val, _values, result); end

  def _reduce_12(val, _values, result); end

  def _reduce_13(val, _values, result); end

  def _reduce_14(val, _values, result); end

  def _reduce_15(val, _values, result); end

  def _reduce_16(val, _values, result); end

  def _reduce_18(val, _values, result); end

  def _reduce_2(val, _values, result); end

  def _reduce_20(val, _values, result); end

  def _reduce_21(val, _values, result); end

  def _reduce_22(val, _values, result); end

  def _reduce_23(val, _values, result); end

  def _reduce_25(val, _values, result); end

  def _reduce_26(val, _values, result); end

  def _reduce_27(val, _values, result); end

  def _reduce_28(val, _values, result); end

  def _reduce_29(val, _values, result); end

  def _reduce_3(val, _values, result); end

  def _reduce_30(val, _values, result); end

  def _reduce_31(val, _values, result); end

  def _reduce_32(val, _values, result); end

  def _reduce_33(val, _values, result); end

  def _reduce_34(val, _values, result); end

  def _reduce_35(val, _values, result); end

  def _reduce_36(val, _values, result); end

  def _reduce_37(val, _values, result); end

  def _reduce_4(val, _values, result); end

  def _reduce_40(val, _values, result); end

  def _reduce_41(val, _values, result); end

  def _reduce_42(val, _values, result); end

  def _reduce_43(val, _values, result); end

  def _reduce_44(val, _values, result); end

  def _reduce_45(val, _values, result); end

  def _reduce_48(val, _values, result); end

  def _reduce_49(val, _values, result); end

  def _reduce_5(val, _values, result); end

  def _reduce_50(val, _values, result); end

  def _reduce_51(val, _values, result); end

  def _reduce_52(val, _values, result); end

  def _reduce_58(val, _values, result); end

  def _reduce_59(val, _values, result); end

  def _reduce_6(val, _values, result); end

  def _reduce_60(val, _values, result); end

  def _reduce_61(val, _values, result); end

  def _reduce_63(val, _values, result); end

  def _reduce_64(val, _values, result); end

  def _reduce_65(val, _values, result); end

  def _reduce_66(val, _values, result); end

  def _reduce_67(val, _values, result); end

  def _reduce_68(val, _values, result); end

  def _reduce_69(val, _values, result); end

  def _reduce_7(val, _values, result); end

  def _reduce_70(val, _values, result); end

  def _reduce_8(val, _values, result); end

  def _reduce_9(val, _values, result); end

  def _reduce_none(val, _values, result); end

  def initialize(namespaces=T.unsafe(nil)); end

  def on_error(error_token_id, error_value, value_stack); end

  def parse(string); end

  def unescape_css_identifier(identifier); end

  def unescape_css_string(str); end

  def xpath_for(string, options=T.unsafe(nil)); end
  Racc_arg = ::T.let(nil, ::T.untyped)
  Racc_debug_parser = ::T.let(nil, ::T.untyped)
  Racc_token_to_s_table = ::T.let(nil, ::T.untyped)
end

class Nokogiri::CSS::Parser
  def self.[](string); end

  def self.[]=(string, value); end

  def self.cache_on(); end

  def self.cache_on=(cache_on); end

  def self.cache_on?(); end

  def self.clear_cache(); end

  def self.parse(selector); end

  def self.set_cache(_); end

  def self.without_cache(&block); end
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::SyntaxError
end

class Nokogiri::CSS::Tokenizer
  def _next_token(); end

  def action(); end

  def filename(); end

  def lineno(); end

  def load_file(filename); end

  def next_token(); end

  def scan(str); end

  def scan_file(filename); end

  def scan_setup(str); end

  def scan_str(str); end

  def state(); end

  def state=(state); end
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer::ScanError
end

class Nokogiri::CSS::Tokenizer
end

class Nokogiri::CSS::XPathVisitor
  def accept(node); end

  def visit_attribute_condition(node); end

  def visit_child_selector(node); end

  def visit_class_condition(node); end

  def visit_combinator(node); end

  def visit_conditional_selector(node); end

  def visit_descendant_selector(node); end

  def visit_direct_adjacent_selector(node); end

  def visit_element_name(node); end

  def visit_following_selector(node); end

  def visit_function(node); end

  def visit_id(node); end

  def visit_not(node); end

  def visit_pseudo_class(node); end
end

class Nokogiri::CSS::XPathVisitor
end

module Nokogiri::CSS
  extend ::T::Sig
  def self.parse(selector); end

  def self.xpath_for(selector, options=T.unsafe(nil)); end
end

module Nokogiri::Decorators
end

module Nokogiri::Decorators::Slop
  def method_missing(name, *args, &block); end
  XPATH_PREFIX = ::T.let(nil, ::T.untyped)
end

module Nokogiri::Decorators::Slop
  extend ::T::Sig
end

module Nokogiri::Decorators
  extend ::T::Sig
end

class Nokogiri::EncodingHandler
  def name(); end
end

class Nokogiri::EncodingHandler
  def self.[](_); end

  def self.alias(_, _1); end

  def self.clear_aliases!(); end

  def self.delete(_); end
end

module Nokogiri::HTML
  NamedCharacters = ::T.let(nil, ::T.untyped)
end

class Nokogiri::HTML::Builder
  def to_html(); end
end

class Nokogiri::HTML::Builder
end

class Nokogiri::HTML::Document
  def meta_encoding(); end

  def meta_encoding=(encoding); end

  def serialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(text); end
end

class Nokogiri::HTML::Document
end

class Nokogiri::HTML::DocumentFragment
end

class Nokogiri::HTML::DocumentFragment
  def self.parse(tags, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::ElementDescription
  def block?(); end

  def default_sub_element(); end

  def deprecated?(); end

  def deprecated_attributes(); end

  def description(); end

  def empty?(); end

  def implied_end_tag?(); end

  def implied_start_tag?(); end

  def inline?(); end

  def name(); end

  def optional_attributes(); end

  def required_attributes(); end

  def save_end_tag?(); end

  def sub_elements(); end
  ACTION_ATTR = ::T.let(nil, ::T.untyped)
  ALIGN_ATTR = ::T.let(nil, ::T.untyped)
  ALT_ATTR = ::T.let(nil, ::T.untyped)
  APPLET_ATTRS = ::T.let(nil, ::T.untyped)
  AREA_ATTRS = ::T.let(nil, ::T.untyped)
  ATTRS = ::T.let(nil, ::T.untyped)
  A_ATTRS = ::T.let(nil, ::T.untyped)
  BASEFONT_ATTRS = ::T.let(nil, ::T.untyped)
  BGCOLOR_ATTR = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  BLOCKLI_ELT = ::T.let(nil, ::T.untyped)
  BODY_ATTRS = ::T.let(nil, ::T.untyped)
  BODY_CONTENTS = ::T.let(nil, ::T.untyped)
  BODY_DEPR = ::T.let(nil, ::T.untyped)
  BUTTON_ATTRS = ::T.let(nil, ::T.untyped)
  CELLHALIGN = ::T.let(nil, ::T.untyped)
  CELLVALIGN = ::T.let(nil, ::T.untyped)
  CLEAR_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ATTRS = ::T.let(nil, ::T.untyped)
  COL_ELT = ::T.let(nil, ::T.untyped)
  COMPACT_ATTR = ::T.let(nil, ::T.untyped)
  COMPACT_ATTRS = ::T.let(nil, ::T.untyped)
  CONTENT_ATTR = ::T.let(nil, ::T.untyped)
  COREATTRS = ::T.let(nil, ::T.untyped)
  CORE_ATTRS = ::T.let(nil, ::T.untyped)
  CORE_I18N_ATTRS = ::T.let(nil, ::T.untyped)
  DIR_ATTR = ::T.let(nil, ::T.untyped)
  DL_CONTENTS = ::T.let(nil, ::T.untyped)
  DefaultDescriptions = ::T.let(nil, ::T.untyped)
  EDIT_ATTRS = ::T.let(nil, ::T.untyped)
  EMBED_ATTRS = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  EVENTS = ::T.let(nil, ::T.untyped)
  FIELDSET_CONTENTS = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
  FLOW_PARAM = ::T.let(nil, ::T.untyped)
  FONTSTYLE = ::T.let(nil, ::T.untyped)
  FONT_ATTRS = ::T.let(nil, ::T.untyped)
  FORMCTRL = ::T.let(nil, ::T.untyped)
  FORM_ATTRS = ::T.let(nil, ::T.untyped)
  FORM_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAMESET_ATTRS = ::T.let(nil, ::T.untyped)
  FRAMESET_CONTENTS = ::T.let(nil, ::T.untyped)
  FRAME_ATTRS = ::T.let(nil, ::T.untyped)
  HEADING = ::T.let(nil, ::T.untyped)
  HEAD_ATTRS = ::T.let(nil, ::T.untyped)
  HEAD_CONTENTS = ::T.let(nil, ::T.untyped)
  HREF_ATTRS = ::T.let(nil, ::T.untyped)
  HR_DEPR = ::T.let(nil, ::T.untyped)
  HTML_ATTRS = ::T.let(nil, ::T.untyped)
  HTML_CDATA = ::T.let(nil, ::T.untyped)
  HTML_CONTENT = ::T.let(nil, ::T.untyped)
  HTML_FLOW = ::T.let(nil, ::T.untyped)
  HTML_INLINE = ::T.let(nil, ::T.untyped)
  HTML_PCDATA = ::T.let(nil, ::T.untyped)
  I18N = ::T.let(nil, ::T.untyped)
  I18N_ATTRS = ::T.let(nil, ::T.untyped)
  IFRAME_ATTRS = ::T.let(nil, ::T.untyped)
  IMG_ATTRS = ::T.let(nil, ::T.untyped)
  INLINE = ::T.let(nil, ::T.untyped)
  INLINE_P = ::T.let(nil, ::T.untyped)
  INPUT_ATTRS = ::T.let(nil, ::T.untyped)
  LABEL_ATTR = ::T.let(nil, ::T.untyped)
  LABEL_ATTRS = ::T.let(nil, ::T.untyped)
  LANGUAGE_ATTR = ::T.let(nil, ::T.untyped)
  LEGEND_ATTRS = ::T.let(nil, ::T.untyped)
  LINK_ATTRS = ::T.let(nil, ::T.untyped)
  LIST = ::T.let(nil, ::T.untyped)
  LI_ELT = ::T.let(nil, ::T.untyped)
  MAP_CONTENTS = ::T.let(nil, ::T.untyped)
  META_ATTRS = ::T.let(nil, ::T.untyped)
  MODIFIER = ::T.let(nil, ::T.untyped)
  NAME_ATTR = ::T.let(nil, ::T.untyped)
  NOFRAMES_CONTENT = ::T.let(nil, ::T.untyped)
  OBJECT_ATTRS = ::T.let(nil, ::T.untyped)
  OBJECT_CONTENTS = ::T.let(nil, ::T.untyped)
  OBJECT_DEPR = ::T.let(nil, ::T.untyped)
  OL_ATTRS = ::T.let(nil, ::T.untyped)
  OPTGROUP_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ATTRS = ::T.let(nil, ::T.untyped)
  OPTION_ELT = ::T.let(nil, ::T.untyped)
  PARAM_ATTRS = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PHRASE = ::T.let(nil, ::T.untyped)
  PRE_CONTENT = ::T.let(nil, ::T.untyped)
  PROMPT_ATTRS = ::T.let(nil, ::T.untyped)
  QUOTE_ATTRS = ::T.let(nil, ::T.untyped)
  ROWS_COLS_ATTR = ::T.let(nil, ::T.untyped)
  SCRIPT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_ATTRS = ::T.let(nil, ::T.untyped)
  SELECT_CONTENT = ::T.let(nil, ::T.untyped)
  SPECIAL = ::T.let(nil, ::T.untyped)
  SRC_ALT_ATTRS = ::T.let(nil, ::T.untyped)
  STYLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_ATTRS = ::T.let(nil, ::T.untyped)
  TABLE_CONTENTS = ::T.let(nil, ::T.untyped)
  TABLE_DEPR = ::T.let(nil, ::T.untyped)
  TALIGN_ATTRS = ::T.let(nil, ::T.untyped)
  TARGET_ATTR = ::T.let(nil, ::T.untyped)
  TEXTAREA_ATTRS = ::T.let(nil, ::T.untyped)
  TH_TD_ATTR = ::T.let(nil, ::T.untyped)
  TH_TD_DEPR = ::T.let(nil, ::T.untyped)
  TR_CONTENTS = ::T.let(nil, ::T.untyped)
  TR_ELT = ::T.let(nil, ::T.untyped)
  TYPE_ATTR = ::T.let(nil, ::T.untyped)
  UL_DEPR = ::T.let(nil, ::T.untyped)
  VERSION_ATTR = ::T.let(nil, ::T.untyped)
  WIDTH_ATTR = ::T.let(nil, ::T.untyped)
end

Nokogiri::HTML::ElementDescription::Desc = Struct::HTMLElementDescription

class Nokogiri::HTML::ElementDescription
  def self.[](_); end
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityDescription
end

class Nokogiri::HTML::EntityLookup
  def [](name); end

  def get(_); end
end

class Nokogiri::HTML::EntityLookup
end

module Nokogiri::HTML::SAX
end

class Nokogiri::HTML::SAX::Parser
  def parse_file(filename, encoding=T.unsafe(nil)); end

  def parse_memory(data, encoding=T.unsafe(nil)); end
end

class Nokogiri::HTML::SAX::Parser
end

class Nokogiri::HTML::SAX::ParserContext
end

class Nokogiri::HTML::SAX::ParserContext
  def self.file(_, _1); end

  def self.memory(_, _1); end
end

class Nokogiri::HTML::SAX::PushParser
end

class Nokogiri::HTML::SAX::PushParser
end

module Nokogiri::HTML::SAX
  extend ::T::Sig
end

module Nokogiri::HTML
  extend ::T::Sig
  def self.fragment(string, encoding=T.unsafe(nil)); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

class Nokogiri::SyntaxError
end

class Nokogiri::SyntaxError
end

class Nokogiri::VersionInfo
  def compiled_parser_version(); end

  def engine(); end

  def jruby?(); end

  def libxml2?(); end

  def libxml2_using_packaged?(); end

  def libxml2_using_system?(); end

  def loaded_parser_version(); end

  def to_hash(); end

  def to_markdown(); end

  def warnings(); end
end

class Nokogiri::VersionInfo
  def self.instance(); end
end

module Nokogiri::XML
  XML_C14N_1_0 = ::T.let(nil, ::T.untyped)
  XML_C14N_1_1 = ::T.let(nil, ::T.untyped)
  XML_C14N_EXCLUSIVE_1_0 = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Attr
  def content=(content); end

  def value(); end

  def value=(value); end
end

class Nokogiri::XML::Attr
end

class Nokogiri::XML::AttributeDecl
  def attribute_type(); end

  def default(); end

  def enumeration(); end
end

class Nokogiri::XML::AttributeDecl
end

class Nokogiri::XML::Builder
  def <<(string); end

  def [](ns); end

  def arity(); end

  def arity=(arity); end

  def cdata(string); end

  def comment(string); end

  def context(); end

  def context=(context); end

  def doc(); end

  def doc=(doc); end

  def initialize(options=T.unsafe(nil), root=T.unsafe(nil), &block); end

  def method_missing(method, *args, &block); end

  def parent(); end

  def parent=(parent); end

  def text(string); end

  def to_xml(*args); end
end

class Nokogiri::XML::Builder
  def self.with(root, &block); end
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CDATA
end

class Nokogiri::XML::CharacterData
  include ::Nokogiri::XML::PP::CharacterData
end

class Nokogiri::XML::CharacterData
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::Comment
end

class Nokogiri::XML::DTD
  def entities(); end

  def external_id(); end

  def html5_dtd?(); end

  def html_dtd?(); end

  def notations(); end

  def system_id(); end

  def validate(_); end
end

class Nokogiri::XML::DTD
end

class Nokogiri::XML::Document
  def canonicalize(*_); end

  def collect_namespaces(); end

  def create_cdata(string, &block); end

  def create_comment(string, &block); end

  def create_element(name, *args, &block); end

  def create_entity(*_); end

  def create_text_node(string, &block); end

  def decorate(node); end

  def decorators(key); end

  def encoding(); end

  def encoding=(encoding); end

  def errors(); end

  def errors=(errors); end

  def fragment(tags=T.unsafe(nil)); end

  def initialize(*args); end

  def remove_namespaces!(); end

  def root(); end

  def root=(root); end

  def slop!(); end

  def to_java(); end

  def to_xml(*args, &block); end

  def url(); end

  def validate(); end

  def version(); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NCNAME_CHAR = ::T.let(nil, ::T.untyped)
  NCNAME_RE = ::T.let(nil, ::T.untyped)
  NCNAME_START_CHAR = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Document
  def self.empty_doc?(string_or_io); end

  def self.parse(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.read_io(_, _1, _2, _3); end

  def self.read_memory(_, _1, _2, _3); end

  def self.wrap(document); end
end

class Nokogiri::XML::DocumentFragment
  def dup(); end

  def errors(); end

  def errors=(things); end

  def initialize(document, tags=T.unsafe(nil), ctx=T.unsafe(nil)); end

  def search(*rules); end

  def serialize(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end
end

class Nokogiri::XML::DocumentFragment
  def self.parse(tags); end
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::Element
end

class Nokogiri::XML::ElementContent
  def children(); end

  def document(); end

  def name(); end

  def occur(); end

  def prefix(); end

  def type(); end
  ELEMENT = ::T.let(nil, ::T.untyped)
  MULT = ::T.let(nil, ::T.untyped)
  ONCE = ::T.let(nil, ::T.untyped)
  OPT = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  PCDATA = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  SEQ = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ElementContent
end

class Nokogiri::XML::ElementDecl
  def element_type(); end

  def prefix(); end
end

class Nokogiri::XML::ElementDecl
end

class Nokogiri::XML::EntityDecl
  def entity_type(); end

  def external_id(); end

  def original_content(); end

  def system_id(); end
  EXTERNAL_GENERAL_PARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_GENERAL_UNPARSED = ::T.let(nil, ::T.untyped)
  EXTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_GENERAL = ::T.let(nil, ::T.untyped)
  INTERNAL_PARAMETER = ::T.let(nil, ::T.untyped)
  INTERNAL_PREDEFINED = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::EntityDecl
  def self.new(name, doc, *args); end
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::EntityReference
end

class Nokogiri::XML::Namespace
  include ::Nokogiri::XML::PP::Node
  def document(); end

  def href(); end

  def prefix(); end
end

class Nokogiri::XML::Namespace
end

class Nokogiri::XML::Node
  include ::Nokogiri::XML::PP::Node
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def <<(node_or_tags); end

  def ==(other); end

  def >(selector); end

  def [](name); end

  def []=(name, value); end

  def accept(visitor); end

  def add_child(node_or_tags); end

  def add_class(name); end

  def add_namespace(_, _1); end

  def add_namespace_definition(_, _1); end

  def add_next_sibling(node_or_tags); end

  def add_previous_sibling(node_or_tags); end

  def after(node_or_tags); end

  def ancestors(selector=T.unsafe(nil)); end

  def append_class(name); end

  def attr(name); end

  def attribute(_); end

  def attribute_nodes(); end

  def attribute_with_ns(_, _1); end

  def attributes(); end

  def before(node_or_tags); end

  def canonicalize(mode=T.unsafe(nil), inclusive_namespaces=T.unsafe(nil), with_comments=T.unsafe(nil)); end

  def cdata?(); end

  def child(); end

  def children(); end

  def children=(node_or_tags); end

  def classes(); end

  def comment?(); end

  def content(); end

  def content=(string); end

  def create_external_subset(_, _1, _2); end

  def create_internal_subset(_, _1, _2); end

  def css_path(); end

  def decorate!(); end

  def default_namespace=(url); end

  def delete(name); end

  def description(); end

  def do_xinclude(options=T.unsafe(nil)); end

  def document(); end

  def document?(); end

  def dup(*_); end

  def each(); end

  def elem?(); end

  def element?(); end

  def element_children(); end

  def elements(); end

  def encode_special_chars(_); end

  def external_subset(); end

  def first_element_child(); end

  def fragment(tags); end

  def fragment?(); end

  def get_attribute(name); end

  def has_attribute?(_); end

  def html?(); end

  def initialize(name, document); end

  def inner_html(*args); end

  def inner_html=(node_or_tags); end

  def inner_text(); end

  def internal_subset(); end

  def key?(_); end

  def keys(); end

  def lang(); end

  def lang=(lang); end

  def last_element_child(); end

  def line(); end

  def matches?(selector); end

  def name(); end

  def name=(name); end

  def namespace(); end

  def namespace=(ns); end

  def namespace_definitions(); end

  def namespace_scopes(); end

  def namespaced_key?(_, _1); end

  def namespaces(); end

  def native_content=(native_content); end

  def next(); end

  def next=(node_or_tags); end

  def next_element(); end

  def next_sibling(); end

  def node_name(); end

  def node_name=(node_name); end

  def node_type(); end

  def parent(); end

  def parent=(parent_node); end

  def parse(string_or_io, options=T.unsafe(nil)); end

  def path(); end

  def pointer_id(); end

  def prepend_child(node_or_tags); end

  def previous(); end

  def previous=(node_or_tags); end

  def previous_element(); end

  def previous_sibling(); end

  def processing_instruction?(); end

  def read_only?(); end

  def remove(); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def replace(node_or_tags); end

  def serialize(*args, &block); end

  def set_attribute(name, value); end

  def swap(node_or_tags); end

  def text(); end

  def text?(); end

  def to_html(options=T.unsafe(nil)); end

  def to_str(); end

  def to_xhtml(options=T.unsafe(nil)); end

  def to_xml(options=T.unsafe(nil)); end

  def traverse(&block); end

  def type(); end

  def unlink(); end

  def values(); end

  def wrap(html); end

  def write_html_to(io, options=T.unsafe(nil)); end

  def write_to(io, *options); end

  def write_xhtml_to(io, options=T.unsafe(nil)); end

  def write_xml_to(io, options=T.unsafe(nil)); end

  def xml?(); end
  ATTRIBUTE_DECL = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_NODE = ::T.let(nil, ::T.untyped)
  CDATA_SECTION_NODE = ::T.let(nil, ::T.untyped)
  COMMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCB_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_FRAG_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  DOCUMENT_TYPE_NODE = ::T.let(nil, ::T.untyped)
  DTD_NODE = ::T.let(nil, ::T.untyped)
  ELEMENT_DECL = ::T.let(nil, ::T.untyped)
  ELEMENT_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_DECL = ::T.let(nil, ::T.untyped)
  ENTITY_NODE = ::T.let(nil, ::T.untyped)
  ENTITY_REF_NODE = ::T.let(nil, ::T.untyped)
  HTML_DOCUMENT_NODE = ::T.let(nil, ::T.untyped)
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
  NAMESPACE_DECL = ::T.let(nil, ::T.untyped)
  NOTATION_NODE = ::T.let(nil, ::T.untyped)
  PI_NODE = ::T.let(nil, ::T.untyped)
  TEXT_NODE = ::T.let(nil, ::T.untyped)
  XINCLUDE_END = ::T.let(nil, ::T.untyped)
  XINCLUDE_START = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Node
end

class Nokogiri::XML::NodeSet
  include ::Nokogiri::XML::Searchable
  include ::Enumerable
  def &(_); end

  def +(_); end

  def -(_); end

  def <<(_); end

  def ==(other); end

  def >(selector); end

  def [](*_); end

  def add_class(name); end

  def after(datum); end

  def append_class(name); end

  def attr(key, value=T.unsafe(nil), &block); end

  def attribute(key, value=T.unsafe(nil), &block); end

  def before(datum); end

  def children(); end

  def clone(); end

  def delete(_); end

  def document(); end

  def document=(document); end

  def each(); end

  def empty?(); end

  def filter(expr); end

  def first(n=T.unsafe(nil)); end

  def index(node=T.unsafe(nil)); end

  def initialize(document, list=T.unsafe(nil)); end

  def inner_html(*args); end

  def inner_text(); end

  def last(); end

  def length(); end

  def pop(); end

  def push(_); end

  def remove(); end

  def remove_attr(name); end

  def remove_attribute(name); end

  def remove_class(name=T.unsafe(nil)); end

  def reverse(); end

  def set(key, value=T.unsafe(nil), &block); end

  def shift(); end

  def size(); end

  def slice(*_); end

  def text(); end

  def to_a(); end

  def to_ary(); end

  def to_html(*args); end

  def to_xhtml(*args); end

  def to_xml(*args); end

  def unlink(); end

  def wrap(html); end

  def |(_); end
  IMPLIED_XPATH_CONTEXTS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::NodeSet
end

class Nokogiri::XML::Notation
end

class Nokogiri::XML::Notation
end

module Nokogiri::XML::PP
end

module Nokogiri::XML::PP::CharacterData
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::CharacterData
  extend ::T::Sig
end

module Nokogiri::XML::PP::Node
  def inspect(); end

  def pretty_print(pp); end
end

module Nokogiri::XML::PP::Node
  extend ::T::Sig
end

module Nokogiri::XML::PP
  extend ::T::Sig
end

class Nokogiri::XML::ParseOptions
  def compact(); end

  def compact?(); end

  def default_html(); end

  def default_html?(); end

  def default_xml(); end

  def default_xml?(); end

  def dtdattr(); end

  def dtdattr?(); end

  def dtdload(); end

  def dtdload?(); end

  def dtdvalid(); end

  def dtdvalid?(); end

  def huge(); end

  def huge?(); end

  def initialize(options=T.unsafe(nil)); end

  def nobasefix(); end

  def nobasefix?(); end

  def noblanks(); end

  def noblanks?(); end

  def nocdata(); end

  def nocdata?(); end

  def nocompact(); end

  def nodefault_html(); end

  def nodefault_xml(); end

  def nodict(); end

  def nodict?(); end

  def nodtdattr(); end

  def nodtdload(); end

  def nodtdvalid(); end

  def noent(); end

  def noent?(); end

  def noerror(); end

  def noerror?(); end

  def nohuge(); end

  def nonet(); end

  def nonet?(); end

  def nonobasefix(); end

  def nonoblanks(); end

  def nonocdata(); end

  def nonodict(); end

  def nonoent(); end

  def nonoerror(); end

  def nononet(); end

  def nonowarning(); end

  def nonoxincnode(); end

  def nonsclean(); end

  def noold10(); end

  def nopedantic(); end

  def norecover(); end

  def nosax1(); end

  def nowarning(); end

  def nowarning?(); end

  def noxinclude(); end

  def noxincnode(); end

  def noxincnode?(); end

  def nsclean(); end

  def nsclean?(); end

  def old10(); end

  def old10?(); end

  def options(); end

  def options=(options); end

  def pedantic(); end

  def pedantic?(); end

  def recover(); end

  def recover?(); end

  def sax1(); end

  def sax1?(); end

  def strict(); end

  def strict?(); end

  def to_i(); end

  def xinclude(); end

  def xinclude?(); end
  COMPACT = ::T.let(nil, ::T.untyped)
  DEFAULT_HTML = ::T.let(nil, ::T.untyped)
  DEFAULT_XML = ::T.let(nil, ::T.untyped)
  DTDATTR = ::T.let(nil, ::T.untyped)
  DTDLOAD = ::T.let(nil, ::T.untyped)
  DTDVALID = ::T.let(nil, ::T.untyped)
  HUGE = ::T.let(nil, ::T.untyped)
  NOBASEFIX = ::T.let(nil, ::T.untyped)
  NOBLANKS = ::T.let(nil, ::T.untyped)
  NOCDATA = ::T.let(nil, ::T.untyped)
  NODICT = ::T.let(nil, ::T.untyped)
  NOENT = ::T.let(nil, ::T.untyped)
  NOERROR = ::T.let(nil, ::T.untyped)
  NONET = ::T.let(nil, ::T.untyped)
  NOWARNING = ::T.let(nil, ::T.untyped)
  NOXINCNODE = ::T.let(nil, ::T.untyped)
  NSCLEAN = ::T.let(nil, ::T.untyped)
  OLD10 = ::T.let(nil, ::T.untyped)
  PEDANTIC = ::T.let(nil, ::T.untyped)
  RECOVER = ::T.let(nil, ::T.untyped)
  SAX1 = ::T.let(nil, ::T.untyped)
  STRICT = ::T.let(nil, ::T.untyped)
  XINCLUDE = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::ParseOptions
end

class Nokogiri::XML::ProcessingInstruction
  def initialize(document, name, content); end
end

class Nokogiri::XML::ProcessingInstruction
end

class Nokogiri::XML::Reader
  include ::Enumerable
  def attribute(_); end

  def attribute_at(_); end

  def attribute_count(); end

  def attribute_nodes(); end

  def attributes(); end

  def attributes?(); end

  def base_uri(); end

  def default?(); end

  def depth(); end

  def each(); end

  def empty_element?(); end

  def encoding(); end

  def errors(); end

  def errors=(errors); end

  def initialize(source, url=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def inner_xml(); end

  def lang(); end

  def local_name(); end

  def name(); end

  def namespace_uri(); end

  def namespaces(); end

  def node_type(); end

  def outer_xml(); end

  def prefix(); end

  def read(); end

  def self_closing?(); end

  def source(); end

  def state(); end

  def value(); end

  def value?(); end

  def xml_version(); end
  TYPE_ATTRIBUTE = ::T.let(nil, ::T.untyped)
  TYPE_CDATA = ::T.let(nil, ::T.untyped)
  TYPE_COMMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_FRAGMENT = ::T.let(nil, ::T.untyped)
  TYPE_DOCUMENT_TYPE = ::T.let(nil, ::T.untyped)
  TYPE_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ELEMENT = ::T.let(nil, ::T.untyped)
  TYPE_END_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY = ::T.let(nil, ::T.untyped)
  TYPE_ENTITY_REFERENCE = ::T.let(nil, ::T.untyped)
  TYPE_NONE = ::T.let(nil, ::T.untyped)
  TYPE_NOTATION = ::T.let(nil, ::T.untyped)
  TYPE_PROCESSING_INSTRUCTION = ::T.let(nil, ::T.untyped)
  TYPE_SIGNIFICANT_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_TEXT = ::T.let(nil, ::T.untyped)
  TYPE_WHITESPACE = ::T.let(nil, ::T.untyped)
  TYPE_XML_DECLARATION = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::Reader
  def self.from_io(*_); end

  def self.from_memory(*_); end
end

class Nokogiri::XML::RelaxNG
end

class Nokogiri::XML::RelaxNG
end

module Nokogiri::XML::SAX
end

class Nokogiri::XML::SAX::Document
  def cdata_block(string); end

  def characters(string); end

  def comment(string); end

  def end_document(); end

  def end_element(name); end

  def end_element_namespace(name, prefix=T.unsafe(nil), uri=T.unsafe(nil)); end

  def error(string); end

  def processing_instruction(name, content); end

  def start_document(); end

  def start_element(name, attrs=T.unsafe(nil)); end

  def start_element_namespace(name, attrs=T.unsafe(nil), prefix=T.unsafe(nil), uri=T.unsafe(nil), ns=T.unsafe(nil)); end

  def warning(string); end

  def xmldecl(version, encoding, standalone); end
end

class Nokogiri::XML::SAX::Document
end

class Nokogiri::XML::SAX::Parser
  def document(); end

  def document=(document); end

  def encoding(); end

  def encoding=(encoding); end

  def initialize(doc=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def parse(thing, &block); end

  def parse_file(filename); end

  def parse_io(io, encoding=T.unsafe(nil)); end

  def parse_memory(data); end
  ENCODINGS = ::T.let(nil, ::T.untyped)
end

class Nokogiri::XML::SAX::Parser
end

class Nokogiri::XML::SAX::ParserContext
  def column(); end

  def line(); end

  def parse_with(_); end

  def recovery(); end

  def recovery=(recovery); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end
end

class Nokogiri::XML::SAX::ParserContext
  def self.file(_); end

  def self.io(_, _1); end

  def self.memory(_); end

  def self.new(thing, encoding=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
  def <<(chunk, last_chunk=T.unsafe(nil)); end

  def document(); end

  def document=(document); end

  def finish(); end

  def initialize(doc=T.unsafe(nil), file_name=T.unsafe(nil), encoding=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def replace_entities(); end

  def replace_entities=(replace_entities); end

  def write(chunk, last_chunk=T.unsafe(nil)); end
end

class Nokogiri::XML::SAX::PushParser
end

module Nokogiri::XML::SAX
  extend ::T::Sig
end

class Nokogiri::XML::Schema
  def errors(); end

  def errors=(errors); end

  def valid?(thing); end

  def validate(thing); end
end

class Nokogiri::XML::Schema
  def self.from_document(_); end

  def self.new(string_or_io); end

  def self.read_memory(_); end
end

module Nokogiri::XML::Searchable
  def %(*args); end

  def /(*args); end

  def at(*args); end

  def at_css(*args); end

  def at_xpath(*args); end

  def css(*args); end

  def search(*args); end

  def xpath(*args); end
  LOOKS_LIKE_XPATH = ::T.let(nil, ::T.untyped)
end

module Nokogiri::XML::Searchable
  extend ::T::Sig
end

class Nokogiri::XML::SyntaxError
  def code(); end

  def column(); end

  def domain(); end

  def error?(); end

  def fatal?(); end

  def file(); end

  def int1(); end

  def level(); end

  def line(); end

  def none?(); end

  def str1(); end

  def str2(); end

  def str3(); end

  def warning?(); end
end

class Nokogiri::XML::SyntaxError
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::Text
end

class Nokogiri::XML::XPath
  def document(); end

  def document=(document); end
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath::SyntaxError
end

class Nokogiri::XML::XPath
end

class Nokogiri::XML::XPathContext
  def evaluate(*_); end

  def register_namespaces(namespaces); end

  def register_ns(_, _1); end

  def register_variable(_, _1); end
end

class Nokogiri::XML::XPathContext
  def self.new(_); end
end

module Nokogiri::XML
  extend ::T::Sig
  def self.Reader(string_or_io, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.RelaxNG(string_or_io); end

  def self.Schema(string_or_io); end

  def self.fragment(string); end

  def self.parse(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end
end

module Nokogiri::XSLT
end

class Nokogiri::XSLT::Stylesheet
  def apply_to(document, params=T.unsafe(nil)); end

  def serialize(_); end

  def transform(*_); end
end

class Nokogiri::XSLT::Stylesheet
  def self.parse_stylesheet_doc(_); end
end

module Nokogiri::XSLT
  extend ::T::Sig
  def self.parse(string, modules=T.unsafe(nil)); end

  def self.quote_params(params); end

  def self.register(_, _1); end
end

module Nokogiri
  extend ::T::Sig
  def self.HTML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.Slop(*args, &block); end

  def self.XML(thing, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil), &block); end

  def self.XSLT(stylesheet, modules=T.unsafe(nil)); end

  def self.install_default_aliases(); end

  def self.jruby?(); end

  def self.make(input=T.unsafe(nil), opts=T.unsafe(nil), &blk); end

  def self.parse(string, url=T.unsafe(nil), encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.uses_libxml?(); end
end

class NotImplementedError
  extend ::T::Sig
end

class Numeric
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def byte(); end

  def bytes(); end

  def day(); end

  def days(); end

  def exabyte(); end

  def exabytes(); end

  def finite?(); end

  def fortnight(); end

  def fortnights(); end

  def gigabyte(); end

  def gigabytes(); end

  def hour(); end

  def hours(); end

  def in_milliseconds(); end

  def infinite?(); end

  def kilobyte(); end

  def kilobytes(); end

  def megabyte(); end

  def megabytes(); end

  def minute(); end

  def minutes(); end

  def negative?(); end

  def petabyte(); end

  def petabytes(); end

  def positive?(); end

  def second(); end

  def seconds(); end

  def terabyte(); end

  def terabytes(); end

  def week(); end

  def weeks(); end
  EXABYTE = ::T.let(nil, ::T.untyped)
  GIGABYTE = ::T.let(nil, ::T.untyped)
  KILOBYTE = ::T.let(nil, ::T.untyped)
  MEGABYTE = ::T.let(nil, ::T.untyped)
  PETABYTE = ::T.let(nil, ::T.untyped)
  TERABYTE = ::T.let(nil, ::T.untyped)
end

class Numeric
  extend ::T::Sig
end

module OAuth2
end

class OAuth2::AccessToken
  def [](key); end

  def client(); end

  def delete(path, opts=T.unsafe(nil), &block); end

  def expired?(); end

  def expires?(); end

  def expires_at(); end

  def expires_in(); end

  def get(path, opts=T.unsafe(nil), &block); end

  def headers(); end

  def initialize(client, token, opts=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def params(); end

  def patch(path, opts=T.unsafe(nil), &block); end

  def post(path, opts=T.unsafe(nil), &block); end

  def put(path, opts=T.unsafe(nil), &block); end

  def refresh!(params=T.unsafe(nil)); end

  def refresh_token(); end

  def refresh_token=(refresh_token); end

  def request(verb, path, opts=T.unsafe(nil), &block); end

  def to_hash(); end

  def token(); end
end

class OAuth2::AccessToken
  def self.from_hash(client, hash); end

  def self.from_kvform(client, kvform); end
end

class OAuth2::Authenticator
  def apply(params); end

  def id(); end

  def initialize(id, secret, mode); end

  def mode(); end

  def secret(); end
end

class OAuth2::Authenticator
  def self.encode_basic_auth(user, password); end
end

class OAuth2::Client
  def assertion(); end

  def auth_code(); end

  def authorize_url(params=T.unsafe(nil)); end

  def client_credentials(); end

  def connection(); end

  def connection=(connection); end

  def get_token(params, access_token_opts=T.unsafe(nil), access_token_class=T.unsafe(nil)); end

  def id(); end

  def implicit(); end

  def initialize(client_id, client_secret, options=T.unsafe(nil), &block); end

  def options(); end

  def options=(options); end

  def password(); end

  def redirection_params(); end

  def request(verb, url, opts=T.unsafe(nil)); end

  def secret(); end

  def site(); end

  def site=(value); end

  def token_url(params=T.unsafe(nil)); end
end

class OAuth2::Client
end

class OAuth2::Error
  def code(); end

  def description(); end

  def error_message(response_body, opts=T.unsafe(nil)); end

  def initialize(response); end

  def response(); end
end

class OAuth2::Error
end

class OAuth2::MACToken
  def algorithm(); end

  def algorithm=(alg); end

  def header(verb, url); end

  def initialize(client, token, secret, opts=T.unsafe(nil)); end

  def secret(); end

  def signature(timestamp, nonce, verb, uri); end
end

class OAuth2::MACToken
  def self.from_access_token(token, secret, options=T.unsafe(nil)); end
end

class OAuth2::Response
  def body(); end

  def content_type(); end

  def error(); end

  def error=(error); end

  def headers(); end

  def initialize(response, opts=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parsed(); end

  def parser(); end

  def response(); end

  def status(); end
end

class OAuth2::Response
  def self.register_parser(key, mime_types, &block); end
end

module OAuth2::Strategy
end

class OAuth2::Strategy::Assertion
  def authorize_url(); end

  def build_assertion(params); end

  def build_request(params); end

  def get_token(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::Assertion
end

class OAuth2::Strategy::AuthCode
  def authorize_params(params=T.unsafe(nil)); end

  def authorize_url(params=T.unsafe(nil)); end

  def get_token(code, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::AuthCode
end

class OAuth2::Strategy::Base
  def initialize(client); end
end

class OAuth2::Strategy::Base
end

class OAuth2::Strategy::ClientCredentials
  def authorize_url(); end

  def get_token(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::ClientCredentials
end

class OAuth2::Strategy::Implicit
  def authorize_params(params=T.unsafe(nil)); end

  def authorize_url(params=T.unsafe(nil)); end

  def get_token(*_); end
end

class OAuth2::Strategy::Implicit
end

class OAuth2::Strategy::Password
  def authorize_url(); end

  def get_token(username, password, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class OAuth2::Strategy::Password
end

module OAuth2::Strategy
  extend ::T::Sig
end

module OAuth2
  extend ::T::Sig
end

module OTNetstring
end

class OTNetstring::Error
end

class OTNetstring::Error
end

module OTNetstring
  extend ::T::Sig
  def self.encode(obj, string_sep=T.unsafe(nil)); end

  def self.parse(io, encoding=T.unsafe(nil), fallback_encoding=T.unsafe(nil)); end
end

class Object
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::PP::ObjectMixin
  include ::ActiveSupport::Dependencies::Loadable
  include ::ActiveSupport::Tryable
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  def `(command); end

  def as_json(options=T.unsafe(nil)); end

  def dclone(); end

  def html_safe?(); end

  def presence_in(another_object); end

  def to_yaml(options=T.unsafe(nil)); end
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RANSACK_FORM_BUILDER = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
  UI = ::T.let(nil, ::T.untyped)
end

class Object
  extend ::T::Sig
  def self.yaml_tag(url); end
end

class ObjectSpace::WeakMap
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def [](_); end

  def []=(_, _1); end

  def each(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def key?(_); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

class ObjectSpace::WeakMap
  extend ::T::Sig
end

module ObjectSpace
  extend ::T::Sig
  def self.count_objects(*_); end

  def self.define_finalizer(*_); end

  def self.garbage_collect(*_); end

  def self.undefine_finalizer(_); end
end

module Octokit
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Octokit::AbuseDetected
end

class Octokit::AbuseDetected
end

class Octokit::AccountSuspended
end

class Octokit::AccountSuspended
end

class Octokit::ApplicationCredentialsRequired
end

class Octokit::ApplicationCredentialsRequired
end

class Octokit::Arguments
  def initialize(args); end

  def options(); end
end

class Octokit::Arguments
end

module Octokit::Authentication
  def application_authenticated?(); end

  def basic_authenticated?(); end

  def bearer_authenticated?(); end

  def token_authenticated?(); end

  def user_authenticated?(); end
end

module Octokit::Authentication
  extend ::T::Sig
end

class Octokit::BadGateway
end

class Octokit::BadGateway
end

class Octokit::BadRequest
end

class Octokit::BadRequest
end

class Octokit::BranchNotProtected
end

class Octokit::BranchNotProtected
end

class Octokit::Client
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Preview
  include ::Octokit::Warnable
  include ::Octokit::Client::Authorizations
  include ::Octokit::Client::Commits
  include ::Octokit::Client::CommitComments
  include ::Octokit::Client::CommunityProfile
  include ::Octokit::Client::Contents
  include ::Octokit::Client::Deployments
  include ::Octokit::Client::Downloads
  include ::Octokit::Client::Emojis
  include ::Octokit::Client::Events
  include ::Octokit::Client::Feeds
  include ::Octokit::Client::Gists
  include ::Octokit::Client::Gitignore
  include ::Octokit::Client::Hooks
  include ::Octokit::Client::Apps
  include ::Octokit::Client::Issues
  include ::Octokit::Client::Labels
  include ::Octokit::Client::LegacySearch
  include ::Octokit::Client::Licenses
  include ::Octokit::Client::Meta
  include ::Octokit::Client::Markdown
  include ::Octokit::Client::Marketplace
  include ::Octokit::Client::Milestones
  include ::Octokit::Client::Notifications
  include ::Octokit::Client::Objects
  include ::Octokit::Client::Organizations
  include ::Octokit::Client::Pages
  include ::Octokit::Client::Projects
  include ::Octokit::Client::PubSubHubbub
  include ::Octokit::Client::PullRequests
  include ::Octokit::Client::RateLimit
  include ::Octokit::Client::Reactions
  include ::Octokit::Client::Refs
  include ::Octokit::Client::Releases
  include ::Octokit::Client::Repositories
  include ::Octokit::Client::RepositoryInvitations
  include ::Octokit::Client::Reviews
  include ::Octokit::Client::Say
  include ::Octokit::Client::Search
  include ::Octokit::Client::ServiceStatus
  include ::Octokit::Client::SourceImport
  include ::Octokit::Client::Stats
  include ::Octokit::Client::Statuses
  include ::Octokit::Client::Traffic
  include ::Octokit::Client::Users
  def access_token=(value); end

  def as_app(key=T.unsafe(nil), secret=T.unsafe(nil), &block); end

  def bearer_token=(value); end

  def client_id=(value); end

  def client_secret=(value); end

  def client_without_redirects(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def login=(value); end

  def password=(value); end
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Client::Apps
  def add_repo_to_installation(installation, repo, options=T.unsafe(nil)); end

  def add_repository_to_app_installation(installation, repo, options=T.unsafe(nil)); end

  def add_repository_to_integration_installation(installation, repo, options=T.unsafe(nil)); end

  def create_app_installation_access_token(installation, options=T.unsafe(nil)); end

  def create_installation_access_token(installation, options=T.unsafe(nil)); end

  def create_integration_installation_access_token(installation, options=T.unsafe(nil)); end

  def find_app_installations(options=T.unsafe(nil)); end

  def find_installation_repositories_for_user(installation, options=T.unsafe(nil)); end

  def find_installations(options=T.unsafe(nil)); end

  def find_integration_installations(options=T.unsafe(nil)); end

  def find_organization_installation(organization, options=T.unsafe(nil)); end

  def find_repository_installation(repo, options=T.unsafe(nil)); end

  def find_user_installation(user, options=T.unsafe(nil)); end

  def find_user_installations(options=T.unsafe(nil)); end

  def installation(id, options=T.unsafe(nil)); end

  def list_app_installation_repositories(options=T.unsafe(nil)); end

  def list_installation_repos(options=T.unsafe(nil)); end

  def list_integration_installation_repositories(options=T.unsafe(nil)); end

  def remove_repo_from_installation(installation, repo, options=T.unsafe(nil)); end

  def remove_repository_from_app_installation(installation, repo, options=T.unsafe(nil)); end

  def remove_repository_from_integration_installation(installation, repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Apps
  extend ::T::Sig
end

module Octokit::Client::Authorizations
  def authorization(number, options=T.unsafe(nil)); end

  def authorizations(options=T.unsafe(nil)); end

  def authorize_url(app_id=T.unsafe(nil), options=T.unsafe(nil)); end

  def check_application_authorization(token, options=T.unsafe(nil)); end

  def create_authorization(options=T.unsafe(nil)); end

  def delete_application_authorization(token, options=T.unsafe(nil)); end

  def delete_authorization(number, options=T.unsafe(nil)); end

  def reset_application_authorization(token, options=T.unsafe(nil)); end

  def revoke_all_application_authorizations(options=T.unsafe(nil)); end

  def revoke_application_authorization(token, options=T.unsafe(nil)); end

  def scopes(token=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_authorization(number, options=T.unsafe(nil)); end
end

module Octokit::Client::Authorizations
  extend ::T::Sig
end

module Octokit::Client::CommitComments
  def commit_comment(repo, id, options=T.unsafe(nil)); end

  def commit_comments(repo, sha, options=T.unsafe(nil)); end

  def create_commit_comment(repo, sha, body, path=T.unsafe(nil), line=T.unsafe(nil), position=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_commit_comment(repo, id, options=T.unsafe(nil)); end

  def list_commit_comments(repo, options=T.unsafe(nil)); end

  def update_commit_comment(repo, id, body, options=T.unsafe(nil)); end
end

module Octokit::Client::CommitComments
  extend ::T::Sig
end

module Octokit::Client::Commits
  def commit(repo, sha, options=T.unsafe(nil)); end

  def commits(*args); end

  def commits_before(*args); end

  def commits_between(*args); end

  def commits_on(*args); end

  def commits_since(*args); end

  def compare(repo, start, endd, options=T.unsafe(nil)); end

  def create_commit(repo, message, tree, parents=T.unsafe(nil), options=T.unsafe(nil)); end

  def git_commit(repo, sha, options=T.unsafe(nil)); end

  def iso8601(date); end

  def list_commits(*args); end

  def merge(repo, base, head, options=T.unsafe(nil)); end

  def parse_date(date); end
end

module Octokit::Client::Commits
  extend ::T::Sig
end

module Octokit::Client::CommunityProfile
  def community_profile(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::CommunityProfile
  extend ::T::Sig
end

module Octokit::Client::Contents
  def add_content(*args); end

  def add_contents(*args); end

  def archive_link(repo, options=T.unsafe(nil)); end

  def content(repo, options=T.unsafe(nil)); end

  def contents(repo, options=T.unsafe(nil)); end

  def create_content(*args); end

  def create_contents(*args); end

  def delete_content(repo, path, message, sha, options=T.unsafe(nil)); end

  def delete_contents(repo, path, message, sha, options=T.unsafe(nil)); end

  def readme(repo, options=T.unsafe(nil)); end

  def remove_content(repo, path, message, sha, options=T.unsafe(nil)); end

  def remove_contents(repo, path, message, sha, options=T.unsafe(nil)); end

  def update_content(*args); end

  def update_contents(*args); end
end

module Octokit::Client::Contents
  extend ::T::Sig
end

module Octokit::Client::Deployments
  def create_deployment(repo, ref, options=T.unsafe(nil)); end

  def create_deployment_status(deployment_url, state, options=T.unsafe(nil)); end

  def deployment(repo, deployment_id, options=T.unsafe(nil)); end

  def deployment_statuses(deployment_url, options=T.unsafe(nil)); end

  def deployments(repo, options=T.unsafe(nil)); end

  def list_deployment_statuses(deployment_url, options=T.unsafe(nil)); end

  def list_deployments(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Deployments
  extend ::T::Sig
end

module Octokit::Client::Downloads
  def delete_download(repo, id, options=T.unsafe(nil)); end

  def download(repo, id, options=T.unsafe(nil)); end

  def downloads(repo, options=T.unsafe(nil)); end

  def list_downloads(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Downloads
  extend ::T::Sig
end

module Octokit::Client::Emojis
  def emojis(options=T.unsafe(nil)); end
end

module Octokit::Client::Emojis
  extend ::T::Sig
end

module Octokit::Client::Events
  def issue_event(repo, number, options=T.unsafe(nil)); end

  def issue_events(repo, number, options=T.unsafe(nil)); end

  def organization_events(org, options=T.unsafe(nil)); end

  def organization_public_events(org, options=T.unsafe(nil)); end

  def public_events(options=T.unsafe(nil)); end

  def received_events(user, options=T.unsafe(nil)); end

  def received_public_events(user, options=T.unsafe(nil)); end

  def repo_issue_events(repo, options=T.unsafe(nil)); end

  def repository_events(repo, options=T.unsafe(nil)); end

  def repository_issue_events(repo, options=T.unsafe(nil)); end

  def repository_network_events(repo, options=T.unsafe(nil)); end

  def user_events(user, options=T.unsafe(nil)); end

  def user_public_events(user, options=T.unsafe(nil)); end
end

module Octokit::Client::Events
  extend ::T::Sig
end

module Octokit::Client::Feeds
  def feed(name, options=T.unsafe(nil)); end

  def feeds(); end
end

module Octokit::Client::Feeds
  extend ::T::Sig
end

module Octokit::Client::Gists
  def create_gist(options=T.unsafe(nil)); end

  def create_gist_comment(gist_id, comment, options=T.unsafe(nil)); end

  def delete_gist(gist, options=T.unsafe(nil)); end

  def delete_gist_comment(gist_id, gist_comment_id, options=T.unsafe(nil)); end

  def edit_gist(gist, options=T.unsafe(nil)); end

  def fork_gist(gist, options=T.unsafe(nil)); end

  def gist(gist, options=T.unsafe(nil)); end

  def gist_comment(gist_id, gist_comment_id, options=T.unsafe(nil)); end

  def gist_comments(gist_id, options=T.unsafe(nil)); end

  def gist_commits(gist, options=T.unsafe(nil)); end

  def gist_forks(gist, options=T.unsafe(nil)); end

  def gist_starred?(gist, options=T.unsafe(nil)); end

  def gists(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_gists(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def public_gists(options=T.unsafe(nil)); end

  def star_gist(gist, options=T.unsafe(nil)); end

  def starred_gists(options=T.unsafe(nil)); end

  def unstar_gist(gist, options=T.unsafe(nil)); end

  def update_gist_comment(gist_id, gist_comment_id, comment, options=T.unsafe(nil)); end
end

module Octokit::Client::Gists
  extend ::T::Sig
end

module Octokit::Client::Gitignore
  def gitignore_template(template_name, options=T.unsafe(nil)); end

  def gitignore_templates(options=T.unsafe(nil)); end
end

module Octokit::Client::Gitignore
  extend ::T::Sig
end

module Octokit::Client::Hooks
  def available_hooks(options=T.unsafe(nil)); end

  def create_hook(repo, name, config, options=T.unsafe(nil)); end

  def create_org_hook(org, config, options=T.unsafe(nil)); end

  def edit_hook(repo, id, name, config, options=T.unsafe(nil)); end

  def edit_org_hook(org, id, config, options=T.unsafe(nil)); end

  def hook(repo, id, options=T.unsafe(nil)); end

  def hooks(repo, options=T.unsafe(nil)); end

  def list_org_hooks(org, options=T.unsafe(nil)); end

  def org_hook(org, id, options=T.unsafe(nil)); end

  def org_hooks(org, options=T.unsafe(nil)); end

  def parse_payload(payload_string); end

  def ping_hook(repo, id, options=T.unsafe(nil)); end

  def ping_org_hook(org, id, options=T.unsafe(nil)); end

  def remove_hook(repo, id, options=T.unsafe(nil)); end

  def remove_org_hook(org, id, options=T.unsafe(nil)); end

  def test_hook(repo, id, options=T.unsafe(nil)); end

  def update_org_hook(org, id, config, options=T.unsafe(nil)); end
end

module Octokit::Client::Hooks
  extend ::T::Sig
end

module Octokit::Client::Issues
  def add_assignees(repo, number, assignees, options=T.unsafe(nil)); end

  def add_comment(repo, number, comment, options=T.unsafe(nil)); end

  def close_issue(repo, number, options=T.unsafe(nil)); end

  def create_issue(repo, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete_comment(repo, number, options=T.unsafe(nil)); end

  def issue(repo, number, options=T.unsafe(nil)); end

  def issue_comment(repo, number, options=T.unsafe(nil)); end

  def issue_comments(repo, number, options=T.unsafe(nil)); end

  def issue_timeline(repo, number, options=T.unsafe(nil)); end

  def issues(repository=T.unsafe(nil), options=T.unsafe(nil)); end

  def issues_comments(repo, options=T.unsafe(nil)); end

  def list_assignees(repo, options=T.unsafe(nil)); end

  def list_issues(repository=T.unsafe(nil), options=T.unsafe(nil)); end

  def lock_issue(repo, number, options=T.unsafe(nil)); end

  def open_issue(repo, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def org_issues(org, options=T.unsafe(nil)); end

  def remove_assignees(repo, number, assignees, options=T.unsafe(nil)); end

  def reopen_issue(repo, number, options=T.unsafe(nil)); end

  def unlock_issue(repo, number, options=T.unsafe(nil)); end

  def update_comment(repo, number, comment, options=T.unsafe(nil)); end

  def update_issue(repo, number, *args); end

  def user_issues(options=T.unsafe(nil)); end
end

module Octokit::Client::Issues
  extend ::T::Sig
end

module Octokit::Client::Labels
  def add_label(repo, label, color=T.unsafe(nil), options=T.unsafe(nil)); end

  def add_labels_to_an_issue(repo, number, labels); end

  def delete_label!(repo, label, options=T.unsafe(nil)); end

  def label(repo, name, options=T.unsafe(nil)); end

  def labels(repo, options=T.unsafe(nil)); end

  def labels_for_issue(repo, number, options=T.unsafe(nil)); end

  def labels_for_milestone(repo, number, options=T.unsafe(nil)); end

  def remove_all_labels(repo, number, options=T.unsafe(nil)); end

  def remove_label(repo, number, label, options=T.unsafe(nil)); end

  def replace_all_labels(repo, number, labels, options=T.unsafe(nil)); end

  def update_label(repo, label, options=T.unsafe(nil)); end
end

module Octokit::Client::Labels
  extend ::T::Sig
end

module Octokit::Client::LegacySearch
  def legacy_search_issues(repo, search_term, state=T.unsafe(nil), options=T.unsafe(nil)); end

  def legacy_search_repositories(q, options=T.unsafe(nil)); end

  def legacy_search_users(search, options=T.unsafe(nil)); end
end

module Octokit::Client::LegacySearch
  extend ::T::Sig
end

module Octokit::Client::Licenses
  def license(license_name, options=T.unsafe(nil)); end

  def licenses(options=T.unsafe(nil)); end

  def repository_license_contents(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Licenses
  extend ::T::Sig
end

module Octokit::Client::Markdown
  def markdown(text, options=T.unsafe(nil)); end
end

module Octokit::Client::Markdown
  extend ::T::Sig
end

module Octokit::Client::Marketplace
  def list_accounts_for_plan(plan_id, options=T.unsafe(nil)); end

  def list_plans(options=T.unsafe(nil)); end

  def marketplace_purchases(options=T.unsafe(nil)); end

  def plan_for_account(account_id, options=T.unsafe(nil)); end
end

module Octokit::Client::Marketplace
  extend ::T::Sig
end

module Octokit::Client::Meta
  def github_meta(options=T.unsafe(nil)); end

  def meta(options=T.unsafe(nil)); end
end

module Octokit::Client::Meta
  extend ::T::Sig
end

module Octokit::Client::Milestones
  def create_milestone(repository, title, options=T.unsafe(nil)); end

  def delete_milestone(repository, number, options=T.unsafe(nil)); end

  def edit_milestone(repository, number, options=T.unsafe(nil)); end

  def list_milestones(repository, options=T.unsafe(nil)); end

  def milestone(repository, number, options=T.unsafe(nil)); end

  def milestones(repository, options=T.unsafe(nil)); end

  def update_milestone(repository, number, options=T.unsafe(nil)); end
end

module Octokit::Client::Milestones
  extend ::T::Sig
end

module Octokit::Client::Notifications
  def delete_thread_subscription(thread_id, options=T.unsafe(nil)); end

  def mark_notifications_as_read(options=T.unsafe(nil)); end

  def mark_repo_notifications_as_read(repo, options=T.unsafe(nil)); end

  def mark_repository_notifications_as_read(repo, options=T.unsafe(nil)); end

  def mark_thread_as_read(thread_id, options=T.unsafe(nil)); end

  def notifications(options=T.unsafe(nil)); end

  def repo_notifications(repo, options=T.unsafe(nil)); end

  def repository_notifications(repo, options=T.unsafe(nil)); end

  def thread_notifications(thread_id, options=T.unsafe(nil)); end

  def thread_subscription(thread_id, options=T.unsafe(nil)); end

  def update_thread_subscription(thread_id, options=T.unsafe(nil)); end
end

module Octokit::Client::Notifications
  extend ::T::Sig
end

module Octokit::Client::Objects
  def blob(repo, blob_sha, options=T.unsafe(nil)); end

  def create_blob(repo, content, encoding=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_tag(repo, tag, message, object_sha, type, tagger_name, tagger_email, tagger_date, options=T.unsafe(nil)); end

  def create_tree(repo, tree, options=T.unsafe(nil)); end

  def tag(repo, tag_sha, options=T.unsafe(nil)); end

  def tree(repo, tree_sha, options=T.unsafe(nil)); end
end

module Octokit::Client::Objects
  extend ::T::Sig
end

module Octokit::Client::Organizations
  def add_team_member(team_id, user, options=T.unsafe(nil)); end

  def add_team_membership(team_id, user, options=T.unsafe(nil)); end

  def add_team_repo(team_id, repo, options=T.unsafe(nil)); end

  def add_team_repository(team_id, repo, options=T.unsafe(nil)); end

  def all_organizations(options=T.unsafe(nil)); end

  def all_orgs(options=T.unsafe(nil)); end

  def child_teams(team_id, options=T.unsafe(nil)); end

  def conceal_membership(org, user, options=T.unsafe(nil)); end

  def convert_to_outside_collaborator(org, user, options=T.unsafe(nil)); end

  def create_team(org, options=T.unsafe(nil)); end

  def delete_migration_archive(org, id, options=T.unsafe(nil)); end

  def delete_team(team_id, options=T.unsafe(nil)); end

  def list_organizations(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_orgs(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def migration_archive_url(org, id, options=T.unsafe(nil)); end

  def migration_status(org, id, options=T.unsafe(nil)); end

  def migrations(org, options=T.unsafe(nil)); end

  def org(org, options=T.unsafe(nil)); end

  def org_invitations(org, options=T.unsafe(nil)); end

  def org_member?(org, user, options=T.unsafe(nil)); end

  def org_members(org, options=T.unsafe(nil)); end

  def org_membership(org, options=T.unsafe(nil)); end

  def org_memberships(options=T.unsafe(nil)); end

  def org_public_member?(org, user, options=T.unsafe(nil)); end

  def org_public_members(org, options=T.unsafe(nil)); end

  def org_repos(org, options=T.unsafe(nil)); end

  def org_repositories(org, options=T.unsafe(nil)); end

  def org_teams(org, options=T.unsafe(nil)); end

  def organization(org, options=T.unsafe(nil)); end

  def organization_invitations(org, options=T.unsafe(nil)); end

  def organization_member?(org, user, options=T.unsafe(nil)); end

  def organization_members(org, options=T.unsafe(nil)); end

  def organization_membership(org, options=T.unsafe(nil)); end

  def organization_memberships(options=T.unsafe(nil)); end

  def organization_public_member?(org, user, options=T.unsafe(nil)); end

  def organization_public_members(org, options=T.unsafe(nil)); end

  def organization_repositories(org, options=T.unsafe(nil)); end

  def organization_teams(org, options=T.unsafe(nil)); end

  def organizations(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def orgs(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def outside_collaborators(org, options=T.unsafe(nil)); end

  def publicize_membership(org, user, options=T.unsafe(nil)); end

  def remove_org_member(org, user, options=T.unsafe(nil)); end

  def remove_org_membership(org, options=T.unsafe(nil)); end

  def remove_organization_member(org, user, options=T.unsafe(nil)); end

  def remove_organization_membership(org, options=T.unsafe(nil)); end

  def remove_outside_collaborator(org, user, options=T.unsafe(nil)); end

  def remove_team_member(team_id, user, options=T.unsafe(nil)); end

  def remove_team_membership(team_id, user, options=T.unsafe(nil)); end

  def remove_team_repo(team_id, repo, options=T.unsafe(nil)); end

  def remove_team_repository(team_id, repo, options=T.unsafe(nil)); end

  def start_migration(org, repositories, options=T.unsafe(nil)); end

  def team(team_id, options=T.unsafe(nil)); end

  def team_invitations(team_id, options=T.unsafe(nil)); end

  def team_member?(team_id, user, options=T.unsafe(nil)); end

  def team_members(team_id, options=T.unsafe(nil)); end

  def team_membership(team_id, user, options=T.unsafe(nil)); end

  def team_repo?(team_id, repo, options=T.unsafe(nil)); end

  def team_repos(team_id, options=T.unsafe(nil)); end

  def team_repositories(team_id, options=T.unsafe(nil)); end

  def team_repository?(team_id, repo, options=T.unsafe(nil)); end

  def unlock_repository(org, id, repo, options=T.unsafe(nil)); end

  def unpublicize_membership(org, user, options=T.unsafe(nil)); end

  def update_org(org, values, options=T.unsafe(nil)); end

  def update_org_membership(org, options=T.unsafe(nil)); end

  def update_organization(org, values, options=T.unsafe(nil)); end

  def update_organization_membership(org, options=T.unsafe(nil)); end

  def update_team(team_id, options=T.unsafe(nil)); end

  def user_teams(options=T.unsafe(nil)); end
end

module Octokit::Client::Organizations
  extend ::T::Sig
end

module Octokit::Client::Pages
  def latest_pages_build(repo, options=T.unsafe(nil)); end

  def list_pages_builds(repo, options=T.unsafe(nil)); end

  def pages(repo, options=T.unsafe(nil)); end

  def pages_build(repo, id, options=T.unsafe(nil)); end

  def pages_builds(repo, options=T.unsafe(nil)); end

  def request_page_build(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Pages
  extend ::T::Sig
end

module Octokit::Client::Projects
  def column_cards(id, options=T.unsafe(nil)); end

  def create_org_project(org, name, options=T.unsafe(nil)); end

  def create_organization_project(org, name, options=T.unsafe(nil)); end

  def create_project(repo, name, options=T.unsafe(nil)); end

  def create_project_card(id, options=T.unsafe(nil)); end

  def create_project_column(id, name, options=T.unsafe(nil)); end

  def delete_project(id, options=T.unsafe(nil)); end

  def delete_project_card(id, options=T.unsafe(nil)); end

  def delete_project_column(id, options=T.unsafe(nil)); end

  def move_project_card(id, position, options=T.unsafe(nil)); end

  def move_project_column(id, position, options=T.unsafe(nil)); end

  def org_projects(org, options=T.unsafe(nil)); end

  def organization_projects(org, options=T.unsafe(nil)); end

  def project(id, options=T.unsafe(nil)); end

  def project_card(id, options=T.unsafe(nil)); end

  def project_column(id, options=T.unsafe(nil)); end

  def project_columns(id, options=T.unsafe(nil)); end

  def projects(repo, options=T.unsafe(nil)); end

  def update_project(id, options=T.unsafe(nil)); end

  def update_project_card(id, options=T.unsafe(nil)); end

  def update_project_column(id, name, options=T.unsafe(nil)); end
end

module Octokit::Client::Projects
  extend ::T::Sig
end

module Octokit::Client::PubSubHubbub
  def subscribe(topic, callback, secret=T.unsafe(nil)); end

  def subscribe_service_hook(repo, service_name, service_arguments=T.unsafe(nil), secret=T.unsafe(nil)); end

  def unsubscribe(topic, callback); end

  def unsubscribe_service_hook(repo, service_name); end
end

module Octokit::Client::PubSubHubbub
  extend ::T::Sig
end

module Octokit::Client::PullRequests
  def close_pull_request(repo, number, options=T.unsafe(nil)); end

  def create_pull_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def create_pull_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_pull_request(repo, base, head, title, body=T.unsafe(nil), options=T.unsafe(nil)); end

  def create_pull_request_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def create_pull_request_comment_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_pull_request_for_issue(repo, base, head, issue, options=T.unsafe(nil)); end

  def create_review_reply(repo, pull_id, body, comment_id, options=T.unsafe(nil)); end

  def create_view_comment(repo, pull_id, body, commit_id, path, position, options=T.unsafe(nil)); end

  def delete_pull_comment(repo, comment_id, options=T.unsafe(nil)); end

  def delete_pull_request_comment(repo, comment_id, options=T.unsafe(nil)); end

  def delete_review_comment(repo, comment_id, options=T.unsafe(nil)); end

  def merge_pull_request(repo, number, commit_message=T.unsafe(nil), options=T.unsafe(nil)); end

  def pull(repo, number, options=T.unsafe(nil)); end

  def pull_comment(repo, comment_id, options=T.unsafe(nil)); end

  def pull_comments(repo, number, options=T.unsafe(nil)); end

  def pull_commits(repo, number, options=T.unsafe(nil)); end

  def pull_files(repo, number, options=T.unsafe(nil)); end

  def pull_merged?(repo, number, options=T.unsafe(nil)); end

  def pull_request(repo, number, options=T.unsafe(nil)); end

  def pull_request_comment(repo, comment_id, options=T.unsafe(nil)); end

  def pull_request_comments(repo, number, options=T.unsafe(nil)); end

  def pull_request_commits(repo, number, options=T.unsafe(nil)); end

  def pull_request_files(repo, number, options=T.unsafe(nil)); end

  def pull_request_merged?(repo, number, options=T.unsafe(nil)); end

  def pull_requests(repo, options=T.unsafe(nil)); end

  def pull_requests_comments(repo, options=T.unsafe(nil)); end

  def pulls(repo, options=T.unsafe(nil)); end

  def pulls_comments(repo, options=T.unsafe(nil)); end

  def review_comment(repo, comment_id, options=T.unsafe(nil)); end

  def review_comments(repo, number, options=T.unsafe(nil)); end

  def reviews_comments(repo, options=T.unsafe(nil)); end

  def update_pull_comment(repo, comment_id, body, options=T.unsafe(nil)); end

  def update_pull_request(*args); end

  def update_pull_request_comment(repo, comment_id, body, options=T.unsafe(nil)); end

  def update_review_comment(repo, comment_id, body, options=T.unsafe(nil)); end
end

module Octokit::Client::PullRequests
  extend ::T::Sig
end

module Octokit::Client::RateLimit
  def rate_limit(options=T.unsafe(nil)); end

  def rate_limit!(options=T.unsafe(nil)); end

  def rate_limit_remaining(options=T.unsafe(nil)); end

  def rate_limit_remaining!(options=T.unsafe(nil)); end

  def ratelimit(options=T.unsafe(nil)); end

  def ratelimit!(options=T.unsafe(nil)); end

  def ratelimit_remaining(options=T.unsafe(nil)); end

  def ratelimit_remaining!(options=T.unsafe(nil)); end
end

module Octokit::Client::RateLimit
  extend ::T::Sig
end

module Octokit::Client::Reactions
  def commit_comment_reactions(repo, id, options=T.unsafe(nil)); end

  def create_commit_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def create_issue_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def create_issue_reaction(repo, number, reaction, options=T.unsafe(nil)); end

  def create_pull_request_review_comment_reaction(repo, id, reaction, options=T.unsafe(nil)); end

  def delete_reaction(id, options=T.unsafe(nil)); end

  def issue_comment_reactions(repo, id, options=T.unsafe(nil)); end

  def issue_reactions(repo, number, options=T.unsafe(nil)); end

  def pull_request_review_comment_reactions(repo, id, options=T.unsafe(nil)); end
end

module Octokit::Client::Reactions
  extend ::T::Sig
end

module Octokit::Client::Refs
  def create_ref(repo, ref, sha, options=T.unsafe(nil)); end

  def create_reference(repo, ref, sha, options=T.unsafe(nil)); end

  def delete_branch(repo, branch, options=T.unsafe(nil)); end

  def delete_ref(repo, ref, options=T.unsafe(nil)); end

  def delete_reference(repo, ref, options=T.unsafe(nil)); end

  def list_references(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_refs(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def ref(repo, ref, options=T.unsafe(nil)); end

  def reference(repo, ref, options=T.unsafe(nil)); end

  def references(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def refs(repo, namespace=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_branch(repo, branch, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_ref(repo, ref, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end

  def update_reference(repo, ref, sha, force=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Refs
  extend ::T::Sig
end

module Octokit::Client::Releases
  def create_release(repo, tag_name, options=T.unsafe(nil)); end

  def delete_release(url, options=T.unsafe(nil)); end

  def delete_release_asset(asset_url, options=T.unsafe(nil)); end

  def edit_release(url, options=T.unsafe(nil)); end

  def edit_release_asset(asset_url, options=T.unsafe(nil)); end

  def latest_release(repo, options=T.unsafe(nil)); end

  def list_releases(repo, options=T.unsafe(nil)); end

  def release(url, options=T.unsafe(nil)); end

  def release_asset(asset_url, options=T.unsafe(nil)); end

  def release_assets(release_url, options=T.unsafe(nil)); end

  def release_for_tag(repo, tag_name, options=T.unsafe(nil)); end

  def releases(repo, options=T.unsafe(nil)); end

  def update_release(url, options=T.unsafe(nil)); end

  def update_release_asset(asset_url, options=T.unsafe(nil)); end

  def upload_asset(release_url, path_or_file, options=T.unsafe(nil)); end
end

module Octokit::Client::Releases
  extend ::T::Sig
end

module Octokit::Client::Repositories
  def add_collab(repo, collaborator, options=T.unsafe(nil)); end

  def add_collaborator(repo, collaborator, options=T.unsafe(nil)); end

  def add_deploy_key(repo, title, key, options=T.unsafe(nil)); end

  def all_repositories(options=T.unsafe(nil)); end

  def branch(repo, branch, options=T.unsafe(nil)); end

  def branch_protection(repo, branch, options=T.unsafe(nil)); end

  def branches(repo, options=T.unsafe(nil)); end

  def check_assignee(repo, assignee, options=T.unsafe(nil)); end

  def collaborator?(repo, collaborator, options=T.unsafe(nil)); end

  def collaborators(repo, options=T.unsafe(nil)); end

  def collabs(repo, options=T.unsafe(nil)); end

  def contribs(repo, anon=T.unsafe(nil), options=T.unsafe(nil)); end

  def contributors(repo, anon=T.unsafe(nil), options=T.unsafe(nil)); end

  def create(name, options=T.unsafe(nil)); end

  def create_repo(name, options=T.unsafe(nil)); end

  def create_repository(name, options=T.unsafe(nil)); end

  def delete_repo(repo, options=T.unsafe(nil)); end

  def delete_repository(repo, options=T.unsafe(nil)); end

  def delete_subscription(repo, options=T.unsafe(nil)); end

  def deploy_key(repo, id, options=T.unsafe(nil)); end

  def deploy_keys(repo, options=T.unsafe(nil)); end

  def edit(repo, options=T.unsafe(nil)); end

  def edit_deploy_key(repo, id, options); end

  def edit_repository(repo, options=T.unsafe(nil)); end

  def fork(repo, options=T.unsafe(nil)); end

  def forks(repo, options=T.unsafe(nil)); end

  def get_branch(repo, branch, options=T.unsafe(nil)); end

  def languages(repo, options=T.unsafe(nil)); end

  def list_deploy_keys(repo, options=T.unsafe(nil)); end

  def list_repos(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def list_repositories(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def network(repo, options=T.unsafe(nil)); end

  def permission_level(repo, collaborator, options=T.unsafe(nil)); end

  def protect_branch(repo, branch, options=T.unsafe(nil)); end

  def remove_collab(repo, collaborator, options=T.unsafe(nil)); end

  def remove_collaborator(repo, collaborator, options=T.unsafe(nil)); end

  def remove_deploy_key(repo, id, options=T.unsafe(nil)); end

  def replace_all_topics(repo, names, options=T.unsafe(nil)); end

  def repo(repo, options=T.unsafe(nil)); end

  def repo_assignees(repo, options=T.unsafe(nil)); end

  def repo_teams(repo, options=T.unsafe(nil)); end

  def repos(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def repositories(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def repository(repo, options=T.unsafe(nil)); end

  def repository?(repo, options=T.unsafe(nil)); end

  def repository_assignees(repo, options=T.unsafe(nil)); end

  def repository_teams(repo, options=T.unsafe(nil)); end

  def set_private(repo, options=T.unsafe(nil)); end

  def set_public(repo, options=T.unsafe(nil)); end

  def star(repo, options=T.unsafe(nil)); end

  def stargazers(repo, options=T.unsafe(nil)); end

  def subscribers(repo, options=T.unsafe(nil)); end

  def subscription(repo, options=T.unsafe(nil)); end

  def tags(repo, options=T.unsafe(nil)); end

  def teams(repo, options=T.unsafe(nil)); end

  def topics(repo, options=T.unsafe(nil)); end

  def transfer_repo(repo, new_owner, options=T.unsafe(nil)); end

  def transfer_repository(repo, new_owner, options=T.unsafe(nil)); end

  def unprotect_branch(repo, branch, options=T.unsafe(nil)); end

  def unstar(repo, options=T.unsafe(nil)); end

  def unwatch(repo, options=T.unsafe(nil)); end

  def update(repo, options=T.unsafe(nil)); end

  def update_deploy_key(repo, id, options); end

  def update_repository(repo, options=T.unsafe(nil)); end

  def update_subscription(repo, options=T.unsafe(nil)); end

  def watch(repo, options=T.unsafe(nil)); end

  def watchers(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Repositories
  extend ::T::Sig
end

module Octokit::Client::RepositoryInvitations
  def accept_repo_invitation(invitation_id, options=T.unsafe(nil)); end

  def accept_repository_invitation(invitation_id, options=T.unsafe(nil)); end

  def decline_invitation(invitation_id, options=T.unsafe(nil)); end

  def decline_repository_invitation(invitation_id, options=T.unsafe(nil)); end

  def delete_repo_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def delete_repository_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def invite_user_to_repo(repo, user, options=T.unsafe(nil)); end

  def invite_user_to_repository(repo, user, options=T.unsafe(nil)); end

  def repo_invitations(repo, options=T.unsafe(nil)); end

  def repository_invitations(repo, options=T.unsafe(nil)); end

  def update_repo_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def update_repository_invitation(repo, invitation_id, options=T.unsafe(nil)); end

  def user_repo_invitations(options=T.unsafe(nil)); end

  def user_repository_invitations(options=T.unsafe(nil)); end
end

module Octokit::Client::RepositoryInvitations
  extend ::T::Sig
end

module Octokit::Client::Reviews
  def create_pull_request_review(repo, number, options=T.unsafe(nil)); end

  def delete_pull_request_review(repo, number, review, options=T.unsafe(nil)); end

  def delete_pull_request_review_request(repo, id, reviewers=T.unsafe(nil), options=T.unsafe(nil)); end

  def dismiss_pull_request_review(repo, number, review, message, options=T.unsafe(nil)); end

  def pull_request_review(repo, number, review, options=T.unsafe(nil)); end

  def pull_request_review_comments(repo, number, review, options=T.unsafe(nil)); end

  def pull_request_review_requests(repo, number, options=T.unsafe(nil)); end

  def pull_request_reviews(repo, number, options=T.unsafe(nil)); end

  def request_pull_request_review(repo, number, reviewers=T.unsafe(nil), options=T.unsafe(nil)); end

  def submit_pull_request_review(repo, number, review, event, options=T.unsafe(nil)); end
end

module Octokit::Client::Reviews
  extend ::T::Sig
end

module Octokit::Client::Say
  def octocat(text=T.unsafe(nil), options=T.unsafe(nil)); end

  def say(text=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Say
  extend ::T::Sig
end

module Octokit::Client::Search
  def search_code(query, options=T.unsafe(nil)); end

  def search_commits(query, options=T.unsafe(nil)); end

  def search_issues(query, options=T.unsafe(nil)); end

  def search_repos(query, options=T.unsafe(nil)); end

  def search_repositories(query, options=T.unsafe(nil)); end

  def search_users(query, options=T.unsafe(nil)); end
end

module Octokit::Client::Search
  extend ::T::Sig
end

module Octokit::Client::ServiceStatus
  def github_status(); end

  def github_status_last_message(); end

  def github_status_messages(); end
  STATUS_ROOT = ::T.let(nil, ::T.untyped)
end

module Octokit::Client::ServiceStatus
  extend ::T::Sig
end

module Octokit::Client::SourceImport
  def cancel_source_import(repo, options=T.unsafe(nil)); end

  def map_source_import_commit_author(author_url, values, options=T.unsafe(nil)); end

  def set_source_import_lfs_preference(repo, use_lfs, options=T.unsafe(nil)); end

  def source_import_commit_authors(repo, options=T.unsafe(nil)); end

  def source_import_large_files(repo, options=T.unsafe(nil)); end

  def source_import_progress(repo, options=T.unsafe(nil)); end

  def start_source_import(*args); end

  def update_source_import(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::SourceImport
  extend ::T::Sig
end

module Octokit::Client::Stats
  def code_frequency_stats(repo, options=T.unsafe(nil)); end

  def commit_activity_stats(repo, options=T.unsafe(nil)); end

  def contributor_stats(repo, options=T.unsafe(nil)); end

  def contributors_stats(repo, options=T.unsafe(nil)); end

  def participation_stats(repo, options=T.unsafe(nil)); end

  def punch_card(repo, options=T.unsafe(nil)); end

  def punch_card_stats(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Stats
  extend ::T::Sig
end

module Octokit::Client::Statuses
  def combined_status(repo, ref, options=T.unsafe(nil)); end

  def create_status(repo, sha, state, options=T.unsafe(nil)); end

  def list_statuses(repo, sha, options=T.unsafe(nil)); end

  def status(repo, ref, options=T.unsafe(nil)); end

  def statuses(repo, sha, options=T.unsafe(nil)); end
end

module Octokit::Client::Statuses
  extend ::T::Sig
end

module Octokit::Client::Traffic
  def clones(repo, options=T.unsafe(nil)); end

  def top_paths(repo, options=T.unsafe(nil)); end

  def top_referrers(repo, options=T.unsafe(nil)); end

  def views(repo, options=T.unsafe(nil)); end
end

module Octokit::Client::Traffic
  extend ::T::Sig
end

module Octokit::Client::Users
  def add_email(email, options=T.unsafe(nil)); end

  def add_key(title, key, options=T.unsafe(nil)); end

  def all_users(options=T.unsafe(nil)); end

  def emails(options=T.unsafe(nil)); end

  def exchange_code_for_token(code, app_id=T.unsafe(nil), app_secret=T.unsafe(nil), options=T.unsafe(nil)); end

  def follow(user, options=T.unsafe(nil)); end

  def followers(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def following(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def follows?(*args); end

  def key(key_id, options=T.unsafe(nil)); end

  def keys(options=T.unsafe(nil)); end

  def remove_email(email); end

  def remove_key(id, options=T.unsafe(nil)); end

  def starred(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def starred?(repo, options=T.unsafe(nil)); end

  def subscriptions(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def unfollow(user, options=T.unsafe(nil)); end

  def update_key(key_id, options=T.unsafe(nil)); end

  def update_user(options); end

  def user(user=T.unsafe(nil), options=T.unsafe(nil)); end

  def user_keys(user, options=T.unsafe(nil)); end

  def validate_credentials(options=T.unsafe(nil)); end

  def watched(user=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Octokit::Client::Users
  extend ::T::Sig
end

class Octokit::Client
end

class Octokit::ClientError
end

class Octokit::ClientError
end

module Octokit::Configurable
  def access_token(); end

  def access_token=(access_token); end

  def api_endpoint(); end

  def api_endpoint=(api_endpoint); end

  def auto_paginate(); end

  def auto_paginate=(auto_paginate); end

  def bearer_token(); end

  def bearer_token=(bearer_token); end

  def client_id(); end

  def client_id=(client_id); end

  def client_secret(); end

  def client_secret=(client_secret); end

  def configure(); end

  def connection_options(); end

  def connection_options=(connection_options); end

  def default_media_type(); end

  def default_media_type=(default_media_type); end

  def login(); end

  def login=(login); end

  def management_console_endpoint(); end

  def management_console_endpoint=(management_console_endpoint); end

  def management_console_password=(management_console_password); end

  def middleware(); end

  def middleware=(middleware); end

  def netrc(); end

  def netrc=(netrc); end

  def netrc?(); end

  def netrc_file(); end

  def netrc_file=(netrc_file); end

  def password=(password); end

  def per_page(); end

  def per_page=(per_page); end

  def proxy(); end

  def proxy=(proxy); end

  def reset!(); end

  def same_options?(opts); end

  def setup(); end

  def ssl_verify_mode(); end

  def ssl_verify_mode=(ssl_verify_mode); end

  def user_agent(); end

  def user_agent=(user_agent); end

  def web_endpoint(); end

  def web_endpoint=(web_endpoint); end
end

module Octokit::Configurable
  extend ::T::Sig
  def self.keys(); end
end

class Octokit::Conflict
end

class Octokit::Conflict
end

module Octokit::Connection
  include ::Octokit::Authentication
  def agent(); end

  def delete(url, options=T.unsafe(nil)); end

  def endpoint(); end

  def get(url, options=T.unsafe(nil)); end

  def head(url, options=T.unsafe(nil)); end

  def last_response(); end

  def paginate(url, options=T.unsafe(nil), &block); end

  def patch(url, options=T.unsafe(nil)); end

  def post(url, options=T.unsafe(nil)); end

  def put(url, options=T.unsafe(nil)); end

  def root(); end
  CONVENIENCE_HEADERS = ::T.let(nil, ::T.untyped)
end

module Octokit::Connection
  extend ::T::Sig
end

module Octokit::Default
  API_ENDPOINT = ::T.let(nil, ::T.untyped)
  MEDIA_TYPE = ::T.let(nil, ::T.untyped)
  MIDDLEWARE = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
  WEB_ENDPOINT = ::T.let(nil, ::T.untyped)
end

Octokit::Default::RACK_BUILDER_CLASS = Faraday::RackBuilder

module Octokit::Default
  extend ::T::Sig
  def self.access_token(); end

  def self.api_endpoint(); end

  def self.auto_paginate(); end

  def self.bearer_token(); end

  def self.client_id(); end

  def self.client_secret(); end

  def self.connection_options(); end

  def self.default_media_type(); end

  def self.login(); end

  def self.management_console_endpoint(); end

  def self.management_console_password(); end

  def self.middleware(); end

  def self.netrc(); end

  def self.netrc_file(); end

  def self.options(); end

  def self.password(); end

  def self.per_page(); end

  def self.proxy(); end

  def self.ssl_verify_mode(); end

  def self.user_agent(); end

  def self.web_endpoint(); end
end

class Octokit::EnterpriseAdminClient
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Warnable
  include ::Octokit::EnterpriseAdminClient::AdminStats
  include ::Octokit::EnterpriseAdminClient::License
  include ::Octokit::EnterpriseAdminClient::Orgs
  include ::Octokit::EnterpriseAdminClient::SearchIndexing
  include ::Octokit::EnterpriseAdminClient::Users
  def initialize(options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::AdminStats
  def admin_comments_stats(); end

  def admin_gists_stats(); end

  def admin_hooks_stats(); end

  def admin_issues_stats(); end

  def admin_milestones_stats(); end

  def admin_organization_stats(); end

  def admin_pages_stats(); end

  def admin_pull_requests_stats(); end

  def admin_repository_stats(); end

  def admin_stats(); end

  def admin_users_stats(); end
end

module Octokit::EnterpriseAdminClient::AdminStats
  extend ::T::Sig
end

module Octokit::EnterpriseAdminClient::License
  def license_info(); end
end

module Octokit::EnterpriseAdminClient::License
  extend ::T::Sig
end

module Octokit::EnterpriseAdminClient::Orgs
  def create_organization(login, admin, options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::Orgs
  extend ::T::Sig
end

module Octokit::EnterpriseAdminClient::SearchIndexing
  def index_organization(user); end

  def index_organizations_repositories(user); end

  def index_organizations_repositories_code(user); end

  def index_organizations_repositories_issues(user); end

  def index_repository(repo); end

  def index_repository_code(repo); end

  def index_repository_issues(repo); end

  def index_user(user); end

  def index_users_repositories(user); end

  def index_users_repositories_code(user); end

  def index_users_repositories_issues(user); end
end

module Octokit::EnterpriseAdminClient::SearchIndexing
  extend ::T::Sig
end

module Octokit::EnterpriseAdminClient::Users
  def create_impersonation_token(login, options=T.unsafe(nil)); end

  def create_user(login, email, options=T.unsafe(nil)); end

  def delete_impersonation_token(login, options=T.unsafe(nil)); end

  def delete_key(id, options=T.unsafe(nil)); end

  def delete_user(username, options=T.unsafe(nil)); end

  def demote(user, options=T.unsafe(nil)); end

  def list_all_keys(options=T.unsafe(nil)); end

  def promote(user, options=T.unsafe(nil)); end

  def rename_user(old_login, new_login, options=T.unsafe(nil)); end

  def suspend(user, options=T.unsafe(nil)); end

  def unsuspend(user, options=T.unsafe(nil)); end
end

module Octokit::EnterpriseAdminClient::Users
  extend ::T::Sig
end

class Octokit::EnterpriseAdminClient
end

class Octokit::EnterpriseManagementConsoleClient
  include ::Octokit::Configurable
  include ::Octokit::Connection
  include ::Octokit::Authentication
  include ::Octokit::Warnable
  include ::Octokit::EnterpriseManagementConsoleClient::ManagementConsole
  def initialize(options=T.unsafe(nil)); end

  def management_console_endpoint=(value); end

  def management_console_password=(value); end
end

module Octokit::EnterpriseManagementConsoleClient::ManagementConsole
  def add_authorized_key(key); end

  def authorized_keys(); end

  def config_check(); end

  def config_status(); end

  def delete_authorized_key(key); end

  def edit_maintenance_status(maintenance); end

  def edit_settings(settings); end

  def get_authorized_keys(); end

  def get_maintenance_status(); end

  def get_settings(); end

  def maintenance_status(); end

  def remove_authorized_key(key); end

  def set_maintenance_status(maintenance); end

  def settings(); end

  def start_configuration(); end

  def upgrade(license); end

  def upload_license(license, settings=T.unsafe(nil)); end
end

module Octokit::EnterpriseManagementConsoleClient::ManagementConsole
  extend ::T::Sig
end

class Octokit::EnterpriseManagementConsoleClient
end

class Octokit::Error
  def documentation_url(); end

  def errors(); end

  def initialize(response=T.unsafe(nil)); end

  def response_body(); end

  def response_headers(); end

  def response_status(); end
end

class Octokit::Error
  def self.error_for_401(headers); end

  def self.error_for_403(body); end

  def self.error_for_404(body); end

  def self.from_response(response); end
end

class Octokit::Forbidden
end

class Octokit::Forbidden
end

class Octokit::Gist
  def id(); end

  def id=(id); end

  def initialize(gist); end

  def url(); end
end

class Octokit::Gist
  def self.from_url(url); end
end

class Octokit::InternalServerError
end

class Octokit::InternalServerError
end

class Octokit::InvalidRepository
end

class Octokit::InvalidRepository
end

class Octokit::MethodNotAllowed
end

class Octokit::MethodNotAllowed
end

module Octokit::Middleware
end

class Octokit::Middleware::FollowRedirects
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  ENV_TO_CLEAR = ::T.let(nil, ::T.untyped)
  FOLLOW_LIMIT = ::T.let(nil, ::T.untyped)
  REDIRECT_CODES = ::T.let(nil, ::T.untyped)
  URI_UNSAFE = ::T.let(nil, ::T.untyped)
end

class Octokit::Middleware::FollowRedirects
end

class Octokit::Middleware::RedirectLimitReached
  def initialize(response); end
end

class Octokit::Middleware::RedirectLimitReached
end

module Octokit::Middleware
  extend ::T::Sig
end

class Octokit::MissingContentType
end

class Octokit::MissingContentType
end

class Octokit::NotAcceptable
end

class Octokit::NotAcceptable
end

class Octokit::NotFound
end

class Octokit::NotFound
end

class Octokit::NotImplemented
end

class Octokit::NotImplemented
end

class Octokit::OneTimePasswordRequired
  def password_delivery(); end
  OTP_DELIVERY_PATTERN = ::T.let(nil, ::T.untyped)
end

class Octokit::OneTimePasswordRequired
  def self.required_header(headers); end
end

class Octokit::Organization
end

class Octokit::Organization
  def self.path(org); end
end

module Octokit::Preview
  def ensure_api_media_type(type, options); end

  def warn_preview(type); end
  PREVIEW_TYPES = ::T.let(nil, ::T.untyped)
end

module Octokit::Preview
  extend ::T::Sig
end

class Octokit::RateLimit
end

class Octokit::RateLimit
  def self.from_response(response); end
end

class Octokit::RepoArguments
  def repo(); end
end

class Octokit::RepoArguments
end

class Octokit::Repository
  def id(); end

  def id=(id); end

  def id_api_path(); end

  def initialize(repo); end

  def name(); end

  def name=(name); end

  def named_api_path(); end

  def owner(); end

  def owner=(owner); end

  def path(); end

  def repo(); end

  def slug(); end

  def url(); end

  def user(); end

  def username(); end
  NAME_WITH_OWNER_PATTERN = ::T.let(nil, ::T.untyped)
end

class Octokit::Repository
  def self.from_url(url); end

  def self.path(repo); end
end

class Octokit::RepositoryUnavailable
end

class Octokit::RepositoryUnavailable
end

module Octokit::Response
end

class Octokit::Response::FeedParser
end

class Octokit::Response::FeedParser
end

class Octokit::Response::RaiseError
end

class Octokit::Response::RaiseError
end

module Octokit::Response
  extend ::T::Sig
end

class Octokit::ServerError
end

class Octokit::ServerError
end

class Octokit::ServiceUnavailable
end

class Octokit::ServiceUnavailable
end

class Octokit::TooManyLoginAttempts
end

class Octokit::TooManyLoginAttempts
end

class Octokit::TooManyRequests
end

class Octokit::TooManyRequests
end

class Octokit::Unauthorized
end

class Octokit::Unauthorized
end

class Octokit::UnavailableForLegalReasons
end

class Octokit::UnavailableForLegalReasons
end

class Octokit::UnprocessableEntity
end

class Octokit::UnprocessableEntity
end

class Octokit::UnsupportedMediaType
end

class Octokit::UnsupportedMediaType
end

class Octokit::UnverifiedEmail
end

class Octokit::UnverifiedEmail
end

class Octokit::User
end

class Octokit::User
  def self.path(user); end
end

module Octokit::Warnable
  def octokit_warn(*message); end
end

module Octokit::Warnable
  extend ::T::Sig
end

module Octokit
  extend ::Octokit::Configurable
  extend ::T::Sig
  def self.client(); end

  def self.enterprise_admin_client(); end

  def self.enterprise_management_console_client(); end
end

class Offer
  include ::Offer::GeneratedAssociationMethods
  include ::PaperTrail::Model::InstanceMethods
  def after_add_for_versions(); end

  def after_add_for_versions=(val); end

  def after_add_for_versions?(); end

  def after_remove_for_versions(); end

  def after_remove_for_versions=(val); end

  def after_remove_for_versions?(); end

  def autosave_associated_records_for_order(*args); end

  def autosave_associated_records_for_responds_to(*args); end

  def autosave_associated_records_for_versions(*args); end

  def before_add_for_versions(); end

  def before_add_for_versions=(val); end

  def before_add_for_versions?(); end

  def before_remove_for_versions(); end

  def before_remove_for_versions=(val); end

  def before_remove_for_versions?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def paper_trail_event(); end

  def paper_trail_event=(paper_trail_event); end

  def paper_trail_options(); end

  def paper_trail_options=(val); end

  def paper_trail_options?(); end

  def validate_associated_records_for_versions(*args); end

  def version(); end

  def version=(version); end

  def version_association_name(); end

  def version_association_name=(val); end

  def version_association_name?(); end

  def version_class_name(); end

  def version_class_name=(val); end

  def version_class_name?(); end

  def versions_association_name(); end

  def versions_association_name=(val); end

  def versions_association_name?(); end
end

module Offer::GeneratedAssociationMethods
  def build_order(*args, &block); end

  def build_responds_to(*args, &block); end

  def create_order(*args, &block); end

  def create_order!(*args, &block); end

  def create_responds_to(*args, &block); end

  def create_responds_to!(*args, &block); end

  def order(); end

  def order=(value); end

  def reload_order(); end

  def reload_responds_to(); end

  def responds_to(); end

  def responds_to=(value); end

  def version_ids(); end

  def version_ids=(ids); end

  def versions(); end

  def versions=(value); end
end

module Offer::GeneratedAssociationMethods
  extend ::T::Sig
end

class Offer
  def self.after_add_for_versions(); end

  def self.after_add_for_versions=(val); end

  def self.after_add_for_versions?(); end

  def self.after_remove_for_versions(); end

  def self.after_remove_for_versions=(val); end

  def self.after_remove_for_versions?(); end

  def self.before_add_for_versions(); end

  def self.before_add_for_versions=(val); end

  def self.before_add_for_versions?(); end

  def self.before_remove_for_versions(); end

  def self.before_remove_for_versions=(val); end

  def self.before_remove_for_versions?(); end

  def self.paper_trail_options(); end

  def self.paper_trail_options=(val); end

  def self.paper_trail_options?(); end

  def self.pending(*args); end

  def self.submitted(*args); end

  def self.version_association_name(); end

  def self.version_association_name=(val); end

  def self.version_association_name?(); end

  def self.version_class_name(); end

  def self.version_class_name=(val); end

  def self.version_class_name?(); end

  def self.versions_association_name(); end

  def self.versions_association_name=(val); end

  def self.versions_association_name?(); end
end

class OfferEvent
end

module OfferQueryHelper
  extend ::T::Sig
end

module OfferService
  extend ::T::Sig
end

module OmniAuth
  VERSION = ::T.let(nil, ::T.untyped)
end

module OmniAuth::Artsy
end

module OmniAuth::Artsy::Config
  def artsy_api_url(); end

  def artsy_api_url=(artsy_api_url); end

  def reset(); end
end

module OmniAuth::Artsy::Config
  extend ::OmniAuth::Artsy::Config
  extend ::T::Sig
end

module OmniAuth::Artsy
  extend ::T::Sig
  def self.config(); end

  def self.configure(); end

  def self.reconfigure_strategy(); end
end

class OmniAuth::AuthHash
  def regular_writer(key, value); end

  def valid?(); end
end

class OmniAuth::AuthHash::InfoHash
  def name(); end

  def name?(); end

  def to_hash(); end

  def valid?(); end
end

class OmniAuth::AuthHash::InfoHash
  def self.subkey_class(); end
end

class OmniAuth::AuthHash
  def self.subkey_class(); end
end

class OmniAuth::Builder
  def before_callback_phase(&block); end

  def before_options_phase(&block); end

  def before_request_phase(&block); end

  def configure(&block); end

  def initialize(app, &block); end

  def on_failure(&block); end

  def options(options=T.unsafe(nil)); end

  def provider(klass, *args, &block); end

  def rack14?(); end

  def rack2?(); end
end

class OmniAuth::Builder
end

class OmniAuth::Configuration
  include ::Singleton
  def add_camelization(name, camelized); end

  def add_mock(provider, original=T.unsafe(nil)); end

  def allowed_request_methods(); end

  def allowed_request_methods=(allowed_request_methods); end

  def before_callback_phase(&block); end

  def before_callback_phase=(before_callback_phase); end

  def before_options_phase(&block); end

  def before_options_phase=(before_options_phase); end

  def before_request_phase(&block); end

  def before_request_phase=(before_request_phase); end

  def camelizations(); end

  def camelizations=(camelizations); end

  def failure_raise_out_environments(); end

  def failure_raise_out_environments=(failure_raise_out_environments); end

  def form_css(); end

  def form_css=(form_css); end

  def full_host(); end

  def full_host=(full_host); end

  def logger(); end

  def logger=(logger); end

  def mock_auth(); end

  def mock_auth=(mock_auth); end

  def on_failure(&block); end

  def on_failure=(on_failure); end

  def path_prefix(); end

  def path_prefix=(path_prefix); end

  def test_mode(); end

  def test_mode=(test_mode); end
end

class OmniAuth::Configuration
  extend ::Singleton::SingletonClassMethods
  def self.default_logger(); end

  def self.defaults(); end

  def self.instance(); end
end

class OmniAuth::Error
end

class OmniAuth::Error
end

class OmniAuth::FailureEndpoint
  def call(); end

  def env(); end

  def initialize(env); end

  def origin_query_param(); end

  def raise_out!(); end

  def redirect_to_failure(); end

  def strategy_name_query_param(); end
end

class OmniAuth::FailureEndpoint
  def self.call(env); end
end

class OmniAuth::Form
  def button(text); end

  def css(); end

  def fieldset(legend, options=T.unsafe(nil), &block); end

  def footer(); end

  def header(title, header_info); end

  def html(html); end

  def initialize(options=T.unsafe(nil)); end

  def input_field(type, name); end

  def label_field(text, target); end

  def options(); end

  def options=(options); end

  def password_field(label, name); end

  def text_field(label, name); end

  def to_html(); end

  def to_response(); end
  DEFAULT_CSS = ::T.let(nil, ::T.untyped)
end

class OmniAuth::Form
  def self.build(options=T.unsafe(nil), &block); end
end

class OmniAuth::KeyStore
end

class OmniAuth::KeyStore
  def self.override_logging(); end
end

class OmniAuth::NoSessionError
end

class OmniAuth::NoSessionError
end

module OmniAuth::OAuth2
  VERSION = ::T.let(nil, ::T.untyped)
end

module OmniAuth::OAuth2
  extend ::T::Sig
end

module OmniAuth::Strategies
end

class OmniAuth::Strategies::Artsy
  def raw_info(); end
end

class OmniAuth::Strategies::Artsy
  def self.configure(); end
end

class OmniAuth::Strategies::Developer
  include ::OmniAuth::Strategy
end

class OmniAuth::Strategies::Developer
  extend ::OmniAuth::Strategy::ClassMethods
end

class OmniAuth::Strategies::OAuth2
  include ::OmniAuth::Strategy
  def access_token(); end

  def access_token=(access_token); end

  def authorize_params(); end

  def build_access_token(); end

  def client(); end

  def deep_symbolize(options); end

  def options_for(option); end

  def token_params(); end
end

class OmniAuth::Strategies::OAuth2::CallbackError
  def error(); end

  def error=(error); end

  def error_reason(); end

  def error_reason=(error_reason); end

  def error_uri(); end

  def error_uri=(error_uri); end

  def initialize(error, error_reason=T.unsafe(nil), error_uri=T.unsafe(nil)); end
end

class OmniAuth::Strategies::OAuth2::CallbackError
end

class OmniAuth::Strategies::OAuth2
  extend ::OmniAuth::Strategy::ClassMethods
  def self.inherited(subclass); end
end

module OmniAuth::Strategies
  extend ::T::Sig
end

module OmniAuth::Strategy
  def app(); end

  def auth_hash(); end

  def call(env); end

  def call!(env); end

  def call_app!(env=T.unsafe(nil)); end

  def callback_call(); end

  def callback_path(); end

  def callback_phase(); end

  def callback_url(); end

  def credentials(); end

  def current_path(); end

  def custom_path(kind); end

  def dup(); end

  def env(); end

  def extra(); end

  def fail!(message_key, exception=T.unsafe(nil)); end

  def full_host(); end

  def info(); end

  def initialize(app, *args, &block); end

  def inspect(); end

  def log(level, message); end

  def merge_stack(stack); end

  def mock_call!(*_); end

  def mock_callback_call(); end

  def mock_request_call(); end

  def name(); end

  def on_auth_path?(); end

  def on_callback_path?(); end

  def on_path?(path); end

  def on_request_path?(); end

  def options(); end

  def options_call(); end

  def options_request?(); end

  def path_prefix(); end

  def query_string(); end

  def redirect(uri); end

  def request(); end

  def request_call(); end

  def request_path(); end

  def request_phase(); end

  def response(); end

  def script_name(); end

  def session(); end

  def setup_path(); end

  def setup_phase(); end

  def skip_info?(); end

  def ssl?(); end

  def uid(); end

  def user_info(); end
  CURRENT_PATH_REGEX = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
end

module OmniAuth::Strategy::ClassMethods
  def args(args=T.unsafe(nil)); end

  def compile_stack(ancestors, method, context); end

  def configure(options=T.unsafe(nil)); end

  def credentials(&block); end

  def credentials_stack(context); end

  def default_options(); end

  def extra(&block); end

  def extra_stack(context); end

  def info(&block); end

  def info_stack(context); end

  def option(name, value=T.unsafe(nil)); end

  def uid(&block); end

  def uid_stack(context); end
end

module OmniAuth::Strategy::ClassMethods
  extend ::T::Sig
end

class OmniAuth::Strategy::Options
end

class OmniAuth::Strategy::Options
end

module OmniAuth::Strategy
  extend ::T::Sig
  def self.included(base); end
end

module OmniAuth::Test
end

class OmniAuth::Test::PhonySession
  def call(env); end

  def initialize(app); end
end

class OmniAuth::Test::PhonySession
end

module OmniAuth::Test::StrategyMacros
  def sets_an_auth_hash(); end

  def sets_provider_to(provider); end

  def sets_uid_to(uid); end

  def sets_user_info_to(user_info); end
end

module OmniAuth::Test::StrategyMacros
  extend ::T::Sig
end

module OmniAuth::Test::StrategyTestCase
  def app(); end

  def app_response(); end

  def session(); end

  def strategy(); end
end

module OmniAuth::Test::StrategyTestCase
  extend ::T::Sig
end

module OmniAuth::Test
  extend ::T::Sig
end

module OmniAuth::Utils
end

module OmniAuth::Utils
  extend ::T::Sig
  def self.camelize(word, first_letter_in_uppercase=T.unsafe(nil)); end

  def self.deep_merge(hash, other_hash); end

  def self.form_css(); end
end

module OmniAuth
  extend ::T::Sig
  def self.config(); end

  def self.configure(); end

  def self.logger(); end

  def self.mock_auth_for(provider); end

  def self.strategies(); end
end

module Omniauth
end

module Omniauth::Artsy
  VERSION = ::T.let(nil, ::T.untyped)
end

module Omniauth::Artsy
  extend ::T::Sig
end

module Omniauth
  extend ::T::Sig
end

class OpenSSL::ASN1::ASN1Data
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def indefinite_length(); end

  def indefinite_length=(indefinite_length); end
end

class OpenSSL::ASN1::ASN1Data
  extend ::T::Sig
end

class OpenSSL::ASN1::ASN1Error
  extend ::T::Sig
end

class OpenSSL::ASN1::BMPString
  extend ::T::Sig
end

class OpenSSL::ASN1::BitString
  extend ::T::Sig
end

class OpenSSL::ASN1::Boolean
  extend ::T::Sig
end

class OpenSSL::ASN1::Constructive
  extend ::T::Sig
end

class OpenSSL::ASN1::EndOfContent
  extend ::T::Sig
end

class OpenSSL::ASN1::Enumerated
  extend ::T::Sig
end

class OpenSSL::ASN1::GeneralString
  extend ::T::Sig
end

class OpenSSL::ASN1::GeneralizedTime
  extend ::T::Sig
end

class OpenSSL::ASN1::GraphicString
  extend ::T::Sig
end

class OpenSSL::ASN1::IA5String
  extend ::T::Sig
end

class OpenSSL::ASN1::ISO64String
  extend ::T::Sig
end

class OpenSSL::ASN1::Integer
  extend ::T::Sig
end

class OpenSSL::ASN1::Null
  extend ::T::Sig
end

class OpenSSL::ASN1::NumericString
  extend ::T::Sig
end

class OpenSSL::ASN1::ObjectId
  extend ::T::Sig
end

class OpenSSL::ASN1::OctetString
  extend ::T::Sig
end

class OpenSSL::ASN1::Primitive
  extend ::T::Sig
end

class OpenSSL::ASN1::PrintableString
  extend ::T::Sig
end

class OpenSSL::ASN1::Sequence
  extend ::T::Sig
end

class OpenSSL::ASN1::Set
  extend ::T::Sig
end

class OpenSSL::ASN1::T61String
  extend ::T::Sig
end

class OpenSSL::ASN1::UTCTime
  extend ::T::Sig
end

class OpenSSL::ASN1::UTF8String
  extend ::T::Sig
end

class OpenSSL::ASN1::UniversalString
  extend ::T::Sig
end

class OpenSSL::ASN1::VideotexString
  extend ::T::Sig
end

module OpenSSL::ASN1
  extend ::T::Sig
end

class OpenSSL::BN
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def +@(); end

  def -@(); end

  def /(_); end

  def negative?(); end
end

class OpenSSL::BN
  extend ::T::Sig
end

class OpenSSL::BNError
  extend ::T::Sig
end

module OpenSSL::Buffering
  extend ::T::Sig
end

class OpenSSL::Cipher
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::Cipher::AES
  extend ::T::Sig
end

class OpenSSL::Cipher::AES128
  extend ::T::Sig
end

class OpenSSL::Cipher::AES192
  extend ::T::Sig
end

class OpenSSL::Cipher::AES256
  extend ::T::Sig
end

class OpenSSL::Cipher::BF
  extend ::T::Sig
end

class OpenSSL::Cipher::CAST5
  extend ::T::Sig
end

class OpenSSL::Cipher::CipherError
  extend ::T::Sig
end

class OpenSSL::Cipher::DES
  extend ::T::Sig
end

class OpenSSL::Cipher::IDEA
  extend ::T::Sig
end

class OpenSSL::Cipher::RC2
  extend ::T::Sig
end

class OpenSSL::Cipher::RC4
  extend ::T::Sig
end

class OpenSSL::Cipher::RC5
  extend ::T::Sig
end

class OpenSSL::Cipher
  extend ::T::Sig
end

class OpenSSL::Config
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::Config
  extend ::T::Sig
end

class OpenSSL::ConfigError
  extend ::T::Sig
end

class OpenSSL::Digest
  extend ::T::Sig
end

class OpenSSL::Engine
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::Engine::EngineError
  extend ::T::Sig
end

class OpenSSL::Engine
  extend ::T::Sig
end

module OpenSSL::ExtConfig
  extend ::T::Sig
end

class OpenSSL::HMAC
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::HMAC
  extend ::T::Sig
end

class OpenSSL::HMACError
  extend ::T::Sig
end

module OpenSSL::KDF
end

class OpenSSL::KDF::KDFError
end

class OpenSSL::KDF::KDFError
end

module OpenSSL::KDF
  extend ::T::Sig
  def self.pbkdf2_hmac(*_); end
end

class OpenSSL::Netscape::SPKI
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::Netscape::SPKI
  extend ::T::Sig
end

class OpenSSL::Netscape::SPKIError
  extend ::T::Sig
end

module OpenSSL::Netscape
  extend ::T::Sig
end

class OpenSSL::OCSP::BasicResponse
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::OCSP::BasicResponse
  extend ::T::Sig
end

class OpenSSL::OCSP::CertificateId
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::OCSP::CertificateId
  extend ::T::Sig
end

class OpenSSL::OCSP::OCSPError
  extend ::T::Sig
end

class OpenSSL::OCSP::Request
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def signed?(); end
end

class OpenSSL::OCSP::Request
  extend ::T::Sig
end

class OpenSSL::OCSP::Response
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::OCSP::Response
  extend ::T::Sig
end

class OpenSSL::OCSP::SingleResponse
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::OCSP::SingleResponse
  extend ::T::Sig
end

module OpenSSL::OCSP
  extend ::T::Sig
end

class OpenSSL::OpenSSLError
  extend ::T::Sig
end

class OpenSSL::PKCS12
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKCS12::PKCS12Error
  extend ::T::Sig
end

class OpenSSL::PKCS12
  extend ::T::Sig
end

module OpenSSL::PKCS5
  extend ::T::Sig
end

class OpenSSL::PKCS7
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKCS7::PKCS7Error
  extend ::T::Sig
end

class OpenSSL::PKCS7::RecipientInfo
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKCS7::RecipientInfo
  extend ::T::Sig
end

OpenSSL::PKCS7::Signer = OpenSSL::PKCS7::SignerInfo

class OpenSSL::PKCS7::SignerInfo
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKCS7::SignerInfo
  extend ::T::Sig
end

class OpenSSL::PKCS7
  extend ::T::Sig
end

class OpenSSL::PKey::DH
  extend ::T::Sig
end

class OpenSSL::PKey::DHError
  extend ::T::Sig
end

class OpenSSL::PKey::DSA
  extend ::T::Sig
end

class OpenSSL::PKey::DSAError
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Group
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKey::EC::Group::Error
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Group
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Point
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_octet_string(_); end
end

class OpenSSL::PKey::EC::Point::Error
  extend ::T::Sig
end

class OpenSSL::PKey::EC::Point
  extend ::T::Sig
end

class OpenSSL::PKey::EC
  extend ::T::Sig
end

class OpenSSL::PKey::ECError
  extend ::T::Sig
end

class OpenSSL::PKey::PKey
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::PKey::PKey
  extend ::T::Sig
end

class OpenSSL::PKey::PKeyError
  extend ::T::Sig
end

class OpenSSL::PKey::RSA
  def sign_pss(*_); end

  def verify_pss(*_); end
end

class OpenSSL::PKey::RSA
  extend ::T::Sig
end

class OpenSSL::PKey::RSAError
  extend ::T::Sig
end

module OpenSSL::PKey
  extend ::T::Sig
end

class OpenSSL::Random::RandomError
  extend ::T::Sig
end

module OpenSSL::Random
  extend ::T::Sig
end

module OpenSSL::SSL
  OP_ALLOW_UNSAFE_LEGACY_RENEGOTIATION = ::T.let(nil, ::T.untyped)
  OP_CRYPTOPRO_TLSEXT_BUG = ::T.let(nil, ::T.untyped)
  OP_LEGACY_SERVER_CONNECT = ::T.let(nil, ::T.untyped)
  OP_SAFARI_ECDHE_ECDSA_BUG = ::T.let(nil, ::T.untyped)
  OP_TLSEXT_PADDING = ::T.let(nil, ::T.untyped)
  SSL2_VERSION = ::T.let(nil, ::T.untyped)
  SSL3_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_1_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_2_VERSION = ::T.let(nil, ::T.untyped)
  TLS1_VERSION = ::T.let(nil, ::T.untyped)
end

class OpenSSL::SSL::SSLSocket
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def alpn_protocol(); end

  def tmp_key(); end
end

class OpenSSL::SSL::SSLSocket
  extend ::T::Sig
end

module OpenSSL::SSL::SocketForwarder
  extend ::T::Sig
end

module OpenSSL::SSL
  extend ::T::Sig
end

module OpenSSL::X509
  V_FLAG_TRUSTED_FIRST = ::T.let(nil, ::T.untyped)
end

class OpenSSL::X509::Attribute
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end
end

class OpenSSL::X509::Attribute
  extend ::T::Sig
end

class OpenSSL::X509::AttributeError
  extend ::T::Sig
end

class OpenSSL::X509::CRL
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end
end

class OpenSSL::X509::CRL
  extend ::T::Sig
end

class OpenSSL::X509::CRLError
  extend ::T::Sig
end

class OpenSSL::X509::Certificate
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::X509::Certificate
  extend ::T::Sig
end

class OpenSSL::X509::CertificateError
  extend ::T::Sig
end

class OpenSSL::X509::Extension
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end
end

class OpenSSL::X509::Extension
  extend ::T::Sig
end

class OpenSSL::X509::ExtensionError
  extend ::T::Sig
end

class OpenSSL::X509::ExtensionFactory
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::X509::ExtensionFactory
  extend ::T::Sig
end

class OpenSSL::X509::Name
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def to_utf8(); end
end

module OpenSSL::X509::Name::RFC2253DN
  extend ::T::Sig
end

class OpenSSL::X509::Name
  extend ::T::Sig
end

class OpenSSL::X509::NameError
  extend ::T::Sig
end

class OpenSSL::X509::Request
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end
end

class OpenSSL::X509::Request
  extend ::T::Sig
end

class OpenSSL::X509::RequestError
  extend ::T::Sig
end

class OpenSSL::X509::Revoked
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def to_der(); end
end

class OpenSSL::X509::Revoked
  extend ::T::Sig
end

class OpenSSL::X509::RevokedError
  extend ::T::Sig
end

class OpenSSL::X509::Store
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::X509::Store
  extend ::T::Sig
end

class OpenSSL::X509::StoreContext
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenSSL::X509::StoreContext
  extend ::T::Sig
end

class OpenSSL::X509::StoreError
  extend ::T::Sig
end

module OpenSSL::X509
  extend ::T::Sig
end

module OpenSSL
  extend ::T::Sig
  def self.fips_mode(); end
end

class OpenStruct
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class OpenStruct
  extend ::T::Sig
end

module OpenURI
  Options = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
  def <<(str); end

  def io(); end

  def size(); end
  StringMax = ::T.let(nil, ::T.untyped)
end

class OpenURI::Buffer
end

class OpenURI::HTTPError
  def initialize(message, io); end

  def io(); end
end

class OpenURI::HTTPError
end

class OpenURI::HTTPRedirect
  def initialize(message, io, uri); end

  def uri(); end
end

class OpenURI::HTTPRedirect
end

module OpenURI::Meta
  def base_uri(); end

  def base_uri=(base_uri); end

  def charset(); end

  def content_encoding(); end

  def content_type(); end

  def content_type_parse(); end

  def last_modified(); end

  def meta(); end

  def meta_add_field(name, value); end

  def meta_add_field2(name, values); end

  def meta_setup_encoding(); end

  def metas(); end

  def status(); end

  def status=(status); end
  RE_LWS = ::T.let(nil, ::T.untyped)
  RE_PARAMETERS = ::T.let(nil, ::T.untyped)
  RE_QUOTED_STRING = ::T.let(nil, ::T.untyped)
  RE_TOKEN = ::T.let(nil, ::T.untyped)
end

module OpenURI::Meta
  extend ::T::Sig
  def self.init(obj, src=T.unsafe(nil)); end
end

module OpenURI::OpenRead
  def open(*rest, &block); end

  def read(options=T.unsafe(nil)); end
end

module OpenURI::OpenRead
  extend ::T::Sig
end

module OpenURI
  extend ::T::Sig
  def self.check_options(options); end

  def self.open_http(buf, target, proxy, options); end

  def self.open_loop(uri, options); end

  def self.open_uri(name, *rest); end

  def self.redirectable?(uri1, uri2); end

  def self.scan_open_optional_arguments(*rest); end
end

OptParse = OptionParser

class OptionParser
  def abort(mesg=T.unsafe(nil)); end

  def accept(*args, &blk); end

  def add_officious(); end

  def banner(); end

  def banner=(banner); end

  def base(); end

  def candidate(word); end

  def compsys(to, name=T.unsafe(nil)); end

  def def_head_option(*opts, &block); end

  def def_option(*opts, &block); end

  def def_tail_option(*opts, &block); end

  def default_argv(); end

  def default_argv=(default_argv); end

  def define(*opts, &block); end

  def define_head(*opts, &block); end

  def define_tail(*opts, &block); end

  def environment(env=T.unsafe(nil)); end

  def getopts(*args); end

  def help(); end

  def inc(*args); end

  def initialize(banner=T.unsafe(nil), width=T.unsafe(nil), indent=T.unsafe(nil)); end

  def load(filename=T.unsafe(nil)); end

  def make_switch(opts, block=T.unsafe(nil)); end

  def new(); end

  def on(*opts, &block); end

  def on_head(*opts, &block); end

  def on_tail(*opts, &block); end

  def order(*argv, into: T.unsafe(nil), &nonopt); end

  def order!(argv=T.unsafe(nil), into: T.unsafe(nil), &nonopt); end

  def parse(*argv, into: T.unsafe(nil)); end

  def parse!(argv=T.unsafe(nil), into: T.unsafe(nil)); end

  def permute(*argv, into: T.unsafe(nil)); end

  def permute!(argv=T.unsafe(nil), into: T.unsafe(nil)); end

  def program_name(); end

  def program_name=(program_name); end

  def reject(*args, &blk); end

  def release(); end

  def release=(release); end

  def remove(); end

  def separator(string); end

  def set_banner(_); end

  def set_program_name(_); end

  def set_summary_indent(_); end

  def set_summary_width(_); end

  def summarize(to=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil), &blk); end

  def summary_indent(); end

  def summary_indent=(summary_indent); end

  def summary_width(); end

  def summary_width=(summary_width); end

  def terminate(arg=T.unsafe(nil)); end

  def to_a(); end

  def top(); end

  def ver(); end

  def version(); end

  def version=(version); end

  def warn(mesg=T.unsafe(nil)); end
  ArgumentStyle = ::T.let(nil, ::T.untyped)
  COMPSYS_HEADER = ::T.let(nil, ::T.untyped)
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  DefaultList = ::T.let(nil, ::T.untyped)
  NO_ARGUMENT = ::T.let(nil, ::T.untyped)
  NoArgument = ::T.let(nil, ::T.untyped)
  OPTIONAL_ARGUMENT = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
  Officious = ::T.let(nil, ::T.untyped)
  OptionalArgument = ::T.let(nil, ::T.untyped)
  REQUIRED_ARGUMENT = ::T.let(nil, ::T.untyped)
  RequiredArgument = ::T.let(nil, ::T.untyped)
  SPLAT_PROC = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  DecimalInteger = ::T.let(nil, ::T.untyped)
  DecimalNumeric = ::T.let(nil, ::T.untyped)
  OctalInteger = ::T.let(nil, ::T.untyped)
end

module OptionParser::Acceptables
  extend ::T::Sig
end

class OptionParser::AmbiguousArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousArgument
end

class OptionParser::AmbiguousOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::AmbiguousOption
end

module OptionParser::Arguable
  def getopts(*args); end

  def initialize(*args); end

  def options(); end

  def options=(opt); end

  def order!(&blk); end

  def parse!(); end

  def permute!(); end
end

module OptionParser::Arguable
  extend ::T::Sig
  def self.extend_object(obj); end
end

class OptionParser::CompletingHash
  include ::OptionParser::Completion
  def match(key); end
end

class OptionParser::CompletingHash
end

module OptionParser::Completion
  def candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def complete(key, icase=T.unsafe(nil), pat=T.unsafe(nil)); end

  def convert(opt=T.unsafe(nil), val=T.unsafe(nil), *_); end
end

module OptionParser::Completion
  extend ::T::Sig
  def self.candidate(key, icase=T.unsafe(nil), pat=T.unsafe(nil), &block); end

  def self.regexp(key, icase); end
end

class OptionParser::InvalidArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidArgument
end

class OptionParser::InvalidOption
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::InvalidOption
end

class OptionParser::List
  def accept(t, pat=T.unsafe(nil), &block); end

  def add_banner(to); end

  def append(*args); end

  def atype(); end

  def complete(id, opt, icase=T.unsafe(nil), *pat, &block); end

  def compsys(*args, &block); end

  def each_option(&block); end

  def list(); end

  def long(); end

  def prepend(*args); end

  def reject(t); end

  def search(id, key); end

  def short(); end

  def summarize(*args, &block); end
end

class OptionParser::List
end

class OptionParser::MissingArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::MissingArgument
end

class OptionParser::NeedlessArgument
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::NeedlessArgument
end

class OptionParser::OptionMap
  include ::OptionParser::Completion
end

class OptionParser::OptionMap
end

class OptionParser::ParseError
  def args(); end

  def initialize(*args); end

  def reason(); end

  def reason=(reason); end

  def recover(argv); end

  def set_backtrace(array); end

  def set_option(opt, eq); end
  Reason = ::T.let(nil, ::T.untyped)
end

class OptionParser::ParseError
  def self.filter_backtrace(array); end
end

class OptionParser::Switch
  def add_banner(to); end

  def arg(); end

  def block(); end

  def compsys(sdone, ldone); end

  def conv(); end

  def desc(); end

  def initialize(pattern=T.unsafe(nil), conv=T.unsafe(nil), short=T.unsafe(nil), long=T.unsafe(nil), arg=T.unsafe(nil), desc=T.unsafe(nil), block=T.unsafe(nil)); end

  def long(); end

  def match_nonswitch?(str); end

  def pattern(); end

  def short(); end

  def summarize(sdone=T.unsafe(nil), ldone=T.unsafe(nil), width=T.unsafe(nil), max=T.unsafe(nil), indent=T.unsafe(nil)); end

  def switch_name(); end
end

class OptionParser::Switch::NoArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::NoArgument
  def self.incompatible_argument_styles(*_); end
end

class OptionParser::Switch::OptionalArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::OptionalArgument
end

class OptionParser::Switch::PlacedArgument
  def parse(arg, argv, &error); end
end

class OptionParser::Switch::PlacedArgument
end

class OptionParser::Switch::RequiredArgument
  def parse(arg, argv); end
end

class OptionParser::Switch::RequiredArgument
end

class OptionParser::Switch
  def self.guess(arg); end

  def self.incompatible_argument_styles(arg, t); end

  def self.pattern(); end
end

class OptionParser
  def self.accept(*args, &blk); end

  def self.getopts(*args); end

  def self.inc(arg, default=T.unsafe(nil)); end

  def self.reject(*args, &blk); end

  def self.terminate(arg=T.unsafe(nil)); end

  def self.top(); end

  def self.with(*args, &block); end
end

class Order
  include ::Order::GeneratedAssociationMethods
  include ::PaperTrail::Model::InstanceMethods
  def abandon!(state_reason=T.unsafe(nil), &block); end

  def after_add_for_admin_notes(); end

  def after_add_for_admin_notes=(val); end

  def after_add_for_admin_notes?(); end

  def after_add_for_line_items(); end

  def after_add_for_line_items=(val); end

  def after_add_for_line_items?(); end

  def after_add_for_offers(); end

  def after_add_for_offers=(val); end

  def after_add_for_offers?(); end

  def after_add_for_state_histories(); end

  def after_add_for_state_histories=(val); end

  def after_add_for_state_histories?(); end

  def after_add_for_transactions(); end

  def after_add_for_transactions=(val); end

  def after_add_for_transactions?(); end

  def after_add_for_versions(); end

  def after_add_for_versions=(val); end

  def after_add_for_versions?(); end

  def after_remove_for_admin_notes(); end

  def after_remove_for_admin_notes=(val); end

  def after_remove_for_admin_notes?(); end

  def after_remove_for_line_items(); end

  def after_remove_for_line_items=(val); end

  def after_remove_for_line_items?(); end

  def after_remove_for_offers(); end

  def after_remove_for_offers=(val); end

  def after_remove_for_offers?(); end

  def after_remove_for_state_histories(); end

  def after_remove_for_state_histories=(val); end

  def after_remove_for_state_histories?(); end

  def after_remove_for_transactions(); end

  def after_remove_for_transactions=(val); end

  def after_remove_for_transactions?(); end

  def after_remove_for_versions(); end

  def after_remove_for_versions=(val); end

  def after_remove_for_versions?(); end

  def approve!(state_reason=T.unsafe(nil), &block); end

  def autosave_associated_records_for_admin_notes(*args); end

  def autosave_associated_records_for_last_offer(*args); end

  def autosave_associated_records_for_line_items(*args); end

  def autosave_associated_records_for_offers(*args); end

  def autosave_associated_records_for_state_histories(*args); end

  def autosave_associated_records_for_transactions(*args); end

  def autosave_associated_records_for_versions(*args); end

  def before_add_for_admin_notes(); end

  def before_add_for_admin_notes=(val); end

  def before_add_for_admin_notes?(); end

  def before_add_for_line_items(); end

  def before_add_for_line_items=(val); end

  def before_add_for_line_items?(); end

  def before_add_for_offers(); end

  def before_add_for_offers=(val); end

  def before_add_for_offers?(); end

  def before_add_for_state_histories(); end

  def before_add_for_state_histories=(val); end

  def before_add_for_state_histories?(); end

  def before_add_for_transactions(); end

  def before_add_for_transactions=(val); end

  def before_add_for_transactions?(); end

  def before_add_for_versions(); end

  def before_add_for_versions=(val); end

  def before_add_for_versions?(); end

  def before_remove_for_admin_notes(); end

  def before_remove_for_admin_notes=(val); end

  def before_remove_for_admin_notes?(); end

  def before_remove_for_line_items(); end

  def before_remove_for_line_items=(val); end

  def before_remove_for_line_items?(); end

  def before_remove_for_offers(); end

  def before_remove_for_offers=(val); end

  def before_remove_for_offers?(); end

  def before_remove_for_state_histories(); end

  def before_remove_for_state_histories=(val); end

  def before_remove_for_state_histories?(); end

  def before_remove_for_transactions(); end

  def before_remove_for_transactions=(val); end

  def before_remove_for_transactions?(); end

  def before_remove_for_versions(); end

  def before_remove_for_versions=(val); end

  def before_remove_for_versions?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def buyer_lapse!(state_reason=T.unsafe(nil), &block); end

  def fulfill!(state_reason=T.unsafe(nil), &block); end

  def paper_trail_event(); end

  def paper_trail_event=(paper_trail_event); end

  def paper_trail_options(); end

  def paper_trail_options=(val); end

  def paper_trail_options?(); end

  def refund!(state_reason=T.unsafe(nil), &block); end

  def reject!(state_reason=T.unsafe(nil), &block); end

  def seller_lapse!(state_reason=T.unsafe(nil), &block); end

  def submit!(state_reason=T.unsafe(nil), &block); end

  def validate_associated_records_for_admin_notes(*args); end

  def validate_associated_records_for_line_items(*args); end

  def validate_associated_records_for_offers(*args); end

  def validate_associated_records_for_state_histories(*args); end

  def validate_associated_records_for_transactions(*args); end

  def validate_associated_records_for_versions(*args); end

  def version(); end

  def version=(version); end

  def version_association_name(); end

  def version_association_name=(val); end

  def version_association_name?(); end

  def version_class_name(); end

  def version_class_name=(val); end

  def version_class_name?(); end

  def versions_association_name(); end

  def versions_association_name=(val); end

  def versions_association_name?(); end
end

module Order::GeneratedAssociationMethods
  def admin_note_ids(); end

  def admin_note_ids=(ids); end

  def admin_notes(); end

  def admin_notes=(value); end

  def build_last_offer(*args, &block); end

  def create_last_offer(*args, &block); end

  def create_last_offer!(*args, &block); end

  def last_offer(); end

  def last_offer=(value); end

  def line_item_ids(); end

  def line_item_ids=(ids); end

  def line_items(); end

  def line_items=(value); end

  def offer_ids(); end

  def offer_ids=(ids); end

  def offers(); end

  def offers=(value); end

  def reload_last_offer(); end

  def state_histories(); end

  def state_histories=(value); end

  def state_history_ids(); end

  def state_history_ids=(ids); end

  def transaction_ids(); end

  def transaction_ids=(ids); end

  def transactions(); end

  def transactions=(value); end

  def version_ids(); end

  def version_ids=(ids); end

  def versions(); end

  def versions=(value); end
end

module Order::GeneratedAssociationMethods
  extend ::T::Sig
end

class Order
  def self.active(*args); end

  def self.after_add_for_admin_notes(); end

  def self.after_add_for_admin_notes=(val); end

  def self.after_add_for_admin_notes?(); end

  def self.after_add_for_line_items(); end

  def self.after_add_for_line_items=(val); end

  def self.after_add_for_line_items?(); end

  def self.after_add_for_offers(); end

  def self.after_add_for_offers=(val); end

  def self.after_add_for_offers?(); end

  def self.after_add_for_state_histories(); end

  def self.after_add_for_state_histories=(val); end

  def self.after_add_for_state_histories?(); end

  def self.after_add_for_transactions(); end

  def self.after_add_for_transactions=(val); end

  def self.after_add_for_transactions?(); end

  def self.after_add_for_versions(); end

  def self.after_add_for_versions=(val); end

  def self.after_add_for_versions?(); end

  def self.after_remove_for_admin_notes(); end

  def self.after_remove_for_admin_notes=(val); end

  def self.after_remove_for_admin_notes?(); end

  def self.after_remove_for_line_items(); end

  def self.after_remove_for_line_items=(val); end

  def self.after_remove_for_line_items?(); end

  def self.after_remove_for_offers(); end

  def self.after_remove_for_offers=(val); end

  def self.after_remove_for_offers?(); end

  def self.after_remove_for_state_histories(); end

  def self.after_remove_for_state_histories=(val); end

  def self.after_remove_for_state_histories?(); end

  def self.after_remove_for_transactions(); end

  def self.after_remove_for_transactions=(val); end

  def self.after_remove_for_transactions?(); end

  def self.after_remove_for_versions(); end

  def self.after_remove_for_versions=(val); end

  def self.after_remove_for_versions?(); end

  def self.approved(*args); end

  def self.before_add_for_admin_notes(); end

  def self.before_add_for_admin_notes=(val); end

  def self.before_add_for_admin_notes?(); end

  def self.before_add_for_line_items(); end

  def self.before_add_for_line_items=(val); end

  def self.before_add_for_line_items?(); end

  def self.before_add_for_offers(); end

  def self.before_add_for_offers=(val); end

  def self.before_add_for_offers?(); end

  def self.before_add_for_state_histories(); end

  def self.before_add_for_state_histories=(val); end

  def self.before_add_for_state_histories?(); end

  def self.before_add_for_transactions(); end

  def self.before_add_for_transactions=(val); end

  def self.before_add_for_transactions?(); end

  def self.before_add_for_versions(); end

  def self.before_add_for_versions=(val); end

  def self.before_add_for_versions?(); end

  def self.before_remove_for_admin_notes(); end

  def self.before_remove_for_admin_notes=(val); end

  def self.before_remove_for_admin_notes?(); end

  def self.before_remove_for_line_items(); end

  def self.before_remove_for_line_items=(val); end

  def self.before_remove_for_line_items?(); end

  def self.before_remove_for_offers(); end

  def self.before_remove_for_offers=(val); end

  def self.before_remove_for_offers?(); end

  def self.before_remove_for_state_histories(); end

  def self.before_remove_for_state_histories=(val); end

  def self.before_remove_for_state_histories?(); end

  def self.before_remove_for_transactions(); end

  def self.before_remove_for_transactions=(val); end

  def self.before_remove_for_transactions?(); end

  def self.before_remove_for_versions(); end

  def self.before_remove_for_versions=(val); end

  def self.before_remove_for_versions?(); end

  def self.by_last_admin_note(*args); end

  def self.paper_trail_options(); end

  def self.paper_trail_options=(val); end

  def self.paper_trail_options?(); end

  def self.pending(*args); end

  def self.version_association_name(); end

  def self.version_association_name=(val); end

  def self.version_association_name?(); end

  def self.version_class_name(); end

  def self.version_class_name=(val); end

  def self.version_class_name?(); end

  def self.versions_association_name(); end

  def self.versions_association_name=(val); end

  def self.versions_association_name?(); end
end

class OrderEvent
end

module OrderHelper
  extend ::T::Sig
end

module OrderService
  extend ::T::Sig
end

module OrmAdapter
  VERSION = ::T.let(nil, ::T.untyped)
end

class OrmAdapter::ActiveRecord
  def conditions_to_fields(conditions); end

  def construct_relation(relation, options); end

  def order_clause(order); end
end

class OrmAdapter::ActiveRecord
end

class OrmAdapter::Base
  def column_names(); end

  def create!(attributes=T.unsafe(nil)); end

  def destroy(object); end

  def extract_conditions!(options=T.unsafe(nil)); end

  def find_all(options=T.unsafe(nil)); end

  def find_first(options=T.unsafe(nil)); end

  def get(id); end

  def get!(id); end

  def initialize(klass); end

  def klass(); end

  def normalize_order(order); end

  def valid_object?(object); end

  def wrap_key(key); end
end

class OrmAdapter::Base
  def self.inherited(adapter); end
end

class OrmAdapter::NotSupportedError
end

class OrmAdapter::NotSupportedError
end

module OrmAdapter::ToAdapter
  def to_adapter(); end
end

module OrmAdapter::ToAdapter
  extend ::T::Sig
end

module OrmAdapter
  extend ::T::Sig
  def self.adapters(); end
end

module PG
  include ::PG::Constants
  ERROR_CLASSES = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PG::ActiveSqlTransaction
end

class PG::ActiveSqlTransaction
end

class PG::AdminShutdown
end

class PG::AdminShutdown
end

class PG::AmbiguousAlias
end

class PG::AmbiguousAlias
end

class PG::AmbiguousColumn
end

class PG::AmbiguousColumn
end

class PG::AmbiguousFunction
end

class PG::AmbiguousFunction
end

class PG::AmbiguousParameter
end

class PG::AmbiguousParameter
end

class PG::ArraySubscriptError
end

class PG::ArraySubscriptError
end

class PG::AssertFailure
end

class PG::AssertFailure
end

class PG::BadCopyFileFormat
end

class PG::BadCopyFileFormat
end

class PG::BasicTypeMapBasedOnResult
  include ::PG::BasicTypeRegistry
  def initialize(connection); end
end

class PG::BasicTypeMapBasedOnResult
end

class PG::BasicTypeMapForQueries
  include ::PG::BasicTypeRegistry
  def initialize(connection); end
  DEFAULT_ARRAY_TYPE_MAP = ::T.let(nil, ::T.untyped)
  DEFAULT_TYPE_MAP = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeMapForQueries
end

class PG::BasicTypeMapForResults
  include ::PG::BasicTypeRegistry
  def initialize(connection); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
  def initialize(typenames); end

  def typecast_result_value(result, _tuple, field); end
end

class PG::BasicTypeMapForResults::WarningTypeMap
end

class PG::BasicTypeMapForResults
end

module PG::BasicTypeRegistry
  def check_format_and_direction(format, direction); end
  CODERS_BY_NAME = ::T.let(nil, ::T.untyped)
  ValidDirections = ::T.let(nil, ::T.untyped)
  ValidFormats = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeRegistry::CoderMap
  def coder_by_name(name); end

  def coder_by_oid(oid); end

  def coders(); end

  def coders_by_name(); end

  def coders_by_oid(); end

  def initialize(result, coders_by_name, format, arraycoder); end

  def typenames_by_oid(); end
  DONT_QUOTE_TYPES = ::T.let(nil, ::T.untyped)
end

class PG::BasicTypeRegistry::CoderMap
end

module PG::BasicTypeRegistry
  extend ::T::Sig
  def self.alias_type(format, new, old); end

  def self.register_type(format, name, encoder_class, decoder_class); end
end

module PG::BinaryDecoder
end

class PG::BinaryDecoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Boolean
end

class PG::BinaryDecoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Bytea
end

class PG::BinaryDecoder::Float
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Float
end

class PG::BinaryDecoder::Integer
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Integer
end

class PG::BinaryDecoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::String
end

class PG::BinaryDecoder::Timestamp
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::Timestamp
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampLocal
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtc
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::TimestampUtcToLocal
end

class PG::BinaryDecoder::ToBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryDecoder::ToBase64
end

module PG::BinaryDecoder
  extend ::T::Sig
end

module PG::BinaryEncoder
end

class PG::BinaryEncoder::Boolean
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Boolean
end

class PG::BinaryEncoder::Bytea
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Bytea
end

class PG::BinaryEncoder::FromBase64
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::FromBase64
end

class PG::BinaryEncoder::Int2
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int2
end

class PG::BinaryEncoder::Int4
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int4
end

class PG::BinaryEncoder::Int8
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::Int8
end

class PG::BinaryEncoder::String
  include ::PG::Coder::BinaryFormatting
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::BinaryEncoder::String
end

module PG::BinaryEncoder
  extend ::T::Sig
end

class PG::BranchTransactionAlreadyActive
end

class PG::BranchTransactionAlreadyActive
end

class PG::CannotCoerce
end

class PG::CannotCoerce
end

class PG::CannotConnectNow
end

class PG::CannotConnectNow
end

class PG::CantChangeRuntimeParam
end

class PG::CantChangeRuntimeParam
end

class PG::CardinalityViolation
end

class PG::CardinalityViolation
end

class PG::CaseNotFound
end

class PG::CaseNotFound
end

class PG::CharacterNotInRepertoire
end

class PG::CharacterNotInRepertoire
end

class PG::CheckViolation
end

class PG::CheckViolation
end

class PG::Coder
  def ==(v); end

  def decode(*_); end

  def encode(*_); end

  def flags(); end

  def flags=(flags); end

  def format(); end

  def format=(format); end

  def initialize(params=T.unsafe(nil)); end

  def marshal_dump(); end

  def marshal_load(str); end

  def name(); end

  def name=(name); end

  def oid(); end

  def oid=(oid); end

  def to_h(); end
  FORMAT_ERROR_MASK = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_PARTIAL = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_RAISE = ::T.let(nil, ::T.untyped)
  FORMAT_ERROR_TO_STRING = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_APP_UTC = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_LOCAL = ::T.let(nil, ::T.untyped)
  TIMESTAMP_DB_UTC = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
  def initialize(params=T.unsafe(nil)); end
  Params = ::T.let(nil, ::T.untyped)
end

module PG::Coder::BinaryFormatting
  extend ::T::Sig
end

class PG::Coder
end

class PG::CollationMismatch
end

class PG::CollationMismatch
end

class PG::CompositeCoder
  def delimiter(); end

  def delimiter=(delimiter); end

  def elements_type(); end

  def elements_type=(elements_type); end

  def needs_quotation=(needs_quotation); end

  def needs_quotation?(); end
end

class PG::CompositeCoder
end

class PG::CompositeDecoder
end

class PG::CompositeDecoder
end

class PG::CompositeEncoder
end

class PG::CompositeEncoder
end

class PG::ConfigFileError
end

class PG::ConfigFileError
end

class PG::ConfigurationLimitExceeded
end

class PG::ConfigurationLimitExceeded
end

class PG::Connection
  include ::PG::Constants
  def async_describe_portal(_); end

  def async_describe_prepared(_); end

  def async_exec(*_); end

  def async_exec_params(*_); end

  def async_exec_prepared(*_); end

  def async_prepare(*_); end

  def async_query(*_); end

  def backend_pid(); end

  def block(*_); end

  def cancel(); end

  def client_encoding=(client_encoding); end

  def close(); end

  def conndefaults(); end

  def conndefaults_hash(); end

  def connect_poll(); end

  def connection_needs_password(); end

  def connection_used_password(); end

  def conninfo(); end

  def conninfo_hash(); end

  def consume_input(); end

  def copy_data(sql, coder=T.unsafe(nil)); end

  def db(); end

  def decoder_for_get_copy_data(); end

  def decoder_for_get_copy_data=(decoder_for_get_copy_data); end

  def describe_portal(_); end

  def describe_prepared(_); end

  def discard_results(); end

  def encoder_for_put_copy_data(); end

  def encoder_for_put_copy_data=(encoder_for_put_copy_data); end

  def error_message(); end

  def escape(_); end

  def escape_bytea(_); end

  def escape_identifier(_); end

  def escape_literal(_); end

  def escape_string(_); end

  def exec_params(*_); end

  def exec_prepared(*_); end

  def external_encoding(); end

  def finish(); end

  def finished?(); end

  def flush(); end

  def get_client_encoding(); end

  def get_copy_data(*_); end

  def get_last_result(); end

  def get_result(); end

  def guess_result_memsize=(guess_result_memsize); end

  def host(); end

  def initialize(*_); end

  def internal_encoding(); end

  def internal_encoding=(internal_encoding); end

  def is_busy(); end

  def isnonblocking(); end

  def lo_close(_); end

  def lo_creat(*_); end

  def lo_create(_); end

  def lo_export(_, _1); end

  def lo_import(_); end

  def lo_lseek(_, _1, _2); end

  def lo_open(*_); end

  def lo_read(_, _1); end

  def lo_seek(_, _1, _2); end

  def lo_tell(_); end

  def lo_truncate(_, _1); end

  def lo_unlink(_); end

  def lo_write(_, _1); end

  def loclose(_); end

  def locreat(*_); end

  def locreate(_); end

  def loexport(_, _1); end

  def loimport(_); end

  def lolseek(_, _1, _2); end

  def loopen(*_); end

  def loread(_, _1); end

  def loseek(_, _1, _2); end

  def lotell(_); end

  def lotruncate(_, _1); end

  def lounlink(_); end

  def lowrite(_, _1); end

  def make_empty_pgresult(_); end

  def nonblocking?(); end

  def notifies(); end

  def notifies_wait(*_); end

  def options(); end

  def parameter_status(_); end

  def pass(); end

  def port(); end

  def prepare(*_); end

  def protocol_version(); end

  def put_copy_data(*_); end

  def put_copy_end(*_); end

  def query(*_); end

  def quote_ident(_); end

  def reset(); end

  def reset_poll(); end

  def reset_start(); end

  def send_describe_portal(_); end

  def send_describe_prepared(_); end

  def send_prepare(*_); end

  def send_query(*_); end

  def send_query_params(*_); end

  def send_query_prepared(*_); end

  def server_version(); end

  def set_client_encoding(_); end

  def set_default_encoding(); end

  def set_error_verbosity(_); end

  def set_notice_processor(); end

  def set_notice_receiver(); end

  def set_single_row_mode(); end

  def setnonblocking(_); end

  def socket(); end

  def socket_io(); end

  def ssl_attribute(_); end

  def ssl_attribute_names(); end

  def ssl_attributes(); end

  def ssl_in_use?(); end

  def status(); end

  def sync_describe_portal(_); end

  def sync_describe_prepared(_); end

  def sync_exec(*_); end

  def sync_exec_params(*_); end

  def sync_exec_prepared(*_); end

  def sync_prepare(*_); end

  def trace(_); end

  def transaction(); end

  def transaction_status(); end

  def tty(); end

  def type_map_for_queries(); end

  def type_map_for_queries=(type_map_for_queries); end

  def type_map_for_results(); end

  def type_map_for_results=(type_map_for_results); end

  def unescape_bytea(_); end

  def untrace(); end

  def user(); end

  def wait_for_notify(*_); end
  CONNECT_ARGUMENT_ORDER = ::T.let(nil, ::T.untyped)
  REDIRECT_METHODS = ::T.let(nil, ::T.untyped)
end

class PG::Connection
  def self.async_api=(enable); end

  def self.conndefaults(); end

  def self.conndefaults_hash(); end

  def self.connect(*_); end

  def self.connect_start(*_); end

  def self.encrypt_password(_, _1); end

  def self.escape(_); end

  def self.escape_bytea(_); end

  def self.escape_string(_); end

  def self.isthreadsafe(); end

  def self.open(*_); end

  def self.parse_connect_args(*args); end

  def self.ping(*_); end

  def self.quote_connstr(value); end

  def self.quote_ident(_); end

  def self.setdb(*_); end

  def self.setdblogin(*_); end

  def self.unescape_bytea(_); end
end

class PG::ConnectionBad
end

class PG::ConnectionBad
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionDoesNotExist
end

class PG::ConnectionException
end

class PG::ConnectionException
end

class PG::ConnectionFailure
end

class PG::ConnectionFailure
end

module PG::Constants
  CONNECTION_AUTH_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_AWAITING_RESPONSE = ::T.let(nil, ::T.untyped)
  CONNECTION_BAD = ::T.let(nil, ::T.untyped)
  CONNECTION_MADE = ::T.let(nil, ::T.untyped)
  CONNECTION_NEEDED = ::T.let(nil, ::T.untyped)
  CONNECTION_OK = ::T.let(nil, ::T.untyped)
  CONNECTION_SETENV = ::T.let(nil, ::T.untyped)
  CONNECTION_SSL_STARTUP = ::T.let(nil, ::T.untyped)
  CONNECTION_STARTED = ::T.let(nil, ::T.untyped)
  INVALID_OID = ::T.let(nil, ::T.untyped)
  INV_READ = ::T.let(nil, ::T.untyped)
  INV_WRITE = ::T.let(nil, ::T.untyped)
  InvalidOid = ::T.let(nil, ::T.untyped)
  PGRES_BAD_RESPONSE = ::T.let(nil, ::T.untyped)
  PGRES_COMMAND_OK = ::T.let(nil, ::T.untyped)
  PGRES_COPY_BOTH = ::T.let(nil, ::T.untyped)
  PGRES_COPY_IN = ::T.let(nil, ::T.untyped)
  PGRES_COPY_OUT = ::T.let(nil, ::T.untyped)
  PGRES_EMPTY_QUERY = ::T.let(nil, ::T.untyped)
  PGRES_FATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_NONFATAL_ERROR = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_FAILED = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_OK = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_READING = ::T.let(nil, ::T.untyped)
  PGRES_POLLING_WRITING = ::T.let(nil, ::T.untyped)
  PGRES_SINGLE_TUPLE = ::T.let(nil, ::T.untyped)
  PGRES_TUPLES_OK = ::T.let(nil, ::T.untyped)
  PG_DIAG_COLUMN_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONSTRAINT_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_CONTEXT = ::T.let(nil, ::T.untyped)
  PG_DIAG_DATATYPE_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_INTERNAL_QUERY = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_DETAIL = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_HINT = ::T.let(nil, ::T.untyped)
  PG_DIAG_MESSAGE_PRIMARY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SCHEMA_NAME = ::T.let(nil, ::T.untyped)
  PG_DIAG_SEVERITY = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FILE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_FUNCTION = ::T.let(nil, ::T.untyped)
  PG_DIAG_SOURCE_LINE = ::T.let(nil, ::T.untyped)
  PG_DIAG_SQLSTATE = ::T.let(nil, ::T.untyped)
  PG_DIAG_STATEMENT_POSITION = ::T.let(nil, ::T.untyped)
  PG_DIAG_TABLE_NAME = ::T.let(nil, ::T.untyped)
  PQERRORS_DEFAULT = ::T.let(nil, ::T.untyped)
  PQERRORS_TERSE = ::T.let(nil, ::T.untyped)
  PQERRORS_VERBOSE = ::T.let(nil, ::T.untyped)
  PQPING_NO_ATTEMPT = ::T.let(nil, ::T.untyped)
  PQPING_NO_RESPONSE = ::T.let(nil, ::T.untyped)
  PQPING_OK = ::T.let(nil, ::T.untyped)
  PQPING_REJECT = ::T.let(nil, ::T.untyped)
  PQTRANS_ACTIVE = ::T.let(nil, ::T.untyped)
  PQTRANS_IDLE = ::T.let(nil, ::T.untyped)
  PQTRANS_INERROR = ::T.let(nil, ::T.untyped)
  PQTRANS_INTRANS = ::T.let(nil, ::T.untyped)
  PQTRANS_UNKNOWN = ::T.let(nil, ::T.untyped)
  SEEK_CUR = ::T.let(nil, ::T.untyped)
  SEEK_END = ::T.let(nil, ::T.untyped)
  SEEK_SET = ::T.let(nil, ::T.untyped)
end

module PG::Constants
  extend ::T::Sig
end

class PG::CopyCoder
  def delimiter(); end

  def delimiter=(delimiter); end

  def null_string(); end

  def null_string=(null_string); end

  def type_map(); end

  def type_map=(type_map); end
end

class PG::CopyCoder
end

class PG::CopyDecoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyDecoder
end

class PG::CopyEncoder
  include ::PG::Coder::BinaryFormatting
end

class PG::CopyEncoder
end

class PG::CrashShutdown
end

class PG::CrashShutdown
end

class PG::DataCorrupted
end

class PG::DataCorrupted
end

class PG::DataException
end

class PG::DataException
end

class PG::DatabaseDropped
end

class PG::DatabaseDropped
end

class PG::DatatypeMismatch
end

class PG::DatatypeMismatch
end

class PG::DatetimeFieldOverflow
end

class PG::DatetimeFieldOverflow
end

class PG::DependentObjectsStillExist
end

class PG::DependentObjectsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DependentPrivilegeDescriptorsStillExist
end

class PG::DiagnosticsException
end

class PG::DiagnosticsException
end

class PG::DiskFull
end

class PG::DiskFull
end

class PG::DivisionByZero
end

class PG::DivisionByZero
end

class PG::DuplicateAlias
end

class PG::DuplicateAlias
end

class PG::DuplicateColumn
end

class PG::DuplicateColumn
end

class PG::DuplicateCursor
end

class PG::DuplicateCursor
end

class PG::DuplicateDatabase
end

class PG::DuplicateDatabase
end

class PG::DuplicateFile
end

class PG::DuplicateFile
end

class PG::DuplicateFunction
end

class PG::DuplicateFunction
end

class PG::DuplicateObject
end

class PG::DuplicateObject
end

class PG::DuplicatePstatement
end

class PG::DuplicatePstatement
end

class PG::DuplicateSchema
end

class PG::DuplicateSchema
end

class PG::DuplicateTable
end

class PG::DuplicateTable
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREContainingSqlNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREModifyingSqlDataNotPermitted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREProhibitedSqlStatementAttempted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::EREReadingSqlDataNotPermitted
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEEventTriggerProtocolViolated
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIEInvalidSqlstateReturned
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIENullValueNotAllowed
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIESrfProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::ERIETriggerProtocolViolated
end

class PG::Error
  def connection(); end

  def error(); end

  def result(); end
end

class PG::Error
end

class PG::ErrorInAssignment
end

class PG::ErrorInAssignment
end

class PG::EscapeCharacterConflict
end

class PG::EscapeCharacterConflict
end

class PG::ExclusionViolation
end

class PG::ExclusionViolation
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineException
end

class PG::ExternalRoutineInvocationException
end

class PG::ExternalRoutineInvocationException
end

class PG::FdwColumnNameNotFound
end

class PG::FdwColumnNameNotFound
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwDynamicParameterValueNeeded
end

class PG::FdwError
end

class PG::FdwError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwFunctionSequenceError
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInconsistentDescriptorInformation
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidAttributeValue
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnName
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidColumnNumber
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataType
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDataTypeDescriptors
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidDescriptorFieldIdentifier
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidHandle
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionIndex
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidOptionName
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringFormat
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidStringLengthOrBufferLength
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwInvalidUseOfNullPointer
end

class PG::FdwNoSchemas
end

class PG::FdwNoSchemas
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOptionNameNotFound
end

class PG::FdwOutOfMemory
end

class PG::FdwOutOfMemory
end

class PG::FdwReplyHandle
end

class PG::FdwReplyHandle
end

class PG::FdwSchemaNotFound
end

class PG::FdwSchemaNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTableNotFound
end

class PG::FdwTooManyHandles
end

class PG::FdwTooManyHandles
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateExecution
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToCreateReply
end

class PG::FdwUnableToEstablishConnection
end

class PG::FdwUnableToEstablishConnection
end

class PG::FeatureNotSupported
end

class PG::FeatureNotSupported
end

class PG::FloatingPointException
end

class PG::FloatingPointException
end

class PG::ForeignKeyViolation
end

class PG::ForeignKeyViolation
end

class PG::GeneratedAlways
end

class PG::GeneratedAlways
end

class PG::GroupingError
end

class PG::GroupingError
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::HeldCursorRequiresSameIsolationLevel
end

class PG::IdleInTransactionSessionTimeout
end

class PG::IdleInTransactionSessionTimeout
end

class PG::InFailedSqlTransaction
end

class PG::InFailedSqlTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateAccessModeForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::InappropriateIsolationLevelForBranchTransaction
end

class PG::IndeterminateCollation
end

class PG::IndeterminateCollation
end

class PG::IndeterminateDatatype
end

class PG::IndeterminateDatatype
end

class PG::IndexCorrupted
end

class PG::IndexCorrupted
end

class PG::IndicatorOverflow
end

class PG::IndicatorOverflow
end

class PG::InsufficientPrivilege
end

class PG::InsufficientPrivilege
end

class PG::InsufficientResources
end

class PG::InsufficientResources
end

class PG::IntegrityConstraintViolation
end

class PG::IntegrityConstraintViolation
end

class PG::InternalError
end

class PG::InternalError
end

class PG::IntervalFieldOverflow
end

class PG::IntervalFieldOverflow
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForLog
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNthValue
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForNtile
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForPowerFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidArgumentForWidthBucketFunction
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidAuthorizationSpecification
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidBinaryRepresentation
end

class PG::InvalidCatalogName
end

class PG::InvalidCatalogName
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidChangeOfResultFields
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidCharacterValueForCast
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnDefinition
end

class PG::InvalidColumnReference
end

class PG::InvalidColumnReference
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorDefinition
end

class PG::InvalidCursorName
end

class PG::InvalidCursorName
end

class PG::InvalidCursorState
end

class PG::InvalidCursorState
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatabaseDefinition
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidDatetimeFormat
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeCharacter
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeOctet
end

class PG::InvalidEscapeSequence
end

class PG::InvalidEscapeSequence
end

class PG::InvalidForeignKey
end

class PG::InvalidForeignKey
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidFunctionDefinition
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantOperation
end

class PG::InvalidGrantor
end

class PG::InvalidGrantor
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidIndicatorParameterValue
end

class PG::InvalidName
end

class PG::InvalidName
end

class PG::InvalidObjectDefinition
end

class PG::InvalidObjectDefinition
end

class PG::InvalidParameterValue
end

class PG::InvalidParameterValue
end

class PG::InvalidPassword
end

class PG::InvalidPassword
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidPstatementDefinition
end

class PG::InvalidRecursion
end

class PG::InvalidRecursion
end

class PG::InvalidRegularExpression
end

class PG::InvalidRegularExpression
end

class PG::InvalidResultStatus
end

class PG::InvalidResultStatus
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRoleSpecification
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInLimitClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidRowCountInResultOffsetClause
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaDefinition
end

class PG::InvalidSchemaName
end

class PG::InvalidSchemaName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidSqlStatementName
end

class PG::InvalidTableDefinition
end

class PG::InvalidTableDefinition
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleArgument
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTablesampleRepeat
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTextRepresentation
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTimeZoneDisplacementValue
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionInitiation
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionState
end

class PG::InvalidTransactionTermination
end

class PG::InvalidTransactionTermination
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidUseOfEscapeCharacter
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlComment
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlContent
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlDocument
end

class PG::InvalidXmlProcessingInstruction
end

class PG::InvalidXmlProcessingInstruction
end

class PG::IoError
end

class PG::IoError
end

class PG::LEInvalidSpecification
end

class PG::LEInvalidSpecification
end

class PG::LocatorException
end

class PG::LocatorException
end

class PG::LockFileExists
end

class PG::LockFileExists
end

class PG::LockNotAvailable
end

class PG::LockNotAvailable
end

class PG::MostSpecificTypeMismatch
end

class PG::MostSpecificTypeMismatch
end

class PG::NameTooLong
end

class PG::NameTooLong
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoActiveSqlTransactionForBranchTransaction
end

class PG::NoDataFound
end

class PG::NoDataFound
end

class PG::NoResultError
end

class PG::NoResultError
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NonstandardUseOfEscapeCharacter
end

class PG::NotAllCopyDataRetrieved
end

class PG::NotAllCopyDataRetrieved
end

class PG::NotAnXmlDocument
end

class PG::NotAnXmlDocument
end

class PG::NotNullViolation
end

class PG::NotNullViolation
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNoIndicatorParameter
end

class PG::NullValueNotAllowed
end

class PG::NullValueNotAllowed
end

class PG::NumericValueOutOfRange
end

class PG::NumericValueOutOfRange
end

class PG::ObjectInUse
end

class PG::ObjectInUse
end

class PG::ObjectNotInPrerequisiteState
end

class PG::ObjectNotInPrerequisiteState
end

class PG::OperatorIntervention
end

class PG::OperatorIntervention
end

class PG::OutOfMemory
end

class PG::OutOfMemory
end

class PG::PlpgsqlError
end

class PG::PlpgsqlError
end

class PG::ProgramLimitExceeded
end

class PG::ProgramLimitExceeded
end

class PG::ProtocolViolation
end

class PG::ProtocolViolation
end

class PG::QueryCanceled
end

class PG::QueryCanceled
end

class PG::RaiseException
end

class PG::RaiseException
end

class PG::ReadOnlySqlTransaction
end

class PG::ReadOnlySqlTransaction
end

class PG::ReservedName
end

class PG::ReservedName
end

class PG::RestrictViolation
end

class PG::RestrictViolation
end

class PG::Result
  include ::Enumerable
  include ::PG::Constants
  def [](_); end

  def autoclear?(); end

  def check(); end

  def check_result(); end

  def clear(); end

  def cleared?(); end

  def cmd_status(); end

  def cmd_tuples(); end

  def cmdtuples(); end

  def column_values(_); end

  def each(); end

  def each_row(); end

  def error_field(_); end

  def error_message(); end

  def fformat(_); end

  def field_values(_); end

  def fields(); end

  def fmod(_); end

  def fname(_); end

  def fnumber(_); end

  def fsize(_); end

  def ftable(_); end

  def ftablecol(_); end

  def ftype(_); end

  def getisnull(_, _1); end

  def getlength(_, _1); end

  def getvalue(_, _1); end

  def map_types!(type_map); end

  def nfields(); end

  def nparams(); end

  def ntuples(); end

  def num_fields(); end

  def num_tuples(); end

  def oid_value(); end

  def paramtype(_); end

  def res_status(_); end

  def result_error_field(_); end

  def result_error_message(); end

  def result_status(); end

  def stream_each(); end

  def stream_each_row(); end

  def stream_each_tuple(); end

  def tuple(_); end

  def tuple_values(_); end

  def type_map(); end

  def type_map=(type_map); end

  def values(); end
end

class PG::Result
end

class PG::SEInvalidSpecification
end

class PG::SEInvalidSpecification
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREFunctionExecutedNoReturnStatement
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREModifyingSqlDataNotPermitted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREProhibitedSqlStatementAttempted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SREReadingSqlDataNotPermitted
end

class PG::SavepointException
end

class PG::SavepointException
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SchemaAndDataStatementMixingNotSupported
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::SequenceGeneratorLimitExceeded
end

class PG::ServerError
end

class PG::ServerError
end

class PG::SimpleCoder
end

class PG::SimpleCoder
end

class PG::SimpleDecoder
end

class PG::SimpleDecoder
end

class PG::SimpleEncoder
end

class PG::SimpleEncoder
end

class PG::SnapshotTooOld
end

class PG::SnapshotTooOld
end

class PG::SqlRoutineException
end

class PG::SqlRoutineException
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlStatementNotYetComplete
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlclientUnableToEstablishSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::SqlserverRejectedEstablishmentOfSqlconnection
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StackedDiagnosticsAccessedWithoutActiveHandler
end

class PG::StatementTooComplex
end

class PG::StatementTooComplex
end

class PG::StringDataLengthMismatch
end

class PG::StringDataLengthMismatch
end

class PG::StringDataRightTruncation
end

class PG::StringDataRightTruncation
end

class PG::SubstringError
end

class PG::SubstringError
end

class PG::SyntaxError
end

class PG::SyntaxError
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SyntaxErrorOrAccessRuleViolation
end

class PG::SystemError
end

class PG::SystemError
end

class PG::TRDeadlockDetected
end

class PG::TRDeadlockDetected
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRIntegrityConstraintViolation
end

class PG::TRSerializationFailure
end

class PG::TRSerializationFailure
end

class PG::TRStatementCompletionUnknown
end

class PG::TRStatementCompletionUnknown
end

module PG::TextDecoder
end

class PG::TextDecoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Array
end

class PG::TextDecoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Boolean
end

class PG::TextDecoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Bytea
end

class PG::TextDecoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::CopyRow
end

class PG::TextDecoder::Date
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
  ISO_DATE = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Date
end

class PG::TextDecoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Float
end

class PG::TextDecoder::FromBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::FromBase64
end

class PG::TextDecoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Identifier
end

class PG::TextDecoder::Inet
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Inet
end

class PG::TextDecoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Integer
end

class PG::TextDecoder::JSON
  def decode(string, tuple=T.unsafe(nil), field=T.unsafe(nil)); end
end

class PG::TextDecoder::JSON
end

class PG::TextDecoder::Numeric
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Numeric
end

class PG::TextDecoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::String
end

class PG::TextDecoder::Timestamp
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextDecoder::Timestamp
end

class PG::TextDecoder::TimestampLocal
end

class PG::TextDecoder::TimestampLocal
end

class PG::TextDecoder::TimestampUtc
end

class PG::TextDecoder::TimestampUtc
end

class PG::TextDecoder::TimestampUtcToLocal
end

class PG::TextDecoder::TimestampUtcToLocal
end

PG::TextDecoder::TimestampWithTimeZone = PG::TextDecoder::Timestamp

PG::TextDecoder::TimestampWithoutTimeZone = PG::TextDecoder::TimestampLocal

module PG::TextDecoder
  extend ::T::Sig
end

module PG::TextEncoder
end

class PG::TextEncoder::Array
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Array
end

class PG::TextEncoder::Boolean
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Boolean
end

class PG::TextEncoder::Bytea
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Bytea
end

class PG::TextEncoder::CopyRow
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::CopyRow
end

class PG::TextEncoder::Date
  def encode(value); end
  STRFTIME_ISO_DATE = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Date
end

class PG::TextEncoder::Float
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Float
end

class PG::TextEncoder::Identifier
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Identifier
end

class PG::TextEncoder::Inet
  def encode(value); end
end

class PG::TextEncoder::Inet
end

class PG::TextEncoder::Integer
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::Integer
end

class PG::TextEncoder::JSON
  def encode(value); end
end

class PG::TextEncoder::JSON
end

class PG::TextEncoder::Numeric
  def encode(value); end
end

class PG::TextEncoder::Numeric
end

class PG::TextEncoder::QuotedLiteral
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::QuotedLiteral
end

class PG::TextEncoder::String
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::String
end

class PG::TextEncoder::TimestampUtc
  def encode(value); end
  STRFTIME_ISO_DATETIME_WITHOUT_TIMEZONE_UTC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::TimestampUtc
end

class PG::TextEncoder::TimestampWithTimeZone
  def encode(value); end
  STRFTIME_ISO_DATETIME_WITH_TIMEZONE = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::TimestampWithTimeZone
end

class PG::TextEncoder::TimestampWithoutTimeZone
  def encode(value); end
  STRFTIME_ISO_DATETIME_WITHOUT_TIMEZONE = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::TimestampWithoutTimeZone
end

class PG::TextEncoder::ToBase64
  CFUNC = ::T.let(nil, ::T.untyped)
end

class PG::TextEncoder::ToBase64
end

module PG::TextEncoder
  extend ::T::Sig
end

class PG::TooManyArguments
end

class PG::TooManyArguments
end

class PG::TooManyColumns
end

class PG::TooManyColumns
end

class PG::TooManyConnections
end

class PG::TooManyConnections
end

class PG::TooManyRows
end

class PG::TooManyRows
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionResolutionUnknown
end

class PG::TransactionRollback
end

class PG::TransactionRollback
end

class PG::TriggeredActionException
end

class PG::TriggeredActionException
end

class PG::TriggeredDataChangeViolation
end

class PG::TriggeredDataChangeViolation
end

class PG::TrimError
end

class PG::TrimError
end

class PG::Tuple
  include ::Enumerable
  def [](_); end

  def each(); end

  def each_key(&block); end

  def each_value(); end

  def fetch(*_); end

  def has_key?(key); end

  def index(_); end

  def key?(key); end

  def keys(); end

  def length(); end

  def size(); end

  def values(); end
end

class PG::Tuple
end

class PG::TypeMap
end

module PG::TypeMap::DefaultTypeMappable
  def default_type_map(); end

  def default_type_map=(default_type_map); end

  def with_default_type_map(_); end
end

module PG::TypeMap::DefaultTypeMappable
  extend ::T::Sig
end

class PG::TypeMap
end

class PG::TypeMapAllStrings
end

class PG::TypeMapAllStrings
end

class PG::TypeMapByClass
  include ::PG::TypeMap::DefaultTypeMappable
  def [](_); end

  def []=(_, _1); end

  def coders(); end
end

class PG::TypeMapByClass
end

class PG::TypeMapByColumn
  include ::PG::TypeMap::DefaultTypeMappable
  def coders(); end

  def initialize(_); end

  def oids(); end
end

class PG::TypeMapByColumn
end

class PG::TypeMapByMriType
  include ::PG::TypeMap::DefaultTypeMappable
  def [](_); end

  def []=(_, _1); end

  def coders(); end
end

class PG::TypeMapByMriType
end

class PG::TypeMapByOid
  include ::PG::TypeMap::DefaultTypeMappable
  def add_coder(_); end

  def build_column_map(_); end

  def coders(); end

  def max_rows_for_online_lookup(); end

  def max_rows_for_online_lookup=(max_rows_for_online_lookup); end

  def rm_coder(_, _1); end
end

class PG::TypeMapByOid
end

class PG::TypeMapInRuby
  include ::PG::TypeMap::DefaultTypeMappable
  def typecast_copy_get(_, _1, _2, _3); end

  def typecast_query_param(_, _1); end

  def typecast_result_value(_, _1, _2); end
end

class PG::TypeMapInRuby
end

class PG::UnableToSend
end

class PG::UnableToSend
end

class PG::UndefinedColumn
end

class PG::UndefinedColumn
end

class PG::UndefinedFile
end

class PG::UndefinedFile
end

class PG::UndefinedFunction
end

class PG::UndefinedFunction
end

class PG::UndefinedObject
end

class PG::UndefinedObject
end

class PG::UndefinedParameter
end

class PG::UndefinedParameter
end

class PG::UndefinedTable
end

class PG::UndefinedTable
end

class PG::UniqueViolation
end

class PG::UniqueViolation
end

class PG::UnterminatedCString
end

class PG::UnterminatedCString
end

class PG::UntranslatableCharacter
end

class PG::UntranslatableCharacter
end

class PG::WindowingError
end

class PG::WindowingError
end

class PG::WithCheckOptionViolation
end

class PG::WithCheckOptionViolation
end

class PG::WrongObjectType
end

class PG::WrongObjectType
end

class PG::ZeroLengthCharacterString
end

class PG::ZeroLengthCharacterString
end

module PG
  extend ::T::Sig
  def self.connect(*args); end

  def self.init_openssl(_, _1); end

  def self.init_ssl(_); end

  def self.is_threadsafe?(); end

  def self.isthreadsafe(); end

  def self.library_version(); end

  def self.threadsafe?(); end

  def self.version_string(include_buildnum=T.unsafe(nil)); end
end

module PP::ObjectMixin
  extend ::T::Sig
end

module PP::PPMethods
  extend ::T::Sig
end

class PP::SingleLine
  extend ::T::Sig
end

class PP
  extend ::T::Sig
end

class PStore
  def [](name); end

  def []=(name, value); end

  def abort(); end

  def commit(); end

  def delete(name); end

  def fetch(name, default=T.unsafe(nil)); end

  def initialize(file, thread_safe=T.unsafe(nil)); end

  def path(); end

  def root?(name); end

  def roots(); end

  def transaction(read_only=T.unsafe(nil)); end

  def ultra_safe(); end

  def ultra_safe=(ultra_safe); end
  EMPTY_MARSHAL_CHECKSUM = ::T.let(nil, ::T.untyped)
  EMPTY_MARSHAL_DATA = ::T.let(nil, ::T.untyped)
  EMPTY_STRING = ::T.let(nil, ::T.untyped)
  RDWR_ACCESS = ::T.let(nil, ::T.untyped)
  RD_ACCESS = ::T.let(nil, ::T.untyped)
  WR_ACCESS = ::T.let(nil, ::T.untyped)
end

PStore::CHECKSUM_ALGO = Digest::SHA512

class PStore::Error
end

class PStore::Error
end

class PStore
end

module PaperTrail
  E_RAILS_NOT_LOADED = ::T.let(nil, ::T.untyped)
  E_TIMESTAMP_FIELD_CONFIG = ::T.let(nil, ::T.untyped)
end

module PaperTrail::AttributeSerializers
end

module PaperTrail::AttributeSerializers::AttributeSerializerFactory
  AR_PG_ARRAY_CLASS = ::T.let(nil, ::T.untyped)
end

module PaperTrail::AttributeSerializers::AttributeSerializerFactory
  extend ::T::Sig
  def self.for(klass, attr); end
end

class PaperTrail::AttributeSerializers::CastAttributeSerializer
  def deserialize(attr, val); end

  def initialize(klass); end

  def serialize(attr, val); end
end

class PaperTrail::AttributeSerializers::CastAttributeSerializer
end

class PaperTrail::AttributeSerializers::ObjectAttribute
  def deserialize(attributes); end

  def initialize(model_class); end

  def serialize(attributes); end
end

class PaperTrail::AttributeSerializers::ObjectAttribute
end

class PaperTrail::AttributeSerializers::ObjectChangesAttribute
  def deserialize(changes); end

  def initialize(item_class); end

  def serialize(changes); end
end

class PaperTrail::AttributeSerializers::ObjectChangesAttribute
end

module PaperTrail::AttributeSerializers
  extend ::T::Sig
end

module PaperTrail::Cleaner
  def clean_versions!(options=T.unsafe(nil)); end
end

module PaperTrail::Cleaner
  extend ::T::Sig
end

class PaperTrail::Config
  include ::Singleton
  def association_reify_error_behaviour(); end

  def association_reify_error_behaviour=(association_reify_error_behaviour); end

  def enabled(); end

  def enabled=(enable); end

  def object_changes_adapter(); end

  def object_changes_adapter=(object_changes_adapter); end

  def serializer(); end

  def serializer=(serializer); end

  def track_associations=(value); end

  def track_associations?(); end

  def version_limit(); end

  def version_limit=(version_limit); end
  E_PT_AT_REMOVED = ::T.let(nil, ::T.untyped)
end

class PaperTrail::Config
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module PaperTrail::Events
end

class PaperTrail::Events::Base
  def changed_notably?(); end

  def initialize(record, in_after_callback); end
  RAILS_GTE_5_1 = ::T.let(nil, ::T.untyped)
end

class PaperTrail::Events::Base
end

class PaperTrail::Events::Create
  def data(); end
end

class PaperTrail::Events::Create
end

class PaperTrail::Events::Destroy
  def data(); end
end

class PaperTrail::Events::Destroy
end

class PaperTrail::Events::Update
  def data(); end

  def initialize(record, in_after_callback, is_touch, force_changes); end
end

class PaperTrail::Events::Update
end

module PaperTrail::Events
  extend ::T::Sig
end

class PaperTrail::FulfillmentVersion
  include ::PaperTrail::FulfillmentVersion::GeneratedAssociationMethods
end

module PaperTrail::FulfillmentVersion::GeneratedAssociationMethods
end

module PaperTrail::FulfillmentVersion::GeneratedAssociationMethods
  extend ::T::Sig
end

class PaperTrail::LineItemVersion
  include ::PaperTrail::LineItemVersion::GeneratedAssociationMethods
end

module PaperTrail::LineItemVersion::GeneratedAssociationMethods
end

module PaperTrail::LineItemVersion::GeneratedAssociationMethods
  extend ::T::Sig
end

module PaperTrail::Model
end

module PaperTrail::Model::InstanceMethods
  def paper_trail(); end
end

module PaperTrail::Model::InstanceMethods
  extend ::T::Sig
end

module PaperTrail::Model
  extend ::T::Sig
  def self.included(base); end
end

class PaperTrail::ModelConfig
  def initialize(model_class); end

  def on_create(); end

  def on_destroy(recording_order=T.unsafe(nil)); end

  def on_touch(); end

  def on_update(); end

  def setup(options=T.unsafe(nil)); end

  def version_class(); end
  E_CANNOT_RECORD_AFTER_DESTROY = ::T.let(nil, ::T.untyped)
  E_HPT_ABSTRACT_CLASS = ::T.let(nil, ::T.untyped)
end

class PaperTrail::ModelConfig
end

class PaperTrail::OfferVersion
  include ::PaperTrail::OfferVersion::GeneratedAssociationMethods
end

module PaperTrail::OfferVersion::GeneratedAssociationMethods
end

module PaperTrail::OfferVersion::GeneratedAssociationMethods
  extend ::T::Sig
end

class PaperTrail::OrderVersion
  include ::PaperTrail::OrderVersion::GeneratedAssociationMethods
end

module PaperTrail::OrderVersion::GeneratedAssociationMethods
end

module PaperTrail::OrderVersion::GeneratedAssociationMethods
  extend ::T::Sig
end

module PaperTrail::Queries
end

module PaperTrail::Queries::Versions
end

class PaperTrail::Queries::Versions::WhereObject
  def execute(); end

  def initialize(version_model_class, attributes); end
end

class PaperTrail::Queries::Versions::WhereObject
end

class PaperTrail::Queries::Versions::WhereObjectChanges
  def execute(); end

  def initialize(version_model_class, attributes); end
end

class PaperTrail::Queries::Versions::WhereObjectChanges
end

module PaperTrail::Queries::Versions
  extend ::T::Sig
end

module PaperTrail::Queries
  extend ::T::Sig
end

module PaperTrail::Rails
end

module PaperTrail::Rails::Controller
  def info_for_paper_trail(); end

  def paper_trail_enabled_for_controller(); end

  def user_for_paper_trail(); end
end

module PaperTrail::Rails::Controller
  extend ::T::Sig
  def self.included(controller); end
end

class PaperTrail::Rails::Engine
end

class PaperTrail::Rails::Engine
end

module PaperTrail::Rails
  extend ::T::Sig
end

class PaperTrail::RecordHistory
  def index(version); end

  def initialize(versions, version_class); end
end

class PaperTrail::RecordHistory
end

class PaperTrail::RecordTrail
  def clear_rolled_back_versions(); end

  def clear_version_instance(); end

  def data_for_create(); end

  def data_for_destroy(); end

  def data_for_update(); end

  def data_for_update_columns(); end

  def enabled?(); end

  def initialize(record); end

  def live?(); end

  def next_version(); end

  def originator(); end

  def previous_version(); end

  def record_create(); end

  def record_destroy(recording_order); end

  def record_update(force:, in_after_callback:, is_touch:); end

  def record_update_columns(changes); end

  def reset_timestamp_attrs_for_update_if_needed(); end

  def save_version?(); end

  def save_with_version(*args); end

  def source_version(); end

  def update_column(name, value); end

  def update_columns(attributes); end

  def version_at(timestamp, reify_options=T.unsafe(nil)); end

  def versions_between(start_time, end_time); end
  RAILS_GTE_5_1 = ::T.let(nil, ::T.untyped)
end

class PaperTrail::RecordTrail
end

module PaperTrail::Reifier
end

module PaperTrail::Reifier
  extend ::T::Sig
  def self.reify(version, options); end
end

module PaperTrail::Request
end

class PaperTrail::Request::InvalidOption
end

class PaperTrail::Request::InvalidOption
end

module PaperTrail::Request
  extend ::T::Sig
  def self.controller_info(); end

  def self.controller_info=(value); end

  def self.disable_model(model_class); end

  def self.enable_model(model_class); end

  def self.enabled=(value); end

  def self.enabled?(); end

  def self.enabled_for_model(model, value); end

  def self.enabled_for_model?(model); end

  def self.merge(options); end

  def self.set(options); end

  def self.to_h(); end

  def self.whodunnit(); end

  def self.whodunnit=(value); end

  def self.with(options); end
end

module PaperTrail::Serializers
end

module PaperTrail::Serializers::JSON
  def dump(object); end

  def load(string); end

  def where_object_changes_condition(*_); end

  def where_object_condition(arel_field, field, value); end
end

module PaperTrail::Serializers::JSON
  extend ::PaperTrail::Serializers::JSON
  extend ::T::Sig
end

module PaperTrail::Serializers::YAML
  def dump(object); end

  def load(string); end

  def where_object_changes_condition(*_); end

  def where_object_condition(arel_field, field, value); end
end

module PaperTrail::Serializers::YAML
  extend ::PaperTrail::Serializers::YAML
  extend ::T::Sig
end

module PaperTrail::Serializers
  extend ::T::Sig
end

class PaperTrail::TransactionVersion
  include ::PaperTrail::TransactionVersion::GeneratedAssociationMethods
end

module PaperTrail::TransactionVersion::GeneratedAssociationMethods
end

module PaperTrail::TransactionVersion::GeneratedAssociationMethods
  extend ::T::Sig
end

module PaperTrail::TypeSerializers
end

class PaperTrail::TypeSerializers::PostgresArraySerializer
  def deserialize(array); end

  def initialize(subtype, delimiter); end

  def serialize(array); end
end

class PaperTrail::TypeSerializers::PostgresArraySerializer
end

module PaperTrail::TypeSerializers
  extend ::T::Sig
end

module PaperTrail::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module PaperTrail::VERSION
  extend ::T::Sig
end

class PaperTrail::Version
  include ::PaperTrail::Version::GeneratedAssociationMethods
  include ::Kaminari::ActiveRecordModelExtension
  include ::Kaminari::ConfigurationMethods
  include ::PaperTrail::VersionConcern
  def autosave_associated_records_for_item(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

module PaperTrail::Version::GeneratedAssociationMethods
  def item(); end

  def item=(value); end

  def reload_item(); end
end

module PaperTrail::Version::GeneratedAssociationMethods
  extend ::T::Sig
end

class PaperTrail::Version
  extend ::Kaminari::ConfigurationMethods::ClassMethods
  extend ::PaperTrail::VersionConcern::ClassMethods
  def self.page(num=T.unsafe(nil)); end
end

module PaperTrail::VersionConcern
  def changeset(); end

  def index(); end

  def next(); end

  def object_deserialized(); end

  def paper_trail_originator(); end

  def previous(); end

  def reify(options=T.unsafe(nil)); end

  def sibling_versions(reload=T.unsafe(nil)); end

  def terminator(); end

  def version_author(); end
end

module PaperTrail::VersionConcern::ClassMethods
  def between(start_time, end_time); end

  def creates(); end

  def destroys(); end

  def not_creates(); end

  def object_changes_col_is_json?(); end

  def object_col_is_json?(); end

  def preceding(obj, timestamp_arg=T.unsafe(nil)); end

  def primary_key_is_int?(); end

  def subsequent(obj, timestamp_arg=T.unsafe(nil)); end

  def timestamp_sort_order(direction=T.unsafe(nil)); end

  def updates(); end

  def where_object(args=T.unsafe(nil)); end

  def where_object_changes(args=T.unsafe(nil)); end

  def with_item_keys(item_type, item_id); end
end

module PaperTrail::VersionConcern::ClassMethods
  extend ::T::Sig
end

module PaperTrail::VersionConcern
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module PaperTrail
  extend ::PaperTrail::Cleaner
  extend ::T::Sig
  def self.config(); end

  def self.configure(); end

  def self.enabled=(value); end

  def self.enabled?(); end

  def self.gem_version(); end

  def self.request(options=T.unsafe(nil), &block); end

  def self.serializer(); end

  def self.serializer=(value); end

  def self.timestamp_field=(_field_name); end

  def self.version(); end
end

module Parallel
  Stop = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class Parallel::Break
end

class Parallel::Break
end

class Parallel::DeadWorker
end

class Parallel::DeadWorker
end

class Parallel::ExceptionWrapper
  def exception(); end

  def initialize(exception); end
end

class Parallel::ExceptionWrapper
end

class Parallel::JobFactory
  def initialize(source, mutex); end

  def next(); end

  def pack(item, index); end

  def size(); end

  def unpack(data); end
end

class Parallel::JobFactory
end

class Parallel::Kill
end

class Parallel::Kill
end

module Parallel::ProcessorCount
  def physical_processor_count(); end

  def processor_count(); end
end

module Parallel::ProcessorCount
  extend ::T::Sig
end

class Parallel::UndumpableException
  def initialize(original); end
end

class Parallel::UndumpableException
end

class Parallel::UserInterruptHandler
  INTERRUPT_SIGNAL = ::T.let(nil, ::T.untyped)
end

class Parallel::UserInterruptHandler
  def self.kill(thing); end

  def self.kill_on_ctrl_c(pids, options); end
end

class Parallel::Worker
  def close_pipes(); end

  def initialize(read, write, pid); end

  def pid(); end

  def read(); end

  def stop(); end

  def thread(); end

  def thread=(thread); end

  def work(data); end

  def write(); end
end

class Parallel::Worker
end

module Parallel
  extend ::Parallel::ProcessorCount
  extend ::T::Sig
  def self.all?(*args, &block); end

  def self.any?(*args, &block); end

  def self.each(array, options=T.unsafe(nil), &block); end

  def self.each_with_index(array, options=T.unsafe(nil), &block); end

  def self.in_processes(options=T.unsafe(nil), &block); end

  def self.in_threads(options=T.unsafe(nil)); end

  def self.map(source, options=T.unsafe(nil), &block); end

  def self.map_with_index(array, options=T.unsafe(nil), &block); end

  def self.worker_number(); end

  def self.worker_number=(worker_num); end
end

ParseError = Racc::ParseError

module Parser
  MESSAGES = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Parser::AST
end

class Parser::AST::Node
  def loc(); end

  def location(); end
end

class Parser::AST::Node
end

class Parser::AST::Processor
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_argument(node); end

  def on_array(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_blockarg_expr(node); end

  def on_break(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_const(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_for(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_if(node); end

  def on_iflipflop(node); end

  def on_index(node); end

  def on_indexasgn(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_current_line(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_procarg0(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_restarg_expr(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_super(node); end

  def on_undef(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_var(node); end

  def on_vasgn(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def process_argument_node(node); end

  def process_regular_node(node); end

  def process_var_asgn_node(node); end

  def process_variable_node(node); end
end

class Parser::AST::Processor
end

module Parser::AST
  extend ::T::Sig
end

class Parser::Base
  def builder(); end

  def context(); end

  def diagnostics(); end

  def initialize(builder=T.unsafe(nil)); end

  def parse(source_buffer); end

  def parse_with_comments(source_buffer); end

  def reset(); end

  def source_buffer(); end

  def static_env(); end

  def tokenize(source_buffer, recover=T.unsafe(nil)); end
end

class Parser::Base
  def self.default_parser(); end

  def self.parse(string, file=T.unsafe(nil), line=T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_file_with_comments(filename); end

  def self.parse_with_comments(string, file=T.unsafe(nil), line=T.unsafe(nil)); end
end

module Parser::Builders
end

class Parser::Builders::Default
  def __ENCODING__(__ENCODING__t); end

  def __FILE__(__FILE__t); end

  def __LINE__(__LINE__t); end

  def accessible(node); end

  def alias(alias_t, to, from); end

  def arg(name_t); end

  def arg_expr(expr); end

  def args(begin_t, args, end_t, check_args=T.unsafe(nil)); end

  def array(begin_t, elements, end_t); end

  def assign(lhs, eql_t, rhs); end

  def assignable(node); end

  def associate(begin_t, pairs, end_t); end

  def attr_asgn(receiver, dot_t, selector_t); end

  def back_ref(token); end

  def begin(begin_t, body, end_t); end

  def begin_body(compound_stmt, rescue_bodies=T.unsafe(nil), else_t=T.unsafe(nil), else_=T.unsafe(nil), ensure_t=T.unsafe(nil), ensure_=T.unsafe(nil)); end

  def begin_keyword(begin_t, body, end_t); end

  def binary_op(receiver, operator_t, arg); end

  def block(method_call, begin_t, args, body, end_t); end

  def block_pass(amper_t, arg); end

  def blockarg(amper_t, name_t); end

  def blockarg_expr(amper_t, expr); end

  def call_lambda(lambda_t); end

  def call_method(receiver, dot_t, selector_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def call_type_for_dot(dot_t); end

  def case(case_t, expr, when_bodies, else_t, else_body, end_t); end

  def character(char_t); end

  def complex(complex_t); end

  def compstmt(statements); end

  def condition(cond_t, cond, then_t, if_true, else_t, if_false, end_t); end

  def condition_mod(if_true, if_false, cond_t, cond); end

  def const(name_t); end

  def const_fetch(scope, t_colon2, name_t); end

  def const_global(t_colon3, name_t); end

  def const_op_assignable(node); end

  def cvar(token); end

  def dedent_string(node, dedent_level); end

  def def_class(class_t, name, lt_t, superclass, body, end_t); end

  def def_method(def_t, name_t, args, body, end_t); end

  def def_module(module_t, name, body, end_t); end

  def def_sclass(class_t, lshft_t, expr, body, end_t); end

  def def_singleton(def_t, definee, dot_t, name_t, args, body, end_t); end

  def emit_file_line_as_literals(); end

  def emit_file_line_as_literals=(emit_file_line_as_literals); end

  def false(false_t); end

  def float(float_t); end

  def for(for_t, iterator, in_t, iteratee, do_t, body, end_t); end

  def gvar(token); end

  def ident(token); end

  def index(receiver, lbrack_t, indexes, rbrack_t); end

  def index_asgn(receiver, lbrack_t, indexes, rbrack_t); end

  def integer(integer_t); end

  def ivar(token); end

  def keyword_cmd(type, keyword_t, lparen_t=T.unsafe(nil), args=T.unsafe(nil), rparen_t=T.unsafe(nil)); end

  def kwarg(name_t); end

  def kwoptarg(name_t, value); end

  def kwrestarg(dstar_t, name_t=T.unsafe(nil)); end

  def kwsplat(dstar_t, arg); end

  def logical_op(type, lhs, op_t, rhs); end

  def loop(type, keyword_t, cond, do_t, body, end_t); end

  def loop_mod(type, body, keyword_t, cond); end

  def match_op(receiver, match_t, arg); end

  def multi_assign(lhs, eql_t, rhs); end

  def multi_lhs(begin_t, items, end_t); end

  def nil(nil_t); end

  def not_op(not_t, begin_t=T.unsafe(nil), receiver=T.unsafe(nil), end_t=T.unsafe(nil)); end

  def nth_ref(token); end

  def objc_kwarg(kwname_t, assoc_t, name_t); end

  def objc_restarg(star_t, name=T.unsafe(nil)); end

  def objc_varargs(pair, rest_of_varargs); end

  def op_assign(lhs, op_t, rhs); end

  def optarg(name_t, eql_t, value); end

  def pair(key, assoc_t, value); end

  def pair_keyword(key_t, value); end

  def pair_list_18(list); end

  def pair_quoted(begin_t, parts, end_t, value); end

  def parser(); end

  def parser=(parser); end

  def postexe(postexe_t, lbrace_t, compstmt, rbrace_t); end

  def preexe(preexe_t, lbrace_t, compstmt, rbrace_t); end

  def procarg0(arg); end

  def range_exclusive(lhs, dot3_t, rhs); end

  def range_inclusive(lhs, dot2_t, rhs); end

  def rational(rational_t); end

  def regexp_compose(begin_t, parts, end_t, options); end

  def regexp_options(regopt_t); end

  def rescue_body(rescue_t, exc_list, assoc_t, exc_var, then_t, compound_stmt); end

  def restarg(star_t, name_t=T.unsafe(nil)); end

  def restarg_expr(star_t, expr=T.unsafe(nil)); end

  def self(token); end

  def shadowarg(name_t); end

  def splat(star_t, arg=T.unsafe(nil)); end

  def string(string_t); end

  def string_compose(begin_t, parts, end_t); end

  def string_internal(string_t); end

  def symbol(symbol_t); end

  def symbol_compose(begin_t, parts, end_t); end

  def symbol_internal(symbol_t); end

  def symbols_compose(begin_t, parts, end_t); end

  def ternary(cond, question_t, if_true, colon_t, if_false); end

  def true(true_t); end

  def unary_num(unary_t, numeric); end

  def unary_op(op_t, receiver); end

  def undef_method(undef_t, names); end

  def when(when_t, patterns, then_t, body); end

  def word(parts); end

  def words_compose(begin_t, parts, end_t); end

  def xstring_compose(begin_t, parts, end_t); end
end

class Parser::Builders::Default
  def self.emit_encoding(); end

  def self.emit_encoding=(emit_encoding); end

  def self.emit_index(); end

  def self.emit_index=(emit_index); end

  def self.emit_lambda(); end

  def self.emit_lambda=(emit_lambda); end

  def self.emit_procarg0(); end

  def self.emit_procarg0=(emit_procarg0); end

  def self.modernize(); end
end

module Parser::Builders
  extend ::T::Sig
end

class Parser::ClobberingError
end

class Parser::ClobberingError
end

class Parser::Context
  def class_definition_allowed?(); end

  def dynamic_const_definition_allowed?(); end

  def in_class?(); end

  def indirectly_in_def?(); end

  def module_definition_allowed?(); end

  def pop(); end

  def push(state); end

  def reset(); end

  def stack(); end
end

class Parser::Context
end

module Parser::Deprecation
  def warn_of_deprecation(); end

  def warned_of_deprecation=(warned_of_deprecation); end
end

module Parser::Deprecation
  extend ::T::Sig
end

class Parser::Diagnostic
  def arguments(); end

  def highlights(); end

  def initialize(level, reason, arguments, location, highlights=T.unsafe(nil)); end

  def level(); end

  def location(); end

  def message(); end

  def reason(); end

  def render(); end
  LEVELS = ::T.let(nil, ::T.untyped)
end

class Parser::Diagnostic::Engine
  def all_errors_are_fatal(); end

  def all_errors_are_fatal=(all_errors_are_fatal); end

  def consumer(); end

  def consumer=(consumer); end

  def ignore?(diagnostic); end

  def ignore_warnings(); end

  def ignore_warnings=(ignore_warnings); end

  def initialize(consumer=T.unsafe(nil)); end

  def process(diagnostic); end

  def raise?(diagnostic); end
end

class Parser::Diagnostic::Engine
end

class Parser::Diagnostic
end

class Parser::Lexer
  def advance(); end

  def arg_or_cmdarg(); end

  def cmdarg(); end

  def cmdarg=(cmdarg); end

  def comments(); end

  def comments=(comments); end

  def cond(); end

  def cond=(cond); end

  def dedent_level(); end

  def diagnostic(type, reason, arguments=T.unsafe(nil), location=T.unsafe(nil), highlights=T.unsafe(nil)); end

  def diagnostics(); end

  def diagnostics=(diagnostics); end

  def emit(type, value=T.unsafe(nil), s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_comment(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def emit_do(do_block=T.unsafe(nil)); end

  def emit_table(table, s=T.unsafe(nil), e=T.unsafe(nil)); end

  def encode_escape(ord); end

  def encoding(); end

  def eof_codepoint?(point); end

  def force_utf32(); end

  def force_utf32=(force_utf32); end

  def in_kwarg(); end

  def in_kwarg=(in_kwarg); end

  def initialize(version); end

  def literal(); end

  def next_state_for_literal(literal); end

  def pop_cmdarg(); end

  def pop_cond(); end

  def pop_literal(); end

  def push_cmdarg(); end

  def push_cond(); end

  def push_literal(*args); end

  def range(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def reset(reset_state=T.unsafe(nil)); end

  def source_buffer(); end

  def source_buffer=(source_buffer); end

  def stack_pop(); end

  def state(); end

  def state=(state); end

  def static_env(); end

  def static_env=(static_env); end

  def tok(s=T.unsafe(nil), e=T.unsafe(nil)); end

  def tokens(); end

  def tokens=(tokens); end

  def version?(*versions); end
  ESCAPES = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  KEYWORDS_BEGIN = ::T.let(nil, ::T.untyped)
  LEX_STATES = ::T.let(nil, ::T.untyped)
  PUNCTUATION = ::T.let(nil, ::T.untyped)
  PUNCTUATION_BEGIN = ::T.let(nil, ::T.untyped)
  REGEXP_META_CHARACTERS = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Dedenter
  def dedent(string); end

  def initialize(dedent_level); end

  def interrupt(); end
end

class Parser::Lexer::Dedenter
end

class Parser::Lexer::Literal
  def backslash_delimited?(); end

  def clear_buffer(); end

  def coerce_encoding(string); end

  def dedent_level(); end

  def delimiter?(delimiter); end

  def emit(token, type, s, e); end

  def emit_start_tok(); end

  def end_interp_brace_and_try_closing(); end

  def extend_content(); end

  def extend_space(ts, te); end

  def extend_string(string, ts, te); end

  def flush_string(); end

  def heredoc?(); end

  def heredoc_e(); end

  def infer_indent_level(line); end

  def initialize(lexer, str_type, delimiter, str_s, heredoc_e=T.unsafe(nil), indent=T.unsafe(nil), dedent_body=T.unsafe(nil), label_allowed=T.unsafe(nil)); end

  def interpolate?(); end

  def munge_escape?(character); end

  def nest_and_try_closing(delimiter, ts, te, lookahead=T.unsafe(nil)); end

  def plain_heredoc?(); end

  def regexp?(); end

  def saved_herebody_s(); end

  def saved_herebody_s=(saved_herebody_s); end

  def squiggly_heredoc?(); end

  def start_interp_brace(); end

  def str_s(); end

  def type(); end

  def words?(); end
  DELIMITERS = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Parser::Lexer::Literal
end

class Parser::Lexer::StackState
  def active?(); end

  def clear(); end

  def empty?(); end

  def initialize(name); end

  def lexpop(); end

  def pop(); end

  def push(bit); end
end

class Parser::Lexer::StackState
end

class Parser::Lexer
  def self.lex_en_expr_arg(); end

  def self.lex_en_expr_arg=(lex_en_expr_arg); end

  def self.lex_en_expr_beg(); end

  def self.lex_en_expr_beg=(lex_en_expr_beg); end

  def self.lex_en_expr_cmdarg(); end

  def self.lex_en_expr_cmdarg=(lex_en_expr_cmdarg); end

  def self.lex_en_expr_dot(); end

  def self.lex_en_expr_dot=(lex_en_expr_dot); end

  def self.lex_en_expr_end(); end

  def self.lex_en_expr_end=(lex_en_expr_end); end

  def self.lex_en_expr_endarg(); end

  def self.lex_en_expr_endarg=(lex_en_expr_endarg); end

  def self.lex_en_expr_endfn(); end

  def self.lex_en_expr_endfn=(lex_en_expr_endfn); end

  def self.lex_en_expr_fname(); end

  def self.lex_en_expr_fname=(lex_en_expr_fname); end

  def self.lex_en_expr_labelarg(); end

  def self.lex_en_expr_labelarg=(lex_en_expr_labelarg); end

  def self.lex_en_expr_mid(); end

  def self.lex_en_expr_mid=(lex_en_expr_mid); end

  def self.lex_en_expr_value(); end

  def self.lex_en_expr_value=(lex_en_expr_value); end

  def self.lex_en_expr_variable(); end

  def self.lex_en_expr_variable=(lex_en_expr_variable); end

  def self.lex_en_interp_backslash_delimited(); end

  def self.lex_en_interp_backslash_delimited=(lex_en_interp_backslash_delimited); end

  def self.lex_en_interp_backslash_delimited_words(); end

  def self.lex_en_interp_backslash_delimited_words=(lex_en_interp_backslash_delimited_words); end

  def self.lex_en_interp_string(); end

  def self.lex_en_interp_string=(lex_en_interp_string); end

  def self.lex_en_interp_words(); end

  def self.lex_en_interp_words=(lex_en_interp_words); end

  def self.lex_en_leading_dot(); end

  def self.lex_en_leading_dot=(lex_en_leading_dot); end

  def self.lex_en_line_begin(); end

  def self.lex_en_line_begin=(lex_en_line_begin); end

  def self.lex_en_line_comment(); end

  def self.lex_en_line_comment=(lex_en_line_comment); end

  def self.lex_en_plain_backslash_delimited(); end

  def self.lex_en_plain_backslash_delimited=(lex_en_plain_backslash_delimited); end

  def self.lex_en_plain_backslash_delimited_words(); end

  def self.lex_en_plain_backslash_delimited_words=(lex_en_plain_backslash_delimited_words); end

  def self.lex_en_plain_string(); end

  def self.lex_en_plain_string=(lex_en_plain_string); end

  def self.lex_en_plain_words(); end

  def self.lex_en_plain_words=(lex_en_plain_words); end

  def self.lex_en_regexp_modifiers(); end

  def self.lex_en_regexp_modifiers=(lex_en_regexp_modifiers); end

  def self.lex_error(); end

  def self.lex_error=(lex_error); end

  def self.lex_start(); end

  def self.lex_start=(lex_start); end
end

module Parser::Meta
  NODE_TYPES = ::T.let(nil, ::T.untyped)
end

module Parser::Meta
  extend ::T::Sig
end

class Parser::Rewriter
  def assignment?(node); end

  def initialize(*_); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Rewriter
  extend ::Parser::Deprecation
end

module Parser::Source
end

class Parser::Source::Buffer
  def column_for_position(position); end

  def decompose_position(position); end

  def first_line(); end

  def initialize(name, first_line=T.unsafe(nil)); end

  def last_line(); end

  def line_for_position(position); end

  def line_range(lineno); end

  def name(); end

  def raw_source=(input); end

  def read(); end

  def slice(range); end

  def source(); end

  def source=(input); end

  def source_line(lineno); end

  def source_lines(); end

  def source_range(); end
  ENCODING_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Buffer
  def self.recognize_encoding(string); end

  def self.reencode_string(input); end
end

class Parser::Source::Comment
  def ==(other); end

  def document?(); end

  def initialize(range); end

  def inline?(); end

  def loc(); end

  def location(); end

  def text(); end

  def type(); end
end

class Parser::Source::Comment::Associator
  def associate(); end

  def associate_locations(); end

  def initialize(ast, comments); end

  def skip_directives(); end

  def skip_directives=(skip_directives); end
  MAGIC_COMMENT_RE = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Comment::Associator
end

class Parser::Source::Comment
  def self.associate(ast, comments); end

  def self.associate_locations(ast, comments); end
end

class Parser::Source::Map
  def ==(other); end

  def column(); end

  def expression(); end

  def first_line(); end

  def initialize(expression); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def node(); end

  def node=(node); end

  def to_hash(); end

  def update_expression(expression_l); end

  def with(&block); end

  def with_expression(expression_l); end
end

class Parser::Source::Map::Collection
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end
end

class Parser::Source::Map::Collection
end

class Parser::Source::Map::Condition
  def begin(); end

  def else(); end

  def end(); end

  def initialize(keyword_l, begin_l, else_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Condition
end

class Parser::Source::Map::Constant
  def double_colon(); end

  def initialize(double_colon, name, expression); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Constant
end

class Parser::Source::Map::Definition
  def end(); end

  def initialize(keyword_l, operator_l, name_l, end_l); end

  def keyword(); end

  def name(); end

  def operator(); end
end

class Parser::Source::Map::Definition
end

class Parser::Source::Map::For
  def begin(); end

  def end(); end

  def in(); end

  def initialize(keyword_l, in_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::For
end

class Parser::Source::Map::Heredoc
  def heredoc_body(); end

  def heredoc_end(); end

  def initialize(begin_l, body_l, end_l); end
end

class Parser::Source::Map::Heredoc
end

class Parser::Source::Map::Index
  def begin(); end

  def end(); end

  def initialize(begin_l, end_l, expression_l); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Index
end

class Parser::Source::Map::Keyword
  def begin(); end

  def end(); end

  def initialize(keyword_l, begin_l, end_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::Keyword
end

class Parser::Source::Map::ObjcKwarg
  def argument(); end

  def initialize(keyword_l, operator_l, argument_l, expression_l); end

  def keyword(); end

  def operator(); end
end

class Parser::Source::Map::ObjcKwarg
end

class Parser::Source::Map::Operator
  def initialize(operator, expression); end

  def operator(); end
end

class Parser::Source::Map::Operator
end

class Parser::Source::Map::RescueBody
  def assoc(); end

  def begin(); end

  def initialize(keyword_l, assoc_l, begin_l, expression_l); end

  def keyword(); end
end

class Parser::Source::Map::RescueBody
end

class Parser::Source::Map::Send
  def begin(); end

  def dot(); end

  def end(); end

  def initialize(dot_l, selector_l, begin_l, end_l, expression_l); end

  def operator(); end

  def selector(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Send
end

class Parser::Source::Map::Ternary
  def colon(); end

  def initialize(question_l, colon_l, expression_l); end

  def question(); end
end

class Parser::Source::Map::Ternary
end

class Parser::Source::Map::Variable
  def initialize(name_l, expression_l=T.unsafe(nil)); end

  def name(); end

  def operator(); end

  def update_operator(operator_l); end

  def with_operator(operator_l); end
end

class Parser::Source::Map::Variable
end

class Parser::Source::Map
end

class Parser::Source::Range
  include ::Comparable
  def adjust(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end

  def begin(); end

  def begin_pos(); end

  def column(); end

  def column_range(); end

  def contained?(other); end

  def contains?(other); end

  def crossing?(other); end

  def disjoint?(other); end

  def empty?(); end

  def end(); end

  def end_pos(); end

  def first_line(); end

  def initialize(source_buffer, begin_pos, end_pos); end

  def intersect(other); end

  def is?(*what); end

  def join(other); end

  def last_column(); end

  def last_line(); end

  def length(); end

  def line(); end

  def overlaps?(other); end

  def resize(new_size); end

  def size(); end

  def source(); end

  def source_buffer(); end

  def source_line(); end

  def to_a(); end

  def with(begin_pos: T.unsafe(nil), end_pos: T.unsafe(nil)); end
end

class Parser::Source::Range
end

class Parser::Source::Rewriter
  def diagnostics(); end

  def initialize(source_buffer); end

  def insert_after(range, content); end

  def insert_after_multi(range, content); end

  def insert_before(range, content); end

  def insert_before_multi(range, content); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, before, after); end
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
end

class Parser::Source::Rewriter::Action
  include ::Comparable
  def allow_multiple_insertions(); end

  def allow_multiple_insertions?(); end

  def initialize(range, replacement=T.unsafe(nil), allow_multiple_insertions=T.unsafe(nil), order=T.unsafe(nil)); end

  def order(); end

  def range(); end

  def replacement(); end
end

class Parser::Source::Rewriter::Action
end

class Parser::Source::Rewriter
  extend ::Parser::Deprecation
end

class Parser::Source::TreeRewriter
  def diagnostics(); end

  def in_transaction?(); end

  def initialize(source_buffer, crossing_deletions: T.unsafe(nil), different_replacements: T.unsafe(nil), swallowed_insertions: T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_after_multi(range, text); end

  def insert_before(range, content); end

  def insert_before_multi(range, text); end

  def process(); end

  def remove(range); end

  def replace(range, content); end

  def source_buffer(); end

  def transaction(); end

  def wrap(range, insert_before, insert_after); end
  ACTIONS = ::T.let(nil, ::T.untyped)
  DEPRECATION_WARNING = ::T.let(nil, ::T.untyped)
  POLICY_TO_LEVEL = ::T.let(nil, ::T.untyped)
end

class Parser::Source::TreeRewriter::Action
  def call_enforcer_for_merge(action); end

  def combine(action); end

  def do_combine(action); end

  def fuse_deletions(action, fusible, other_sibblings); end

  def initialize(range, enforcer, insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil), children: T.unsafe(nil)); end

  def insert_after(); end

  def insert_before(); end

  def insertion?(); end

  def merge(action); end

  def ordered_replacements(); end

  def place_in_hierachy(action); end

  def range(); end

  def relationship_with(action); end

  def replacement(); end

  def swallow(children); end

  def with(range: T.unsafe(nil), children: T.unsafe(nil), insert_before: T.unsafe(nil), replacement: T.unsafe(nil), insert_after: T.unsafe(nil)); end
end

class Parser::Source::TreeRewriter::Action
end

class Parser::Source::TreeRewriter
  extend ::Parser::Deprecation
end

module Parser::Source
  extend ::T::Sig
end

class Parser::StaticEnvironment
  def declare(name); end

  def declared?(name); end

  def extend_dynamic(); end

  def extend_static(); end

  def reset(); end

  def unextend(); end
end

class Parser::StaticEnvironment
end

class Parser::SyntaxError
  def diagnostic(); end

  def initialize(diagnostic); end
end

class Parser::SyntaxError
end

class Parser::TreeRewriter
  def assignment?(node); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def replace(range, content); end

  def rewrite(source_buffer, ast, **policy); end

  def wrap(range, before, after); end
end

class Parser::TreeRewriter
end

module Parser
  extend ::T::Sig
end

module Parts
end

class Parts::EpiloguePart
  include ::Parts::Part
  def initialize(boundary); end
end

class Parts::EpiloguePart
end

class Parts::FilePart
  include ::Parts::Part
  def build_head(boundary, name, filename, type, content_len, opts=T.unsafe(nil), headers=T.unsafe(nil)); end

  def initialize(boundary, name, io, headers=T.unsafe(nil)); end
end

class Parts::FilePart
end

class Parts::ParamPart
  include ::Parts::Part
  def build_part(boundary, name, value, headers=T.unsafe(nil)); end

  def initialize(boundary, name, value, headers=T.unsafe(nil)); end
end

class Parts::ParamPart
end

module Parts::Part
  def length(); end

  def to_io(); end
end

module Parts::Part
  extend ::T::Sig
  def self.file?(value); end

  def self.new(boundary, name, value, headers=T.unsafe(nil)); end
end

module Parts
  extend ::T::Sig
end

class PatchedStringIO
  def orig_read_nonblock(*_); end

  def read_nonblock(size, *args); end
end

class PatchedStringIO
end

class Pathname
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def empty?(); end

  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end

end

class Pathname
  extend ::T::Sig
end

module PaymentService
  extend ::T::Sig
end

module Polyamorous
end

Polyamorous::InnerJoin = Arel::Nodes::InnerJoin

class Polyamorous::Join
  include ::Polyamorous::TreeNode
  def ==(other); end

  def eql?(other); end

  def initialize(name, type=T.unsafe(nil), klass=T.unsafe(nil)); end

  def klass(); end

  def klass=(klass); end

  def name(); end

  def name=(name); end

  def type(); end

  def type=(type); end
end

class Polyamorous::Join
end

Polyamorous::JoinAssociation = ActiveRecord::Associations::JoinDependency::JoinAssociation

module Polyamorous::JoinAssociationExtensions
  include ::Polyamorous::SwappingReflectionClass
  def build_constraint(klass, table, key, foreign_table, foreign_key); end

  def initialize(reflection, children, polymorphic_class=T.unsafe(nil), join_type=T.unsafe(nil)); end
end

module Polyamorous::JoinAssociationExtensions
  extend ::T::Sig
  def self.prepended(base); end
end

Polyamorous::JoinBase = ActiveRecord::Associations::JoinDependency::JoinBase

class ActiveRecord::Associations::JoinDependency
end

Polyamorous::JoinDependency::JoinAssociation = ActiveRecord::Associations::JoinDependency::JoinAssociation

Polyamorous::JoinDependency::JoinBase = ActiveRecord::Associations::JoinDependency::JoinBase

class ActiveRecord::Associations::JoinDependency
end

module Polyamorous::JoinDependencyExtensions
  def build(associations, base_klass); end
end

module Polyamorous::JoinDependencyExtensions::ClassMethods
  def walk_tree(associations, hash); end
end

module Polyamorous::JoinDependencyExtensions::ClassMethods
  extend ::T::Sig
end

module Polyamorous::JoinDependencyExtensions
  extend ::T::Sig
end

Polyamorous::OuterJoin = Arel::Nodes::OuterJoin

module Polyamorous::SwappingReflectionClass
  def swapping_reflection_klass(reflection, klass); end
end

module Polyamorous::SwappingReflectionClass
  extend ::T::Sig
end

module Polyamorous::TreeNode
  def add_to_tree(hash); end
end

module Polyamorous::TreeNode
  extend ::T::Sig
end

module Polyamorous
  extend ::T::Sig
end

class PrettyPrint
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::Breakable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::Breakable
  extend ::T::Sig
end

class PrettyPrint::Group
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::Group
  extend ::T::Sig
end

class PrettyPrint::GroupQueue
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::GroupQueue
  extend ::T::Sig
end

class PrettyPrint::SingleLine
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::SingleLine
  extend ::T::Sig
end

class PrettyPrint::Text
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class PrettyPrint::Text
  extend ::T::Sig
end

class PrettyPrint
  extend ::T::Sig
end

class Proc
  include ::MethodSource::MethodExtensions
  include ::MethodSource::SourceLocation::ProcExtensions
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ===(*_); end

  def [](*_); end

  def clone(); end

  def lambda?(); end

  def yield(*_); end
end

class Proc
  extend ::T::Sig
end

module Process
  CLOCK_MONOTONIC_RAW_APPROX = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW = ::T.let(nil, ::T.untyped)
  CLOCK_UPTIME_RAW_APPROX = ::T.let(nil, ::T.untyped)
end

module Process::GID
  extend ::T::Sig
end

class Process::Status
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Process::Status
  extend ::T::Sig
end

module Process::Sys
  extend ::T::Sig
  def self.getegid(); end

end

class Process::Tms
  def cstime(); end

  def cstime=(_); end

  def cutime(); end

  def cutime=(_); end

  def stime(); end

  def stime=(_); end

  def utime(); end

  def utime=(_); end
end

class Process::Tms
  extend ::T::Sig
  def self.[](*_); end

  def self.members(); end
end

module Process::UID
  extend ::T::Sig
end

class Process::Waiter
  extend ::T::Sig
end

module Process
  extend ::T::Sig
  def self.last_status(); end

  def self.setpgrp(); end

end

class ProgressBar
end

class ProgressBar::Base
  def autofinish(); end

  def autofinish=(autofinish); end

  def autostart(); end

  def autostart=(autostart); end

  def bar(); end

  def bar=(bar); end

  def clear(*args, &block); end

  def decrement(); end

  def finish(); end

  def finished(); end

  def finished=(finished); end

  def finished?(); end

  def format(other); end

  def format=(other); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def log(*args, &block); end

  def output(); end

  def output=(output); end

  def pause(); end

  def paused?(); end

  def percentage(); end

  def percentage=(percentage); end

  def progress(*args, &block); end

  def progress=(new_progress); end

  def progress_mark=(mark); end

  def progressable(); end

  def progressable=(progressable); end

  def rate(); end

  def rate=(rate); end

  def refresh(*args, &block); end

  def remainder_mark=(mark); end

  def reset(); end

  def resume(); end

  def start(options=T.unsafe(nil)); end

  def started?(); end

  def stop(); end

  def stopped?(); end

  def time(); end

  def time=(time); end

  def timer(); end

  def timer=(timer); end

  def title(); end

  def title=(title); end

  def title_comp(); end

  def title_comp=(title_comp); end

  def to_h(); end

  def to_s(new_format=T.unsafe(nil)); end

  def total(*args, &block); end

  def total=(new_total); end

  def update_progress(*args); end
end

class ProgressBar::Base
  extend ::Forwardable
end

module ProgressBar::Calculators
end

class ProgressBar::Calculators::Length
  def calculate_length(); end

  def current_length(); end

  def current_length=(current_length); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_changed?(); end

  def length_override(); end

  def length_override=(other); end

  def output(); end

  def output=(output); end

  def reset_length(); end
end

class ProgressBar::Calculators::Length
end

class ProgressBar::Calculators::RunningAverage
end

class ProgressBar::Calculators::RunningAverage
  def self.calculate(current_average, new_value_to_average, smoothing_factor); end
end

module ProgressBar::Calculators
  extend ::T::Sig
end

module ProgressBar::Components
end

class ProgressBar::Components::Bar
  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def progress(); end

  def progress=(progress); end

  def progress_mark(); end

  def progress_mark=(progress_mark); end

  def remainder_mark(); end

  def remainder_mark=(remainder_mark); end

  def to_s(options=T.unsafe(nil)); end

  def upa_steps(); end

  def upa_steps=(upa_steps); end
  DEFAULT_PROGRESS_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_REMAINDER_MARK = ::T.let(nil, ::T.untyped)
  DEFAULT_UPA_STEPS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Bar
end

class ProgressBar::Components::Percentage
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end
end

class ProgressBar::Components::Percentage
end

class ProgressBar::Components::Rate
  def initialize(options=T.unsafe(nil)); end

  def progress(); end

  def progress=(progress); end

  def rate_scale(); end

  def rate_scale=(rate_scale); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Components::Rate
end

class ProgressBar::Components::Time
  def elapsed_with_label(); end

  def estimated_with_friendly_oob(); end

  def estimated_with_label(); end

  def estimated_with_no_oob(); end

  def estimated_with_unknown_oob(); end

  def initialize(options=T.unsafe(nil)); end

  def out_of_bounds_time_format(); end

  def out_of_bounds_time_format=(format); end

  def progress(); end

  def progress=(progress); end

  def timer(); end

  def timer=(timer); end
  ELAPSED_LABEL = ::T.let(nil, ::T.untyped)
  ESTIMATED_LABEL = ::T.let(nil, ::T.untyped)
  NO_TIME_ELAPSED_TEXT = ::T.let(nil, ::T.untyped)
  OOB_FRIENDLY_TIME_TEXT = ::T.let(nil, ::T.untyped)
  OOB_LIMIT_IN_HOURS = ::T.let(nil, ::T.untyped)
  OOB_TIME_FORMATS = ::T.let(nil, ::T.untyped)
  OOB_UNKNOWN_TIME_TEXT = ::T.let(nil, ::T.untyped)
  TIME_FORMAT = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Time
end

class ProgressBar::Components::Title
  def initialize(options=T.unsafe(nil)); end

  def title(); end

  def title=(title); end
  DEFAULT_TITLE = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Components::Title
end

module ProgressBar::Components
  extend ::T::Sig
end

module ProgressBar::Format
end

class ProgressBar::Format::Formatter
end

class ProgressBar::Format::Formatter
  def self.process(format_string, max_length, bar); end
end

class ProgressBar::Format::Molecule
  def bar_molecule?(); end

  def full_key(); end

  def initialize(letter); end

  def key(); end

  def key=(key); end

  def lookup_value(environment, length=T.unsafe(nil)); end

  def method_name(); end

  def method_name=(method_name); end

  def non_bar_molecule?(); end
  BAR_MOLECULES = ::T.let(nil, ::T.untyped)
  MOLECULES = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::Molecule
end

class ProgressBar::Format::String
  def bar_molecule_placeholder_length(); end

  def bar_molecules(); end

  def displayable_length(); end

  def molecules(); end

  def non_bar_molecules(); end
  ANSI_SGR_PATTERN = ::T.let(nil, ::T.untyped)
  MOLECULE_PATTERN = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Format::String
end

module ProgressBar::Format
  extend ::T::Sig
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::InvalidProgressError
end

class ProgressBar::Output
  def bar(); end

  def bar=(bar); end

  def clear_string(); end

  def initialize(options=T.unsafe(nil)); end

  def length(); end

  def length_calculator(); end

  def length_calculator=(length_calculator); end

  def log(string); end

  def refresh(options=T.unsafe(nil)); end

  def stream(); end

  def stream=(stream); end

  def throttle(); end

  def throttle=(throttle); end

  def with_refresh(); end
  DEFAULT_OUTPUT_STREAM = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Output
  def self.detect(options=T.unsafe(nil)); end
end

module ProgressBar::Outputs
end

class ProgressBar::Outputs::NonTty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def last_update_length(); end

  def last_update_length=(last_update_length); end

  def refresh_with_format_change(*_); end

  def resolve_format(*_); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::NonTty
end

class ProgressBar::Outputs::Tty
  def bar_update_string(); end

  def clear(); end

  def default_format(); end

  def eol(); end

  def refresh_with_format_change(); end

  def resolve_format(other_format); end
  DEFAULT_FORMAT_STRING = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Outputs::Tty
end

module ProgressBar::Outputs
  extend ::T::Sig
end

class ProgressBar::Progress
  def absolute(); end

  def decrement(); end

  def finish(); end

  def finished?(); end

  def increment(); end

  def initialize(options=T.unsafe(nil)); end

  def none?(); end

  def percentage_completed(); end

  def percentage_completed_with_precision(); end

  def progress(); end

  def progress=(new_progress); end

  def reset(); end

  def running_average(); end

  def running_average=(running_average); end

  def smoothing(); end

  def smoothing=(smoothing); end

  def start(options=T.unsafe(nil)); end

  def starting_position(); end

  def starting_position=(starting_position); end

  def total(); end

  def total=(new_total); end

  def total_with_unknown_indicator(); end

  def unknown?(); end
  DEFAULT_BEGINNING_POSITION = ::T.let(nil, ::T.untyped)
  DEFAULT_SMOOTHING = ::T.let(nil, ::T.untyped)
  DEFAULT_TOTAL = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Progress
end

module ProgressBar::Refinements
end

module ProgressBar::Refinements::Enumerator
end

module ProgressBar::Refinements::Enumerator
  extend ::T::Sig
end

module ProgressBar::Refinements
  extend ::T::Sig
end

class ProgressBar::Throttle
  def choke(options=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def rate(); end

  def rate=(rate); end

  def started_at(); end

  def started_at=(started_at); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def timer(); end

  def timer=(timer); end
end

class ProgressBar::Throttle
end

class ProgressBar::Time
  def initialize(time=T.unsafe(nil)); end

  def now(); end

  def time(); end

  def time=(time); end

  def unmocked_time_method(); end
  TIME_MOCKING_LIBRARY_METHODS = ::T.let(nil, ::T.untyped)
end

class ProgressBar::Time
end

class ProgressBar::Timer
  def divide_seconds(seconds); end

  def elapsed_seconds(); end

  def elapsed_whole_seconds(); end

  def initialize(options=T.unsafe(nil)); end

  def pause(); end

  def reset(); end

  def reset?(); end

  def restart(); end

  def resume(); end

  def start(); end

  def started?(); end

  def started_at(); end

  def started_at=(started_at); end

  def stop(); end

  def stopped?(); end

  def stopped_at(); end

  def stopped_at=(stopped_at); end

  def time(); end

  def time=(time); end
end

class ProgressBar::Timer
end

class ProgressBar
  def self.create(*args); end
end

module Psych
  LIBYAML_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Psych::BadAlias
end

class Psych::BadAlias
end

class Psych::ClassLoader
  def big_decimal(); end

  def complex(); end

  def date(); end

  def date_time(); end

  def exception(); end

  def load(klassname); end

  def object(); end

  def psych_omap(); end

  def psych_set(); end

  def range(); end

  def rational(); end

  def regexp(); end

  def struct(); end

  def symbol(); end

  def symbolize(sym); end
  BIG_DECIMAL = ::T.let(nil, ::T.untyped)
  CACHE = ::T.let(nil, ::T.untyped)
  COMPLEX = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  DATE_TIME = ::T.let(nil, ::T.untyped)
  EXCEPTION = ::T.let(nil, ::T.untyped)
  OBJECT = ::T.let(nil, ::T.untyped)
  PSYCH_OMAP = ::T.let(nil, ::T.untyped)
  PSYCH_SET = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  RATIONAL = ::T.let(nil, ::T.untyped)
  REGEXP = ::T.let(nil, ::T.untyped)
  STRUCT = ::T.let(nil, ::T.untyped)
  SYMBOL = ::T.let(nil, ::T.untyped)
end

class Psych::ClassLoader::Restricted
  def initialize(classes, symbols); end
end

class Psych::ClassLoader::Restricted
end

class Psych::ClassLoader
end

class Psych::Coder
  def [](k); end

  def []=(k, v); end

  def add(k, v); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(tag); end

  def map(tag=T.unsafe(nil), style=T.unsafe(nil)); end

  def map=(map); end

  def object(); end

  def object=(object); end

  def represent_map(tag, map); end

  def represent_object(tag, obj); end

  def represent_scalar(tag, value); end

  def represent_seq(tag, list); end

  def scalar(*args); end

  def scalar=(value); end

  def seq(); end

  def seq=(list); end

  def style(); end

  def style=(style); end

  def tag(); end

  def tag=(tag); end

  def type(); end
end

class Psych::Coder
end

class Psych::DisallowedClass
  def initialize(klass_name); end
end

class Psych::DisallowedClass
end

class Psych::Emitter
  def alias(_); end

  def canonical(); end

  def canonical=(canonical); end

  def end_document(_); end

  def indentation(); end

  def indentation=(indentation); end

  def initialize(*_); end

  def line_width(); end

  def line_width=(line_width); end

  def scalar(_, _1, _2, _3, _4, _5); end

  def start_document(_, _1, _2); end

  def start_mapping(_, _1, _2, _3); end

  def start_sequence(_, _1, _2, _3); end

  def start_stream(_); end
end

class Psych::Emitter
end

class Psych::Exception
end

class Psych::Exception
end

class Psych::FALLBACK
  def to_ruby(); end

  def to_ruby=(_); end
end

class Psych::FALLBACK
  def self.[](*_); end

  def self.members(); end
end

class Psych::Handler
  def alias(anchor); end

  def empty(); end

  def end_document(implicit); end

  def end_mapping(); end

  def end_sequence(); end

  def end_stream(); end

  def event_location(start_line, start_column, end_line, end_column); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end

  def start_stream(encoding); end

  def streaming?(); end
  EVENTS = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class Psych::Handler::DumperOptions
  def canonical(); end

  def canonical=(canonical); end

  def indentation(); end

  def indentation=(indentation); end

  def line_width(); end

  def line_width=(line_width); end
end

class Psych::Handler::DumperOptions
end

class Psych::Handler
end

module Psych::Handlers
end

class Psych::Handlers::DocumentStream
  def initialize(&block); end
end

class Psych::Handlers::DocumentStream
end

module Psych::Handlers
  extend ::T::Sig
end

module Psych::JSON
end

module Psych::JSON::RubyEvents
  def visit_DateTime(o); end

  def visit_String(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end
end

module Psych::JSON::RubyEvents
  extend ::T::Sig
end

class Psych::JSON::Stream
  include ::Psych::Streaming
end

class Psych::JSON::Stream::Emitter
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::Stream::Emitter
end

class Psych::JSON::Stream
  extend ::Psych::Streaming::ClassMethods
end

class Psych::JSON::TreeBuilder
  include ::Psych::JSON::YAMLEvents
end

class Psych::JSON::TreeBuilder
end

module Psych::JSON::YAMLEvents
  def end_document(implicit_end=T.unsafe(nil)); end

  def scalar(value, anchor, tag, plain, quoted, style); end

  def start_document(version, tag_directives, implicit); end

  def start_mapping(anchor, tag, implicit, style); end

  def start_sequence(anchor, tag, implicit, style); end
end

module Psych::JSON::YAMLEvents
  extend ::T::Sig
end

module Psych::JSON
  extend ::T::Sig
end

module Psych::Nodes
end

class Psych::Nodes::Alias
  def anchor(); end

  def anchor=(anchor); end

  def initialize(anchor); end
end

class Psych::Nodes::Alias
end

class Psych::Nodes::Document
  def implicit(); end

  def implicit=(implicit); end

  def implicit_end(); end

  def implicit_end=(implicit_end); end

  def initialize(version=T.unsafe(nil), tag_directives=T.unsafe(nil), implicit=T.unsafe(nil)); end

  def root(); end

  def tag_directives(); end

  def tag_directives=(tag_directives); end

  def version(); end

  def version=(version); end
end

class Psych::Nodes::Document
end

class Psych::Nodes::Mapping
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Mapping
end

class Psych::Nodes::Node
  include ::Enumerable
  def children(); end

  def each(&block); end

  def end_column(); end

  def end_column=(end_column); end

  def end_line(); end

  def end_line=(end_line); end

  def start_column(); end

  def start_column=(start_column); end

  def start_line(); end

  def start_line=(start_line); end

  def tag(); end

  def to_ruby(); end

  def to_yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end

  def transform(); end

  def yaml(io=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Psych::Nodes::Node
end

class Psych::Nodes::Scalar
  def anchor(); end

  def anchor=(anchor); end

  def initialize(value, anchor=T.unsafe(nil), tag=T.unsafe(nil), plain=T.unsafe(nil), quoted=T.unsafe(nil), style=T.unsafe(nil)); end

  def plain(); end

  def plain=(plain); end

  def quoted(); end

  def quoted=(quoted); end

  def style(); end

  def style=(style); end

  def tag=(tag); end

  def value(); end

  def value=(value); end
  ANY = ::T.let(nil, ::T.untyped)
  DOUBLE_QUOTED = ::T.let(nil, ::T.untyped)
  FOLDED = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  PLAIN = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTED = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Scalar
end

class Psych::Nodes::Sequence
  def anchor(); end

  def anchor=(anchor); end

  def implicit(); end

  def implicit=(implicit); end

  def initialize(anchor=T.unsafe(nil), tag=T.unsafe(nil), implicit=T.unsafe(nil), style=T.unsafe(nil)); end

  def style(); end

  def style=(style); end

  def tag=(tag); end
  ANY = ::T.let(nil, ::T.untyped)
  BLOCK = ::T.let(nil, ::T.untyped)
  FLOW = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Sequence
end

class Psych::Nodes::Stream
  def encoding(); end

  def encoding=(encoding); end

  def initialize(encoding=T.unsafe(nil)); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Nodes::Stream
end

module Psych::Nodes
  extend ::T::Sig
end

class Psych::Omap
end

class Psych::Omap
end

class Psych::Parser
  def external_encoding=(external_encoding); end

  def handler(); end

  def handler=(handler); end

  def initialize(handler=T.unsafe(nil)); end

  def mark(); end

  def parse(*_); end
  ANY = ::T.let(nil, ::T.untyped)
  UTF16BE = ::T.let(nil, ::T.untyped)
  UTF16LE = ::T.let(nil, ::T.untyped)
  UTF8 = ::T.let(nil, ::T.untyped)
end

class Psych::Parser::Mark
end

class Psych::Parser::Mark
end

class Psych::Parser
end

class Psych::ScalarScanner
  def class_loader(); end

  def initialize(class_loader); end

  def parse_int(string); end

  def parse_time(string); end

  def tokenize(string); end
  FLOAT = ::T.let(nil, ::T.untyped)
  INTEGER = ::T.let(nil, ::T.untyped)
  TIME = ::T.let(nil, ::T.untyped)
end

class Psych::ScalarScanner
end

class Psych::Set
end

class Psych::Set
end

class Psych::Stream
  include ::Psych::Streaming
end

class Psych::Stream::Emitter
  def end_document(implicit_end=T.unsafe(nil)); end
end

class Psych::Stream::Emitter
end

class Psych::Stream
  extend ::Psych::Streaming::ClassMethods
end

module Psych::Streaming
  def start(encoding=T.unsafe(nil)); end
end

module Psych::Streaming::ClassMethods
  def new(io); end
end

module Psych::Streaming::ClassMethods
  extend ::T::Sig
end

module Psych::Streaming
  extend ::T::Sig
end

class Psych::SyntaxError
  def column(); end

  def context(); end

  def file(); end

  def initialize(file, line, col, offset, problem, context); end

  def line(); end

  def offset(); end

  def problem(); end
end

class Psych::SyntaxError
end

class Psych::TreeBuilder
  def end_document(implicit_end=T.unsafe(nil)); end

  def root(); end
end

class Psych::TreeBuilder
end

module Psych::Visitors
end

class Psych::Visitors::DepthFirst
  def initialize(block); end
end

class Psych::Visitors::DepthFirst
end

class Psych::Visitors::Emitter
  def initialize(io, options=T.unsafe(nil)); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
end

class Psych::Visitors::Emitter
end

class Psych::Visitors::JSONTree
  include ::Psych::JSON::RubyEvents
end

class Psych::Visitors::JSONTree
  def self.create(options=T.unsafe(nil)); end
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::NoAliasRuby
end

class Psych::Visitors::ToRuby
  def class_loader(); end

  def initialize(ss, class_loader); end

  def visit_Psych_Nodes_Alias(o); end

  def visit_Psych_Nodes_Document(o); end

  def visit_Psych_Nodes_Mapping(o); end

  def visit_Psych_Nodes_Scalar(o); end

  def visit_Psych_Nodes_Sequence(o); end

  def visit_Psych_Nodes_Stream(o); end
  SHOVEL = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::ToRuby
  def self.create(); end
end

class Psych::Visitors::Visitor
  def accept(target); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Psych::Visitors::Visitor
end

class Psych::Visitors::YAMLTree
  def <<(object); end

  def finish(); end

  def finished(); end

  def finished?(); end

  def initialize(emitter, ss, options); end

  def push(object); end

  def start(encoding=T.unsafe(nil)); end

  def started(); end

  def started?(); end

  def tree(); end

  def visit_Array(o); end

  def visit_BasicObject(o); end

  def visit_BigDecimal(o); end

  def visit_Class(o); end

  def visit_Complex(o); end

  def visit_Date(o); end

  def visit_DateTime(o); end

  def visit_Delegator(o); end

  def visit_Encoding(o); end

  def visit_Enumerator(o); end

  def visit_Exception(o); end

  def visit_FalseClass(o); end

  def visit_Float(o); end

  def visit_Hash(o); end

  def visit_Integer(o); end

  def visit_Module(o); end

  def visit_NameError(o); end

  def visit_NilClass(o); end

  def visit_Object(o); end

  def visit_Psych_Omap(o); end

  def visit_Psych_Set(o); end

  def visit_Range(o); end

  def visit_Rational(o); end

  def visit_Regexp(o); end

  def visit_String(o); end

  def visit_Struct(o); end

  def visit_Symbol(o); end

  def visit_Time(o); end

  def visit_TrueClass(o); end
end

class Psych::Visitors::YAMLTree
  def self.create(options=T.unsafe(nil), emitter=T.unsafe(nil)); end
end

module Psych::Visitors
  extend ::T::Sig
end

module Psych
  extend ::T::Sig
  def self.add_builtin_type(type_tag, &block); end

  def self.add_domain_type(domain, type_tag, &block); end

  def self.add_tag(tag, klass); end

  def self.domain_types(); end

  def self.domain_types=(domain_types); end

  def self.dump(o, io=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.dump_stream(*objects); end

  def self.dump_tags(); end

  def self.dump_tags=(dump_tags); end

  def self.libyaml_version(); end

  def self.load(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.load_file(filename, fallback: T.unsafe(nil)); end

  def self.load_stream(yaml, filename=T.unsafe(nil)); end

  def self.load_tags(); end

  def self.load_tags=(load_tags); end

  def self.parse(yaml, filename=T.unsafe(nil), fallback: T.unsafe(nil)); end

  def self.parse_file(filename); end

  def self.parse_stream(yaml, filename=T.unsafe(nil), &block); end

  def self.parser(); end

  def self.remove_type(type_tag); end

  def self.safe_load(yaml, whitelist_classes=T.unsafe(nil), whitelist_symbols=T.unsafe(nil), aliases=T.unsafe(nil), filename=T.unsafe(nil), symbolize_names: T.unsafe(nil)); end

  def self.to_json(object); end
end

module PublicSuffix
  BANG = ::T.let(nil, ::T.untyped)
  DOT = ::T.let(nil, ::T.untyped)
  STAR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::Domain
  def domain(); end

  def domain?(); end

  def initialize(*args); end

  def name(); end

  def sld(); end

  def subdomain(); end

  def subdomain?(); end

  def tld(); end

  def to_a(); end

  def trd(); end
end

class PublicSuffix::Domain
  def self.name_to_labels(name); end
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainInvalid
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::DomainNotAllowed
end

class PublicSuffix::Error
end

class PublicSuffix::Error
end

class PublicSuffix::List
  def <<(rule); end

  def ==(other); end

  def add(rule); end

  def clear(); end

  def default_rule(); end

  def each(&block); end

  def empty?(); end

  def eql?(other); end

  def find(name, default: T.unsafe(nil), **options); end

  def rules(); end

  def size(); end
  DEFAULT_LIST_PATH = ::T.let(nil, ::T.untyped)
end

class PublicSuffix::List
  def self.default(**options); end

  def self.default=(value); end

  def self.parse(input, private_domains: T.unsafe(nil)); end
end

module PublicSuffix::Rule
end

class PublicSuffix::Rule::Base
  def ==(other); end

  def decompose(*_); end

  def eql?(other); end

  def initialize(value:, length: T.unsafe(nil), private: T.unsafe(nil)); end

  def length(); end

  def match?(name); end

  def parts(); end

  def private(); end

  def value(); end
end

class PublicSuffix::Rule::Base
  def self.build(content, private: T.unsafe(nil)); end
end

class PublicSuffix::Rule::Entry
  def length=(_); end

  def private(); end

  def private=(_); end

  def type(); end

  def type=(_); end
end

class PublicSuffix::Rule::Entry
  def self.[](*_); end

  def self.members(); end
end

class PublicSuffix::Rule::Exception
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Exception
end

class PublicSuffix::Rule::Normal
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Normal
end

class PublicSuffix::Rule::Wildcard
  def decompose(domain); end

  def rule(); end
end

class PublicSuffix::Rule::Wildcard
end

module PublicSuffix::Rule
  extend ::T::Sig
  def self.default(); end

  def self.factory(content, private: T.unsafe(nil)); end
end

module PublicSuffix
  extend ::T::Sig
  def self.decompose(name, rule); end

  def self.domain(name, **options); end

  def self.normalize(name); end

  def self.parse(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end

  def self.valid?(name, list: T.unsafe(nil), default_rule: T.unsafe(nil), ignore_private: T.unsafe(nil)); end
end

module Puma
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  IS_JRUBY = ::T.let(nil, ::T.untyped)
  IS_WINDOWS = ::T.let(nil, ::T.untyped)
  Plugins = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
  include ::Puma::Const
  def add_ssl_listener(host, port, ctx, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_tcp_listener(host, port, optimize_for_latency=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def add_unix_listener(path, umask=T.unsafe(nil), mode=T.unsafe(nil), backlog=T.unsafe(nil)); end

  def close(); end

  def connected_port(); end

  def env(sock); end

  def import_from_env(); end

  def inherit_ssl_listener(fd, ctx); end

  def inherit_tcp_listener(host, port, fd); end

  def inherit_unix_listener(path, fd); end

  def initialize(events); end

  def ios(); end

  def listeners(); end

  def loopback_addresses(); end

  def parse(binds, logger); end
  RACK_VERSION = ::T.let(nil, ::T.untyped)
end

class Puma::Binder
end

class Puma::Client
  include ::Puma::Const
  def body(); end

  def call(); end

  def close(); end

  def closed?(*args, &block); end

  def decode_chunk(chunk); end

  def eagerly_finish(); end

  def env(); end

  def finish(); end

  def hijacked(); end

  def in_data_phase(); end

  def initialize(io, env=T.unsafe(nil)); end

  def io(); end

  def peerip(); end

  def peerip=(peerip); end

  def read_body(); end

  def read_chunked_body(); end

  def ready(); end

  def remote_addr_header(); end

  def remote_addr_header=(remote_addr_header); end

  def reset(fast_check=T.unsafe(nil)); end

  def set_timeout(val); end

  def setup_body(); end

  def setup_chunked_body(body); end

  def tempfile(); end

  def timeout_at(); end

  def to_io(); end

  def try_to_finish(); end

  def write_400(); end

  def write_408(); end

  def write_500(); end
  EmptyBody = ::T.let(nil, ::T.untyped)
end

class Puma::Client
  extend ::Puma::Delegation
end

class Puma::Cluster
  def all_workers_booted?(); end

  def check_workers(force=T.unsafe(nil)); end

  def cull_workers(); end

  def halt(); end

  def next_worker_index(); end

  def phased_restart(); end

  def preload?(); end

  def reload_worker_directory(); end

  def restart(); end

  def run(); end

  def setup_signals(); end

  def spawn_workers(); end

  def start_phased_restart(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end

  def stop_workers(); end

  def wakeup!(); end

  def worker(index, master); end
  WORKER_CHECK_INTERVAL = ::T.let(nil, ::T.untyped)
end

class Puma::Cluster::Worker
  def boot!(); end

  def booted?(); end

  def dead!(); end

  def dead?(); end

  def hup(); end

  def index(); end

  def initialize(idx, pid, phase, options); end

  def kill(); end

  def last_checkin(); end

  def last_status(); end

  def phase(); end

  def pid(); end

  def ping!(status); end

  def ping_timeout?(which); end

  def signal(); end

  def term(); end
end

class Puma::Cluster::Worker
end

class Puma::Cluster
end

module Puma::ConfigDefault
  DefaultRackup = ::T.let(nil, ::T.untyped)
  DefaultTCPHost = ::T.let(nil, ::T.untyped)
  DefaultTCPPort = ::T.let(nil, ::T.untyped)
  DefaultWorkerShutdownTimeout = ::T.let(nil, ::T.untyped)
  DefaultWorkerTimeout = ::T.let(nil, ::T.untyped)
end

module Puma::ConfigDefault
  extend ::T::Sig
end

class Puma::Configuration
  include ::Puma::ConfigDefault
  def app(); end

  def app_configured?(); end

  def clamp(); end

  def config_files(); end

  def configure(); end

  def environment(); end

  def environment_str(); end

  def flatten(); end

  def flatten!(); end

  def initialize(user_options=T.unsafe(nil), default_options=T.unsafe(nil), &block); end

  def load(); end

  def load_plugin(name); end

  def options(); end

  def plugins(); end

  def puma_default_options(); end

  def rackup(); end

  def run_hooks(key, arg); end
end

class Puma::Configuration::ConfigMiddleware
  def call(env); end

  def initialize(config, app); end
end

class Puma::Configuration::ConfigMiddleware
end

class Puma::Configuration
  def self.random_token(); end

  def self.temp_path(); end
end

class Puma::ConnectionError
end

class Puma::ConnectionError
end

module Puma::Const
  CGI_VER = ::T.let(nil, ::T.untyped)
  CHUNKED = ::T.let(nil, ::T.untyped)
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  CLOSE = ::T.let(nil, ::T.untyped)
  CLOSE_CHUNKED = ::T.let(nil, ::T.untyped)
  CODE_NAME = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  CONNECTION_CLOSE = ::T.let(nil, ::T.untyped)
  CONNECTION_KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH2 = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH_S = ::T.let(nil, ::T.untyped)
  CONTINUE = ::T.let(nil, ::T.untyped)
  EARLY_HINTS = ::T.let(nil, ::T.untyped)
  ERROR_400_RESPONSE = ::T.let(nil, ::T.untyped)
  ERROR_404_RESPONSE = ::T.let(nil, ::T.untyped)
  ERROR_408_RESPONSE = ::T.let(nil, ::T.untyped)
  ERROR_500_RESPONSE = ::T.let(nil, ::T.untyped)
  ERROR_503_RESPONSE = ::T.let(nil, ::T.untyped)
  FAST_TRACK_KA_TIMEOUT = ::T.let(nil, ::T.untyped)
  FIRST_DATA_TIMEOUT = ::T.let(nil, ::T.untyped)
  GATEWAY_INTERFACE = ::T.let(nil, ::T.untyped)
  HALT_COMMAND = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HIJACK = ::T.let(nil, ::T.untyped)
  HIJACK_IO = ::T.let(nil, ::T.untyped)
  HIJACK_P = ::T.let(nil, ::T.untyped)
  HTTP = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTPS_KEY = ::T.let(nil, ::T.untyped)
  HTTP_10_200 = ::T.let(nil, ::T.untyped)
  HTTP_11 = ::T.let(nil, ::T.untyped)
  HTTP_11_100 = ::T.let(nil, ::T.untyped)
  HTTP_11_200 = ::T.let(nil, ::T.untyped)
  HTTP_CONNECTION = ::T.let(nil, ::T.untyped)
  HTTP_EXPECT = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_FOR = ::T.let(nil, ::T.untyped)
  KEEP_ALIVE = ::T.let(nil, ::T.untyped)
  LINE_END = ::T.let(nil, ::T.untyped)
  LOCALHOST = ::T.let(nil, ::T.untyped)
  LOCALHOST_ADDR = ::T.let(nil, ::T.untyped)
  LOCALHOST_IP = ::T.let(nil, ::T.untyped)
  MAX_BODY = ::T.let(nil, ::T.untyped)
  MAX_HEADER = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  PERSISTENT_TIMEOUT = ::T.let(nil, ::T.untyped)
  PORT_443 = ::T.let(nil, ::T.untyped)
  PORT_80 = ::T.let(nil, ::T.untyped)
  PUMA_CONFIG = ::T.let(nil, ::T.untyped)
  PUMA_PEERCERT = ::T.let(nil, ::T.untyped)
  PUMA_SERVER_STRING = ::T.let(nil, ::T.untyped)
  PUMA_SOCKET = ::T.let(nil, ::T.untyped)
  PUMA_TMP_BASE = ::T.let(nil, ::T.untyped)
  PUMA_VERSION = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_AFTER_REPLY = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  REMOTE_ADDR = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  REQUEST_URI = ::T.let(nil, ::T.untyped)
  RESTART_COMMAND = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SERVER_SOFTWARE = ::T.let(nil, ::T.untyped)
  STOP_COMMAND = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING2 = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING_CHUNKED = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  WRITE_TIMEOUT = ::T.let(nil, ::T.untyped)
end

module Puma::Const
  extend ::T::Sig
end

class Puma::DSL
  include ::Puma::ConfigDefault
  def _load_from(path); end

  def _offer_plugins(); end

  def activate_control_app(url=T.unsafe(nil), opts=T.unsafe(nil)); end

  def after_worker_boot(&block); end

  def after_worker_fork(&block); end

  def app(obj=T.unsafe(nil), &block); end

  def before_fork(&block); end

  def bind(url); end

  def clean_thread_locals(which=T.unsafe(nil)); end

  def clear_binds!(); end

  def daemonize(which=T.unsafe(nil)); end

  def debug(); end

  def directory(dir); end

  def drain_on_shutdown(which=T.unsafe(nil)); end

  def early_hints(answer=T.unsafe(nil)); end

  def environment(environment); end

  def first_data_timeout(seconds); end

  def force_shutdown_after(val=T.unsafe(nil)); end

  def get(key, default=T.unsafe(nil)); end

  def initialize(options, config); end

  def inject(&blk); end

  def load(file); end

  def log_requests(which=T.unsafe(nil)); end

  def lowlevel_error_handler(obj=T.unsafe(nil), &block); end

  def on_restart(&block); end

  def on_worker_boot(&block); end

  def on_worker_fork(&block); end

  def on_worker_shutdown(&block); end

  def persistent_timeout(seconds); end

  def pidfile(path); end

  def plugin(name); end

  def port(port, host=T.unsafe(nil)); end

  def preload_app!(answer=T.unsafe(nil)); end

  def prune_bundler(answer=T.unsafe(nil)); end

  def queue_requests(answer=T.unsafe(nil)); end

  def quiet(which=T.unsafe(nil)); end

  def rackup(path); end

  def restart_command(cmd); end

  def set_remote_address(val=T.unsafe(nil)); end

  def shutdown_debug(val=T.unsafe(nil)); end

  def ssl_bind(host, port, opts); end

  def state_path(path); end

  def stdout_redirect(stdout=T.unsafe(nil), stderr=T.unsafe(nil), append=T.unsafe(nil)); end

  def tag(string); end

  def tcp_mode(); end

  def tcp_mode!(); end

  def threads(min, max); end

  def worker_boot_timeout(timeout); end

  def worker_directory(dir); end

  def worker_shutdown_timeout(timeout); end

  def worker_timeout(timeout); end

  def workers(count); end
end

class Puma::DSL
end

module Puma::Delegation
  def forward(what, who); end
end

module Puma::Delegation
  extend ::T::Sig
end

class Puma::Events
  include ::Puma::Const
  def debug(str); end

  def error(str); end

  def fire(hook, *args); end

  def fire_on_booted!(); end

  def format(str); end

  def formatter(); end

  def formatter=(formatter); end

  def initialize(stdout, stderr); end

  def log(str); end

  def on_booted(&block); end

  def parse_error(server, env, error); end

  def register(hook, obj=T.unsafe(nil), &blk); end

  def ssl_error(server, peeraddr, peercert, error); end

  def stderr(); end

  def stdout(); end

  def unknown_error(server, error, kind=T.unsafe(nil), env=T.unsafe(nil)); end

  def write(str); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

class Puma::Events::DefaultFormatter
  def call(str); end
end

class Puma::Events::DefaultFormatter
end

class Puma::Events::PidFormatter
  def call(str); end
end

class Puma::Events::PidFormatter
end

class Puma::Events
  def self.null(); end

  def self.stdio(); end

  def self.strings(); end
end

class Puma::HttpParser
  def body(); end

  def error?(); end

  def execute(_, _1, _2); end

  def finish(); end

  def finished?(); end

  def nread(); end

  def reset(); end
end

class Puma::HttpParser
end

class Puma::HttpParserError
end

class Puma::HttpParserError
end

class Puma::IOBuffer
  def <<(_); end

  def append(*_); end

  def capacity(); end

  def reset(); end

  def to_str(); end

  def used(); end
end

class Puma::IOBuffer
end

class Puma::Launcher
  def binder(); end

  def config(); end

  def connected_port(); end

  def delete_pidfile(); end

  def events(); end

  def halt(); end

  def initialize(conf, launcher_args=T.unsafe(nil)); end

  def options(); end

  def phased_restart(); end

  def restart(); end

  def restart_args(); end

  def restart_dir(); end

  def run(); end

  def stats(); end

  def stop(); end

  def write_pid(); end

  def write_state(); end
  KEYS_NOT_TO_PERSIST_IN_STATE = ::T.let(nil, ::T.untyped)
end

class Puma::Launcher
end

module Puma::MiniSSL
  VERIFY_FAIL_IF_NO_PEER_CERT = ::T.let(nil, ::T.untyped)
  VERIFY_NONE = ::T.let(nil, ::T.untyped)
  VERIFY_PEER = ::T.let(nil, ::T.untyped)
end

class Puma::MiniSSL::Context
  def ca(); end

  def ca=(ca); end

  def cert(); end

  def cert=(cert); end

  def check(); end

  def key(); end

  def key=(key); end

  def ssl_cipher_filter(); end

  def ssl_cipher_filter=(ssl_cipher_filter); end

  def verify_mode(); end

  def verify_mode=(verify_mode); end
end

class Puma::MiniSSL::Context
end

class Puma::MiniSSL::Engine
  def extract(); end

  def init?(); end

  def inject(_); end

  def peercert(); end

  def read(); end

  def shutdown(); end

  def write(_); end
end

class Puma::MiniSSL::Engine
  def self.client(); end

  def self.server(_); end
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::SSLError
end

class Puma::MiniSSL::Server
  def accept(); end

  def accept_nonblock(); end

  def close(); end

  def initialize(socket, ctx); end

  def to_io(); end
end

class Puma::MiniSSL::Server
end

class Puma::MiniSSL::Socket
  def <<(data); end

  def close(); end

  def closed?(); end

  def engine_read_all(); end

  def flush(); end

  def initialize(socket, engine); end

  def peeraddr(); end

  def peercert(); end

  def read_and_drop(timeout=T.unsafe(nil)); end

  def read_nonblock(size, *_); end

  def readpartial(size); end

  def should_drop_bytes?(); end

  def syswrite(data); end

  def to_io(); end

  def write(data); end

  def write_nonblock(data, *_); end
end

class Puma::MiniSSL::Socket
end

module Puma::MiniSSL
  extend ::T::Sig
  def self.check(); end
end

class Puma::NullIO
  def close(); end

  def each(); end

  def eof?(); end

  def gets(); end

  def puts(*ary); end

  def read(count=T.unsafe(nil), _buffer=T.unsafe(nil)); end

  def rewind(); end

  def size(); end

  def sync=(v); end

  def write(*ary); end
end

class Puma::NullIO
end

class Puma::Plugin
  def in_background(&blk); end

  def initialize(loader); end

  def workers_supported?(); end
  CALLER_FILE = ::T.let(nil, ::T.untyped)
end

class Puma::Plugin
  def self.create(&blk); end

  def self.extract_name(ary); end
end

class Puma::PluginLoader
  def create(name); end

  def fire_starts(launcher); end
end

class Puma::PluginLoader
end

class Puma::PluginRegistry
  def add_background(blk); end

  def find(name); end

  def fire_background(); end

  def register(name, cls); end
end

class Puma::PluginRegistry
end

module Puma::Rack
end

class Puma::Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Puma::Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Puma::Rack::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Puma::Rack::Options
end

module Puma::Rack
  extend ::T::Sig
end

class Puma::Reactor
  def add(c); end

  def calculate_sleep(); end

  def clear!(); end

  def initialize(server, app_pool); end

  def run(); end

  def run_in_thread(); end

  def shutdown(); end
  DefaultSleepFor = ::T.let(nil, ::T.untyped)
end

class Puma::Reactor
end

class Puma::Runner
  def app(); end

  def before_restart(); end

  def daemon?(); end

  def debug(str); end

  def development?(); end

  def error(str); end

  def initialize(cli, events); end

  def load_and_bind(); end

  def log(str); end

  def output_header(mode); end

  def redirect_io(); end

  def redirected_io?(); end

  def ruby_engine(); end

  def start_control(); end

  def start_server(); end

  def test?(); end
end

class Puma::Runner
end

class Puma::Server
  include ::Puma::Const
  def add_ssl_listener(*args, &block); end

  def add_tcp_listener(*args, &block); end

  def add_unix_listener(*args, &block); end

  def app(); end

  def app=(app); end

  def auto_trim_time(); end

  def auto_trim_time=(auto_trim_time); end

  def backlog(); end

  def begin_restart(); end

  def binder(); end

  def binder=(binder); end

  def closed_socket?(socket); end

  def connected_port(*args, &block); end

  def cork_socket(socket); end

  def default_server_port(env); end

  def early_hints(); end

  def early_hints=(early_hints); end

  def events(); end

  def first_data_timeout(); end

  def first_data_timeout=(first_data_timeout); end

  def graceful_shutdown(); end

  def halt(sync=T.unsafe(nil)); end

  def handle_check(); end

  def handle_request(req, lines); end

  def handle_servers(); end

  def handle_servers_lopez_mode(); end

  def inherit_binder(bind); end

  def initialize(app, events=T.unsafe(nil), options=T.unsafe(nil)); end

  def leak_stack_on_error(); end

  def leak_stack_on_error=(leak_stack_on_error); end

  def lowlevel_error(e, env); end

  def max_threads(); end

  def max_threads=(max_threads); end

  def min_threads(); end

  def min_threads=(min_threads); end

  def normalize_env(env, client); end

  def persistent_timeout(); end

  def persistent_timeout=(persistent_timeout); end

  def pool_capacity(); end

  def process_client(client, buffer); end

  def read_body(env, client, body, cl); end

  def reaping_time(); end

  def reaping_time=(reaping_time); end

  def run(background=T.unsafe(nil)); end

  def run_lopez_mode(background=T.unsafe(nil)); end

  def running(); end

  def shutting_down?(); end

  def stop(sync=T.unsafe(nil)); end

  def tcp_mode!(); end

  def thread(); end

  def uncork_socket(socket); end
  ThreadLocalKey = ::T.let(nil, ::T.untyped)
end

class Puma::Server
  extend ::Puma::Delegation
  def self.current(); end
end

class Puma::Single
  def halt(); end

  def jruby_daemon?(); end

  def jruby_daemon_start(); end

  def restart(); end

  def run(); end

  def stats(); end

  def stop(); end

  def stop_blocked(); end
end

class Puma::Single
end

class Puma::ThreadPool
  def <<(work); end

  def auto_reap!(timeout=T.unsafe(nil)); end

  def auto_trim!(timeout=T.unsafe(nil)); end

  def backlog(); end

  def clean_thread_locals(); end

  def clean_thread_locals=(clean_thread_locals); end

  def initialize(min, max, *extra, &block); end

  def pool_capacity(); end

  def reap(); end

  def shutdown(timeout=T.unsafe(nil)); end

  def spawned(); end

  def trim(force=T.unsafe(nil)); end

  def trim_requested(); end

  def wait_until_not_full(); end

  def waiting(); end
  SHUTDOWN_GRACE_TIME = ::T.let(nil, ::T.untyped)
end

class Puma::ThreadPool::AutoTrim
  def initialize(pool, timeout); end

  def start!(); end

  def stop(); end
end

class Puma::ThreadPool::AutoTrim
end

class Puma::ThreadPool::ForceShutdown
end

class Puma::ThreadPool::ForceShutdown
end

class Puma::ThreadPool::Reaper
  def initialize(pool, timeout); end

  def start!(); end

  def stop(); end
end

class Puma::ThreadPool::Reaper
end

class Puma::ThreadPool
  def self.clean_thread_locals(); end
end

class Puma::UnknownPlugin
end

class Puma::UnknownPlugin
end

class Puma::UnsupportedOption
end

class Puma::UnsupportedOption
end

class Puma::UserFileDefaultOptions
  def [](key); end

  def []=(key, value); end

  def all_of(key); end

  def default_options(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def file_options(); end

  def finalize_values(); end

  def initialize(user_options, default_options); end

  def user_options(); end
end

class Puma::UserFileDefaultOptions
end

module Puma::Util
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Puma::Util::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def replace(other); end
end

class Puma::Util::HeaderHash
  def self.new(hash=T.unsafe(nil)); end
end

module Puma::Util
  extend ::T::Sig
  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.pipe(); end

  def self.unescape(s, encoding=T.unsafe(nil)); end
end

module Puma
  extend ::T::Sig
  def self.jruby?(); end

  def self.stats(); end

  def self.stats_object=(val); end

  def self.windows?(); end
end

module Pundit
  def authorize(record, query=T.unsafe(nil), policy_class: T.unsafe(nil)); end

  def permitted_attributes(record, action=T.unsafe(nil)); end

  def policies(); end

  def policy(record); end

  def policy_scope(scope, policy_scope_class: T.unsafe(nil)); end

  def policy_scopes(); end

  def pundit_params_for(record); end

  def pundit_policy_authorized?(); end

  def pundit_policy_scoped?(); end

  def pundit_user(); end

  def skip_authorization(); end

  def skip_policy_scope(); end

  def verify_authorized(); end

  def verify_policy_scoped(); end
  SUFFIX = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Pundit::AuthorizationNotPerformedError
end

class Pundit::AuthorizationNotPerformedError
end

class Pundit::Error
end

class Pundit::Error
end

module Pundit::Generators
end

module Pundit::Generators
  extend ::T::Sig
end

module Pundit::Helper
  def policy_scope(scope); end
end

module Pundit::Helper
  extend ::T::Sig
end

class Pundit::InvalidConstructorError
end

class Pundit::InvalidConstructorError
end

class Pundit::NotAuthorizedError
  def initialize(options=T.unsafe(nil)); end

  def policy(); end

  def query(); end

  def record(); end
end

class Pundit::NotAuthorizedError
end

class Pundit::NotDefinedError
end

class Pundit::NotDefinedError
end

class Pundit::PolicyFinder
  def initialize(object); end

  def object(); end

  def param_key(); end

  def policy(); end

  def policy!(); end

  def scope(); end

  def scope!(); end
end

class Pundit::PolicyFinder
end

class Pundit::PolicyScopingNotPerformedError
end

class Pundit::PolicyScopingNotPerformedError
end

module Pundit
  extend ::ActiveSupport::Concern
  extend ::T::Sig
  def self.authorize(user, record, query, policy_class: T.unsafe(nil)); end

  def self.policy(user, record); end

  def self.policy!(user, record); end

  def self.policy_scope(user, scope); end

  def self.policy_scope!(user, scope); end
end

module QueryHelper
  extend ::T::Sig
end

Queue = Thread::Queue

module REST
  VERSION = ::T.let(nil, ::T.untyped)
end

module REST::Error
end

module REST::Error::Connection
  include ::REST::Error
end

module REST::Error::Connection
  extend ::T::Sig
  def self.class_names(); end

  def self.classes(); end

  def self.extend_classes!(); end
end

module REST::Error::Protocol
  include ::REST::Error
end

module REST::Error::Protocol
  extend ::T::Sig
  def self.class_names(); end

  def self.classes(); end

  def self.extend_classes!(); end
end

module REST::Error::Timeout
  include ::REST::Error
end

module REST::Error::Timeout
  extend ::T::Sig
  def self.class_names(); end

  def self.classes(); end

  def self.extend_classes!(); end
end

module REST::Error
  extend ::T::Sig
end

class REST::Request
  def body(); end

  def body=(body); end

  def headers(); end

  def headers=(headers); end

  def http_proxy(); end

  def http_request(); end

  def initialize(verb, url, body=T.unsafe(nil), headers=T.unsafe(nil), options=T.unsafe(nil), &configure_block); end

  def options(); end

  def options=(options); end

  def path(); end

  def perform(); end

  def proxy_env(); end

  def proxy_settings(); end

  def request(); end

  def request=(request); end

  def request_for_verb(); end

  def url(); end

  def url=(url); end

  def verb(); end

  def verb=(verb); end
end

class REST::Request
  def self.perform(*args, &configure_block); end
end

class REST::Response
  def bad_request?(); end

  def body(); end

  def body=(body); end

  def created?(); end

  def forbidden?(); end

  def found?(); end

  def headers(); end

  def headers=(headers); end

  def initialize(status_code, headers=T.unsafe(nil), body=T.unsafe(nil)); end

  def internal_server_error?(); end

  def moved_permanently?(); end

  def not_found?(); end

  def ok?(); end

  def status_code(); end

  def status_code=(status_code); end

  def success?(); end

  def unauthorized?(); end

  def unprocessable_entity?(); end
  CODES = ::T.let(nil, ::T.untyped)
end

class REST::Response
end

module REST
  extend ::T::Sig
  def self.delete(uri, headers=T.unsafe(nil), options=T.unsafe(nil), &configure_block); end

  def self.get(uri, headers=T.unsafe(nil), options=T.unsafe(nil), &configure_block); end

  def self.head(uri, headers=T.unsafe(nil), options=T.unsafe(nil), &configure_block); end

  def self.patch(uri, body, headers=T.unsafe(nil), options=T.unsafe(nil), &configure_block); end

  def self.post(uri, body, headers=T.unsafe(nil), options=T.unsafe(nil), &configure_block); end

  def self.put(uri, body, headers=T.unsafe(nil), options=T.unsafe(nil), &configure_block); end
end

module REXML
  COPYRIGHT = ::T.let(nil, ::T.untyped)
  Copyright = ::T.let(nil, ::T.untyped)
  DATE = ::T.let(nil, ::T.untyped)
  REVISION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class REXML::AttlistDecl
  include ::Enumerable
  def [](key); end

  def each(&block); end

  def element_name(); end

  def include?(key); end

  def initialize(source); end

  def node_type(); end

  def write(out, indent=T.unsafe(nil)); end
end

class REXML::AttlistDecl
end

class REXML::Attribute
  include ::REXML::Node
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def ==(other); end

  def clone(); end

  def doctype(); end

  def element(); end

  def element=(element); end

  def initialize(first, second=T.unsafe(nil), parent=T.unsafe(nil)); end

  def namespace(arg=T.unsafe(nil)); end

  def node_type(); end

  def normalized=(normalized); end

  def remove(); end

  def to_s(); end

  def to_string(); end

  def value(); end

  def write(output, indent=T.unsafe(nil)); end

  def xpath(); end
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class REXML::Attribute
end

class REXML::Attributes
  def <<(attribute); end

  def [](name); end

  def []=(name, value); end

  def add(attribute); end

  def delete(attribute); end

  def delete_all(name); end

  def each_attribute(); end

  def get_attribute(name); end

  def get_attribute_ns(namespace, name); end

  def initialize(element); end

  def namespaces(); end

  def prefixes(); end
end

class REXML::Attributes
end

class REXML::CData
  def initialize(first, whitespace=T.unsafe(nil), parent=T.unsafe(nil)); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  ILLEGAL = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::CData
end

class REXML::Child
  include ::REXML::Node
  def bytes(); end

  def document(); end

  def initialize(parent=T.unsafe(nil)); end

  def next_sibling(); end

  def next_sibling=(other); end

  def parent(); end

  def parent=(other); end

  def previous_sibling(); end

  def previous_sibling=(other); end

  def remove(); end

  def replace_with(child); end
end

class REXML::Child
end

class REXML::Comment
  include ::Comparable
  def ==(other); end

  def clone(); end

  def initialize(first, second=T.unsafe(nil)); end

  def node_type(); end

  def string(); end

  def string=(string); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Comment
end

class REXML::Declaration
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::Declaration
end

class REXML::DocType
  include ::REXML::XMLTokens
  def add(child); end

  def attribute_of(element, attribute); end

  def attributes_of(element); end

  def clone(); end

  def context(); end

  def entities(); end

  def entity(name); end

  def external_id(); end

  def initialize(first, parent=T.unsafe(nil)); end

  def name(); end

  def namespaces(); end

  def node_type(); end

  def notation(name); end

  def notations(); end

  def public(); end

  def system(); end

  def write(output, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
end

class REXML::DocType
end

class REXML::Document
  def <<(child); end

  def add(child); end

  def add_element(arg=T.unsafe(nil), arg2=T.unsafe(nil)); end

  def doctype(); end

  def encoding(); end

  def entity_expansion_count(); end

  def initialize(source=T.unsafe(nil), context=T.unsafe(nil)); end

  def record_entity_expansion(); end

  def stand_alone?(); end

  def version(); end

  def write(*arguments); end

  def xml_decl(); end
  DECLARATION = ::T.let(nil, ::T.untyped)
end

class REXML::Document
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end

  def self.parse_stream(source, listener); end
end

class REXML::Element
  include ::REXML::Namespace
  include ::REXML::XMLTokens
  def [](name_or_index); end

  def add_attribute(key, value=T.unsafe(nil)); end

  def add_attributes(hash); end

  def add_element(element, attrs=T.unsafe(nil)); end

  def add_namespace(prefix, uri=T.unsafe(nil)); end

  def add_text(text); end

  def attribute(name, namespace=T.unsafe(nil)); end

  def attributes(); end

  def cdatas(); end

  def clone(); end

  def comments(); end

  def context(); end

  def context=(context); end

  def delete_attribute(key); end

  def delete_element(element); end

  def delete_namespace(namespace=T.unsafe(nil)); end

  def each_element(xpath=T.unsafe(nil), &block); end

  def each_element_with_attribute(key, value=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def each_element_with_text(text=T.unsafe(nil), max=T.unsafe(nil), name=T.unsafe(nil), &block); end

  def elements(); end

  def get_elements(xpath); end

  def get_text(path=T.unsafe(nil)); end

  def has_attributes?(); end

  def has_elements?(); end

  def has_text?(); end

  def ignore_whitespace_nodes(); end

  def initialize(arg=T.unsafe(nil), parent=T.unsafe(nil), context=T.unsafe(nil)); end

  def instructions(); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespaces(); end

  def next_element(); end

  def node_type(); end

  def prefixes(); end

  def previous_element(); end

  def raw(); end

  def root(); end

  def root_node(); end

  def text(path=T.unsafe(nil)); end

  def text=(text); end

  def texts(); end

  def whitespace(); end

  def write(output=T.unsafe(nil), indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def xpath(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

class REXML::Element
end

class REXML::ElementDecl
end

class REXML::ElementDecl
end

class REXML::Elements
  include ::Enumerable
  def <<(element=T.unsafe(nil)); end

  def [](index, name=T.unsafe(nil)); end

  def []=(index, element); end

  def add(element=T.unsafe(nil)); end

  def collect(xpath=T.unsafe(nil)); end

  def delete(element); end

  def delete_all(xpath); end

  def each(xpath=T.unsafe(nil)); end

  def empty?(); end

  def index(element); end

  def initialize(parent); end

  def inject(xpath=T.unsafe(nil), initial=T.unsafe(nil)); end

  def size(); end

  def to_a(xpath=T.unsafe(nil)); end
end

class REXML::Elements
end

module REXML::Encoding
  def decode(string); end

  def encode(string); end

  def encoding(); end

  def encoding=(encoding); end
end

module REXML::Encoding
  extend ::T::Sig
end

class REXML::Entity
  include ::REXML::XMLTokens
  def external(); end

  def initialize(stream, value=T.unsafe(nil), parent=T.unsafe(nil), reference=T.unsafe(nil)); end

  def name(); end

  def ndata(); end

  def normalized(); end

  def pubid(); end

  def ref(); end

  def to_s(); end

  def unnormalized(); end

  def value(); end

  def write(out, indent=T.unsafe(nil)); end
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PEREFERENCE_RE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::Entity
  def self.matches?(string); end
end

module REXML::EntityConst
  AMP = ::T.let(nil, ::T.untyped)
  APOS = ::T.let(nil, ::T.untyped)
  GT = ::T.let(nil, ::T.untyped)
  LT = ::T.let(nil, ::T.untyped)
  QUOT = ::T.let(nil, ::T.untyped)
end

module REXML::EntityConst
  extend ::T::Sig
end

class REXML::ExternalEntity
  def initialize(src); end

  def to_s(); end

  def write(output, indent); end
end

class REXML::ExternalEntity
end

module REXML::Formatters
end

class REXML::Formatters::Default
  def initialize(ie_hack=T.unsafe(nil)); end

  def write(node, output); end

  def write_cdata(node, output); end

  def write_comment(node, output); end

  def write_document(node, output); end

  def write_element(node, output); end

  def write_instruction(node, output); end

  def write_text(node, output); end
end

class REXML::Formatters::Default
end

class REXML::Formatters::Pretty
  def compact(); end

  def compact=(compact); end

  def initialize(indentation=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def width(); end

  def width=(width); end
end

class REXML::Formatters::Pretty
end

module REXML::Formatters
  extend ::T::Sig
end

module REXML::Functions
  INTERNAL_METHODS = ::T.let(nil, ::T.untyped)
end

module REXML::Functions
  extend ::T::Sig
  def self.boolean(object=T.unsafe(nil)); end

  def self.ceiling(number); end

  def self.compare_language(lang1, lang2); end

  def self.concat(*objects); end

  def self.contains(string, test); end

  def self.context=(value); end

  def self.count(node_set); end

  def self.false(); end

  def self.floor(number); end

  def self.get_namespace(node_set=T.unsafe(nil)); end

  def self.id(object); end

  def self.lang(language); end

  def self.last(); end

  def self.local_name(node_set=T.unsafe(nil)); end

  def self.name(node_set=T.unsafe(nil)); end

  def self.namespace_context(); end

  def self.namespace_context=(x); end

  def self.namespace_uri(node_set=T.unsafe(nil)); end

  def self.normalize_space(string=T.unsafe(nil)); end

  def self.not(object); end

  def self.number(object=T.unsafe(nil)); end

  def self.position(); end

  def self.processing_instruction(node); end

  def self.round(number); end

  def self.send(name, *args); end

  def self.singleton_method_added(name); end

  def self.starts_with(string, test); end

  def self.string(object=T.unsafe(nil)); end

  def self.string_length(string); end

  def self.string_value(o); end

  def self.substring(string, start, length=T.unsafe(nil)); end

  def self.substring_after(string, test); end

  def self.substring_before(string, test); end

  def self.sum(nodes); end

  def self.text(); end

  def self.translate(string, tr1, tr2); end

  def self.true(); end

  def self.variables(); end

  def self.variables=(x); end
end

class REXML::IOSource
  def initialize(arg, block_size=T.unsafe(nil), encoding=T.unsafe(nil)); end
end

class REXML::IOSource
end

class REXML::Instruction
  def ==(other); end

  def clone(); end

  def content(); end

  def content=(content); end

  def initialize(target, content=T.unsafe(nil)); end

  def node_type(); end

  def target(); end

  def target=(target); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::Instruction
end

module REXML::Light
end

class REXML::Light::Node
  def <<(element); end

  def =~(path); end

  def [](reference, ns=T.unsafe(nil)); end

  def []=(reference, ns, value=T.unsafe(nil)); end

  def children(); end

  def each(); end

  def has_name?(name, namespace=T.unsafe(nil)); end

  def initialize(node=T.unsafe(nil)); end

  def local_name(); end

  def local_name=(name_str); end

  def name(); end

  def name=(name_str, ns=T.unsafe(nil)); end

  def namespace(prefix=T.unsafe(nil)); end

  def namespace=(namespace); end

  def node_type(); end

  def parent(); end

  def parent=(node); end

  def prefix(namespace=T.unsafe(nil)); end

  def root(); end

  def size(); end

  def text=(foo); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
  PARENTS = ::T.let(nil, ::T.untyped)
end

class REXML::Light::Node
end

module REXML::Light
  extend ::T::Sig
end

module REXML::Namespace
  include ::REXML::XMLTokens
  def expanded_name(); end

  def fully_expanded_name(); end

  def has_name?(other, ns=T.unsafe(nil)); end

  def local_name(); end

  def name(); end

  def name=(name); end

  def prefix(); end

  def prefix=(prefix); end
  NAMESPLIT = ::T.let(nil, ::T.untyped)
end

module REXML::Namespace
  extend ::T::Sig
end

module REXML::Node
  def each_recursive(&block); end

  def find_first_recursive(&block); end

  def indent(to, ind); end

  def index_in_parent(); end

  def next_sibling_node(); end

  def parent?(); end

  def previous_sibling_node(); end

  def to_s(indent=T.unsafe(nil)); end
end

module REXML::Node
  extend ::T::Sig
end

class REXML::NotationDecl
  def initialize(name, middle, pub, sys); end

  def name(); end

  def public(); end

  def public=(public); end

  def system(); end

  def system=(system); end

  def to_s(); end

  def write(output, indent=T.unsafe(nil)); end
end

class REXML::NotationDecl
end

class REXML::Output
  include ::REXML::Encoding
  def <<(content); end

  def initialize(real_IO, encd=T.unsafe(nil)); end
end

class REXML::Output
end

class REXML::Parent
  include ::Enumerable
  def <<(object); end

  def [](index); end

  def []=(*args); end

  def add(object); end

  def children(); end

  def deep_clone(); end

  def delete(object); end

  def delete_at(index); end

  def delete_if(&block); end

  def each(&block); end

  def each_child(&block); end

  def each_index(&block); end

  def index(child); end

  def insert_after(child1, child2); end

  def insert_before(child1, child2); end

  def length(); end

  def push(object); end

  def replace_child(to_replace, replacement); end

  def size(); end

  def to_a(); end

  def unshift(object); end
end

class REXML::Parent
end

class REXML::ParseException
  def context(); end

  def continued_exception(); end

  def continued_exception=(continued_exception); end

  def initialize(message, source=T.unsafe(nil), parser=T.unsafe(nil), exception=T.unsafe(nil)); end

  def line(); end

  def parser(); end

  def parser=(parser); end

  def position(); end

  def source(); end

  def source=(source); end
end

class REXML::ParseException
end

module REXML::Parsers
end

class REXML::Parsers::BaseParser
  def add_listener(listener); end

  def empty?(); end

  def entity(reference, entities); end

  def has_next?(); end

  def initialize(source); end

  def normalize(input, entities=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def peek(depth=T.unsafe(nil)); end

  def position(); end

  def pull(); end

  def source(); end

  def stream=(source); end

  def unnormalize(string, entities=T.unsafe(nil), filter=T.unsafe(nil)); end

  def unshift(token); end
  ATTDEF = ::T.let(nil, ::T.untyped)
  ATTDEF_RE = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ATTLISTDECL_START = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_PATTERN = ::T.let(nil, ::T.untyped)
  ATTTYPE = ::T.let(nil, ::T.untyped)
  ATTVALUE = ::T.let(nil, ::T.untyped)
  CDATA_END = ::T.let(nil, ::T.untyped)
  CDATA_PATTERN = ::T.let(nil, ::T.untyped)
  CDATA_START = ::T.let(nil, ::T.untyped)
  CLOSE_MATCH = ::T.let(nil, ::T.untyped)
  COMBININGCHAR = ::T.let(nil, ::T.untyped)
  COMMENT_PATTERN = ::T.let(nil, ::T.untyped)
  COMMENT_START = ::T.let(nil, ::T.untyped)
  DEFAULTDECL = ::T.let(nil, ::T.untyped)
  DEFAULT_ENTITIES = ::T.let(nil, ::T.untyped)
  DIGIT = ::T.let(nil, ::T.untyped)
  DOCTYPE_END = ::T.let(nil, ::T.untyped)
  DOCTYPE_PATTERN = ::T.let(nil, ::T.untyped)
  DOCTYPE_START = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_PATTERN = ::T.let(nil, ::T.untyped)
  ELEMENTDECL_START = ::T.let(nil, ::T.untyped)
  ENCODING = ::T.let(nil, ::T.untyped)
  ENTITYDECL = ::T.let(nil, ::T.untyped)
  ENTITYDEF = ::T.let(nil, ::T.untyped)
  ENTITYVALUE = ::T.let(nil, ::T.untyped)
  ENTITY_START = ::T.let(nil, ::T.untyped)
  ENUMERATEDTYPE = ::T.let(nil, ::T.untyped)
  ENUMERATION = ::T.let(nil, ::T.untyped)
  EREFERENCE = ::T.let(nil, ::T.untyped)
  EXTENDER = ::T.let(nil, ::T.untyped)
  EXTERNALID = ::T.let(nil, ::T.untyped)
  GEDECL = ::T.let(nil, ::T.untyped)
  IDENTITY = ::T.let(nil, ::T.untyped)
  INSTRUCTION_PATTERN = ::T.let(nil, ::T.untyped)
  INSTRUCTION_START = ::T.let(nil, ::T.untyped)
  LETTER = ::T.let(nil, ::T.untyped)
  MISSING_ATTRIBUTE_QUOTES = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NDATADECL = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  NOTATIONDECL_START = ::T.let(nil, ::T.untyped)
  NOTATIONTYPE = ::T.let(nil, ::T.untyped)
  PEDECL = ::T.let(nil, ::T.untyped)
  PEDEF = ::T.let(nil, ::T.untyped)
  PEREFERENCE = ::T.let(nil, ::T.untyped)
  PUBIDCHAR = ::T.let(nil, ::T.untyped)
  PUBIDLITERAL = ::T.let(nil, ::T.untyped)
  PUBLIC = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  REFERENCE_RE = ::T.let(nil, ::T.untyped)
  STANDALONE = ::T.let(nil, ::T.untyped)
  SYSTEM = ::T.let(nil, ::T.untyped)
  SYSTEMENTITY = ::T.let(nil, ::T.untyped)
  SYSTEMLITERAL = ::T.let(nil, ::T.untyped)
  TAG_MATCH = ::T.let(nil, ::T.untyped)
  TEXT_PATTERN = ::T.let(nil, ::T.untyped)
  UNAME_STR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  XMLDECL_PATTERN = ::T.let(nil, ::T.untyped)
  XMLDECL_START = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::BaseParser
end

class REXML::Parsers::StreamParser
  def add_listener(listener); end

  def initialize(source, listener); end

  def parse(); end
end

class REXML::Parsers::StreamParser
end

class REXML::Parsers::TreeParser
  def add_listener(listener); end

  def initialize(source, build_context=T.unsafe(nil)); end

  def parse(); end
end

class REXML::Parsers::TreeParser
end

class REXML::Parsers::XPathParser
  include ::REXML::XMLTokens
  def abbreviate(path); end

  def expand(path); end

  def namespaces=(namespaces); end

  def parse(path); end

  def predicate(path); end

  def predicate_to_string(path, &block); end
  AXIS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
  NCNAMETEST = ::T.let(nil, ::T.untyped)
  NODE_TYPE = ::T.let(nil, ::T.untyped)
  NT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  PI = ::T.let(nil, ::T.untyped)
  QNAME = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE = ::T.let(nil, ::T.untyped)
end

class REXML::Parsers::XPathParser
end

module REXML::Parsers
  extend ::T::Sig
end

module REXML::Security
end

module REXML::Security
  extend ::T::Sig
  def self.entity_expansion_limit(); end

  def self.entity_expansion_limit=(val); end

  def self.entity_expansion_text_limit(); end

  def self.entity_expansion_text_limit=(val); end
end

class REXML::Source
  include ::REXML::Encoding
  def buffer(); end

  def consume(pattern); end

  def current_line(); end

  def empty?(); end

  def encoding=(enc); end

  def initialize(arg, encoding=T.unsafe(nil)); end

  def line(); end

  def match(pattern, cons=T.unsafe(nil)); end

  def match_to(char, pattern); end

  def match_to_consume(char, pattern); end

  def position(); end

  def read(); end

  def scan(pattern, cons=T.unsafe(nil)); end
end

class REXML::Source
end

class REXML::SourceFactory
end

class REXML::SourceFactory
  def self.create_from(arg); end
end

class REXML::SyncEnumerator
  include ::Enumerable
  def each(); end

  def initialize(*enums); end

  def length(); end

  def size(); end
end

class REXML::SyncEnumerator
end

class REXML::Text
  include ::Comparable
  def <<(to_append); end

  def clone(); end

  def doctype(); end

  def empty?(); end

  def indent_text(string, level=T.unsafe(nil), style=T.unsafe(nil), indentfirstline=T.unsafe(nil)); end

  def initialize(arg, respect_whitespace=T.unsafe(nil), parent=T.unsafe(nil), raw=T.unsafe(nil), entity_filter=T.unsafe(nil), illegal=T.unsafe(nil)); end

  def node_type(); end

  def parent=(parent); end

  def raw(); end

  def raw=(raw); end

  def to_s(); end

  def value(); end

  def value=(val); end

  def wrap(string, width, addnewline=T.unsafe(nil)); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def write_with_substitution(out, input); end

  def xpath(); end
  EREFERENCE = ::T.let(nil, ::T.untyped)
  NEEDS_A_SECOND_CHECK = ::T.let(nil, ::T.untyped)
  NUMERICENTITY = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
  SETUTITSBUS = ::T.let(nil, ::T.untyped)
  SLAICEPS = ::T.let(nil, ::T.untyped)
  SPECIALS = ::T.let(nil, ::T.untyped)
  SUBSTITUTES = ::T.let(nil, ::T.untyped)
  VALID_CHAR = ::T.let(nil, ::T.untyped)
  VALID_XML_CHARS = ::T.let(nil, ::T.untyped)
end

class REXML::Text
  def self.check(string, pattern, doctype); end

  def self.expand(ref, doctype, filter); end

  def self.normalize(input, doctype=T.unsafe(nil), entity_filter=T.unsafe(nil)); end

  def self.read_with_substitution(input, illegal=T.unsafe(nil)); end

  def self.unnormalize(string, doctype=T.unsafe(nil), filter=T.unsafe(nil), illegal=T.unsafe(nil)); end
end

class REXML::UndefinedNamespaceException
  def initialize(prefix, source, parser); end
end

class REXML::UndefinedNamespaceException
end

module REXML::Validation
end

class REXML::Validation::ValidationException
  def initialize(msg); end
end

class REXML::Validation::ValidationException
end

module REXML::Validation
  extend ::T::Sig
end

class REXML::XMLDecl
  include ::REXML::Encoding
  def ==(other); end

  def clone(); end

  def dowrite(); end

  def encoding=(enc); end

  def initialize(version=T.unsafe(nil), encoding=T.unsafe(nil), standalone=T.unsafe(nil)); end

  def node_type(); end

  def nowrite(); end

  def old_enc=(encoding); end

  def stand_alone?(); end

  def standalone(); end

  def standalone=(standalone); end

  def version(); end

  def version=(version); end

  def write(writer, indent=T.unsafe(nil), transitive=T.unsafe(nil), ie_hack=T.unsafe(nil)); end

  def writeencoding(); end

  def writethis(); end

  def xmldecl(version, encoding, standalone); end
  DEFAULT_ENCODING = ::T.let(nil, ::T.untyped)
  DEFAULT_STANDALONE = ::T.let(nil, ::T.untyped)
  DEFAULT_VERSION = ::T.let(nil, ::T.untyped)
  START = ::T.let(nil, ::T.untyped)
  STOP = ::T.let(nil, ::T.untyped)
end

class REXML::XMLDecl
  def self.default(); end
end

module REXML::XMLTokens
  NAME = ::T.let(nil, ::T.untyped)
  NAMECHAR = ::T.let(nil, ::T.untyped)
  NAME_CHAR = ::T.let(nil, ::T.untyped)
  NAME_START_CHAR = ::T.let(nil, ::T.untyped)
  NAME_STR = ::T.let(nil, ::T.untyped)
  NCNAME_STR = ::T.let(nil, ::T.untyped)
  NMTOKEN = ::T.let(nil, ::T.untyped)
  NMTOKENS = ::T.let(nil, ::T.untyped)
  REFERENCE = ::T.let(nil, ::T.untyped)
end

module REXML::XMLTokens
  extend ::T::Sig
end

class REXML::XPath
  include ::REXML::Functions
  EMPTY_HASH = ::T.let(nil, ::T.untyped)
end

class REXML::XPath
  def self.each(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil), &block); end

  def self.first(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil)); end

  def self.match(element, path=T.unsafe(nil), namespaces=T.unsafe(nil), variables=T.unsafe(nil)); end
end

class REXML::XPathParser
  include ::REXML::XMLTokens
  def []=(variable_name, value); end

  def first(path_stack, node); end

  def get_first(path, nodeset); end

  def match(path_stack, nodeset); end

  def namespaces=(namespaces=T.unsafe(nil)); end

  def parse(path, nodeset); end

  def predicate(path, nodeset); end

  def variables=(vars=T.unsafe(nil)); end
  ALL = ::T.let(nil, ::T.untyped)
  ELEMENTS = ::T.let(nil, ::T.untyped)
  LITERAL = ::T.let(nil, ::T.untyped)
end

class REXML::XPathParser
end

module REXML
  extend ::T::Sig
end

class REXMLUtilityNode
  def add_node(node); end

  def attributes(); end

  def attributes=(attributes); end

  def children(); end

  def children=(children); end

  def initialize(name, normalized_attributes=T.unsafe(nil)); end

  def inner_html(); end

  def name(); end

  def name=(name); end

  def to_hash(); end

  def to_html(); end

  def type(); end

  def type=(type); end

  def typecast_value(value); end

  def undasherize_keys(params); end
end

class REXMLUtilityNode
  def self.available_typecasts(); end

  def self.available_typecasts=(obj); end

  def self.typecasts(); end

  def self.typecasts=(obj); end
end

class REXMLUtiliyNodeString
  def attributes(); end

  def attributes=(attributes); end
end

class REXMLUtiliyNodeString
end

RSPEC_CONFIGURER = RSpec

module RSpec
end

module RSpec::Core
end

class RSpec::Core::Example
end

RSPEC_NAMESPACE::Core::Example::AllExceptionsExcludingDangerousOnesOnRubiesThatAllowIt = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

class RSpec::Core::Example
end

RSPEC_NAMESPACE::Core::ExclusionRules = RSpec::Core::FilterRules

RSPEC_NAMESPACE::Core::FilterRules = RSpec::Core::FilterRules

module RSpec::Core::Formatters
end

class RSpec::Core::Formatters::SyntaxHighlighter
end

RSPEC_NAMESPACE::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

RSPEC_NAMESPACE::Core::Formatters::SyntaxHighlighter::WindowsImplementation = RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation

class RSpec::Core::Formatters::SyntaxHighlighter
end

module RSpec::Core::Formatters
end

RSPEC_NAMESPACE::Core::SharedContext = RSpec::Core::SharedContext

module RSpec::Core
end

module RSpec::Expectations
end

class RSpec::Expectations::ExpectationTarget
end

RSPEC_NAMESPACE::Expectations::ExpectationTarget::InstanceMethods = RSpec::Expectations::ExpectationTarget::InstanceMethods

class RSpec::Expectations::ExpectationTarget
end

RSPEC_NAMESPACE::Expectations::LegacyMacherAdapter = RSpec::Expectations::LegacyMatcherAdapter

RSPEC_NAMESPACE::Expectations::LegacyMatcherAdapter = RSpec::Expectations::LegacyMatcherAdapter

module RSpec::Expectations
end

module RSpec::Matchers
end

class RSpec::Matchers::AliasedNegatedMatcher
end

RSPEC_NAMESPACE::Matchers::AliasedNegatedMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

class RSpec::Matchers::AliasedNegatedMatcher
end

module RSpec::Matchers::BuiltIn
end

class RSpec::Matchers::BuiltIn::BaseMatcher
end

RSPEC_NAMESPACE::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages = RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages

RSPEC_NAMESPACE::Matchers::BuiltIn::BaseMatcher::HashFormatting = RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting

class RSpec::Matchers::BuiltIn::BaseMatcher
end

module RSpec::Matchers::BuiltIn
end

RSPEC_NAMESPACE::Matchers::Composable = RSpec::Matchers::Composable

RSPEC_NAMESPACE::Matchers::MatcherDelegator = RSpec::Matchers::MatcherDelegator

module RSpec::Matchers
end

RSPEC_NAMESPACE::SharedContext = RSpec::Core::SharedContext

module RSpec::Support
end

RSPEC_NAMESPACE::Support::AllExceptionsExceptOnesWeMustNotRescue = RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue

RSPEC_NAMESPACE::Support::MethodSignatureVerifier = RSpec::Support::MethodSignatureVerifier

RSPEC_NAMESPACE::Support::StrictSignatureVerifier = RSpec::Support::MethodSignatureVerifier

module RSpec::Support
end

module RSpec
end

module RSpec
  MODULES_TO_AUTOLOAD = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  ADDITIONAL_TOP_LEVEL_FILES = ::T.let(nil, ::T.untyped)
  IGNORE_REGEX = ::T.let(nil, ::T.untyped)
  LIB_REGEX = ::T.let(nil, ::T.untyped)
  RSPEC_LIBS = ::T.let(nil, ::T.untyped)
end

class RSpec::CallerFilter
  def self.first_non_rspec_line(skip_frames=T.unsafe(nil), increment=T.unsafe(nil)); end
end

module RSpec::Core
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::AnonymousExampleGroup
end

class RSpec::Core::BacktraceFormatter
  def backtrace_line(line); end

  def exclude?(line); end

  def exclusion_patterns(); end

  def exclusion_patterns=(exclusion_patterns); end

  def filter_gem(gem_name); end

  def format_backtrace(backtrace, options=T.unsafe(nil)); end

  def full_backtrace=(full_backtrace); end

  def full_backtrace?(); end

  def inclusion_patterns(); end

  def inclusion_patterns=(inclusion_patterns); end
end

class RSpec::Core::BacktraceFormatter
end

class RSpec::Core::Configuration
  include ::RSpec::Core::Hooks
  include ::RSpec::Core::Configuration::Readers
  def add_formatter(formatter, output=T.unsafe(nil)); end

  def add_setting(name, opts=T.unsafe(nil)); end

  def after(scope=T.unsafe(nil), *meta, &block); end

  def alias_example_group_to(new_name, *args); end

  def alias_example_to(name, *args); end

  def alias_it_behaves_like_to(new_name, report_label=T.unsafe(nil)); end

  def alias_it_should_behave_like_to(new_name, report_label=T.unsafe(nil)); end

  def append_after(scope=T.unsafe(nil), *meta, &block); end

  def append_before(scope=T.unsafe(nil), *meta, &block); end

  def apply_derived_metadata_to(metadata); end

  def around(scope=T.unsafe(nil), *meta, &block); end

  def backtrace_exclusion_patterns(); end

  def backtrace_exclusion_patterns=(patterns); end

  def backtrace_formatter(); end

  def backtrace_inclusion_patterns(); end

  def backtrace_inclusion_patterns=(patterns); end

  def before(scope=T.unsafe(nil), *meta, &block); end

  def bisect_runner(); end

  def bisect_runner=(value); end

  def bisect_runner_class(); end

  def color(); end

  def color=(color); end

  def color_enabled?(output=T.unsafe(nil)); end

  def color_mode(); end

  def color_mode=(color_mode); end

  def configure_example(example, example_hooks); end

  def configure_expectation_framework(); end

  def configure_group(group); end

  def configure_mock_framework(); end

  def default_color=(default_color); end

  def default_color?(); end

  def default_formatter(); end

  def default_formatter=(value); end

  def default_path=(path); end

  def default_path?(); end

  def define_derived_metadata(*filters, &block); end

  def deprecation_stream=(value); end

  def detail_color=(detail_color); end

  def detail_color?(); end

  def disable_monkey_patching(); end

  def disable_monkey_patching!(); end

  def disable_monkey_patching=(disable_monkey_patching); end

  def drb=(drb); end

  def drb?(); end

  def drb_port=(drb_port); end

  def drb_port?(); end

  def dry_run=(dry_run); end

  def dry_run?(); end

  def error_stream=(error_stream); end

  def error_stream?(); end

  def example_status_persistence_file_path=(value); end

  def exclude_pattern=(value); end

  def exclusion_filter(); end

  def exclusion_filter=(filter); end

  def expect_with(*frameworks); end

  def expectation_framework=(framework); end

  def expectation_frameworks(); end

  def expose_current_running_example_as(method_name); end

  def expose_dsl_globally=(value); end

  def expose_dsl_globally?(); end

  def extend(mod, *filters); end

  def fail_fast=(fail_fast); end

  def fail_fast?(); end

  def fail_if_no_examples=(fail_if_no_examples); end

  def fail_if_no_examples?(); end

  def failure_color=(failure_color); end

  def failure_color?(); end

  def failure_exit_code=(failure_exit_code); end

  def failure_exit_code?(); end

  def files_or_directories_to_run=(*files); end

  def files_to_run(); end

  def files_to_run=(files_to_run); end

  def filter(); end

  def filter=(filter); end

  def filter_gems_from_backtrace(*gem_names); end

  def filter_manager(); end

  def filter_manager=(filter_manager); end

  def filter_run(*args); end

  def filter_run_excluding(*args); end

  def filter_run_including(*args); end

  def filter_run_when_matching(*args); end

  def fixed_color=(fixed_color); end

  def fixed_color?(); end

  def force(hash); end

  def format_docstrings(&block); end

  def format_docstrings_block(); end

  def formatter=(formatter, output=T.unsafe(nil)); end

  def formatter_loader(); end

  def formatters(); end

  def full_backtrace=(true_or_false); end

  def full_backtrace?(); end

  def full_description(); end

  def full_description=(description); end

  def in_project_source_dir_regex(); end

  def include(mod, *filters); end

  def include_context(shared_group_name, *filters); end

  def inclusion_filter(); end

  def inclusion_filter=(filter); end

  def last_run_statuses(); end

  def libs=(libs); end

  def load_spec_files(); end

  def loaded_spec_files(); end

  def max_displayed_failure_line_count=(max_displayed_failure_line_count); end

  def max_displayed_failure_line_count?(); end

  def mock_framework(); end

  def mock_framework=(framework); end

  def mock_with(framework); end

  def on_example_group_definition(&block); end

  def on_example_group_definition_callbacks(); end

  def only_failures?(); end

  def only_failures_but_not_configured?(); end

  def order=(*args, &block); end

  def ordering_manager(); end

  def ordering_registry(*args, &block); end

  def output_stream=(value); end

  def pattern=(value); end

  def pending_color=(pending_color); end

  def pending_color?(); end

  def prepend(mod, *filters); end

  def prepend_after(scope=T.unsafe(nil), *meta, &block); end

  def prepend_before(scope=T.unsafe(nil), *meta, &block); end

  def profile_examples=(profile_examples); end

  def profile_examples?(); end

  def project_source_dirs=(project_source_dirs); end

  def project_source_dirs?(); end

  def raise_errors_for_deprecations!(); end

  def raise_on_warning=(value); end

  def register_ordering(*args, &block); end

  def reporter(); end

  def requires=(paths); end

  def reset(); end

  def reset_filters(); end

  def reset_reporter(); end

  def run_all_when_everything_filtered=(run_all_when_everything_filtered); end

  def run_all_when_everything_filtered?(); end

  def seed(*args, &block); end

  def seed=(*args, &block); end

  def seed_used?(*args, &block); end

  def shared_context_metadata_behavior=(value); end

  def silence_filter_announcements=(silence_filter_announcements); end

  def silence_filter_announcements?(); end

  def spec_files_with_failures(); end

  def start_time=(start_time); end

  def start_time?(); end

  def static_config_filter_manager(); end

  def static_config_filter_manager=(static_config_filter_manager); end

  def success_color=(success_color); end

  def success_color?(); end

  def threadsafe=(threadsafe); end

  def threadsafe?(); end

  def treat_symbols_as_metadata_keys_with_true_values=(_value); end

  def tty=(tty); end

  def tty?(); end

  def warnings=(value); end

  def warnings?(); end

  def when_first_matching_example_defined(*filters); end

  def with_suite_hooks(); end

  def world(); end

  def world=(world); end
  DEFAULT_FORMATTER = ::T.let(nil, ::T.untyped)
  FAILED_STATUS = ::T.let(nil, ::T.untyped)
  MOCKING_ADAPTERS = ::T.let(nil, ::T.untyped)
  PASSED_STATUS = ::T.let(nil, ::T.untyped)
  PENDING_STATUS = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  UNKNOWN_STATUS = ::T.let(nil, ::T.untyped)
  VALID_STATUSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
  def deprecation(*args); end

  def play_onto(reporter); end
end

class RSpec::Core::Configuration::DeprecationReporterBuffer
end

module RSpec::Core::Configuration::ExposeCurrentExample
end

module RSpec::Core::Configuration::ExposeCurrentExample
  extend ::T::Sig
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

class RSpec::Core::Configuration::MustBeConfiguredBeforeExampleGroupsError
end

module RSpec::Core::Configuration::Readers
  def default_color(); end

  def default_path(); end

  def deprecation_stream(); end

  def detail_color(); end

  def drb(); end

  def drb_port(); end

  def dry_run(); end

  def error_stream(); end

  def example_status_persistence_file_path(); end

  def exclude_pattern(); end

  def fail_fast(); end

  def fail_if_no_examples(); end

  def failure_color(); end

  def failure_exit_code(); end

  def fixed_color(); end

  def libs(); end

  def max_displayed_failure_line_count(); end

  def only_failures(); end

  def output_stream(); end

  def pattern(); end

  def pending_color(); end

  def profile_examples(); end

  def project_source_dirs(); end

  def requires(); end

  def run_all_when_everything_filtered(); end

  def shared_context_metadata_behavior(); end

  def silence_filter_announcements(); end

  def start_time(); end

  def success_color(); end

  def threadsafe(); end

  def tty(); end
end

module RSpec::Core::Configuration::Readers
  extend ::T::Sig
end

class RSpec::Core::Configuration
  def self.add_read_only_setting(name, opts=T.unsafe(nil)); end

  def self.add_setting(name, opts=T.unsafe(nil)); end

  def self.define_aliases(name, alias_name); end

  def self.define_predicate_for(*names); end

  def self.define_reader(name); end

  def self.delegate_to_ordering_manager(*methods); end
end

class RSpec::Core::ConfigurationOptions
  def args(); end

  def configure(config); end

  def configure_filter_manager(filter_manager); end

  def initialize(args); end

  def options(); end
  OPTIONS_ORDER = ::T.let(nil, ::T.untyped)
  UNFORCED_OPTIONS = ::T.let(nil, ::T.untyped)
  UNPROCESSABLE_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ConfigurationOptions
end

module RSpec::Core::DSL
end

module RSpec::Core::DSL
  extend ::T::Sig
  def self.change_global_dsl(&changes); end

  def self.example_group_aliases(); end

  def self.expose_example_group_alias(name); end

  def self.expose_example_group_alias_globally(method_name); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end

  def self.top_level(); end

  def self.top_level=(top_level); end
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::DeprecationError
end

class RSpec::Core::Example
  def clock(); end

  def clock=(clock); end

  def description(); end

  def display_exception(); end

  def display_exception=(ex); end

  def duplicate_with(metadata_overrides=T.unsafe(nil)); end

  def example_group(); end

  def example_group_instance(); end

  def exception(); end

  def execution_result(); end

  def fail_with_exception(reporter, exception); end

  def file_path(); end

  def full_description(); end

  def id(); end

  def initialize(example_group_class, description, user_metadata, example_block=T.unsafe(nil)); end

  def inspect_output(); end

  def instance_exec(*args, &block); end

  def location(); end

  def location_rerun_argument(); end

  def metadata(); end

  def pending(); end

  def pending?(); end

  def reporter(); end

  def rerun_argument(); end

  def run(example_group_instance, reporter); end

  def set_aggregate_failures_exception(exception); end

  def set_exception(exception); end

  def skip(); end

  def skip_with_exception(reporter, exception); end

  def skipped?(); end

  def update_inherited_metadata(updates); end
end

class RSpec::Core::Example::ExecutionResult
  include ::RSpec::Core::HashImitatable
  def ensure_timing_set(clock); end

  def example_skipped?(); end

  def exception(); end

  def exception=(exception); end

  def finished_at(); end

  def finished_at=(finished_at); end

  def pending_exception(); end

  def pending_exception=(pending_exception); end

  def pending_fixed(); end

  def pending_fixed=(pending_fixed); end

  def pending_fixed?(); end

  def pending_message(); end

  def pending_message=(pending_message); end

  def record_finished(status, finished_at); end

  def run_time(); end

  def run_time=(run_time); end

  def started_at(); end

  def started_at=(started_at); end

  def status(); end

  def status=(status); end
end

class RSpec::Core::Example::ExecutionResult
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

class RSpec::Core::Example::Procsy
  def ===(*a, &b); end

  def [](*a, &b); end

  def arity(*a, &b); end

  def binding(*a, &b); end

  def call(*args, &block); end

  def clock(*a, &b); end

  def clock=(*a, &b); end

  def clone(*a, &b); end

  def curry(*a, &b); end

  def description(*a, &b); end

  def dup(*a, &b); end

  def duplicate_with(*a, &b); end

  def example(); end

  def example_group(*a, &b); end

  def example_group_instance(*a, &b); end

  def exception(*a, &b); end

  def executed?(); end

  def execution_result(*a, &b); end

  def file_path(*a, &b); end

  def full_description(*a, &b); end

  def hash(*a, &b); end

  def id(*a, &b); end

  def initialize(example, &block); end

  def inspect_output(*a, &b); end

  def lambda?(*a, &b); end

  def location(*a, &b); end

  def location_rerun_argument(*a, &b); end

  def metadata(*a, &b); end

  def parameters(*a, &b); end

  def pending(*a, &b); end

  def pending?(*a, &b); end

  def reporter(*a, &b); end

  def rerun_argument(*a, &b); end

  def run(*args, &block); end

  def skip(*a, &b); end

  def skipped?(*a, &b); end

  def source_location(*a, &b); end

  def to_proc(); end

  def update_inherited_metadata(*a, &b); end

  def wrap(&block); end

  def yield(*a, &b); end
end

class RSpec::Core::Example::Procsy
end

class RSpec::Core::Example
  def self.delegate_to_metadata(key); end

  def self.parse_id(id); end
end

class RSpec::Core::ExampleGroup
  include ::RSpec::Core::MemoizedHelpers
  include ::RSpec::Core::Pending
  def described_class(); end

  def initialize(inspect_output=T.unsafe(nil)); end
  INSTANCE_VARIABLE_TO_IGNORE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup::WrongScopeError
end

class RSpec::Core::ExampleGroup
  extend ::RSpec::Core::Hooks
  extend ::RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::RSpec::Core::SharedExampleGroup
  def self.add_example(example); end

  def self.before_context_ivars(); end

  def self.children(); end

  def self.context(*args, &example_group_block); end

  def self.currently_executing_a_context_hook?(); end

  def self.declaration_locations(); end

  def self.define_example_group_method(name, metadata=T.unsafe(nil)); end

  def self.define_example_method(name, extra_options=T.unsafe(nil)); end

  def self.define_nested_shared_group_method(new_name, report_label=T.unsafe(nil)); end

  def self.delegate_to_metadata(*names); end

  def self.descendant_filtered_examples(); end

  def self.describe(*args, &example_group_block); end

  def self.described_class(); end

  def self.description(); end

  def self.each_instance_variable_for_example(group); end

  def self.ensure_example_groups_are_configured(); end

  def self.example(*all_args, &block); end

  def self.example_group(*args, &example_group_block); end

  def self.examples(); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.fexample(*all_args, &block); end

  def self.file_path(); end

  def self.filtered_examples(); end

  def self.find_and_eval_shared(label, name, inclusion_location, *args, &customization_block); end

  def self.fit(*all_args, &block); end

  def self.focus(*all_args, &block); end

  def self.for_filtered_examples(reporter, &block); end

  def self.fspecify(*all_args, &block); end

  def self.id(); end

  def self.idempotently_define_singleton_method(name, &definition); end

  def self.include_context(name, *args, &block); end

  def self.include_examples(name, *args, &block); end

  def self.it(*all_args, &block); end

  def self.it_behaves_like(name, *args, &customization_block); end

  def self.it_should_behave_like(name, *args, &customization_block); end

  def self.location(); end

  def self.metadata(); end

  def self.next_runnable_index_for(file); end

  def self.ordering_strategy(); end

  def self.parent_groups(); end

  def self.pending(*all_args, &block); end

  def self.remove_example(example); end

  def self.reset_memoized(); end

  def self.run(reporter=T.unsafe(nil)); end

  def self.run_after_context_hooks(example_group_instance); end

  def self.run_before_context_hooks(example_group_instance); end

  def self.run_examples(reporter); end

  def self.set_it_up(description, args, registration_collection, &example_group_block); end

  def self.set_ivars(instance, ivars); end

  def self.skip(*all_args, &block); end

  def self.specify(*all_args, &block); end

  def self.store_before_context_ivars(example_group_instance); end

  def self.subclass(parent, description, args, registration_collection, &example_group_block); end

  def self.superclass_before_context_ivars(); end

  def self.superclass_metadata(); end

  def self.top_level?(); end

  def self.top_level_description(); end

  def self.traverse_tree_until(&block); end

  def self.update_inherited_metadata(updates); end

  def self.with_replaced_metadata(meta); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end

  def self.xexample(*all_args, &block); end

  def self.xit(*all_args, &block); end

  def self.xspecify(*all_args, &block); end
end

class RSpec::Core::ExampleStatusPersister
  def initialize(examples, file_name); end

  def persist(); end
end

class RSpec::Core::ExampleStatusPersister
  def self.load_from(file_name); end

  def self.persist(examples, file_name); end
end

class RSpec::Core::FilterManager
  def add_ids(rerun_path, scoped_ids); end

  def add_location(file_path, line_numbers); end

  def empty?(); end

  def exclude(*args); end

  def exclude_only(*args); end

  def exclude_with_low_priority(*args); end

  def exclusions(); end

  def include(*args); end

  def include_only(*args); end

  def include_with_low_priority(*args); end

  def inclusions(); end

  def prune(examples); end
end

class RSpec::Core::FilterManager
end

class RSpec::Core::FilterRules
  def [](key); end

  def add(updated); end

  def add_with_low_priority(updated); end

  def clear(); end

  def delete(key); end

  def description(); end

  def each_pair(&block); end

  def empty?(); end

  def fetch(*args, &block); end

  def include_example?(example); end

  def initialize(rules=T.unsafe(nil)); end

  def opposite(); end

  def opposite=(opposite); end

  def rules(); end

  def use_only(updated); end
  PROC_HEX_NUMBER = ::T.let(nil, ::T.untyped)
  PROJECT_DIR = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::FilterRules
  def self.build(); end
end

module RSpec::Core::FilterableItemRepository
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
  def items_for(metadata); end
end

class RSpec::Core::FilterableItemRepository::QueryOptimized
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
  def append(item, metadata); end

  def delete(item, metadata); end

  def initialize(applies_predicate); end

  def items_and_filters(); end

  def items_for(request_meta); end

  def prepend(item, metadata); end
end

class RSpec::Core::FilterableItemRepository::UpdateOptimized
end

module RSpec::Core::FilterableItemRepository
  extend ::T::Sig
end

module RSpec::Core::FlatMap
end

module RSpec::Core::FlatMap
  extend ::T::Sig
  def self.flat_map(array, &block); end
end

module RSpec::Core::Formatters
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def example_failed(notification); end

  def example_finished(notification); end

  def initialize(expected_failures); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::BaseBisectFormatter
  def self.inherited(formatter); end
end

class RSpec::Core::Formatters::BaseFormatter
  def close(_notification); end

  def example_group(); end

  def example_group=(example_group); end

  def example_group_started(notification); end

  def initialize(output); end

  def output(); end

  def start(notification); end
end

class RSpec::Core::Formatters::BaseFormatter
end

class RSpec::Core::Formatters::BaseTextFormatter
  def dump_failures(notification); end

  def dump_pending(notification); end

  def dump_summary(summary); end

  def message(notification); end

  def seed(notification); end
end

class RSpec::Core::Formatters::BaseTextFormatter
end

class RSpec::Core::Formatters::BisectDRbFormatter
  def initialize(_output); end

  def notify_results(results); end
end

class RSpec::Core::Formatters::BisectDRbFormatter
end

module RSpec::Core::Formatters::ConsoleCodes
  VT100_CODES = ::T.let(nil, ::T.untyped)
  VT100_CODE_VALUES = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::ConsoleCodes
  extend ::T::Sig
  def self.config_colors_to_methods(); end

  def self.console_code_for(code_or_symbol); end

  def self.wrap(text, code_or_symbol); end
end

class RSpec::Core::Formatters::DeprecationFormatter
  def count(); end

  def deprecation(notification); end

  def deprecation_message_for(data); end

  def deprecation_stream(); end

  def deprecation_summary(_notification); end

  def initialize(deprecation_stream, summary_stream); end

  def output(); end

  def printer(); end

  def summary_stream(); end
  DEPRECATION_STREAM_NOTICE = ::T.let(nil, ::T.untyped)
  RAISE_ERROR_CONFIG_NOTICE = ::T.let(nil, ::T.untyped)
  TOO_MANY_WARNINGS_NOTICE = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deferred_deprecation_warnings(); end

  def print_deprecation_message(data); end

  def stash_deprecation_message(deprecation_message); end

  def summary_stream(); end
  TOO_MANY_USES_LIMIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::DeprecationFormatter::DelayedPrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
  def initialize(file); end

  def puts(*args); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::FileStream
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::GeneratedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
  def deprecation_formatter(); end

  def deprecation_stream(); end

  def deprecation_summary(); end

  def initialize(deprecation_stream, summary_stream, deprecation_formatter); end

  def print_deprecation_message(data); end

  def summary_stream(); end
end

class RSpec::Core::Formatters::DeprecationFormatter::ImmediatePrinter
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
  def puts(message); end

  def summarize(summary_stream, deprecation_count); end
end

class RSpec::Core::Formatters::DeprecationFormatter::RaiseErrorStream
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def initialize(data); end

  def too_many_warnings_message(); end

  def type(); end

  def type=(_); end
end

class RSpec::Core::Formatters::DeprecationFormatter::SpecifiedDeprecationMessage
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Formatters::DeprecationFormatter
end

class RSpec::Core::Formatters::DocumentationFormatter
  def example_failed(failure); end

  def example_group_finished(_notification); end

  def example_passed(passed); end

  def example_pending(pending); end
end

class RSpec::Core::Formatters::DocumentationFormatter
end

class RSpec::Core::Formatters::ExceptionPresenter
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def example(); end

  def exception(); end

  def formatted_backtrace(exception=T.unsafe(nil)); end

  def formatted_cause(exception); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer); end

  def initialize(exception, example, options=T.unsafe(nil)); end

  def message_lines(); end
  PENDING_DETAIL_FORMATTER = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
  def build(); end

  def initialize(example); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
  def initialize(parent); end

  def with_truncated_backtrace(child); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory::CommonBacktraceTruncater
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
end

module RSpec::Core::Formatters::ExceptionPresenter::Factory::EmptyBacktraceFormatter
  extend ::T::Sig
  def self.format_backtrace(*_); end
end

class RSpec::Core::Formatters::ExceptionPresenter::Factory
end

class RSpec::Core::Formatters::ExceptionPresenter
end

class RSpec::Core::Formatters::FallbackMessageFormatter
  def initialize(output); end

  def message(notification); end

  def output(); end
end

class RSpec::Core::Formatters::FallbackMessageFormatter
end

module RSpec::Core::Formatters::Helpers
  DEFAULT_PRECISION = ::T.let(nil, ::T.untyped)
  SUB_SECOND_PRECISION = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::Helpers
  extend ::T::Sig
  def self.format_duration(duration); end

  def self.format_seconds(float, precision=T.unsafe(nil)); end

  def self.organize_ids(ids); end

  def self.pluralize(count, string); end
end

class RSpec::Core::Formatters::HtmlFormatter
  def dump_summary(summary); end

  def example_failed(failure); end

  def example_passed(passed); end

  def example_pending(pending); end

  def example_started(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::HtmlFormatter
end

class RSpec::Core::Formatters::JsonFormatter
  def dump_profile(profile); end

  def dump_profile_slowest_example_groups(profile); end

  def dump_profile_slowest_examples(profile); end

  def dump_summary(summary); end

  def message(notification); end

  def output_hash(); end

  def seed(notification); end

  def stop(notification); end
end

class RSpec::Core::Formatters::JsonFormatter
end

class RSpec::Core::Formatters::Loader
  def add(formatter_to_use, *paths); end

  def default_formatter(); end

  def default_formatter=(default_formatter); end

  def formatters(); end

  def initialize(reporter); end

  def prepare_default(output_stream, deprecation_stream); end

  def reporter(); end

  def setup_default(output_stream, deprecation_stream); end
end

class RSpec::Core::Formatters::Loader
  def self.formatters(); end
end

class RSpec::Core::Formatters::ProfileFormatter
  def dump_profile(profile); end

  def initialize(output); end

  def output(); end
end

class RSpec::Core::Formatters::ProfileFormatter
end

class RSpec::Core::Formatters::ProgressFormatter
  def example_failed(_notification); end

  def example_passed(_notification); end

  def example_pending(_notification); end

  def start_dump(_notification); end
end

class RSpec::Core::Formatters::ProgressFormatter
end

class RSpec::Core::Formatters::SnippetExtractor
  def beginning_line_number(); end

  def expression_lines(); end

  def initialize(source, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def max_line_count(); end

  def source(); end
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoExpressionAtLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchFileError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor::NoSuchLineError
end

class RSpec::Core::Formatters::SnippetExtractor
  def self.extract_expression_lines_at(file_path, beginning_line_number, max_line_count=T.unsafe(nil)); end

  def self.extract_line_at(file_path, line_number); end

  def self.least_indentation_from(lines); end

  def self.source_from_file(path); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def highlight(lines); end

  def initialize(configuration); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  RESET_CODE = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Formatters::SyntaxHighlighter::CodeRayImplementation
  extend ::T::Sig
  def self.highlight_syntax(lines); end
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
end

module RSpec::Core::Formatters::SyntaxHighlighter::NoSyntaxHighlightingImplementation
  extend ::T::Sig
  def self.highlight_syntax(lines); end
end

class RSpec::Core::Formatters::SyntaxHighlighter
  def self.attempt_to_add_rspec_terms_to_coderay_keywords(); end
end

module RSpec::Core::Formatters
  extend ::T::Sig
  def self.register(formatter_class, *notifications); end
end

module RSpec::Core::HashImitatable
  def <(*args, &block); end

  def <=(*args, &block); end

  def >(*args, &block); end

  def >=(*args, &block); end

  def [](key); end

  def []=(key, value); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def assert_valid_keys(*args, &block); end

  def assoc(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect_concat(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def compare_by_identity(*args, &block); end

  def compare_by_identity?(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def deep_merge(*args, &block); end

  def deep_merge!(*args, &block); end

  def deep_stringify_keys(*args, &block); end

  def deep_stringify_keys!(*args, &block); end

  def deep_symbolize_keys(*args, &block); end

  def deep_symbolize_keys!(*args, &block); end

  def deep_transform_keys(*args, &block); end

  def deep_transform_keys!(*args, &block); end

  def default(*args, &block); end

  def default=(*args, &block); end

  def default_proc(*args, &block); end

  def default_proc=(*args, &block); end

  def delete(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_last(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_key(*args, &block); end

  def each_pair(*args, &block); end

  def each_slice(*args, &block); end

  def each_value(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def except(*args, &block); end

  def except!(*args, &block); end

  def exclude?(*args, &block); end

  def extract!(*args, &block); end

  def extractable_options?(*args, &block); end

  def fetch(*args, &block); end

  def fetch_values(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def has_key?(*args, &block); end

  def has_value?(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def inject(*args, &block); end

  def invert(*args, &block); end

  def keep_if(*args, &block); end

  def key(*args, &block); end

  def key?(*args, &block); end

  def keys(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def merge(*args, &block); end

  def merge!(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def nested_under_indifferent_access(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def partition(*args, &block); end

  def pluck(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def rehash(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def replace(*args, &block); end

  def reverse_each(*args, &block); end

  def reverse_merge(*args, &block); end

  def reverse_merge!(*args, &block); end

  def reverse_update(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shift(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort_by(*args, &block); end

  def store(*args, &block); end

  def stringify_keys(*args, &block); end

  def stringify_keys!(*args, &block); end

  def sum(*args, &block); end

  def symbolize_keys(*args, &block); end

  def symbolize_keys!(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def to_a(*args, &block); end

  def to_h(); end

  def to_hash(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_options(*args, &block); end

  def to_options!(*args, &block); end

  def to_proc(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transform_keys(*args, &block); end

  def transform_keys!(*args, &block); end

  def transform_values(*args, &block); end

  def transform_values!(*args, &block); end

  def uniq(*args, &block); end

  def update(*args, &block); end

  def value?(*args, &block); end

  def values(*args, &block); end

  def values_at(*args, &block); end

  def with_defaults(*args, &block); end

  def with_defaults!(*args, &block); end

  def with_indifferent_access(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end
end

module RSpec::Core::HashImitatable::ClassMethods
  def attr_accessor(*names); end

  def hash_attribute_names(); end
end

module RSpec::Core::HashImitatable::ClassMethods
  extend ::T::Sig
end

module RSpec::Core::HashImitatable
  extend ::T::Sig
  def self.included(klass); end
end

module RSpec::Core::Hooks
  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def hooks(); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end
end

class RSpec::Core::Hooks::AfterContextHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterContextHook
end

class RSpec::Core::Hooks::AfterHook
  def run(example); end
end

class RSpec::Core::Hooks::AfterHook
end

class RSpec::Core::Hooks::AroundHook
  def execute_with(example, procsy); end

  def hook_description(); end
end

class RSpec::Core::Hooks::AroundHook
end

class RSpec::Core::Hooks::BeforeHook
  def run(example); end
end

class RSpec::Core::Hooks::BeforeHook
end

class RSpec::Core::Hooks::Hook
  def block(); end

  def block=(_); end

  def options(); end

  def options=(_); end
end

class RSpec::Core::Hooks::Hook
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Hooks::HookCollections
  def all_hooks_for(position, scope); end

  def initialize(owner, filterable_item_repo_class); end

  def matching_hooks_for(position, scope, example_or_group); end

  def processable_hooks_for(position, scope, host); end

  def register(prepend_or_append, position, *args, &block); end

  def register_global_singleton_context_hooks(example, globals); end

  def register_globals(host, globals); end

  def run(position, scope, example_or_group); end

  def run_owned_hooks_for(position, scope, example_or_group); end
  EMPTY_HOOK_ARRAY = ::T.let(nil, ::T.untyped)
  HOOK_TYPES = ::T.let(nil, ::T.untyped)
  SCOPES = ::T.let(nil, ::T.untyped)
  SCOPE_ALIASES = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Hooks::HookCollections
end

module RSpec::Core::Hooks
  extend ::T::Sig
end

class RSpec::Core::InclusionRules
  def add(*args); end

  def add_with_low_priority(*args); end

  def split_file_scoped_rules(); end

  def standalone?(); end
end

class RSpec::Core::InclusionRules
end

module RSpec::Core::Invocations
end

class RSpec::Core::Invocations::Bisect
  def call(options, err, out); end
end

class RSpec::Core::Invocations::Bisect
end

class RSpec::Core::Invocations::DRbWithFallback
  def call(options, err, out); end
end

class RSpec::Core::Invocations::DRbWithFallback
end

class RSpec::Core::Invocations::InitializeProject
  def call(*_args); end
end

class RSpec::Core::Invocations::InitializeProject
end

class RSpec::Core::Invocations::PrintHelp
  def call(_options, _err, out); end

  def hidden_options(); end

  def hidden_options=(_); end

  def parser(); end

  def parser=(_); end
end

class RSpec::Core::Invocations::PrintHelp
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Invocations::PrintVersion
  def call(_options, _err, out); end
end

class RSpec::Core::Invocations::PrintVersion
end

module RSpec::Core::Invocations
  extend ::T::Sig
end

class RSpec::Core::LegacyExampleGroupHash
  include ::RSpec::Core::HashImitatable
  def initialize(metadata); end
end

class RSpec::Core::LegacyExampleGroupHash
  extend ::RSpec::Core::HashImitatable::ClassMethods
end

module RSpec::Core::MemoizedHelpers
  def initialize(*_); end

  def is_expected(); end

  def should(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def should_not(matcher=T.unsafe(nil), message=T.unsafe(nil)); end

  def subject(); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  def let(name, &block); end

  def let!(name, &block); end

  def subject(name=T.unsafe(nil), &block); end

  def subject!(name=T.unsafe(nil), &block); end
end

module RSpec::Core::MemoizedHelpers::ClassMethods
  extend ::T::Sig
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::After
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized::Before
  def self.article(); end

  def self.hook_expression(); end

  def self.hook_intention(); end
end

class RSpec::Core::MemoizedHelpers::ContextHookMemoized
  def self.fetch_or_store(key, &_block); end

  def self.isolate_for_context_hook(example_group_instance); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::NonThreadSafeMemoized
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
  def fetch_or_store(key); end
end

class RSpec::Core::MemoizedHelpers::ThreadsafeMemoized
end

module RSpec::Core::MemoizedHelpers
  extend ::T::Sig
  def self.define_helpers_on(example_group); end

  def self.get_constant_or_yield(example_group, name); end

  def self.module_for(example_group); end
end

module RSpec::Core::Metadata
  RESERVED_KEYS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Metadata::ExampleGroupHash
end

class RSpec::Core::Metadata::ExampleGroupHash
  def self.backwards_compatibility_default_proc(&example_group_selector); end

  def self.create(parent_group_metadata, user_metadata, example_group_index, *args, &block); end

  def self.hash_with_backwards_compatibility_default_proc(); end
end

class RSpec::Core::Metadata::ExampleHash
end

class RSpec::Core::Metadata::ExampleHash
  def self.create(group_metadata, user_metadata, index_provider, description, block); end
end

class RSpec::Core::Metadata::HashPopulator
  def block(); end

  def description_args(); end

  def initialize(metadata, user_metadata, index_provider, description_args, block); end

  def metadata(); end

  def populate(); end

  def user_metadata(); end
end

class RSpec::Core::Metadata::HashPopulator
end

module RSpec::Core::Metadata
  extend ::T::Sig
  def self.ascend(metadata); end

  def self.ascending(metadata); end

  def self.build_hash_from(args, warn_about_example_group_filtering=T.unsafe(nil)); end

  def self.deep_hash_dup(object); end

  def self.id_from(metadata); end

  def self.location_tuple_from(metadata); end

  def self.relative_path(line); end

  def self.relative_path_regex(); end
end

module RSpec::Core::MetadataFilter
end

module RSpec::Core::MetadataFilter
  extend ::T::Sig
  def self.apply?(predicate, filters, metadata); end

  def self.filter_applies?(key, filter_value, metadata); end

  def self.silence_metadata_example_group_deprecations(); end
end

class RSpec::Core::MultipleExceptionError
  include ::RSpec::Core::MultipleExceptionError::InterfaceTag
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(*exceptions); end

  def other_errors(); end

  def summary(); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  def add(exception); end
end

module RSpec::Core::MultipleExceptionError::InterfaceTag
  extend ::T::Sig
  def self.for(ex); end
end

class RSpec::Core::MultipleExceptionError
end

module RSpec::Core::Notifications
end

class RSpec::Core::Notifications::CustomNotification
end

class RSpec::Core::Notifications::CustomNotification
  def self.for(options=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def call_site(); end

  def call_site=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def message(); end

  def message=(_); end

  def replacement(); end

  def replacement=(_); end
end

class RSpec::Core::Notifications::DeprecationNotification
  def self.[](*_); end

  def self.from_hash(data); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExampleNotification
  def example(); end

  def example=(_); end
end

class RSpec::Core::Notifications::ExampleNotification
  def self.[](*_); end

  def self.for(example); end

  def self.members(); end
end

class RSpec::Core::Notifications::ExamplesNotification
  def examples(); end

  def failed_examples(); end

  def failure_notifications(); end

  def fully_formatted_failed_examples(colorizer=T.unsafe(nil)); end

  def fully_formatted_pending_examples(colorizer=T.unsafe(nil)); end

  def initialize(reporter); end

  def notifications(); end

  def pending_examples(); end

  def pending_notifications(); end
end

class RSpec::Core::Notifications::ExamplesNotification
end

class RSpec::Core::Notifications::FailedExampleNotification
  def colorized_formatted_backtrace(colorizer=T.unsafe(nil)); end

  def colorized_message_lines(colorizer=T.unsafe(nil)); end

  def description(); end

  def exception(); end

  def formatted_backtrace(); end

  def fully_formatted(failure_number, colorizer=T.unsafe(nil)); end

  def fully_formatted_lines(failure_number, colorizer=T.unsafe(nil)); end

  def initialize(example, exception_presenter=T.unsafe(nil)); end

  def message_lines(); end
end

class RSpec::Core::Notifications::FailedExampleNotification
end

class RSpec::Core::Notifications::GroupNotification
  def group(); end

  def group=(_); end
end

class RSpec::Core::Notifications::GroupNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::MessageNotification
  def message(); end

  def message=(_); end
end

class RSpec::Core::Notifications::MessageNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications::NullColorizer
end

module RSpec::Core::Notifications::NullColorizer
  extend ::T::Sig
  def self.wrap(line, _code_or_symbol); end
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::NullNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFailedAsExpectedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::PendingExampleFixedNotification
end

class RSpec::Core::Notifications::ProfileNotification
  def duration(); end

  def examples(); end

  def initialize(duration, examples, number_of_examples, example_groups); end

  def number_of_examples(); end

  def percentage(); end

  def slow_duration(); end

  def slowest_examples(); end

  def slowest_groups(); end
end

class RSpec::Core::Notifications::ProfileNotification
end

class RSpec::Core::Notifications::SeedNotification
  def fully_formatted(); end

  def seed(); end

  def seed=(_); end

  def seed_used?(); end

  def used=(_); end
end

class RSpec::Core::Notifications::SeedNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
  def fully_formatted(pending_number, colorizer=T.unsafe(nil)); end
end

class RSpec::Core::Notifications::SkippedExampleNotification
end

class RSpec::Core::Notifications::StartNotification
  def count(); end

  def count=(_); end

  def load_time(); end

  def load_time=(_); end
end

class RSpec::Core::Notifications::StartNotification
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Core::Notifications::SummaryNotification
  include ::RSpec::Core::ShellEscape
  def colorized_rerun_commands(colorizer=T.unsafe(nil)); end

  def colorized_totals_line(colorizer=T.unsafe(nil)); end

  def duration(); end

  def duration=(_); end

  def errors_outside_of_examples_count(); end

  def errors_outside_of_examples_count=(_); end

  def example_count(); end

  def examples(); end

  def examples=(_); end

  def failed_examples(); end

  def failed_examples=(_); end

  def failure_count(); end

  def formatted_duration(); end

  def formatted_load_time(); end

  def fully_formatted(colorizer=T.unsafe(nil)); end

  def load_time(); end

  def load_time=(_); end

  def pending_count(); end

  def pending_examples(); end

  def pending_examples=(_); end

  def totals_line(); end
end

class RSpec::Core::Notifications::SummaryNotification
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::Notifications
  extend ::T::Sig
end

class RSpec::Core::NullReporter
end

class RSpec::Core::NullReporter
end

module RSpec::Core::Ordering
end

class RSpec::Core::Ordering::ConfigurationManager
  def force(hash); end

  def order=(type); end

  def ordering_registry(); end

  def register_ordering(name, strategy=T.unsafe(nil)); end

  def seed(); end

  def seed=(seed); end

  def seed_used?(); end
end

class RSpec::Core::Ordering::ConfigurationManager
end

class RSpec::Core::Ordering::Custom
  def initialize(callable); end

  def order(list); end
end

class RSpec::Core::Ordering::Custom
end

class RSpec::Core::Ordering::Identity
  def order(items); end
end

class RSpec::Core::Ordering::Identity
end

class RSpec::Core::Ordering::Random
  def initialize(configuration); end

  def order(items); end

  def used?(); end
  MAX_32_BIT = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Ordering::Random
end

class RSpec::Core::Ordering::Registry
  def fetch(name, &fallback); end

  def initialize(configuration); end

  def register(sym, strategy); end

  def used_random_seed?(); end
end

class RSpec::Core::Ordering::Registry
end

module RSpec::Core::Ordering
  extend ::T::Sig
end

class RSpec::Core::OutputWrapper
  def <<(*args, &block); end

  def advise(*args, &block); end

  def as_json(*args, &block); end

  def autoclose=(*args, &block); end

  def autoclose?(*args, &block); end

  def beep(*args, &block); end

  def binmode(*args, &block); end

  def binmode?(*args, &block); end

  def bytes(*args, &block); end

  def chars(*args, &block); end

  def close(*args, &block); end

  def close_on_exec=(*args, &block); end

  def close_on_exec?(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def codepoints(*args, &block); end

  def cooked(*args, &block); end

  def cooked!(*args, &block); end

  def cursor(*args, &block); end

  def cursor=(*args, &block); end

  def each(*args, &block); end

  def each_byte(*args, &block); end

  def each_char(*args, &block); end

  def each_codepoint(*args, &block); end

  def each_line(*args, &block); end

  def echo=(*args, &block); end

  def echo?(*args, &block); end

  def eof(*args, &block); end

  def eof?(*args, &block); end

  def external_encoding(*args, &block); end

  def fcntl(*args, &block); end

  def fdatasync(*args, &block); end

  def fileno(*args, &block); end

  def flush(*args, &block); end

  def fsync(*args, &block); end

  def getbyte(*args, &block); end

  def getc(*args, &block); end

  def getch(*args, &block); end

  def getpass(*args, &block); end

  def gets(*args, &block); end

  def goto(*args, &block); end

  def iflush(*args, &block); end

  def initialize(output); end

  def inspect(*args, &block); end

  def internal_encoding(*args, &block); end

  def ioctl(*args, &block); end

  def ioflush(*args, &block); end

  def isatty(*args, &block); end

  def lineno(*args, &block); end

  def lineno=(*args, &block); end

  def lines(*args, &block); end

  def method_missing(name, *args, &block); end

  def noecho(*args, &block); end

  def nonblock(*args, &block); end

  def nonblock=(*args, &block); end

  def nonblock?(*args, &block); end

  def nread(*args, &block); end

  def oflush(*args, &block); end

  def output(); end

  def output=(output); end

  def pathconf(*args, &block); end

  def pid(*args, &block); end

  def pos(*args, &block); end

  def pos=(*args, &block); end

  def pread(*args, &block); end

  def pressed?(*args, &block); end

  def print(*args, &block); end

  def printf(*args, &block); end

  def putc(*args, &block); end

  def puts(*args, &block); end

  def pwrite(*args, &block); end

  def raw(*args, &block); end

  def raw!(*args, &block); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def readbyte(*args, &block); end

  def readchar(*args, &block); end

  def readline(*args, &block); end

  def readlines(*args, &block); end

  def readpartial(*args, &block); end

  def ready?(*args, &block); end

  def reopen(*args, &block); end

  def respond_to?(name, priv=T.unsafe(nil)); end

  def rewind(*args, &block); end

  def seek(*args, &block); end

  def set_encoding(*args, &block); end

  def stat(*args, &block); end

  def sync(*args, &block); end

  def sync=(*args, &block); end

  def sysread(*args, &block); end

  def sysseek(*args, &block); end

  def syswrite(*args, &block); end

  def tell(*args, &block); end

  def to_i(*args, &block); end

  def to_io(*args, &block); end

  def tty?(*args, &block); end

  def ungetbyte(*args, &block); end

  def ungetc(*args, &block); end

  def wait(*args, &block); end

  def wait_readable(*args, &block); end

  def wait_writable(*args, &block); end

  def winsize(*args, &block); end

  def winsize=(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
end

class RSpec::Core::OutputWrapper
end

class RSpec::Core::Parser
  def initialize(original_args); end

  def original_args(); end

  def parse(source=T.unsafe(nil)); end
end

class RSpec::Core::Parser
  def self.parse(args, source=T.unsafe(nil)); end
end

module RSpec::Core::Pending
  def pending(message=T.unsafe(nil)); end

  def skip(message=T.unsafe(nil)); end
  NOT_YET_IMPLEMENTED = ::T.let(nil, ::T.untyped)
  NO_REASON_GIVEN = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::PendingExampleFixedError
end

class RSpec::Core::Pending::SkipDeclaredInExample
  def argument(); end

  def initialize(argument); end
end

class RSpec::Core::Pending::SkipDeclaredInExample
end

module RSpec::Core::Pending
  extend ::T::Sig
  def self.mark_fixed!(example); end

  def self.mark_pending!(example, message_or_bool); end

  def self.mark_skipped!(example, message_or_bool); end
end

class RSpec::Core::Profiler
  def example_group_finished(notification); end

  def example_group_started(notification); end

  def example_groups(); end

  def example_started(notification); end
  NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Profiler
end

class RSpec::Core::Reporter
  def abort_with(msg, exit_status); end

  def close_after(); end

  def deprecation(hash); end

  def example_failed(example); end

  def example_finished(example); end

  def example_group_finished(group); end

  def example_group_started(group); end

  def example_passed(example); end

  def example_pending(example); end

  def example_started(example); end

  def examples(); end

  def fail_fast_limit_met?(); end

  def failed_examples(); end

  def finish(); end

  def initialize(configuration); end

  def message(message); end

  def notify(event, notification); end

  def notify_non_example_exception(exception, context_description); end

  def pending_examples(); end

  def prepare_default(loader, output_stream, deprecation_stream); end

  def publish(event, options=T.unsafe(nil)); end

  def register_listener(listener, *notifications); end

  def registered_listeners(notification); end

  def report(expected_example_count); end

  def start(expected_example_count, time=T.unsafe(nil)); end

  def stop(); end
  RSPEC_NOTIFICATIONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Core::Reporter
end

module RSpec::Core::RubyProject
end

module RSpec::Core::RubyProject
  extend ::T::Sig
  def self.add_dir_to_load_path(dir); end

  def self.add_to_load_path(*dirs); end

  def self.ascend_until(); end

  def self.determine_root(); end

  def self.find_first_parent_containing(dir); end

  def self.root(); end
end

class RSpec::Core::Runner
  def configuration(); end

  def configure(err, out); end

  def initialize(options, configuration=T.unsafe(nil), world=T.unsafe(nil)); end

  def options(); end

  def run(err, out); end

  def run_specs(example_groups); end

  def setup(err, out); end

  def world(); end
end

class RSpec::Core::Runner
  def self.autorun(); end

  def self.autorun_disabled?(); end

  def self.disable_autorun!(); end

  def self.handle_interrupt(); end

  def self.installed_at_exit?(); end

  def self.invoke(); end

  def self.perform_at_exit(); end

  def self.run(args, err=T.unsafe(nil), out=T.unsafe(nil)); end

  def self.running_in_drb?(); end

  def self.trap_interrupt(); end
end

class RSpec::Core::Set
  include ::Enumerable
  def <<(key); end

  def clear(); end

  def delete(key); end

  def each(&block); end

  def empty?(); end

  def include?(key); end

  def initialize(array=T.unsafe(nil)); end

  def merge(values); end
end

class RSpec::Core::Set
end

module RSpec::Core::SharedContext
  def __shared_context_recordings(); end

  def after(*args, &block); end

  def append_after(*args, &block); end

  def append_before(*args, &block); end

  def around(*args, &block); end

  def before(*args, &block); end

  def context(*args, &block); end

  def describe(*args, &block); end

  def hooks(*args, &block); end

  def included(group); end

  def let(*args, &block); end

  def let!(*args, &block); end

  def prepend_after(*args, &block); end

  def prepend_before(*args, &block); end

  def subject(*args, &block); end

  def subject!(*args, &block); end
end

class RSpec::Core::SharedContext::Recording
  def args(); end

  def args=(_); end

  def block(); end

  def block=(_); end

  def method_name(); end

  def method_name=(_); end

  def playback_onto(group); end
end

class RSpec::Core::SharedContext::Recording
  def self.[](*_); end

  def self.members(); end
end

module RSpec::Core::SharedContext
  extend ::T::Sig
  def self.record(methods); end
end

module RSpec::Core::SharedExampleGroup
  def shared_context(name, *args, &block); end

  def shared_examples(name, *args, &block); end

  def shared_examples_for(name, *args, &block); end
end

class RSpec::Core::SharedExampleGroup::Registry
  def add(context, name, *metadata_args, &block); end

  def find(lookup_contexts, name); end
end

class RSpec::Core::SharedExampleGroup::Registry
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
end

module RSpec::Core::SharedExampleGroup::TopLevelDSL
  extend ::T::Sig
  def self.definitions(); end

  def self.expose_globally!(); end

  def self.exposed_globally?(); end

  def self.remove_globally!(); end
end

module RSpec::Core::SharedExampleGroup
  extend ::T::Sig
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def description(); end

  def formatted_inclusion_location(); end

  def inclusion_location(); end

  def initialize(shared_group_name, inclusion_location); end

  def shared_group_name(); end
end

class RSpec::Core::SharedExampleGroupInclusionStackFrame
  def self.current_backtrace(); end

  def self.shared_example_group_inclusions(); end

  def self.with_frame(name, location); end
end

class RSpec::Core::SharedExampleGroupModule
  def definition(); end

  def include_in(klass, inclusion_line, args, customization_block); end

  def included(klass); end

  def initialize(description, definition, metadata); end
end

class RSpec::Core::SharedExampleGroupModule
end

module RSpec::Core::ShellEscape
  SHELLS_ALLOWING_UNQUOTED_IDS = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::ShellEscape
  extend ::T::Sig
  def self.conditionally_quote(id); end

  def self.escape(shell_command); end

  def self.quote(argument); end

  def self.shell_allows_unquoted_ids?(); end
end

class RSpec::Core::SuiteHookContext
  def initialize(hook_description, reporter); end
end

class RSpec::Core::SuiteHookContext
end

class RSpec::Core::Time
end

class RSpec::Core::Time
  def self.now(); end
end

module RSpec::Core::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Core::Version
  extend ::T::Sig
end

module RSpec::Core::Warnings
  def deprecate(deprecated, data=T.unsafe(nil)); end

  def warn_deprecation(message, opts=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end
end

module RSpec::Core::Warnings
  extend ::T::Sig
end

class RSpec::Core::World
  def all_example_groups(); end

  def all_examples(); end

  def announce_exclusion_filter(announcements); end

  def announce_filters(); end

  def announce_inclusion_filter(announcements); end

  def everything_filtered_message(); end

  def example_count(groups=T.unsafe(nil)); end

  def example_groups(); end

  def exclusion_filter(); end

  def filter_manager(); end

  def filtered_examples(); end

  def inclusion_filter(); end

  def initialize(configuration=T.unsafe(nil)); end

  def non_example_failure(); end

  def non_example_failure=(non_example_failure); end

  def num_example_groups_defined_in(file); end

  def ordered_example_groups(); end

  def preceding_declaration_line(absolute_file_name, filter_line); end

  def prepare_example_filtering(); end

  def record(example_group); end

  def registered_example_group_files(); end

  def report_filter_message(message); end

  def reporter(); end

  def reset(); end

  def shared_example_group_registry(); end

  def source_from_file(path); end

  def syntax_highlighter(); end

  def traverse_example_group_trees_until(&block); end

  def wants_to_quit(); end

  def wants_to_quit=(wants_to_quit); end
end

module RSpec::Core::World::Null
end

module RSpec::Core::World::Null
  extend ::T::Sig
  def self.all_example_groups(); end

  def self.example_groups(); end

  def self.non_example_failure(); end

  def self.non_example_failure=(_); end

  def self.registered_example_group_files(); end

  def self.traverse_example_group_trees_until(); end
end

class RSpec::Core::World
end

module RSpec::Core
  extend ::T::Sig
  def self.path_to_executable(); end
end

module RSpec::ExampleGroups
end

module RSpec::ExampleGroups
  extend ::RSpec::Support::RecursiveConstMethods
  extend ::T::Sig
  def self.assign_const(group); end

  def self.base_name_for(group); end

  def self.constant_scope_for(group); end

  def self.disambiguate(name, const_scope); end

  def self.remove_all_constants(); end
end

module RSpec::Expectations
end

class RSpec::Expectations::BlockExpectationTarget
  def not_to(matcher, message=T.unsafe(nil), &block); end

  def to(matcher, message=T.unsafe(nil), &block); end

  def to_not(matcher, message=T.unsafe(nil), &block); end
end

class RSpec::Expectations::BlockExpectationTarget
end

class RSpec::Expectations::BlockSnippetExtractor
  def body_content_lines(); end

  def initialize(proc, method_name); end

  def method_name(); end
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::AmbiguousTargetError
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_content_locations(); end

  def method_call_location(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockLocator
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def beginning_line_number(); end

  def beginning_line_number=(_); end

  def body_tokens(); end

  def method_name(); end

  def method_name=(_); end

  def source(); end

  def source=(_); end

  def state(); end
end

class RSpec::Expectations::BlockSnippetExtractor::BlockTokenExtractor
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::Error
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor::TargetNotFoundError
end

class RSpec::Expectations::BlockSnippetExtractor
  def self.try_extracting_single_line_body_of(proc, method_name); end
end

class RSpec::Expectations::Configuration
  def add_should_and_should_not_to(*modules); end

  def backtrace_formatter(); end

  def backtrace_formatter=(backtrace_formatter); end

  def color?(); end

  def false_positives_handler(); end

  def include_chain_clauses_in_custom_matcher_descriptions=(include_chain_clauses_in_custom_matcher_descriptions); end

  def include_chain_clauses_in_custom_matcher_descriptions?(); end

  def max_formatted_output_length=(length); end

  def on_potential_false_positives(); end

  def on_potential_false_positives=(behavior); end

  def reset_syntaxes_to_default(); end

  def syntax(); end

  def syntax=(values); end

  def warn_about_potential_false_positives=(boolean); end

  def warn_about_potential_false_positives?(); end
  FALSE_POSITIVE_BEHAVIOURS = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
end

module RSpec::Expectations::Configuration::NullBacktraceFormatter
  extend ::T::Sig
  def self.format_backtrace(backtrace); end
end

class RSpec::Expectations::Configuration
end

module RSpec::Expectations::ExpectationHelper
end

module RSpec::Expectations::ExpectationHelper
  extend ::T::Sig
  def self.check_message(msg); end

  def self.handle_failure(matcher, message, failure_message_method); end

  def self.modern_matcher_from(matcher); end

  def self.with_matcher(handler, matcher, message); end
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationNotMetError
end

class RSpec::Expectations::ExpectationTarget
  include ::RSpec::Expectations::ExpectationTarget::InstanceMethods
  def initialize(value); end

  def target(); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  def not_to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def to_not(matcher=T.unsafe(nil), message=T.unsafe(nil), &block); end
end

module RSpec::Expectations::ExpectationTarget::InstanceMethods
  extend ::T::Sig
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
end

module RSpec::Expectations::ExpectationTarget::UndefinedValue
  extend ::T::Sig
end

class RSpec::Expectations::ExpectationTarget
  def self.for(value, block); end
end

class RSpec::Expectations::FailureAggregator
  def aggregate(); end

  def block_label(); end

  def call(failure, options); end

  def failures(); end

  def initialize(block_label, metadata); end

  def metadata(); end

  def other_errors(); end
end

class RSpec::Expectations::FailureAggregator
end

class RSpec::Expectations::LegacyMatcherAdapter
  def initialize(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec1
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def failure_message(); end

  def failure_message_when_negated(); end
end

class RSpec::Expectations::LegacyMatcherAdapter::RSpec2
  def self.interface_matches?(matcher); end
end

class RSpec::Expectations::LegacyMatcherAdapter
  def self.wrap(matcher); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
  def aggregation_block_label(); end

  def aggregation_metadata(); end

  def all_exceptions(); end

  def exception_count_description(); end

  def failures(); end

  def initialize(failure_aggregator); end

  def other_errors(); end

  def summary(); end
end

class RSpec::Expectations::MultipleExpectationsNotMetError
end

class RSpec::Expectations::NegativeExpectationHandler
end

class RSpec::Expectations::NegativeExpectationHandler
  def self.does_not_match?(matcher, actual, &block); end

  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

class RSpec::Expectations::PositiveExpectationHandler
end

class RSpec::Expectations::PositiveExpectationHandler
  def self.handle_matcher(actual, initial_matcher, message=T.unsafe(nil), &block); end

  def self.opposite_should_method(); end

  def self.should_method(); end

  def self.verb(); end
end

module RSpec::Expectations::Syntax
end

module RSpec::Expectations::Syntax
  extend ::T::Sig
  def self.default_should_host(); end

  def self.disable_expect(syntax_host=T.unsafe(nil)); end

  def self.disable_should(syntax_host=T.unsafe(nil)); end

  def self.enable_expect(syntax_host=T.unsafe(nil)); end

  def self.enable_should(syntax_host=T.unsafe(nil)); end

  def self.expect_enabled?(syntax_host=T.unsafe(nil)); end

  def self.should_enabled?(syntax_host=T.unsafe(nil)); end

  def self.warn_about_should!(); end

  def self.warn_about_should_unless_configured(method_name); end
end

module RSpec::Expectations::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Expectations::Version
  extend ::T::Sig
end

module RSpec::Expectations
  extend ::T::Sig
  def self.configuration(); end

  def self.differ(); end

  def self.fail_with(message, expected=T.unsafe(nil), actual=T.unsafe(nil)); end
end

module RSpec::Matchers
  def a_block_changing(*args, &block); end

  def a_block_outputting(*args, &block); end

  def a_block_raising(*args, &block); end

  def a_block_throwing(*args, &block); end

  def a_block_yielding_control(*args, &block); end

  def a_block_yielding_successive_args(*args, &block); end

  def a_block_yielding_with_args(*args, &block); end

  def a_block_yielding_with_no_args(*args, &block); end

  def a_collection_containing_exactly(*args, &block); end

  def a_collection_ending_with(*args, &block); end

  def a_collection_including(*args, &block); end

  def a_collection_starting_with(*args, &block); end

  def a_falsey_value(*args, &block); end

  def a_falsy_value(*args, &block); end

  def a_hash_including(*args, &block); end

  def a_kind_of(*args, &block); end

  def a_nil_value(*args, &block); end

  def a_range_covering(*args, &block); end

  def a_string_ending_with(*args, &block); end

  def a_string_including(*args, &block); end

  def a_string_matching(*args, &block); end

  def a_string_starting_with(*args, &block); end

  def a_truthy_value(*args, &block); end

  def a_value(*args, &block); end

  def a_value_between(*args, &block); end

  def a_value_within(*args, &block); end

  def aggregate_failures(label=T.unsafe(nil), metadata=T.unsafe(nil), &block); end

  def all(expected); end

  def an_instance_of(*args, &block); end

  def an_object_eq_to(*args, &block); end

  def an_object_eql_to(*args, &block); end

  def an_object_equal_to(*args, &block); end

  def an_object_existing(*args, &block); end

  def an_object_having_attributes(*args, &block); end

  def an_object_matching(*args, &block); end

  def an_object_responding_to(*args, &block); end

  def an_object_satisfying(*args, &block); end

  def be(*args); end

  def be_a(klass); end

  def be_a_kind_of(expected); end

  def be_an(klass); end

  def be_an_instance_of(expected); end

  def be_between(min, max); end

  def be_falsey(); end

  def be_falsy(*args, &block); end

  def be_instance_of(expected); end

  def be_kind_of(expected); end

  def be_nil(); end

  def be_truthy(); end

  def be_within(delta); end

  def change(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def changing(*args, &block); end

  def contain_exactly(*items); end

  def containing_exactly(*args, &block); end

  def cover(*values); end

  def covering(*args, &block); end

  def end_with(*expected); end

  def ending_with(*args, &block); end

  def eq(expected); end

  def eq_to(*args, &block); end

  def eql(expected); end

  def eql_to(*args, &block); end

  def equal(expected); end

  def equal_to(*args, &block); end

  def exist(*args); end

  def existing(*args, &block); end

  def expect(value=T.unsafe(nil), &block); end

  def have_attributes(expected); end

  def having_attributes(*args, &block); end

  def include(*expected); end

  def including(*args, &block); end

  def match(expected); end

  def match_array(items); end

  def match_regex(*args, &block); end

  def matching(*args, &block); end

  def output(expected=T.unsafe(nil)); end

  def raise_error(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raise_exception(error=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def raising(*args, &block); end

  def respond_to(*names); end

  def responding_to(*args, &block); end

  def satisfy(description=T.unsafe(nil), &block); end

  def satisfying(*args, &block); end

  def start_with(*expected); end

  def starting_with(*args, &block); end

  def throw_symbol(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def throwing(*args, &block); end

  def within(*args, &block); end

  def yield_control(); end

  def yield_successive_args(*args); end

  def yield_with_args(*args); end

  def yield_with_no_args(); end

  def yielding_control(*args, &block); end

  def yielding_successive_args(*args, &block); end

  def yielding_with_args(*args, &block); end

  def yielding_with_no_args(*args, &block); end
  BE_PREDICATE_REGEX = ::T.let(nil, ::T.untyped)
  DYNAMIC_MATCHER_REGEX = ::T.let(nil, ::T.untyped)
  HAS_REGEX = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::AliasedMatcher
  def description(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(base_matcher, description_block); end

  def method_missing(*_); end
end

class RSpec::Matchers::AliasedMatcher
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedMatcherWithOperatorSupport
end

class RSpec::Matchers::AliasedNegatedMatcher
  def does_not_match?(*args, &block); end

  def matches?(*args, &block); end
end

class RSpec::Matchers::AliasedNegatedMatcher
end

module RSpec::Matchers::BuiltIn
end

class RSpec::Matchers::BuiltIn::All
  def does_not_match?(_actual); end

  def failed_objects(); end

  def initialize(matcher); end

  def matcher(); end
end

class RSpec::Matchers::BuiltIn::All
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  include ::RSpec::Matchers::Composable
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def actual(); end

  def actual_formatted(); end

  def description(); end

  def diffable?(); end

  def expected(); end

  def expected_formatted(); end

  def expects_call_stack_jump?(); end

  def initialize(expected=T.unsafe(nil)); end

  def match_unless_raises(*exceptions); end

  def matcher_name(); end

  def matcher_name=(matcher_name); end

  def matches?(actual); end

  def present_ivars(); end

  def rescued_exception(); end

  def supports_block_expectations?(); end
  UNDEFINED = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def failure_message(); end

  def failure_message_when_negated(); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  extend ::T::Sig
  def self.has_default_failure_messages?(matcher); end
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
end

module RSpec::Matchers::BuiltIn::BaseMatcher::HashFormatting
  extend ::T::Sig
  def self.improve_hash_formatting(inspect_string); end
end

class RSpec::Matchers::BuiltIn::BaseMatcher
  def self.matcher_name(); end
end

class RSpec::Matchers::BuiltIn::Be
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def <(operand); end

  def <=(operand); end

  def ==(operand); end

  def ===(operand); end

  def =~(operand); end

  def >(operand); end

  def >=(operand); end

  def initialize(*args); end
end

class RSpec::Matchers::BuiltIn::Be
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAKindOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeAnInstanceOf
end

class RSpec::Matchers::BuiltIn::BeBetween
  def exclusive(); end

  def inclusive(); end

  def initialize(min, max); end
end

class RSpec::Matchers::BuiltIn::BeBetween
end

class RSpec::Matchers::BuiltIn::BeComparedTo
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def initialize(operand, operator); end
end

class RSpec::Matchers::BuiltIn::BeComparedTo
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

class RSpec::Matchers::BuiltIn::BeFalsey
end

module RSpec::Matchers::BuiltIn::BeHelpers
end

module RSpec::Matchers::BuiltIn::BeHelpers
  extend ::T::Sig
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BeNil
end

class RSpec::Matchers::BuiltIn::BePredicate
  include ::RSpec::Matchers::BuiltIn::BeHelpers
  def does_not_match?(actual, &block); end

  def initialize(*args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::BePredicate
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeTruthy
end

class RSpec::Matchers::BuiltIn::BeWithin
  def initialize(delta); end

  def of(expected); end

  def percent_of(expected); end
end

class RSpec::Matchers::BuiltIn::BeWithin
end

class RSpec::Matchers::BuiltIn::Change
  def by(expected_delta); end

  def by_at_least(minimum); end

  def by_at_most(maximum); end

  def does_not_match?(event_proc); end

  def from(value); end

  def initialize(receiver=T.unsafe(nil), message=T.unsafe(nil), &block); end

  def matches?(event_proc); end

  def to(value); end
end

class RSpec::Matchers::BuiltIn::Change
end

class RSpec::Matchers::BuiltIn::Compound
  def diffable_matcher_list(); end

  def does_not_match?(_actual); end

  def evaluator(); end

  def initialize(matcher_1, matcher_2); end

  def matcher_1(); end

  def matcher_2(); end
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::And
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def initialize(actual, matcher_1, matcher_2); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::NestedEvaluator
  def self.matcher_expects_call_stack_jump?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::Or
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
  def initialize(actual, *_); end

  def matcher_matches?(matcher); end
end

class RSpec::Matchers::BuiltIn::Compound::SequentialEvaluator
end

class RSpec::Matchers::BuiltIn::Compound
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
  def actual_to_expected_matched_indexes(); end

  def expected_to_actual_matched_indexes(); end

  def find_best_solution(); end

  def initialize(expected_to_actual_matched_indexes, actual_to_expected_matched_indexes); end

  def solution(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::NullSolution
  def self.worse_than?(_other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def +(derived_candidate_solution); end

  def candidate?(); end

  def ideal?(); end

  def indeterminate_actual_indexes(); end

  def indeterminate_actual_indexes=(_); end

  def indeterminate_expected_indexes(); end

  def indeterminate_expected_indexes=(_); end

  def unmatched_actual_indexes(); end

  def unmatched_actual_indexes=(_); end

  def unmatched_expected_indexes(); end

  def unmatched_expected_indexes=(_); end

  def unmatched_item_count(); end

  def worse_than?(other); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer::Solution
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Matchers::BuiltIn::ContainExactly::PairingsMaximizer
end

class RSpec::Matchers::BuiltIn::ContainExactly
end

class RSpec::Matchers::BuiltIn::Cover
  def does_not_match?(range); end

  def initialize(*expected); end

  def matches?(range); end
end

class RSpec::Matchers::BuiltIn::Cover
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::EndWith
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eq
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Eql
end

class RSpec::Matchers::BuiltIn::Equal
  LITERAL_SINGLETONS = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::BuiltIn::Equal
end

class RSpec::Matchers::BuiltIn::Exist
  def does_not_match?(actual); end

  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
  def actual_exists?(); end

  def valid_test?(); end

  def validity_message(); end
end

class RSpec::Matchers::BuiltIn::Exist::ExistenceTest
end

class RSpec::Matchers::BuiltIn::Exist
end

class RSpec::Matchers::BuiltIn::Has
  def does_not_match?(actual, &block); end

  def initialize(method_name, *args, &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Has
end

class RSpec::Matchers::BuiltIn::HaveAttributes
  def does_not_match?(actual); end

  def initialize(expected); end

  def respond_to_failed(); end
end

class RSpec::Matchers::BuiltIn::HaveAttributes
end

class RSpec::Matchers::BuiltIn::Include
  def does_not_match?(actual); end

  def expecteds(); end

  def initialize(*expecteds); end
end

class RSpec::Matchers::BuiltIn::Include
end

class RSpec::Matchers::BuiltIn::Match
  def initialize(expected); end

  def with_captures(*captures); end
end

class RSpec::Matchers::BuiltIn::Match
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::NegativeOperatorMatcher
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def !=(_expected); end

  def !~(_expected); end

  def <(expected); end

  def <=(expected); end

  def ==(expected); end

  def ===(expected); end

  def =~(expected); end

  def >(expected); end

  def >=(expected); end

  def description(); end

  def fail_with_message(message); end

  def initialize(actual); end
end

class RSpec::Matchers::BuiltIn::OperatorMatcher
  def self.get(klass, operator); end

  def self.register(klass, operator, matcher); end

  def self.registry(); end

  def self.unregister(klass, operator); end

  def self.use_custom_matcher_or_delegate(operator); end
end

class RSpec::Matchers::BuiltIn::Output
  def does_not_match?(block); end

  def initialize(expected); end

  def matches?(block); end

  def to_stderr(); end

  def to_stderr_from_any_process(); end

  def to_stdout(); end

  def to_stdout_from_any_process(); end
end

class RSpec::Matchers::BuiltIn::Output
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
  def __delegate_operator(actual, operator, expected); end
end

class RSpec::Matchers::BuiltIn::PositiveOperatorMatcher
end

class RSpec::Matchers::BuiltIn::RaiseError
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_error_or_message=T.unsafe(nil), expected_message=T.unsafe(nil), &block); end

  def matches?(given_proc, negative_expectation=T.unsafe(nil), &block); end

  def supports_block_expectations?(); end

  def with_message(expected_message); end
end

class RSpec::Matchers::BuiltIn::RaiseError
end

class RSpec::Matchers::BuiltIn::RespondTo
  def and_any_keywords(); end

  def and_keywords(*keywords); end

  def and_unlimited_arguments(); end

  def argument(); end

  def arguments(); end

  def does_not_match?(actual); end

  def initialize(*names); end

  def with(n); end

  def with_any_keywords(); end

  def with_keywords(*keywords); end

  def with_unlimited_arguments(); end
end

class RSpec::Matchers::BuiltIn::RespondTo
end

class RSpec::Matchers::BuiltIn::Satisfy
  def initialize(description=T.unsafe(nil), &block); end

  def matches?(actual, &block); end
end

class RSpec::Matchers::BuiltIn::Satisfy
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
  def initialize(*expected); end
end

class RSpec::Matchers::BuiltIn::StartOrEndWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::StartWith
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
  include ::RSpec::Matchers::Composable
  def description(); end

  def does_not_match?(given_proc); end

  def expects_call_stack_jump?(); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(expected_symbol=T.unsafe(nil), expected_arg=T.unsafe(nil)); end

  def matches?(given_proc); end

  def supports_block_expectations?(); end
end

class RSpec::Matchers::BuiltIn::ThrowSymbol
end

class RSpec::Matchers::BuiltIn::YieldControl
  def at_least(number); end

  def at_most(number); end

  def does_not_match?(block); end

  def exactly(number); end

  def initialize(); end

  def matches?(block); end

  def once(); end

  def thrice(); end

  def times(); end

  def twice(); end
end

class RSpec::Matchers::BuiltIn::YieldControl
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldSuccessiveArgs
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
  def does_not_match?(block); end

  def initialize(*args); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithArgs
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
  def does_not_match?(block); end

  def matches?(block); end
end

class RSpec::Matchers::BuiltIn::YieldWithNoArgs
end

module RSpec::Matchers::BuiltIn
  extend ::T::Sig
end

module RSpec::Matchers::Composable
  def &(matcher); end

  def ===(value); end

  def and(matcher); end

  def or(matcher); end

  def |(matcher); end
end

module RSpec::Matchers::Composable
  extend ::T::Sig
  def self.should_enumerate?(item); end

  def self.surface_descriptions_in(item); end

  def self.unreadable_io?(object); end
end

module RSpec::Matchers::DSL
  def alias_matcher(new_name, old_name, options=T.unsafe(nil), &description_override); end

  def define(name, &declarations); end

  def define_negated_matcher(negated_name, base_name, &description_override); end

  def matcher(name, &declarations); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  def description(); end

  def diffable?(); end

  def expects_call_stack_jump?(); end

  def supports_block_expectations?(); end
end

module RSpec::Matchers::DSL::DefaultImplementations
  extend ::T::Sig
end

module RSpec::Matchers::DSL::Macros
  def chain(method_name, *attr_names, &definition); end

  def description(&definition); end

  def diffable(); end

  def failure_message(&definition); end

  def failure_message_when_negated(&definition); end

  def match(options=T.unsafe(nil), &match_block); end

  def match_unless_raises(expected_exception=T.unsafe(nil), &match_block); end

  def match_when_negated(&match_block); end

  def supports_block_expectations(); end
  RAISE_NOTIFIER = ::T.let(nil, ::T.untyped)
end

module RSpec::Matchers::DSL::Macros::Deprecated
  def failure_message_for_should(&definition); end

  def failure_message_for_should_not(&definition); end

  def match_for_should(&definition); end

  def match_for_should_not(&definition); end
end

module RSpec::Matchers::DSL::Macros::Deprecated
  extend ::T::Sig
end

module RSpec::Matchers::DSL::Macros
  extend ::T::Sig
end

class RSpec::Matchers::DSL::Matcher
  include ::RSpec::Matchers::DSL::DefaultImplementations
  include ::RSpec::Matchers::BuiltIn::BaseMatcher::DefaultFailureMessages
  include ::RSpec::Matchers
  include ::RSpec::Matchers::Composable
  def actual(); end

  def block_arg(); end

  def expected(); end

  def expected_as_array(); end

  def initialize(name, declarations, matcher_execution_context, *expected, &block_arg); end

  def name(); end

  def rescued_exception(); end
end

class RSpec::Matchers::DSL::Matcher
  extend ::RSpec::Matchers::DSL::Macros
  extend ::RSpec::Matchers::DSL::Macros::Deprecated
end

module RSpec::Matchers::DSL
  extend ::T::Sig
end

module RSpec::Matchers::EnglishPhrasing
end

module RSpec::Matchers::EnglishPhrasing
  extend ::T::Sig
  def self.list(obj); end

  def self.split_words(sym); end
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def initialize(expected_list); end

  def message_with_diff(message, differ, actual); end
  DEFAULT_DIFF_LABEL = ::T.let(nil, ::T.untyped)
  DESCRIPTION_MAX_LENGTH = ::T.let(nil, ::T.untyped)
end

class RSpec::Matchers::ExpectedsForMultipleDiffs
  def self.diff_label_for(matcher); end

  def self.for_many_matchers(matchers); end

  def self.from(expected); end

  def self.truncated(description); end
end

class RSpec::Matchers::MatcherDelegator
  include ::RSpec::Matchers::Composable
  def base_matcher(); end

  def initialize(base_matcher); end

  def method_missing(*args, &block); end
end

class RSpec::Matchers::MatcherDelegator
end

module RSpec::Matchers
  extend ::RSpec::Matchers::DSL
  extend ::T::Sig
  def self.alias_matcher(*args, &block); end

  def self.clear_generated_description(); end

  def self.configuration(); end

  def self.generated_description(); end

  def self.is_a_describable_matcher?(obj); end

  def self.is_a_matcher?(obj); end

  def self.last_description(); end

  def self.last_expectation_handler(); end

  def self.last_expectation_handler=(last_expectation_handler); end

  def self.last_matcher(); end

  def self.last_matcher=(last_matcher); end
end

module RSpec::Rails
end

module RSpec::Rails::FeatureCheck
end

module RSpec::Rails::FeatureCheck
  extend ::T::Sig
  def self.can_check_pending_migrations?(); end

  def self.can_maintain_test_schema?(); end

  def self.has_1_9_hash_syntax?(); end

  def self.has_action_mailer?(); end

  def self.has_action_mailer_preview?(); end

  def self.has_action_mailer_show_preview?(); end

  def self.has_active_job?(); end

  def self.has_active_record?(); end

  def self.has_active_record_migration?(); end

  def self.has_file_fixture?(); end

  def self.type_metatag(type); end
end

class RSpec::Rails::Railtie
end

class RSpec::Rails::Railtie
end

module RSpec::Rails
  extend ::T::Sig
end

module RSpec::Support
  DEFAULT_FAILURE_NOTIFIER = ::T.let(nil, ::T.untyped)
  DEFAULT_WARNING_NOTIFIER = ::T.let(nil, ::T.untyped)
  KERNEL_METHOD_METHOD = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  AVOID_RESCUING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::AllExceptionsExceptOnesWeMustNotRescue
  extend ::T::Sig
  def self.===(exception); end
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::BlockSignature
end

class RSpec::Support::ComparableVersion
  include ::Comparable
  def initialize(string); end

  def segments(); end

  def string(); end
end

class RSpec::Support::ComparableVersion
end

class RSpec::Support::Differ
  def color?(); end

  def diff(actual, expected); end

  def diff_as_object(actual, expected); end

  def diff_as_string(actual, expected); end

  def initialize(opts=T.unsafe(nil)); end
end

class RSpec::Support::Differ
end

class RSpec::Support::DirectoryMaker
end

class RSpec::Support::DirectoryMaker
  def self.mkdir_p(path); end
end

class RSpec::Support::EncodedString
  def <<(string); end

  def ==(*args, &block); end

  def empty?(*args, &block); end

  def encoding(*args, &block); end

  def eql?(*args, &block); end

  def initialize(string, encoding=T.unsafe(nil)); end

  def lines(*args, &block); end

  def source_encoding(); end

  def split(regex_or_string); end

  def to_str(); end
  ENCODE_NO_CONVERTER = ::T.let(nil, ::T.untyped)
  ENCODE_UNCONVERTABLE_BYTES = ::T.let(nil, ::T.untyped)
  REPLACE = ::T.let(nil, ::T.untyped)
  US_ASCII = ::T.let(nil, ::T.untyped)
  UTF_8 = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::EncodedString
  def self.pick_encoding(source_a, source_b); end
end

module RSpec::Support::FuzzyMatcher
end

module RSpec::Support::FuzzyMatcher
  extend ::T::Sig
  def self.values_match?(expected, actual); end
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
  def has_kw_args_in?(args); end

  def initialize(signature); end

  def invalid_kw_args_from(_kw_args); end

  def missing_kw_args_from(_kw_args); end

  def non_kw_args_arity_description(); end

  def valid_non_kw_args?(*args); end
end

class RSpec::Support::LooseSignatureVerifier::SignatureWithKeywordArgumentsMatcher
end

class RSpec::Support::LooseSignatureVerifier
end

class RSpec::Support::MethodSignature
  def arbitrary_kw_args?(); end

  def classify_arity(arity=T.unsafe(nil)); end

  def classify_parameters(); end

  def could_contain_kw_args?(args); end

  def description(); end

  def has_kw_args_in?(args); end

  def initialize(method); end

  def invalid_kw_args_from(given_kw_args); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def missing_kw_args_from(given_kw_args); end

  def non_kw_args_arity_description(); end

  def optional_kw_args(); end

  def required_kw_args(); end

  def unlimited_args?(); end

  def valid_non_kw_args?(positional_arg_count, optional_max_arg_count=T.unsafe(nil)); end
  INFINITY = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::MethodSignature
end

class RSpec::Support::MethodSignatureExpectation
  def empty?(); end

  def expect_arbitrary_keywords(); end

  def expect_arbitrary_keywords=(expect_arbitrary_keywords); end

  def expect_unlimited_arguments(); end

  def expect_unlimited_arguments=(expect_unlimited_arguments); end

  def keywords(); end

  def keywords=(values); end

  def max_count(); end

  def max_count=(number); end

  def min_count(); end

  def min_count=(number); end
end

class RSpec::Support::MethodSignatureExpectation
end

class RSpec::Support::MethodSignatureVerifier
  def error_message(); end

  def initialize(signature, args=T.unsafe(nil)); end

  def kw_args(); end

  def max_non_kw_args(); end

  def min_non_kw_args(); end

  def non_kw_args(); end

  def valid?(); end

  def with_expectation(expectation); end
end

class RSpec::Support::MethodSignatureVerifier
end

module RSpec::Support::OS
end

module RSpec::Support::OS
  extend ::T::Sig
  def self.windows?(); end

  def self.windows_file_path?(); end
end

class RSpec::Support::ObjectFormatter
  def format(object); end

  def initialize(max_formatted_output_length=T.unsafe(nil)); end

  def max_formatted_output_length(); end

  def max_formatted_output_length=(max_formatted_output_length); end

  def prepare_array(array); end

  def prepare_element(element); end

  def prepare_for_inspection(object); end

  def prepare_hash(input_hash); end

  def recursive_structure?(object); end

  def sort_hash_keys(input_hash); end

  def with_entering_structure(structure); end
  ELLIPSIS = ::T.let(nil, ::T.untyped)
  INSPECTOR_CLASSES = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def formatter(); end

  def formatter=(_); end

  def object(); end

  def object=(_); end

  def pretty_print(pp); end
end

class RSpec::Support::ObjectFormatter::BaseInspector
  def self.[](*_); end

  def self.can_inspect?(_object); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
end

class RSpec::Support::ObjectFormatter::BigDecimalInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::DateTimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
end

class RSpec::Support::ObjectFormatter::DelegatorInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
end

class RSpec::Support::ObjectFormatter::DescribableMatcherInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def pretty_print(pp); end

  def text(); end

  def text=(_); end
end

class RSpec::Support::ObjectFormatter::InspectableItem
  def self.[](*_); end

  def self.members(); end
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
end

class RSpec::Support::ObjectFormatter::InspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::TimeInspector
  FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::TimeInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def klass(); end

  def native_object_id(); end
  OBJECT_ID_FORMAT = ::T.let(nil, ::T.untyped)
end

class RSpec::Support::ObjectFormatter::UninspectableObjectInspector
  def self.can_inspect?(object); end
end

class RSpec::Support::ObjectFormatter
  def self.default_instance(); end

  def self.format(object); end

  def self.prepare_for_inspection(object); end
end

module RSpec::Support::RecursiveConstMethods
  def const_defined_on?(mod, const_name); end

  def constants_defined_on(mod); end

  def get_const_defined_on(mod, const_name); end

  def normalize_const_name(const_name); end

  def recursive_const_defined?(const_name); end

  def recursive_const_get(const_name); end
end

module RSpec::Support::RecursiveConstMethods
  extend ::T::Sig
end

class RSpec::Support::ReentrantMutex
  def synchronize(); end
end

class RSpec::Support::ReentrantMutex
end

module RSpec::Support::Ruby
end

module RSpec::Support::Ruby
  extend ::T::Sig
  def self.jruby?(); end

  def self.jruby_9000?(); end

  def self.jruby_version(); end

  def self.mri?(); end

  def self.non_mri?(); end

  def self.rbx?(); end
end

module RSpec::Support::RubyFeatures
end

module RSpec::Support::RubyFeatures
  extend ::T::Sig
  def self.caller_locations_supported?(); end

  def self.fork_supported?(); end

  def self.kw_args_supported?(); end

  def self.module_prepends_supported?(); end

  def self.module_refinement_supported?(); end

  def self.optional_and_splat_args_supported?(); end

  def self.required_kw_args_supported?(); end

  def self.ripper_supported?(); end

  def self.supports_exception_cause?(); end

  def self.supports_rebinding_module_methods?(); end
end

module RSpec::Support::Version
  STRING = ::T.let(nil, ::T.untyped)
end

module RSpec::Support::Version
  extend ::T::Sig
end

module RSpec::Support::Warnings
  def deprecate(deprecated, options=T.unsafe(nil)); end

  def warn_deprecation(message, options=T.unsafe(nil)); end

  def warn_with(message, options=T.unsafe(nil)); end

  def warning(text, options=T.unsafe(nil)); end
end

module RSpec::Support::Warnings
  extend ::T::Sig
end

module RSpec::Support
  extend ::T::Sig
  def self.class_of(object); end

  def self.define_optimized_require_for_rspec(lib, &require_relative); end

  def self.deregister_matcher_definition(&block); end

  def self.failure_notifier(); end

  def self.failure_notifier=(callable); end

  def self.is_a_matcher?(object); end

  def self.matcher_definitions(); end

  def self.method_handle_for(object, method_name); end

  def self.notify_failure(failure, options=T.unsafe(nil)); end

  def self.register_matcher_definition(&block); end

  def self.require_rspec_core(f); end

  def self.require_rspec_expectations(f); end

  def self.require_rspec_matchers(f); end

  def self.require_rspec_support(f); end

  def self.rspec_description_for_object(object); end

  def self.thread_local_data(); end

  def self.warning_notifier(); end

  def self.warning_notifier=(warning_notifier); end

  def self.with_failure_notifier(callable); end
end

module RSpec
  extend ::RSpec::Support::Warnings
  extend ::RSpec::Core::Warnings
  extend ::T::Sig
  def self.clear_examples(); end

  def self.configuration(); end

  def self.configuration=(configuration); end

  def self.configure(); end

  def self.const_missing(name); end

  def self.context(*args, &example_group_block); end

  def self.current_example(); end

  def self.current_example=(example); end

  def self.describe(*args, &example_group_block); end

  def self.example_group(*args, &example_group_block); end

  def self.fcontext(*args, &example_group_block); end

  def self.fdescribe(*args, &example_group_block); end

  def self.reset(); end

  def self.world(); end

  def self.world=(world); end

  def self.xcontext(*args, &example_group_block); end

  def self.xdescribe(*args, &example_group_block); end
end

module Racc
  Racc_No_Extensions = ::T.let(nil, ::T.untyped)
end

class Racc::CparseParams
end

class Racc::CparseParams
end

class Racc::ParseError
  extend ::T::Sig
end

class Racc::Parser
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  Racc_Main_Parsing_Routine = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Id_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Revision_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_C = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Core_Version_R = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Revision = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Type = ::T.let(nil, ::T.untyped)
  Racc_Runtime_Version = ::T.let(nil, ::T.untyped)
  Racc_YY_Parse_Method = ::T.let(nil, ::T.untyped)
end

class Racc::Parser
  extend ::T::Sig
end

module Racc
  extend ::T::Sig
end

module Rack
  CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  ETAG = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  HTTPS = ::T.let(nil, ::T.untyped)
  HTTP_COOKIE = ::T.let(nil, ::T.untyped)
  HTTP_HOST = ::T.let(nil, ::T.untyped)
  HTTP_VERSION = ::T.let(nil, ::T.untyped)
  LINK = ::T.let(nil, ::T.untyped)
  OPTIONS = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_ERRORS = ::T.let(nil, ::T.untyped)
  RACK_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_HIJACK_IO = ::T.let(nil, ::T.untyped)
  RACK_INPUT = ::T.let(nil, ::T.untyped)
  RACK_IS_HIJACK = ::T.let(nil, ::T.untyped)
  RACK_LOGGER = ::T.let(nil, ::T.untyped)
  RACK_METHODOVERRIDE_ORIGINAL_METHOD = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  RACK_MULTIPART_TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  RACK_MULTIPROCESS = ::T.let(nil, ::T.untyped)
  RACK_MULTITHREAD = ::T.let(nil, ::T.untyped)
  RACK_RECURSIVE_INCLUDE = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_COOKIE_STRING = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_INPUT = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_FORM_VARS = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_HASH = ::T.let(nil, ::T.untyped)
  RACK_REQUEST_QUERY_STRING = ::T.let(nil, ::T.untyped)
  RACK_RUNONCE = ::T.let(nil, ::T.untyped)
  RACK_SESSION = ::T.let(nil, ::T.untyped)
  RACK_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  RACK_SESSION_UNPACKED_COOKIE_DATA = ::T.let(nil, ::T.untyped)
  RACK_SHOWSTATUS_DETAIL = ::T.let(nil, ::T.untyped)
  RACK_TEMPFILES = ::T.let(nil, ::T.untyped)
  RACK_URL_SCHEME = ::T.let(nil, ::T.untyped)
  RACK_VERSION = ::T.let(nil, ::T.untyped)
  RELEASE = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_PATH = ::T.let(nil, ::T.untyped)
  SCRIPT_NAME = ::T.let(nil, ::T.untyped)
  SERVER_ADDR = ::T.let(nil, ::T.untyped)
  SERVER_NAME = ::T.let(nil, ::T.untyped)
  SERVER_PORT = ::T.let(nil, ::T.untyped)
  SERVER_PROTOCOL = ::T.let(nil, ::T.untyped)
  SET_COOKIE = ::T.let(nil, ::T.untyped)
  TRACE = ::T.let(nil, ::T.untyped)
  TRANSFER_ENCODING = ::T.let(nil, ::T.untyped)
  UNLINK = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Rack::Auth
end

class Rack::Auth::AbstractHandler
  def initialize(app, realm=T.unsafe(nil), &authenticator); end

  def realm(); end

  def realm=(realm); end
end

class Rack::Auth::AbstractHandler
end

class Rack::Auth::AbstractRequest
  def initialize(env); end

  def params(); end

  def parts(); end

  def provided?(); end

  def request(); end

  def scheme(); end

  def valid?(); end
  AUTHORIZATION_KEYS = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::AbstractRequest
end

class Rack::Auth::Basic
  def call(env); end
end

class Rack::Auth::Basic::Request
  def basic?(); end

  def credentials(); end

  def username(); end
end

class Rack::Auth::Basic::Request
end

class Rack::Auth::Basic
end

module Rack::Auth::Digest
end

class Rack::Auth::Digest::MD5
  def call(env); end

  def initialize(app, realm=T.unsafe(nil), opaque=T.unsafe(nil), &authenticator); end

  def opaque(); end

  def opaque=(opaque); end

  def passwords_hashed=(passwords_hashed); end

  def passwords_hashed?(); end
  QOP = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::MD5
end

class Rack::Auth::Digest::Nonce
  def digest(); end

  def fresh?(); end

  def initialize(timestamp=T.unsafe(nil), given_digest=T.unsafe(nil)); end

  def stale?(); end

  def valid?(); end
end

class Rack::Auth::Digest::Nonce
  def self.parse(string); end

  def self.private_key(); end

  def self.private_key=(private_key); end

  def self.time_limit(); end

  def self.time_limit=(time_limit); end
end

class Rack::Auth::Digest::Params
  def [](k); end

  def []=(k, v); end

  def initialize(); end

  def quote(str); end
  UNQUOTED = ::T.let(nil, ::T.untyped)
end

class Rack::Auth::Digest::Params
  def self.dequote(str); end

  def self.parse(str); end

  def self.split_header_value(str); end
end

class Rack::Auth::Digest::Request
  def correct_uri?(); end

  def digest?(); end

  def method(); end

  def method_missing(sym, *args); end

  def nonce(); end

  def respond_to?(sym, *_); end
end

class Rack::Auth::Digest::Request
end

module Rack::Auth::Digest
  extend ::T::Sig
end

module Rack::Auth
  extend ::T::Sig
end

class Rack::BodyProxy
  def close(); end

  def closed?(); end

  def each(); end

  def initialize(body, &block); end

  def method_missing(method_name, *args, &block); end

  def respond_to?(method_name, include_all=T.unsafe(nil)); end
end

class Rack::BodyProxy
end

class Rack::Builder
  def call(env); end

  def initialize(default_app=T.unsafe(nil), &block); end

  def map(path, &block); end

  def run(app); end

  def to_app(); end

  def use(middleware, *args, &block); end

  def warmup(prc=T.unsafe(nil), &block); end
end

class Rack::Builder
  def self.app(default_app=T.unsafe(nil), &block); end

  def self.new_from_string(builder_script, file=T.unsafe(nil)); end

  def self.parse_file(config, opts=T.unsafe(nil)); end
end

class Rack::Cascade
  def <<(app); end

  def add(app); end

  def apps(); end

  def call(env); end

  def include?(app); end

  def initialize(apps, catch=T.unsafe(nil)); end
  NotFound = ::T.let(nil, ::T.untyped)
end

class Rack::Cascade
end

class Rack::Chunked
  include ::Rack::Utils
  def call(env); end

  def chunkable_version?(ver); end

  def initialize(app); end
end

class Rack::Chunked::Body
  include ::Rack::Utils
  def close(); end

  def each(); end

  def initialize(body); end
  TAIL = ::T.let(nil, ::T.untyped)
  TERM = ::T.let(nil, ::T.untyped)
end

class Rack::Chunked::Body
end

class Rack::Chunked
end

class Rack::CommonLogger
  def call(env); end

  def initialize(app, logger=T.unsafe(nil)); end
  FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::CommonLogger
end

class Rack::ConditionalGet
  def call(env); end

  def initialize(app); end
end

class Rack::ConditionalGet
end

class Rack::Config
  def call(env); end

  def initialize(app, &block); end
end

class Rack::Config
end

class Rack::ContentLength
  include ::Rack::Utils
  def call(env); end

  def initialize(app); end
end

class Rack::ContentLength
end

class Rack::ContentType
  include ::Rack::Utils
  def call(env); end

  def initialize(app, content_type=T.unsafe(nil)); end
end

class Rack::ContentType
end

class Rack::Deflater
  def call(env); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Rack::Deflater::GzipStream
  def close(); end

  def each(&block); end

  def initialize(body, mtime); end

  def write(data); end
end

class Rack::Deflater::GzipStream
end

class Rack::Deflater
end

class Rack::Directory
  def call(env); end

  def check_bad_request(path_info); end

  def check_forbidden(path_info); end

  def entity_not_found(path_info); end

  def filesize_format(int); end

  def get(env); end

  def initialize(root, app=T.unsafe(nil)); end

  def list_directory(path_info, path, script_name); end

  def list_path(env, path, path_info, script_name); end

  def path(); end

  def root(); end

  def stat(node); end
  DIR_FILE = ::T.let(nil, ::T.untyped)
  DIR_PAGE = ::T.let(nil, ::T.untyped)
  FILESIZE_FORMAT = ::T.let(nil, ::T.untyped)
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory::DirectoryBody
end

class Rack::Directory
end

class Rack::ETag
  def call(env); end

  def initialize(app, no_cache_control=T.unsafe(nil), cache_control=T.unsafe(nil)); end
  DEFAULT_CACHE_CONTROL = ::T.let(nil, ::T.untyped)
  ETAG_STRING = ::T.let(nil, ::T.untyped)
end

class Rack::ETag
end

class Rack::File
  def call(env); end

  def get(env); end

  def initialize(root, headers=T.unsafe(nil), default_mime=T.unsafe(nil)); end

  def root(); end

  def serving(request, path); end
  ALLOWED_VERBS = ::T.let(nil, ::T.untyped)
  ALLOW_HEADER = ::T.let(nil, ::T.untyped)
end

class Rack::File::Iterator
  def close(); end

  def each(); end

  def initialize(path, range); end

  def path(); end

  def range(); end

  def to_path(); end
end

class Rack::File::Iterator
end

class Rack::File
end

class Rack::ForwardRequest
  def env(); end

  def initialize(url, env=T.unsafe(nil)); end

  def url(); end
end

class Rack::ForwardRequest
end

module Rack::Handler
end

class Rack::Handler::CGI
end

class Rack::Handler::CGI
  def self.run(app, options=T.unsafe(nil)); end

  def self.send_body(body); end

  def self.send_headers(status, headers); end

  def self.serve(app); end
end

class Rack::Handler::WEBrick
  def initialize(server, app); end
end

class Rack::Handler::WEBrick
  def self.run(app, options=T.unsafe(nil)); end

  def self.shutdown(); end

  def self.valid_options(); end
end

module Rack::Handler
  extend ::T::Sig
  def self.default(); end

  def self.get(server); end

  def self.pick(server_names); end

  def self.register(server, klass); end

  def self.try_require(prefix, const_name); end
end

class Rack::Head
  def call(env); end

  def initialize(app); end
end

class Rack::Head
end

class Rack::Lint
  include ::Rack::Lint::Assertion
  def _call(env); end

  def call(env=T.unsafe(nil)); end

  def check_content_length(status, headers); end

  def check_content_type(status, headers); end

  def check_env(env); end

  def check_error(error); end

  def check_headers(header); end

  def check_hijack(env); end

  def check_hijack_response(headers, env); end

  def check_input(input); end

  def check_status(status); end

  def close(); end

  def each(); end

  def initialize(app); end

  def verify_content_length(bytes); end
end

module Rack::Lint::Assertion
  def assert(message); end
end

module Rack::Lint::Assertion
  extend ::T::Sig
end

class Rack::Lint::ErrorWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def flush(); end

  def initialize(error); end

  def puts(str); end

  def write(str); end
end

class Rack::Lint::ErrorWrapper
end

class Rack::Lint::HijackWrapper
  include ::Rack::Lint::Assertion
  def close(*args, &block); end

  def close_read(*args, &block); end

  def close_write(*args, &block); end

  def closed?(*args, &block); end

  def flush(*args, &block); end

  def initialize(io); end

  def read(*args, &block); end

  def read_nonblock(*args, &block); end

  def write(*args, &block); end

  def write_nonblock(*args, &block); end
  REQUIRED_METHODS = ::T.let(nil, ::T.untyped)
end

class Rack::Lint::HijackWrapper
  extend ::Forwardable
end

class Rack::Lint::InputWrapper
  include ::Rack::Lint::Assertion
  def close(*args); end

  def each(*args); end

  def gets(*args); end

  def initialize(input); end

  def read(*args); end

  def rewind(*args); end
end

class Rack::Lint::InputWrapper
end

class Rack::Lint::LintError
end

class Rack::Lint::LintError
end

class Rack::Lint
end

class Rack::Lock
  def call(env); end

  def initialize(app, mutex=T.unsafe(nil)); end
end

class Rack::Lock
end

class Rack::Logger
  def call(env); end

  def initialize(app, level=T.unsafe(nil)); end
end

class Rack::Logger
end

class Rack::MediaType
  SPLIT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Rack::MediaType
  def self.params(content_type); end

  def self.type(content_type); end
end

class Rack::MethodOverride
  def call(env); end

  def initialize(app); end

  def method_override(env); end
  ALLOWED_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  HTTP_METHOD_OVERRIDE_HEADER = ::T.let(nil, ::T.untyped)
  METHOD_OVERRIDE_PARAM_KEY = ::T.let(nil, ::T.untyped)
end

class Rack::MethodOverride
end

module Rack::Mime
  MIME_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Mime
  extend ::T::Sig
  def self.match?(value, matcher); end

  def self.mime_type(ext, fallback=T.unsafe(nil)); end
end

class Rack::MockRequest
  def delete(uri, opts=T.unsafe(nil)); end

  def get(uri, opts=T.unsafe(nil)); end

  def head(uri, opts=T.unsafe(nil)); end

  def initialize(app); end

  def options(uri, opts=T.unsafe(nil)); end

  def patch(uri, opts=T.unsafe(nil)); end

  def post(uri, opts=T.unsafe(nil)); end

  def put(uri, opts=T.unsafe(nil)); end

  def request(method=T.unsafe(nil), uri=T.unsafe(nil), opts=T.unsafe(nil)); end
  DEFAULT_ENV = ::T.let(nil, ::T.untyped)
end

class Rack::MockRequest::FatalWarner
  def flush(); end

  def puts(warning); end

  def string(); end

  def write(warning); end
end

class Rack::MockRequest::FatalWarner
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest::FatalWarning
end

class Rack::MockRequest
  def self.env_for(uri=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.parse_uri_rfc2396(uri); end
end

class Rack::MockResponse
  def =~(other); end

  def errors(); end

  def errors=(errors); end

  def initialize(status, headers, body, errors=T.unsafe(nil)); end

  def match(other); end

  def original_headers(); end
end

class Rack::MockResponse
end

class Rack::MockSession
  def after_request(&block); end

  def clear_cookies(); end

  def cookie_jar(); end

  def cookie_jar=(cookie_jar); end

  def default_host(); end

  def initialize(app, default_host=T.unsafe(nil)); end

  def last_request(); end

  def last_response(); end

  def request(uri, env); end

  def set_cookie(cookie, uri=T.unsafe(nil)); end
end

class Rack::MockSession
end

module Rack::Multipart
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTE_CHAR = ::T.let(nil, ::T.untyped)
  BROKEN_QUOTED = ::T.let(nil, ::T.untyped)
  BROKEN_UNQUOTED = ::T.let(nil, ::T.untyped)
  CONDISP = ::T.let(nil, ::T.untyped)
  DISPPARM = ::T.let(nil, ::T.untyped)
  EOL = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_INITIAL_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_NAME = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_PARAMETER = ::T.let(nil, ::T.untyped)
  EXTENDED_OTHER_VALUE = ::T.let(nil, ::T.untyped)
  EXTENDED_PARAMETER = ::T.let(nil, ::T.untyped)
  MULTIPART = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_DISPOSITION = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_ID = ::T.let(nil, ::T.untyped)
  MULTIPART_CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER = ::T.let(nil, ::T.untyped)
  REGULAR_PARAMETER_NAME = ::T.let(nil, ::T.untyped)
  RFC2183 = ::T.let(nil, ::T.untyped)
  SECTION = ::T.let(nil, ::T.untyped)
  TOKEN = ::T.let(nil, ::T.untyped)
  VALUE = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Generator
  def dump(); end

  def initialize(params, first=T.unsafe(nil)); end
end

class Rack::Multipart::Generator
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::MultipartPartLimitError
end

class Rack::Multipart::Parser
  def initialize(boundary, tempfile, bufsize, query_parser); end

  def on_read(content); end

  def result(); end

  def state(); end
  BUFSIZE = ::T.let(nil, ::T.untyped)
  CHARSET = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  TEMPFILE_FACTORY = ::T.let(nil, ::T.untyped)
  TEXT_PLAIN = ::T.let(nil, ::T.untyped)
end

class Rack::Multipart::Parser::BoundedIO
  def initialize(io, content_length); end

  def read(size); end

  def rewind(); end
end

class Rack::Multipart::Parser::BoundedIO
end

class Rack::Multipart::Parser::Collector
  include ::Enumerable
  def each(); end

  def initialize(tempfile); end

  def on_mime_body(mime_index, content); end

  def on_mime_finish(mime_index); end

  def on_mime_head(mime_index, head, filename, content_type, name); end
end

class Rack::Multipart::Parser::Collector::BufferPart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::BufferPart
end

class Rack::Multipart::Parser::Collector::MimePart
  def get_data(); end
end

class Rack::Multipart::Parser::Collector::MimePart
end

class Rack::Multipart::Parser::Collector::TempfilePart
  def close(); end

  def file?(); end
end

class Rack::Multipart::Parser::Collector::TempfilePart
end

class Rack::Multipart::Parser::Collector
end

class Rack::Multipart::Parser::MultipartInfo
  def params(); end

  def params=(_); end

  def tmp_files(); end

  def tmp_files=(_); end
end

class Rack::Multipart::Parser::MultipartInfo
  def self.[](*_); end

  def self.members(); end
end

class Rack::Multipart::Parser
  def self.parse(io, content_length, content_type, tmpfile, bufsize, qp); end

  def self.parse_boundary(content_type); end
end

class Rack::Multipart::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(path, content_type=T.unsafe(nil), binary=T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def respond_to?(*args); end
end

class Rack::Multipart::UploadedFile
end

module Rack::Multipart
  extend ::T::Sig
  def self.build_multipart(params, first=T.unsafe(nil)); end

  def self.extract_multipart(req, params=T.unsafe(nil)); end

  def self.parse_multipart(env, params=T.unsafe(nil)); end
end

class Rack::NullLogger
  def <<(msg); end

  def add(severity, message=T.unsafe(nil), progname=T.unsafe(nil), &block); end

  def call(env); end

  def close(); end

  def datetime_format(); end

  def datetime_format=(datetime_format); end

  def debug(progname=T.unsafe(nil), &block); end

  def debug?(); end

  def error(progname=T.unsafe(nil), &block); end

  def error?(); end

  def fatal(progname=T.unsafe(nil), &block); end

  def fatal?(); end

  def formatter(); end

  def formatter=(formatter); end

  def info(progname=T.unsafe(nil), &block); end

  def info?(); end

  def initialize(app); end

  def level(); end

  def level=(level); end

  def progname(); end

  def progname=(progname); end

  def sev_threshold(); end

  def sev_threshold=(sev_threshold); end

  def unknown(progname=T.unsafe(nil), &block); end

  def warn(progname=T.unsafe(nil), &block); end

  def warn?(); end
end

class Rack::NullLogger
end

module Rack::Protection
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def mask_authenticity_token(session); end
  TOKEN_LENGTH = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::AuthenticityToken
  def self.random_token(); end

  def self.token(session); end
end

class Rack::Protection::Base
  def accepts?(env); end

  def app(); end

  def call(env); end

  def default_options(); end

  def default_reaction(env); end

  def deny(env); end

  def drop_session(env); end

  def encrypt(value); end

  def html?(headers); end

  def initialize(app, options=T.unsafe(nil)); end

  def instrument(env); end

  def options(); end

  def origin(env); end

  def random_string(secure=T.unsafe(nil)); end

  def react(env); end

  def referrer(env); end

  def report(env); end

  def safe?(env); end

  def secure_compare(a, b); end

  def session(env); end

  def session?(env); end

  def warn(env, message); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::Base
  def self.default_options(options); end

  def self.default_reaction(reaction); end
end

class Rack::Protection::ContentSecurityPolicy
  def csp_policy(); end
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  NO_ARG_DIRECTIVES = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::ContentSecurityPolicy
end

class Rack::Protection::CookieTossing
  def bad_cookies(); end

  def cookie_paths(path); end

  def empty_cookie(host, path); end

  def redirect(env); end

  def remove_bad_cookies(request, response); end

  def session_key(); end
end

class Rack::Protection::CookieTossing
end

class Rack::Protection::EscapedParams
  def escape(object); end

  def escape_hash(hash); end

  def escape_string(str); end

  def handle(hash); end

  def initialize(*_); end
end

class Rack::Protection::EscapedParams
  extend ::Rack::Utils
end

class Rack::Protection::FormToken
end

class Rack::Protection::FormToken
end

class Rack::Protection::FrameOptions
  def frame_options(); end
end

class Rack::Protection::FrameOptions
end

class Rack::Protection::HttpOrigin
  def base_url(env); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
end

class Rack::Protection::HttpOrigin
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::IPSpoofing
end

class Rack::Protection::JsonCsrf
  def close_body(body); end

  def has_vector?(request, headers); end

  def react_and_close(env, body); end
end

class Rack::Protection::JsonCsrf
end

class Rack::Protection::PathTraversal
  def cleanup(path); end
end

class Rack::Protection::PathTraversal
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteReferrer
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::RemoteToken
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::SessionHijacking
end

class Rack::Protection::StrictTransport
  def strict_transport(); end
end

class Rack::Protection::StrictTransport
end

class Rack::Protection::XSSHeader
end

class Rack::Protection::XSSHeader
end

module Rack::Protection
  extend ::T::Sig
  def self.new(app, options=T.unsafe(nil)); end
end

class Rack::QueryParser
  def initialize(params_class, key_space_limit, param_depth_limit); end

  def key_space_limit(); end

  def make_params(); end

  def new_depth_limit(param_depth_limit); end

  def new_space_limit(key_space_limit); end

  def normalize_params(params, name, v, depth); end

  def param_depth_limit(); end

  def parse_nested_query(qs, d=T.unsafe(nil)); end

  def parse_query(qs, d=T.unsafe(nil), &unescaper); end
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::InvalidParameterError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::ParameterTypeError
end

class Rack::QueryParser::Params
  def [](key); end

  def []=(key, value); end

  def initialize(limit); end

  def key?(key); end

  def to_params_hash(); end
end

class Rack::QueryParser::Params
end

class Rack::QueryParser
  def self.make_default(key_space_limit, param_depth_limit); end
end

class Rack::Recursive
  def _call(env); end

  def call(env); end

  def include(env, path); end

  def initialize(app); end
end

class Rack::Recursive
end

class Rack::Reloader
  def call(env); end

  def initialize(app, cooldown=T.unsafe(nil), backend=T.unsafe(nil)); end

  def reload!(stderr=T.unsafe(nil)); end

  def safe_load(file, mtime, stderr=T.unsafe(nil)); end
end

module Rack::Reloader::Stat
  def figure_path(file, paths); end

  def rotation(); end

  def safe_stat(file); end
end

module Rack::Reloader::Stat
  extend ::T::Sig
end

class Rack::Reloader
end

class Rack::Request
  include ::Rack::Request::Env
  include ::Rack::Request::Helpers
  SCHEME_WHITELIST = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Env
  def add_header(key, v); end

  def delete_header(name); end

  def each_header(&block); end

  def env(); end

  def fetch_header(name, &block); end

  def get_header(name); end

  def has_header?(name); end

  def initialize(env); end

  def set_header(name, v); end
end

module Rack::Request::Env
  extend ::T::Sig
end

module Rack::Request::Helpers
  def GET(); end

  def POST(); end

  def [](key); end

  def []=(key, value); end

  def accept_encoding(); end

  def accept_language(); end

  def authority(); end

  def base_url(); end

  def body(); end

  def content_charset(); end

  def content_length(); end

  def content_type(); end

  def cookies(); end

  def delete?(); end

  def delete_param(k); end

  def form_data?(); end

  def fullpath(); end

  def get?(); end

  def head?(); end

  def host(); end

  def host_with_port(); end

  def ip(); end

  def link?(); end

  def logger(); end

  def media_type(); end

  def media_type_params(); end

  def multithread?(); end

  def options?(); end

  def params(); end

  def parseable_data?(); end

  def patch?(); end

  def path(); end

  def path_info(); end

  def path_info=(s); end

  def port(); end

  def post?(); end

  def put?(); end

  def query_string(); end

  def referer(); end

  def referrer(); end

  def request_method(); end

  def scheme(); end

  def script_name(); end

  def script_name=(s); end

  def session(); end

  def session_options(); end

  def ssl?(); end

  def trace?(); end

  def trusted_proxy?(ip); end

  def unlink?(); end

  def update_param(k, v); end

  def url(); end

  def user_agent(); end

  def values_at(*keys); end

  def xhr?(); end
  DEFAULT_PORTS = ::T.let(nil, ::T.untyped)
  FORM_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_HOST = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PORT = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_PROTO = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SCHEME = ::T.let(nil, ::T.untyped)
  HTTP_X_FORWARDED_SSL = ::T.let(nil, ::T.untyped)
  PARSEABLE_DATA_MEDIA_TYPES = ::T.let(nil, ::T.untyped)
end

module Rack::Request::Helpers
  extend ::T::Sig
end

class Rack::Request
end

class Rack::Response
  include ::Rack::Response::Helpers
  def [](key); end

  def []=(key, v); end

  def body(); end

  def body=(body); end

  def chunked?(); end

  def close(); end

  def delete_header(key); end

  def each(&callback); end

  def empty?(); end

  def finish(&block); end

  def get_header(key); end

  def has_header?(key); end

  def header(); end

  def headers(); end

  def initialize(body=T.unsafe(nil), status=T.unsafe(nil), header=T.unsafe(nil)); end

  def length(); end

  def length=(length); end

  def redirect(target, status=T.unsafe(nil)); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end

  def to_a(&block); end

  def to_ary(&block); end

  def write(str); end
  CHUNKED = ::T.let(nil, ::T.untyped)
end

module Rack::Response::Helpers
  def accepted?(); end

  def add_header(key, v); end

  def bad_request?(); end

  def cache_control(); end

  def cache_control=(v); end

  def client_error?(); end

  def content_length(); end

  def content_type(); end

  def created?(); end

  def delete_cookie(key, value=T.unsafe(nil)); end

  def etag(); end

  def etag=(v); end

  def forbidden?(); end

  def include?(header); end

  def informational?(); end

  def invalid?(); end

  def location(); end

  def location=(location); end

  def media_type(); end

  def media_type_params(); end

  def method_not_allowed?(); end

  def moved_permanently?(); end

  def no_content?(); end

  def not_found?(); end

  def ok?(); end

  def precondition_failed?(); end

  def redirect?(); end

  def redirection?(); end

  def server_error?(); end

  def set_cookie(key, value); end

  def set_cookie_header(); end

  def set_cookie_header=(v); end

  def successful?(); end

  def unauthorized?(); end

  def unprocessable?(); end
end

module Rack::Response::Helpers
  extend ::T::Sig
end

class Rack::Response::Raw
  include ::Rack::Response::Helpers
  def delete_header(key); end

  def get_header(key); end

  def has_header?(key); end

  def headers(); end

  def initialize(status, headers); end

  def set_header(key, v); end

  def status(); end

  def status=(status); end
end

class Rack::Response::Raw
end

class Rack::Response
end

class Rack::Runtime
  def call(env); end

  def initialize(app, name=T.unsafe(nil)); end
  FORMAT_STRING = ::T.let(nil, ::T.untyped)
  HEADER_NAME = ::T.let(nil, ::T.untyped)
end

class Rack::Runtime
end

class Rack::Sendfile
  def call(env); end

  def initialize(app, variation=T.unsafe(nil), mappings=T.unsafe(nil)); end
end

class Rack::Sendfile
end

class Rack::Server
  def app(); end

  def default_options(); end

  def initialize(options=T.unsafe(nil)); end

  def middleware(); end

  def options(); end

  def options=(options); end

  def server(); end

  def start(&blk); end
end

class Rack::Server::Options
  def handler_opts(options); end

  def parse!(args); end
end

class Rack::Server::Options
end

class Rack::Server
  def self.default_middleware_by_environment(); end

  def self.logging_middleware(); end

  def self.middleware(); end

  def self.start(options=T.unsafe(nil)); end
end

module Rack::Session
end

module Rack::Session::Abstract
end

class Rack::Session::Abstract::ID
  def find_session(req, sid); end
end

class Rack::Session::Abstract::ID
  def self.inherited(klass); end
end

class Rack::Session::Abstract::Persisted
  def call(env); end

  def commit_session(req, res); end

  def context(env, app=T.unsafe(nil)); end

  def default_options(); end

  def initialize(app, options=T.unsafe(nil)); end

  def key(); end

  def sid_secure(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::Persisted
end

class Rack::Session::Abstract::SessionHash
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def destroy(); end

  def each(&block); end

  def empty?(); end

  def exists?(); end

  def fetch(key, default=T.unsafe(nil), &block); end

  def has_key?(key); end

  def id(); end

  def id=(id); end

  def include?(key); end

  def initialize(store, req); end

  def key?(key); end

  def keys(); end

  def loaded?(); end

  def merge!(hash); end

  def options(); end

  def replace(hash); end

  def store(key, value); end

  def to_hash(); end

  def update(hash); end

  def values(); end
  Unspecified = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Abstract::SessionHash
  def self.find(req); end

  def self.set(req, session); end

  def self.set_options(req, options); end
end

module Rack::Session::Abstract
  extend ::T::Sig
end

class Rack::Session::Cookie
  def coder(); end
end

class Rack::Session::Cookie::Base64
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Base64::JSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::JSON
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::Marshal
end

class Rack::Session::Cookie::Base64::ZipJSON
  def encode(obj); end
end

class Rack::Session::Cookie::Base64::ZipJSON
end

class Rack::Session::Cookie::Base64
end

class Rack::Session::Cookie::Identity
  def decode(str); end

  def encode(str); end
end

class Rack::Session::Cookie::Identity
end

class Rack::Session::Cookie
end

class Rack::Session::Dalli
  def destroy_session(env, session_id, options); end

  def find_session(req, sid); end

  def get_session(env, sid); end

  def mutex(); end

  def pool(); end

  def set_session(env, session_id, new_session, options); end
  DEFAULT_DALLI_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Dalli
end

class Rack::Session::Pool
  def delete_session(req, session_id, options); end

  def find_session(req, sid); end

  def generate_sid(); end

  def mutex(); end

  def pool(); end

  def with_lock(req); end

  def write_session(req, session_id, new_session, options); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rack::Session::Pool
end

module Rack::Session
  extend ::T::Sig
end

class Rack::ShowExceptions
  def call(env); end

  def dump_exception(exception); end

  def h(obj); end

  def initialize(app); end

  def prefers_plaintext?(env); end

  def pretty(env, exception); end
  CONTEXT = ::T.let(nil, ::T.untyped)
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowExceptions
end

class Rack::ShowStatus
  def call(env); end

  def h(obj); end

  def initialize(app); end
  TEMPLATE = ::T.let(nil, ::T.untyped)
end

class Rack::ShowStatus
end

class Rack::Static
  def add_index_root?(path); end

  def applicable_rules(path); end

  def call(env); end

  def can_serve(path); end

  def initialize(app, options=T.unsafe(nil)); end

  def overwrite_file_path(path); end

  def route_file(path); end
end

class Rack::Static
end

class Rack::TempfileReaper
  def call(env); end

  def initialize(app); end
end

class Rack::TempfileReaper
end

module Rack::Test
  DEFAULT_HOST = ::T.let(nil, ::T.untyped)
  MULTIPART_BOUNDARY = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rack::Test::Cookie
  include ::Rack::Utils
  def default_uri(); end

  def domain(); end

  def empty?(); end

  def expired?(); end

  def expires(); end

  def http_only?(); end

  def initialize(raw, uri=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def matches?(uri); end

  def name(); end

  def path(); end

  def raw(); end

  def replaces?(other); end

  def secure?(); end

  def to_h(); end

  def to_hash(); end

  def valid?(uri); end

  def value(); end
end

class Rack::Test::Cookie
end

class Rack::Test::CookieJar
  def <<(new_cookie); end

  def [](name); end

  def []=(name, value); end

  def delete(name); end

  def for(uri); end

  def get_cookie(name); end

  def hash_for(uri=T.unsafe(nil)); end

  def initialize(cookies=T.unsafe(nil), default_host=T.unsafe(nil)); end

  def merge(raw_cookies, uri=T.unsafe(nil)); end

  def to_hash(); end
  DELIMITER = ::T.let(nil, ::T.untyped)
end

class Rack::Test::CookieJar
end

class Rack::Test::Error
end

class Rack::Test::Error
end

module Rack::Test::Methods
  def _current_session_names(); end

  def authorize(*args, &block); end

  def basic_authorize(*args, &block); end

  def build_rack_mock_session(); end

  def build_rack_test_session(name); end

  def clear_cookies(*args, &block); end

  def current_session(); end

  def custom_request(*args, &block); end

  def delete(*args, &block); end

  def digest_authorize(*args, &block); end

  def env(*args, &block); end

  def follow_redirect!(*args, &block); end

  def get(*args, &block); end

  def head(*args, &block); end

  def header(*args, &block); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(*args, &block); end

  def patch(*args, &block); end

  def post(*args, &block); end

  def put(*args, &block); end

  def rack_mock_session(name=T.unsafe(nil)); end

  def rack_test_session(name=T.unsafe(nil)); end

  def request(*args, &block); end

  def set_cookie(*args, &block); end

  def with_session(name); end
  METHODS = ::T.let(nil, ::T.untyped)
end

module Rack::Test::Methods
  extend ::Forwardable
  extend ::T::Sig
end

class Rack::Test::MockDigestRequest
  def initialize(params); end

  def method(); end

  def method_missing(sym); end

  def response(password); end
end

class Rack::Test::MockDigestRequest
end

class Rack::Test::Session
  include ::Rack::Test::Utils
  include ::Rack::Utils
  def authorize(username, password); end

  def basic_authorize(username, password); end

  def clear_cookies(*args, &block); end

  def custom_request(verb, uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def delete(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def digest_authorize(username, password); end

  def env(name, value); end

  def follow_redirect!(); end

  def get(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def head(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def header(name, value); end

  def initialize(mock_session); end

  def last_request(*args, &block); end

  def last_response(*args, &block); end

  def options(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def patch(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def post(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def put(uri, params=T.unsafe(nil), env=T.unsafe(nil), &block); end

  def request(uri, env=T.unsafe(nil), &block); end

  def set_cookie(*args, &block); end
end

class Rack::Test::Session
  extend ::Forwardable
end

class Rack::Test::UploadedFile
  def content_type(); end

  def content_type=(content_type); end

  def initialize(content, content_type=T.unsafe(nil), binary=T.unsafe(nil), original_filename: T.unsafe(nil)); end

  def local_path(); end

  def method_missing(method_name, *args, &block); end

  def original_filename(); end

  def path(); end

  def tempfile(); end
end

class Rack::Test::UploadedFile
  def self.actually_finalize(file); end

  def self.finalize(file); end
end

module Rack::Test::Utils
  include ::Rack::Utils
end

module Rack::Test::Utils
  extend ::Rack::Utils
  extend ::T::Sig
  def self.build_file_part(parameter_name, uploaded_file); end

  def self.build_multipart(params, first=T.unsafe(nil), multipart=T.unsafe(nil)); end

  def self.build_parts(parameters); end

  def self.build_primitive_part(parameter_name, value); end

  def self.get_parts(parameters); end
end

module Rack::Test
  extend ::T::Sig
  def self.encoding_aware_strings?(); end
end

class Rack::URLMap
  def call(env); end

  def initialize(map=T.unsafe(nil)); end

  def remap(map); end
  INFINITY = ::T.let(nil, ::T.untyped)
  NEGATIVE_INFINITY = ::T.let(nil, ::T.untyped)
end

class Rack::URLMap
end

module Rack::Utils
  COMMON_SEP = ::T.let(nil, ::T.untyped)
  DEFAULT_SEP = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML = ::T.let(nil, ::T.untyped)
  ESCAPE_HTML_PATTERN = ::T.let(nil, ::T.untyped)
  HTTP_STATUS_CODES = ::T.let(nil, ::T.untyped)
  NULL_BYTE = ::T.let(nil, ::T.untyped)
  PATH_SEPS = ::T.let(nil, ::T.untyped)
  STATUS_WITH_NO_ENTITY_BODY = ::T.let(nil, ::T.untyped)
  SYMBOL_TO_STATUS_CODE = ::T.let(nil, ::T.untyped)
end

class Rack::Utils::Context
  def app(); end

  def call(env); end

  def context(env, app=T.unsafe(nil)); end

  def for(); end

  def initialize(app_f, app_r); end

  def recontext(app); end
end

class Rack::Utils::Context
end

class Rack::Utils::HeaderHash
  def [](k); end

  def []=(k, v); end

  def delete(k); end

  def has_key?(k); end

  def include?(k); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(k); end

  def member?(k); end

  def merge(other); end

  def merge!(other); end

  def names(); end

  def replace(other); end
end

class Rack::Utils::HeaderHash
  def self.new(hash=T.unsafe(nil)); end
end

Rack::Utils::InvalidParameterError = Rack::QueryParser::InvalidParameterError

Rack::Utils::KeySpaceConstrainedParams = Rack::QueryParser::Params

Rack::Utils::ParameterTypeError = Rack::QueryParser::ParameterTypeError

module Rack::Utils
  extend ::T::Sig
  def self.add_cookie_to_header(header, key, value); end

  def self.add_remove_cookie_to_header(header, key, value=T.unsafe(nil)); end

  def self.best_q_match(q_value_header, available_mimes); end

  def self.build_nested_query(value, prefix=T.unsafe(nil)); end

  def self.build_query(params); end

  def self.byte_ranges(env, size); end

  def self.clean_path_info(path_info); end

  def self.clock_time(); end

  def self.default_query_parser(); end

  def self.default_query_parser=(default_query_parser); end

  def self.delete_cookie_header!(header, key, value=T.unsafe(nil)); end

  def self.escape(s); end

  def self.escape_html(string); end

  def self.escape_path(s); end

  def self.get_byte_ranges(http_range, size); end

  def self.key_space_limit(); end

  def self.key_space_limit=(v); end

  def self.make_delete_cookie_header(header, key, value); end

  def self.multipart_part_limit(); end

  def self.multipart_part_limit=(multipart_part_limit); end

  def self.param_depth_limit(); end

  def self.param_depth_limit=(v); end

  def self.parse_cookies(env); end

  def self.parse_cookies_header(header); end

  def self.parse_nested_query(qs, d=T.unsafe(nil)); end

  def self.parse_query(qs, d=T.unsafe(nil), &unescaper); end

  def self.q_values(q_value_header); end

  def self.rfc2109(time); end

  def self.rfc2822(time); end

  def self.secure_compare(a, b); end

  def self.select_best_encoding(available_encodings, accept_encoding); end

  def self.set_cookie_header!(header, key, value); end

  def self.status_code(status); end

  def self.unescape(s, encoding=T.unsafe(nil)); end

  def self.unescape_path(s); end

  def self.valid_path?(path); end
end

module Rack
  extend ::T::Sig
  def self.release(); end

  def self.version(); end
end

class Rails::Application
  def asset_precompiled?(logical_path); end

  def assets(); end

  def assets=(assets); end

  def assets_manifest(); end

  def assets_manifest=(assets_manifest); end

  def build_middleware_stack(); end

  def config=(configuration); end

  def config_for(name, env: T.unsafe(nil)); end

  def console(&blk); end

  def credentials(); end

  def default_url_options(*args, &block); end

  def default_url_options=(arg); end

  def encrypted(path, key_path: T.unsafe(nil), env_key: T.unsafe(nil)); end

  def executor(); end

  def generators(&blk); end

  def initialize(initial_variable_values=T.unsafe(nil), &block); end

  def initialize!(group=T.unsafe(nil)); end

  def initialized?(); end

  def initializer(name, opts=T.unsafe(nil), &block); end

  def isolate_namespace(mod); end

  def key_generator(); end

  def message_verifier(verifier_name); end

  def migration_railties(); end

  def ordered_railties(); end

  def precompiled_assets(clear_cache=T.unsafe(nil)); end

  def railties_initializers(current); end

  def rake_tasks(&block); end

  def reload_routes!(); end

  def reloader(); end

  def reloaders(); end

  def require_environment!(); end

  def routes_reloader(); end

  def run_load_hooks!(); end

  def run_tasks_blocks(app); end

  def runner(&blk); end

  def sandbox(); end

  def sandbox=(sandbox); end

  def sandbox?(); end

  def secret_key_base(); end

  def secrets(); end

  def secrets=(secrets); end

  def to_app(); end

  def validate_secret_key_base(secret_key_base); end

  def watchable_args(); end
  INITIAL_VARIABLES = ::T.let(nil, ::T.untyped)
end

class Rails::Application
  def self.add_lib_to_load_path!(root); end

  def self.create(initial_variable_values=T.unsafe(nil), &block); end
end

class Rails::ApplicationController
end

class Rails::ApplicationController
end

module Rails::Command
  include ::Rails::Command::Behavior
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
end

module Rails::Command::Actions
  def load_generators(); end

  def load_tasks(); end

  def require_application_and_environment!(); end

  def set_application_directory!(); end
end

module Rails::Command::Actions
  extend ::T::Sig
end

class Rails::Command::Base
  include ::Rails::Command::Actions
  def help(); end
end

class Rails::Command::Base::Error
end

class Rails::Command::Base::Error
end

class Rails::Command::Base
  def self.banner(*_); end

  def self.base_name(); end

  def self.command_name(); end

  def self.default_command_root(); end

  def self.desc(usage=T.unsafe(nil), description=T.unsafe(nil), options=T.unsafe(nil)); end

  def self.engine?(); end

  def self.executable(); end

  def self.hide_command!(); end

  def self.inherited(base); end

  def self.perform(command, args, config); end

  def self.printing_commands(); end

  def self.usage_path(); end
end

module Rails::Command::Behavior
end

module Rails::Command::Behavior::ClassMethods
  def no_color!(); end

  def subclasses(); end
end

module Rails::Command::Behavior::ClassMethods
  extend ::T::Sig
end

module Rails::Command::Behavior
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Rails::Command
  extend ::ActiveSupport::Autoload
  extend ::Rails::Command::Behavior::ClassMethods
  extend ::T::Sig
  def self.environment(); end

  def self.find_by_namespace(namespace, command_name=T.unsafe(nil)); end

  def self.hidden_commands(); end

  def self.invoke(full_namespace, args=T.unsafe(nil), **config); end

  def self.print_commands(); end

  def self.root(); end

  def self.sorted_groups(); end
end

module Rails::Configuration
end

class Rails::Configuration::Generators
  def aliases(); end

  def aliases=(aliases); end

  def api_only(); end

  def api_only=(api_only); end

  def colorize_logging(); end

  def colorize_logging=(colorize_logging); end

  def fallbacks(); end

  def fallbacks=(fallbacks); end

  def hidden_namespaces(); end

  def hide_namespace(namespace); end

  def method_missing(method, *args); end

  def options(); end

  def options=(options); end

  def templates(); end

  def templates=(templates); end
end

class Rails::Configuration::Generators
end

class Rails::Configuration::MiddlewareStackProxy
  def +(other); end

  def delete(*args, &block); end

  def delete_operations(); end

  def initialize(operations=T.unsafe(nil), delete_operations=T.unsafe(nil)); end

  def insert(*args, &block); end

  def insert_after(*args, &block); end

  def insert_before(*args, &block); end

  def merge_into(other); end

  def operations(); end

  def swap(*args, &block); end

  def unshift(*args, &block); end

  def use(*args, &block); end
end

class Rails::Configuration::MiddlewareStackProxy
end

module Rails::Configuration
  extend ::T::Sig
end

module Rails::Dom
end

module Rails::Dom::Testing
end

module Rails::Dom::Testing::Assertions
  include ::Rails::Dom::Testing::Assertions::DomAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::DomAssertions
  def assert_dom_equal(expected, actual, message=T.unsafe(nil)); end

  def assert_dom_not_equal(expected, actual, message=T.unsafe(nil)); end

  def compare_doms(expected, actual); end

  def equal_attribute?(attr, other_attr); end

  def equal_attribute_nodes?(nodes, other_nodes); end

  def equal_children?(child, other_child); end
end

module Rails::Dom::Testing::Assertions::DomAssertions
  extend ::T::Sig
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  include ::Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  def assert_select(*args, &block); end

  def assert_select_email(&block); end

  def assert_select_encoded(element=T.unsafe(nil), &block); end

  def css_select(*args); end
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
end

module Rails::Dom::Testing::Assertions::SelectorAssertions::CountDescribable
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Rails::Dom::Testing::Assertions::SelectorAssertions
  extend ::T::Sig
end

module Rails::Dom::Testing::Assertions
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Rails::Dom::Testing
  extend ::T::Sig
end

module Rails::Dom
  extend ::T::Sig
end

class Rails::Engine
  def app(); end

  def call(env); end

  def eager_load!(); end

  def endpoint(); end

  def engine_name(*args, &block); end

  def env_config(); end

  def helpers(); end

  def helpers_paths(); end

  def isolated?(*args, &block); end

  def load_console(app=T.unsafe(nil)); end

  def load_generators(app=T.unsafe(nil)); end

  def load_runner(app=T.unsafe(nil)); end

  def load_seed(); end

  def load_tasks(app=T.unsafe(nil)); end

  def middleware(*args, &block); end

  def paths(*args, &block); end

  def railties(); end

  def root(*args, &block); end

  def routes(); end

  def routes?(); end

  def run_tasks_blocks(*_); end
end

class Rails::Engine
  def self.called_from(); end

  def self.called_from=(called_from); end

  def self.eager_load!(*args, &block); end

  def self.endpoint(endpoint=T.unsafe(nil)); end

  def self.engine_name(name=T.unsafe(nil)); end

  def self.find(path); end

  def self.find_root(from); end

  def self.find_root_with_flag(flag, root_path, default=T.unsafe(nil)); end

  def self.isolate_namespace(mod); end

  def self.isolated(); end

  def self.isolated=(isolated); end

  def self.isolated?(); end
end

module Rails::Generators
  include ::Rails::Command::Behavior
  def namespace(); end

  def namespace=(obj); end
  DEFAULT_ALIASES = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

module Rails::Generators::Actions
  def add_source(source, options=T.unsafe(nil), &block); end

  def after_bundle(&block); end

  def application(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def capify!(); end

  def environment(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def gem(*args); end

  def gem_group(*names, &block); end

  def generate(what, *args); end

  def git(commands=T.unsafe(nil)); end

  def initialize(*_); end

  def initializer(filename, data=T.unsafe(nil)); end

  def lib(filename, data=T.unsafe(nil)); end

  def rails_command(command, options=T.unsafe(nil)); end

  def rake(command, options=T.unsafe(nil)); end

  def rakefile(filename, data=T.unsafe(nil)); end

  def readme(path); end

  def route(routing_code); end

  def vendor(filename, data=T.unsafe(nil)); end
end

class Rails::Generators::Actions::CreateMigration
  def existing_migration(); end

  def migration_dir(); end

  def migration_file_name(); end

  def relative_existing_migration(); end
end

class Rails::Generators::Actions::CreateMigration
end

module Rails::Generators::Actions
  extend ::T::Sig
end

class Rails::Generators::ActiveModel
  def destroy(); end

  def errors(); end

  def initialize(name); end

  def name(); end

  def save(); end

  def update(params=T.unsafe(nil)); end
end

class Rails::Generators::ActiveModel
  def self.all(klass); end

  def self.build(klass, params=T.unsafe(nil)); end

  def self.find(klass, params=T.unsafe(nil)); end
end

class Rails::Generators::Base
  include ::Thor::Actions
  include ::Rails::Generators::Actions
end

class Rails::Generators::Base
  def self.add_shebang_option!(); end

  def self.base_name(); end

  def self.base_root(); end

  def self.default_aliases_for_option(name, options); end

  def self.default_for_option(config, name, options, default); end

  def self.default_generator_root(); end

  def self.default_source_root(); end

  def self.default_value_for_option(name, options); end

  def self.generator_name(); end

  def self.hide!(); end

  def self.hook_for(*names, &block); end

  def self.hooks(); end

  def self.inherited(base); end

  def self.prepare_for_invocation(name, value); end

  def self.remove_hook_for(*names); end

  def self.usage_path(); end
end

class Rails::Generators::Error
end

class Rails::Generators::Error
end

class Rails::Generators::GeneratedAttribute
  def attr_options(); end

  def column_name(); end

  def default(); end

  def field_type(); end

  def foreign_key?(); end

  def has_index?(); end

  def has_uniq_index?(); end

  def human_name(); end

  def index_name(); end

  def index_name=(index_name); end

  def initialize(name, type=T.unsafe(nil), index_type=T.unsafe(nil), attr_options=T.unsafe(nil)); end

  def inject_index_options(); end

  def inject_options(); end

  def name(); end

  def name=(name); end

  def options_for_migration(); end

  def password_digest?(); end

  def plural_name(); end

  def polymorphic?(); end

  def reference?(); end

  def required?(); end

  def singular_name(); end

  def token?(); end

  def type(); end

  def type=(type); end
  INDEX_OPTIONS = ::T.let(nil, ::T.untyped)
  UNIQ_INDEX_OPTIONS = ::T.let(nil, ::T.untyped)
end

class Rails::Generators::GeneratedAttribute
  def self.parse(column_definition); end

  def self.reference?(type); end
end

module Rails::Generators::Migration
  def create_migration(destination, data, config=T.unsafe(nil), &block); end

  def migration_class_name(); end

  def migration_file_name(); end

  def migration_number(); end

  def migration_template(source, destination, config=T.unsafe(nil)); end

  def set_migration_assigns!(destination); end
end

module Rails::Generators::Migration::ClassMethods
  def current_migration_number(dirname); end

  def migration_exists?(dirname, file_name); end

  def migration_lookup_at(dirname); end

  def next_migration_number(dirname); end
end

module Rails::Generators::Migration::ClassMethods
  extend ::T::Sig
end

module Rails::Generators::Migration
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

class Rails::Generators::NamedBase
  include ::Coffee::Rails::JsHook
  def file_name(); end

  def initialize(args, *options); end

  def js_template(source, destination); end

  def name(); end

  def name=(name); end
end

class Rails::Generators::NamedBase
  def self.check_class_collision(options=T.unsafe(nil)); end
end

module Rails::Generators::ResourceHelpers
  def controller_file_name(); end

  def controller_name(); end

  def initialize(*args); end
end

module Rails::Generators::ResourceHelpers
  extend ::T::Sig
  def self.included(base); end
end

class Rails::Generators::TestCase
  include ::Rails::Generators::Testing::Behaviour
  include ::ActiveSupport::Testing::Stream
  include ::Rails::Generators::Testing::SetupAndTeardown
  include ::Rails::Generators::Testing::Assertions
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def current_path(); end

  def current_path=(val); end

  def current_path?(); end

  def default_arguments(); end

  def default_arguments=(val); end

  def default_arguments?(); end

  def destination_root(); end

  def destination_root=(val); end

  def destination_root?(); end

  def generator_class(); end

  def generator_class=(val); end

  def generator_class?(); end
end

class Rails::Generators::TestCase
  def self.current_path(); end

  def self.current_path=(val); end

  def self.current_path?(); end

  def self.default_arguments(); end

  def self.default_arguments=(val); end

  def self.default_arguments?(); end

  def self.destination_root(); end

  def self.destination_root=(val); end

  def self.destination_root?(); end

  def self.generator_class(); end

  def self.generator_class=(val); end

  def self.generator_class?(); end
end

module Rails::Generators::Testing::Assertions
  def assert_class_method(method, content, &block); end

  def assert_directory(relative, *contents); end

  def assert_field_default_value(attribute_type, value); end

  def assert_field_type(attribute_type, field_type); end

  def assert_file(relative, *contents); end

  def assert_instance_method(method, content); end

  def assert_method(method, content); end

  def assert_migration(relative, *contents, &block); end

  def assert_no_directory(relative); end

  def assert_no_file(relative); end

  def assert_no_migration(relative); end
end

module Rails::Generators::Testing::Assertions
  extend ::T::Sig
end

module Rails::Generators::Testing::Behaviour
  include ::ActiveSupport::Testing::Stream
  def create_generated_attribute(attribute_type, name=T.unsafe(nil), index=T.unsafe(nil)); end

  def generator(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def run_generator(args=T.unsafe(nil), config=T.unsafe(nil)); end
end

module Rails::Generators::Testing::Behaviour
  extend ::ActiveSupport::Concern
  extend ::T::Sig
end

module Rails::Generators::Testing::SetupAndTeardown
  def setup(); end

  def teardown(); end
end

module Rails::Generators::Testing::SetupAndTeardown
  extend ::T::Sig
end

module Rails::Generators
  extend ::Rails::Command::Behavior::ClassMethods
  extend ::T::Sig
  def self.aliases(); end

  def self.api_only!(); end

  def self.configure!(config); end

  def self.fallbacks(); end

  def self.find_by_namespace(name, base=T.unsafe(nil), context=T.unsafe(nil)); end

  def self.help(command=T.unsafe(nil)); end

  def self.hidden_namespaces(); end

  def self.hide_namespace(*namespaces); end

  def self.hide_namespaces(*namespaces); end

  def self.invoke(namespace, args=T.unsafe(nil), config=T.unsafe(nil)); end

  def self.namespace(); end

  def self.namespace=(obj); end

  def self.options(); end

  def self.print_generators(); end

  def self.public_namespaces(); end

  def self.sorted_groups(); end

  def self.templates_path(); end
end

module Rails::Html
  XPATHS_TO_REMOVE = ::T.let(nil, ::T.untyped)
end

class Rails::Html::FullSanitizer
end

class Rails::Html::FullSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::LinkSanitizer
end

class Rails::Html::PermitScrubber
  def allowed_node?(node); end

  def attributes(); end

  def attributes=(attributes); end

  def initialize(); end

  def keep_node?(node); end

  def scrub_attribute(node, attr_node); end

  def scrub_attribute?(name); end

  def scrub_attributes(node); end

  def scrub_css_attribute(node); end

  def scrub_node(node); end

  def skip_node?(node); end

  def tags(); end

  def tags=(tags); end

  def validate!(var, name); end
end

class Rails::Html::PermitScrubber
end

class Rails::Html::Sanitizer
  def sanitize(html, options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rails::Html::Sanitizer
  def self.full_sanitizer(); end

  def self.link_sanitizer(); end

  def self.white_list_sanitizer(); end
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TargetScrubber
end

class Rails::Html::TextOnlyScrubber
  def initialize(); end
end

class Rails::Html::TextOnlyScrubber
end

class Rails::Html::WhiteListSanitizer
  def sanitize_css(style_string); end
end

class Rails::Html::WhiteListSanitizer
  def self.allowed_attributes(); end

  def self.allowed_attributes=(allowed_attributes); end

  def self.allowed_tags(); end

  def self.allowed_tags=(allowed_tags); end
end

module Rails::Html
  extend ::T::Sig
end

module Rails::Info
  def properties(); end

  def properties=(obj); end
end

module Rails::Info
  extend ::T::Sig
  def self.properties(); end

  def self.properties=(obj); end

  def self.property(name, value=T.unsafe(nil)); end

  def self.to_html(); end
end

class Rails::InfoController
  def _layout_from_proc(); end

  def index(); end

  def properties(); end

  def routes(); end
end

class Rails::InfoController
end

module Rails::Initializable
  def initializers(); end

  def run_initializers(group=T.unsafe(nil), *args); end
end

module Rails::Initializable
  extend ::T::Sig
  def self.included(base); end
end

module Rails::LineFiltering
  def run(reporter, options=T.unsafe(nil)); end
end

module Rails::LineFiltering
  extend ::T::Sig
end

class Rails::MailersController
  def index(); end

  def preview(); end
end

class Rails::MailersController
end

module Rails::Paths
end

class Rails::Paths::Path
  include ::Enumerable
  def <<(path); end

  def absolute_current(); end

  def autoload!(); end

  def autoload?(); end

  def autoload_once!(); end

  def autoload_once?(); end

  def children(); end

  def concat(paths); end

  def each(&block); end

  def eager_load!(); end

  def eager_load?(); end

  def existent(); end

  def existent_directories(); end

  def expanded(); end

  def extensions(); end

  def first(); end

  def glob(); end

  def glob=(glob); end

  def initialize(root, current, paths, options=T.unsafe(nil)); end

  def last(); end

  def load_path!(); end

  def load_path?(); end

  def push(path); end

  def skip_autoload!(); end

  def skip_autoload_once!(); end

  def skip_eager_load!(); end

  def skip_load_path!(); end

  def to_a(); end

  def to_ary(); end

  def unshift(*paths); end
end

class Rails::Paths::Path
end

class Rails::Paths::Root
  def [](path); end

  def []=(path, value); end

  def add(path, options=T.unsafe(nil)); end

  def all_paths(); end

  def autoload_once(); end

  def autoload_paths(); end

  def eager_load(); end

  def initialize(path); end

  def keys(); end

  def load_paths(); end

  def path(); end

  def path=(path); end

  def values(); end

  def values_at(*list); end
end

class Rails::Paths::Root
end

module Rails::Paths
  extend ::T::Sig
end

module Rails::Rack
end

class Rails::Rack::Logger
  def call(env); end

  def initialize(app, taggers=T.unsafe(nil)); end
end

class Rails::Rack::Logger
end

module Rails::Rack
  extend ::T::Sig
end

class Rails::Railtie
  include ::Rails::Initializable
  def config(); end

  def configure(&block); end

  def railtie_name(*args, &block); end

  def railtie_namespace(); end

  def run_console_blocks(app); end

  def run_generators_blocks(app); end

  def run_runner_blocks(app); end

  def run_tasks_blocks(app); end
  ABSTRACT_RAILTIES = ::T.let(nil, ::T.untyped)
end

class Rails::Railtie
  def self.abstract_railtie?(); end

  def self.config(*args, &block); end

  def self.configure(&block); end

  def self.console(&blk); end

  def self.generators(&blk); end

  def self.inherited(base); end

  def self.instance(); end

  def self.railtie_name(name=T.unsafe(nil)); end

  def self.rake_tasks(&blk); end

  def self.runner(&blk); end
end

class Rails::Secrets
end

class Rails::Secrets::MissingKeyError
  def initialize(); end
end

class Rails::Secrets::MissingKeyError
end

class Rails::Secrets
  def self.decrypt(data); end

  def self.encrypt(data); end

  def self.key(); end

  def self.parse(paths, env:); end

  def self.read(); end

  def self.read_for_editing(&block); end

  def self.root=(root); end

  def self.write(contents); end
end

module Rails::TestUnit
end

class Rails::TestUnit::CompositeFilter
  def ===(method); end

  def initialize(runnable, filter, patterns); end

  def named_filter(); end
end

class Rails::TestUnit::CompositeFilter
end

class Rails::TestUnit::Filter
  def ===(method); end

  def initialize(runnable, file, line); end
end

class Rails::TestUnit::Filter
end

class Rails::TestUnit::Runner
  def filters(); end
end

class Rails::TestUnit::Runner
  def self.attach_before_load_options(opts); end

  def self.compose_filter(runnable, filter); end

  def self.filters(); end

  def self.load_tests(argv); end

  def self.parse_options(argv); end

  def self.rake_run(argv=T.unsafe(nil)); end

  def self.run(argv=T.unsafe(nil)); end
end

module Rails::TestUnit
  extend ::T::Sig
end

class Rails::TestUnitRailtie
end

class Rails::TestUnitRailtie
end

module Rails::VERSION
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  PRE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  TINY = ::T.let(nil, ::T.untyped)
end

module Rails::VERSION
  extend ::T::Sig
end

class Rails::WelcomeController
  def index(); end
end

class Rails::WelcomeController
end

module Rails
  extend ::ActiveSupport::Autoload
  extend ::T::Sig
  def self.app_class(); end

  def self.app_class=(app_class); end

  def self.application=(application); end

  def self.backtrace_cleaner(); end

  def self.cache(); end

  def self.cache=(cache); end

  def self.configuration(); end

  def self.env(); end

  def self.env=(environment); end

  def self.gem_version(); end

  def self.groups(*groups); end

  def self.initialize!(*args, &block); end

  def self.initialized?(*args, &block); end

  def self.logger(); end

  def self.logger=(logger); end

  def self.public_path(); end

  def self.root(); end

  def self.version(); end
end

module Rainbow
end

class Rainbow::Color
  def ground(); end
end

class Rainbow::Color::Indexed
  def codes(); end

  def initialize(ground, num); end

  def num(); end
end

class Rainbow::Color::Indexed
end

class Rainbow::Color::Named
  def initialize(ground, name); end
  NAMES = ::T.let(nil, ::T.untyped)
end

class Rainbow::Color::Named
  def self.color_names(); end

  def self.valid_names(); end
end

class Rainbow::Color::RGB
  def b(); end

  def g(); end

  def initialize(ground, *values); end

  def r(); end
end

class Rainbow::Color::RGB
  def self.to_ansi_domain(value); end
end

class Rainbow::Color::X11Named
  include ::Rainbow::X11ColorNames
  def initialize(ground, name); end
end

class Rainbow::Color::X11Named
  def self.color_names(); end

  def self.valid_names(); end
end

class Rainbow::Color
  def self.build(ground, values); end

  def self.parse_hex_color(hex); end
end

class Rainbow::NullPresenter
  def background(*_values); end

  def bg(*_values); end

  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def bright(); end

  def color(*_values); end

  def cyan(); end

  def dark(); end

  def faint(); end

  def fg(*_values); end

  def foreground(*_values); end

  def green(); end

  def hide(); end

  def inverse(); end

  def italic(); end

  def magenta(); end

  def method_missing(method_name, *args); end

  def red(); end

  def reset(); end

  def underline(); end

  def white(); end

  def yellow(); end
end

class Rainbow::NullPresenter
end

class Rainbow::Presenter
  def background(*values); end

  def bg(*values); end

  def black(); end

  def blink(); end

  def blue(); end

  def bold(); end

  def bright(); end

  def color(*values); end

  def cyan(); end

  def dark(); end

  def faint(); end

  def fg(*values); end

  def foreground(*values); end

  def green(); end

  def hide(); end

  def inverse(); end

  def italic(); end

  def magenta(); end

  def method_missing(method_name, *args); end

  def red(); end

  def reset(); end

  def underline(); end

  def white(); end

  def yellow(); end
  TERM_EFFECTS = ::T.let(nil, ::T.untyped)
end

class Rainbow::Presenter
end

class Rainbow::StringUtils
end

class Rainbow::StringUtils
  def self.uncolor(string); end

  def self.wrap_with_sgr(string, codes); end
end

class Rainbow::Wrapper
  def enabled(); end

  def enabled=(enabled); end

  def initialize(enabled=T.unsafe(nil)); end

  def wrap(string); end
end

class Rainbow::Wrapper
end

module Rainbow::X11ColorNames
  NAMES = ::T.let(nil, ::T.untyped)
end

module Rainbow::X11ColorNames
  extend ::T::Sig
end

module Rainbow
  extend ::T::Sig
  def self.enabled(); end

  def self.enabled=(value); end

  def self.global(); end

  def self.new(); end

  def self.uncolor(string); end
end

module Rake
  EARLY = ::T.let(nil, ::T.untyped)
  EMPTY_TASK_ARGS = ::T.let(nil, ::T.untyped)
  LATE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Rake::Application
  include ::Rake::TaskManager
  include ::Rake::TraceOutput
  def add_import(fn); end

  def add_loader(ext, loader); end

  def collect_command_line_tasks(args); end

  def default_task_name(); end

  def deprecate(old_usage, new_usage, call_site); end

  def display_cause_details(ex); end

  def display_error_message(ex); end

  def display_exception_backtrace(ex); end

  def display_exception_details(ex); end

  def display_exception_details_seen(); end

  def display_exception_message_details(ex); end

  def display_prerequisites(); end

  def display_tasks_and_comments(); end

  def dynamic_width(); end

  def dynamic_width_stty(); end

  def dynamic_width_tput(); end

  def exit_because_of_exception(ex); end

  def find_rakefile_location(); end

  def handle_options(argv); end

  def has_cause?(ex); end

  def have_rakefile(); end

  def init(app_name=T.unsafe(nil), argv=T.unsafe(nil)); end

  def invoke_task(task_string); end

  def load_imports(); end

  def load_rakefile(); end

  def name(); end

  def options(); end

  def orig_display_error_messsage(ex); end

  def original_dir(); end

  def parse_task_string(string); end

  def print_rakefile_directory(location); end

  def rake_require(file_name, paths=T.unsafe(nil), loaded=T.unsafe(nil)); end

  def rakefile(); end

  def rakefile_location(backtrace=T.unsafe(nil)); end

  def raw_load_rakefile(); end

  def run(argv=T.unsafe(nil)); end

  def run_with_threads(); end

  def set_default_options(); end

  def standard_exception_handling(); end

  def standard_rake_options(); end

  def system_dir(); end

  def terminal_columns(); end

  def terminal_columns=(terminal_columns); end

  def terminal_width(); end

  def thread_pool(); end

  def top_level(); end

  def top_level_tasks(); end

  def trace(*strings); end

  def truncate(string, width); end

  def truncate_output?(); end

  def tty_output=(tty_output); end

  def tty_output?(); end

  def unix?(); end

  def windows?(); end
  DEFAULT_RAKEFILES = ::T.let(nil, ::T.untyped)
end

class Rake::Application
end

module Rake::Backtrace
  SUPPRESSED_PATHS = ::T.let(nil, ::T.untyped)
  SUPPRESSED_PATHS_RE = ::T.let(nil, ::T.untyped)
  SUPPRESS_PATTERN = ::T.let(nil, ::T.untyped)
  SYS_KEYS = ::T.let(nil, ::T.untyped)
  SYS_PATHS = ::T.let(nil, ::T.untyped)
end

module Rake::Backtrace
  extend ::T::Sig
  def self.collapse(backtrace); end
end

module Rake::Cloneable
end

module Rake::Cloneable
  extend ::T::Sig
end

class Rake::CommandLineOptionError
end

class Rake::CommandLineOptionError
end

class Rake::CpuCounter
  def count(); end

  def count_with_default(default=T.unsafe(nil)); end
end

class Rake::CpuCounter
  def self.count(); end
end

module Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Rake::DSL
  extend ::T::Sig
end

class Rake::DefaultLoader
  def load(fn); end
end

class Rake::DefaultLoader
end

class Rake::EarlyTime
  include ::Comparable
  include ::Singleton
end

class Rake::EarlyTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::FileCreationTask
end

class Rake::FileCreationTask
end

class Rake::FileList
  include ::Rake::Cloneable
  def &(*args, &block); end

  def *(other); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(obj); end

  def ==(array); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def add(*filenames); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def clear_exclude(); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def egrep(pattern, *options); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude(*patterns, &block); end

  def exclude?(*args, &block); end

  def excluded_from_list?(fn); end

  def existing(); end

  def existing!(); end

  def ext(newext=T.unsafe(nil)); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def gsub(pat, rep); end

  def gsub!(pat, rep); end

  def import(array); end

  def include(*filenames); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def initialize(*patterns); end

  def inject(*args, &block); end

  def insert(*args, &block); end

  def inspect(*args, &block); end

  def is_a?(klass); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def kind_of?(klass); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(&block); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def permutation(*args, &block); end

  def pluck(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def resolve(); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def sub(pat, rep); end

  def sub!(pat, rep); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_a(); end

  def to_ary(); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PATTERNS = ::T.let(nil, ::T.untyped)
  DEFAULT_IGNORE_PROCS = ::T.let(nil, ::T.untyped)
  DELEGATING_METHODS = ::T.let(nil, ::T.untyped)
  GLOB_PATTERN = ::T.let(nil, ::T.untyped)
  MUST_DEFINE = ::T.let(nil, ::T.untyped)
  MUST_NOT_DEFINE = ::T.let(nil, ::T.untyped)
  SPECIAL_RETURN = ::T.let(nil, ::T.untyped)
end

class Rake::FileList
  def self.[](*args); end

  def self.glob(pattern, *args); end
end

class Rake::FileTask
end

class Rake::FileTask
end

module Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
  def cd(*args, &block); end

  def chdir(*args, &block); end

  def chmod(*args, &block); end

  def chmod_R(*args, &block); end

  def chown(*args, &block); end

  def chown_R(*args, &block); end

  def copy(*args, &block); end

  def cp(*args, &block); end

  def cp_r(*args, &block); end

  def install(*args, &block); end

  def link(*args, &block); end

  def ln(*args, &block); end

  def ln_s(*args, &block); end

  def ln_sf(*args, &block); end

  def makedirs(*args, &block); end

  def mkdir(*args, &block); end

  def mkdir_p(*args, &block); end

  def mkpath(*args, &block); end

  def move(*args, &block); end

  def mv(*args, &block); end

  def nowrite(value=T.unsafe(nil)); end

  def rake_check_options(options, *optdecl); end

  def rake_merge_option(args, defaults); end

  def rake_output_message(message); end

  def remove(*args, &block); end

  def rm(*args, &block); end

  def rm_f(*args, &block); end

  def rm_r(*args, &block); end

  def rm_rf(*args, &block); end

  def rmdir(*args, &block); end

  def rmtree(*args, &block); end

  def safe_unlink(*args, &block); end

  def symlink(*args, &block); end

  def touch(*args, &block); end

  def verbose(value=T.unsafe(nil)); end

  def when_writing(msg=T.unsafe(nil)); end
  DEFAULT = ::T.let(nil, ::T.untyped)
end

module Rake::FileUtilsExt
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::T::Sig
  def self.nowrite_flag(); end

  def self.nowrite_flag=(nowrite_flag); end

  def self.verbose_flag(); end

  def self.verbose_flag=(verbose_flag); end
end

class Rake::InvocationChain
  def append(invocation); end

  def member?(invocation); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::InvocationChain::EmptyInvocationChain
  def append(invocation); end

  def member?(obj); end
end

class Rake::InvocationChain::EmptyInvocationChain
end

class Rake::InvocationChain
  def self.append(invocation, chain); end
end

module Rake::InvocationExceptionMixin
  def chain(); end

  def chain=(value); end
end

module Rake::InvocationExceptionMixin
  extend ::T::Sig
end

class Rake::LateTime
  include ::Comparable
  include ::Singleton
end

class Rake::LateTime
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class Rake::LinkedList
  include ::Enumerable
  def ==(other); end

  def conj(item); end

  def each(); end

  def empty?(); end

  def head(); end

  def initialize(head, tail=T.unsafe(nil)); end

  def tail(); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::LinkedList::EmptyLinkedList
  def initialize(); end
end

class Rake::LinkedList::EmptyLinkedList
end

class Rake::LinkedList
  def self.cons(head, tail); end

  def self.empty(); end

  def self.make(*args); end
end

class Rake::MultiTask
end

class Rake::MultiTask
end

class Rake::NameSpace
  def [](name); end

  def initialize(task_manager, scope_list); end

  def scope(); end

  def tasks(); end
end

class Rake::NameSpace
end

module Rake::PrivateReader
end

module Rake::PrivateReader::ClassMethods
  def private_reader(*names); end
end

module Rake::PrivateReader::ClassMethods
  extend ::T::Sig
end

module Rake::PrivateReader
  extend ::T::Sig
  def self.included(base); end
end

class Rake::Promise
  def initialize(args, &block); end

  def recorder(); end

  def recorder=(recorder); end

  def value(); end

  def work(); end
  NOT_SET = ::T.let(nil, ::T.untyped)
end

class Rake::Promise
end

class Rake::PseudoStatus
  def >>(n); end

  def exited?(); end

  def exitstatus(); end

  def initialize(code=T.unsafe(nil)); end

  def stopped?(); end

  def to_i(); end
end

class Rake::PseudoStatus
end

class Rake::RuleRecursionOverflowError
  def add_target(target); end

  def initialize(*args); end
end

class Rake::RuleRecursionOverflowError
end

class Rake::Scope
  def path(); end

  def path_with_task_name(task_name); end

  def trim(n); end
  EMPTY = ::T.let(nil, ::T.untyped)
end

class Rake::Scope::EmptyScope
  def path(); end

  def path_with_task_name(task_name); end
end

class Rake::Scope::EmptyScope
end

class Rake::Scope
end

class Rake::Task
  def actions(); end

  def add_description(description); end

  def all_prerequisite_tasks(); end

  def already_invoked(); end

  def application(); end

  def application=(application); end

  def arg_description(); end

  def arg_names(); end

  def clear(); end

  def clear_actions(); end

  def clear_args(); end

  def clear_comments(); end

  def clear_prerequisites(); end

  def collect_prerequisites(seen); end

  def comment(); end

  def comment=(comment); end

  def enhance(deps=T.unsafe(nil), &block); end

  def execute(args=T.unsafe(nil)); end

  def full_comment(); end

  def initialize(task_name, app); end

  def investigation(); end

  def invoke(*args); end

  def invoke_prerequisites(task_args, invocation_chain); end

  def invoke_prerequisites_concurrently(task_args, invocation_chain); end

  def invoke_with_call_chain(task_args, invocation_chain); end

  def locations(); end

  def name(); end

  def name_with_args(); end

  def needed?(); end

  def prereqs(); end

  def prerequisite_tasks(); end

  def prerequisites(); end

  def reenable(); end

  def scope(); end

  def set_arg_names(args); end

  def source(); end

  def sources(); end

  def sources=(sources); end

  def timestamp(); end
end

class Rake::Task
  def self.[](task_name); end

  def self.clear(); end

  def self.create_rule(*args, &block); end

  def self.define_task(*args, &block); end

  def self.scope_name(scope, task_name); end

  def self.task_defined?(task_name); end

  def self.tasks(); end
end

class Rake::TaskArgumentError
end

class Rake::TaskArgumentError
end

class Rake::TaskArguments
  include ::Enumerable
  def [](index); end

  def each(&block); end

  def extras(); end

  def fetch(*args, &block); end

  def has_key?(key); end

  def initialize(names, values, parent=T.unsafe(nil)); end

  def key?(key); end

  def lookup(name); end

  def method_missing(sym, *args); end

  def names(); end

  def new_scope(names); end

  def to_a(); end

  def to_hash(); end

  def values_at(*keys); end

  def with_defaults(defaults); end
end

class Rake::TaskArguments
end

module Rake::TaskManager
  def [](task_name, scopes=T.unsafe(nil)); end

  def clear(); end

  def create_rule(*args, &block); end

  def current_scope(); end

  def define_task(task_class, *args, &block); end

  def enhance_with_matching_rule(task_name, level=T.unsafe(nil)); end

  def generate_did_you_mean_suggestions(task_name); end

  def generate_message_for_undefined_task(task_name); end

  def in_namespace(name); end

  def initialize(); end

  def intern(task_class, task_name); end

  def last_description(); end

  def last_description=(last_description); end

  def lookup(task_name, initial_scope=T.unsafe(nil)); end

  def resolve_args(args); end

  def synthesize_file_task(task_name); end

  def tasks(); end

  def tasks_in_scope(scope); end
end

module Rake::TaskManager
  extend ::T::Sig
  def self.record_task_metadata(); end

  def self.record_task_metadata=(record_task_metadata); end
end

class Rake::ThreadHistoryDisplay
  include ::Rake::PrivateReader
  def initialize(stats); end

  def show(); end
end

class Rake::ThreadHistoryDisplay
  extend ::Rake::PrivateReader::ClassMethods
end

class Rake::ThreadPool
  def future(*args, &block); end

  def gather_history(); end

  def history(); end

  def initialize(thread_count); end

  def join(); end

  def statistics(); end
end

class Rake::ThreadPool
end

module Rake::TraceOutput
  def trace_on(out, *strings); end
end

module Rake::TraceOutput
  extend ::T::Sig
end

module Rake::Version
  BUILD = ::T.let(nil, ::T.untyped)
  MAJOR = ::T.let(nil, ::T.untyped)
  MINOR = ::T.let(nil, ::T.untyped)
  NUMBERS = ::T.let(nil, ::T.untyped)
  OTHER = ::T.let(nil, ::T.untyped)
end

module Rake::Version
  extend ::T::Sig
end

module Rake::Win32
end

class Rake::Win32::Win32HomeError
end

class Rake::Win32::Win32HomeError
end

module Rake::Win32
  extend ::T::Sig
  def self.normalize(path); end

  def self.win32_system_dir(); end

  def self.windows?(); end
end

module Rake
  extend ::Rake::FileUtilsExt
  extend ::FileUtils
  extend ::FileUtils::StreamUtils_
  extend ::T::Sig
  def self.add_rakelib(*files); end

  def self.application(); end

  def self.application=(app); end

  def self.each_dir_parent(dir); end

  def self.from_pathname(path); end

  def self.load_rakefile(path); end

  def self.original_dir(); end

  def self.suggested_thread_count(); end

  def self.with_application(block_application=T.unsafe(nil)); end
end

RakeFileUtils = Rake::FileUtilsExt

class Random
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

module Random::Formatter
  def alphanumeric(n=T.unsafe(nil)); end

  ALPHANUMERIC = ::T.let(nil, ::T.untyped)
end

module Random::Formatter
  extend ::T::Sig
end

class Random
  extend ::T::Sig
  def self.urandom(_); end
end

class Range
  include ::ActiveSupport::EachTimeWithZone
  include ::ActiveSupport::IncludeTimeWithZone
  include ::ActiveSupport::IncludeWithRange
  include ::ActiveSupport::RangeWithFormat
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def overlaps?(other); end

  def sum(identity=T.unsafe(nil)); end
end

class Range
  extend ::T::Sig
end

class RangeError
  extend ::T::Sig
end

module Ransack
  SUPPORTS_ATTRIBUTE_ALIAS = ::T.let(nil, ::T.untyped)
end

module Ransack::Adapters
end

module Ransack::Adapters::ActiveRecord
end

module Ransack::Adapters::ActiveRecord::Base
  def ransack(params=T.unsafe(nil), options=T.unsafe(nil)); end

  def ransack_alias(new_name, old_name); end

  def ransackable_associations(auth_object=T.unsafe(nil)); end

  def ransackable_attributes(auth_object=T.unsafe(nil)); end

  def ransackable_scopes(auth_object=T.unsafe(nil)); end

  def ransackable_scopes_skip_sanitize_args(); end

  def ransacker(name, opts=T.unsafe(nil), &block); end

  def ransortable_attributes(auth_object=T.unsafe(nil)); end

  def search(params=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Ransack::Adapters::ActiveRecord::Base
  extend ::T::Sig
  def self.extended(base); end
end

class Ransack::Adapters::ActiveRecord::Context
  def alias_tracker(); end

  def attribute_method?(str, klass=T.unsafe(nil)); end

  def build_correlated_subquery(association); end

  def evaluate(search, opts=T.unsafe(nil)); end

  def join_sources(); end

  def lock_association(association); end

  def primary_key(); end

  def relation_for(object); end

  def remove_association(association); end

  def table_for(parent); end

  def type_for(attr); end
end

Ransack::Adapters::ActiveRecord::Context::JoinDependency = ActiveRecord::Associations::JoinDependency

class Ransack::Adapters::ActiveRecord::Context
end

module Ransack::Adapters::ActiveRecord
  extend ::T::Sig
end

class Ransack::Adapters::ActiveRecordAdapter
  def require_adapter(); end

  def require_constants(); end

  def require_context(); end

  def require_nodes(); end

  def require_search(); end
end

class Ransack::Adapters::ActiveRecordAdapter
end

class Ransack::Adapters::MongoidAdapter
  def require_adapter(); end

  def require_constants(); end

  def require_context(); end

  def require_nodes(); end

  def require_search(); end
end

class Ransack::Adapters::MongoidAdapter
end

module Ransack::Adapters
  extend ::T::Sig
  def self.instantiate_object_mapper(); end

  def self.object_mapper(); end
end

module Ransack::ClassMethods
  def i18n_scope(); end

  def model_name(); end
end

module Ransack::ClassMethods
  extend ::T::Sig
end

module Ransack::Configuration
  def add_predicate(name, opts=T.unsafe(nil)); end

  def arel_predicate_with_suffix(arel_predicate, suffix); end

  def configure(); end

  def custom_arrows=(opts=T.unsafe(nil)); end

  def hide_sort_order_indicators=(boolean); end

  def ignore_unknown_conditions=(boolean); end

  def options(); end

  def options=(obj); end

  def predicates(); end

  def predicates=(obj); end

  def sanitize_custom_scope_booleans=(boolean); end

  def search_key=(name); end
end

class Ransack::Configuration::PredicateCollection
  def [](*args, &block); end

  def []=(key, value); end

  def has_key?(*args, &block); end

  def keys(*args, &block); end

  def sorted_names_with_underscores(); end
end

class Ransack::Configuration::PredicateCollection
end

module Ransack::Configuration
  extend ::T::Sig
  def self.options(); end

  def self.options=(obj); end

  def self.predicates(); end

  def self.predicates=(obj); end
end

module Ransack::Constants
  AND = ::T.let(nil, ::T.untyped)
  AND_OR = ::T.let(nil, ::T.untyped)
  AREL_PREDICATES = ::T.let(nil, ::T.untyped)
  ASSOCIATION_JOIN = ::T.let(nil, ::T.untyped)
  ATTRIBUTE = ::T.let(nil, ::T.untyped)
  ATTRIBUTES = ::T.let(nil, ::T.untyped)
  A_S_I = ::T.let(nil, ::T.untyped)
  BOOLEAN_VALUES = ::T.let(nil, ::T.untyped)
  CAP_SEARCH = ::T.let(nil, ::T.untyped)
  COMBINATOR = ::T.let(nil, ::T.untyped)
  CONT = ::T.let(nil, ::T.untyped)
  DERIVED_PREDICATES = ::T.let(nil, ::T.untyped)
  DISTINCT = ::T.let(nil, ::T.untyped)
  DOT_ASTERIX = ::T.let(nil, ::T.untyped)
  EQ = ::T.let(nil, ::T.untyped)
  EQ_ANY = ::T.let(nil, ::T.untyped)
  FALSE_VALUES = ::T.let(nil, ::T.untyped)
  I = ::T.let(nil, ::T.untyped)
  IN_NOT_IN = ::T.let(nil, ::T.untyped)
  JOIN_NODE = ::T.let(nil, ::T.untyped)
  LEFT_PARENTHESIS = ::T.let(nil, ::T.untyped)
  NOT_EQ = ::T.let(nil, ::T.untyped)
  NOT_EQ_ALL = ::T.let(nil, ::T.untyped)
  OR = ::T.let(nil, ::T.untyped)
  Q = ::T.let(nil, ::T.untyped)
  RAILS_5_1 = ::T.let(nil, ::T.untyped)
  RAILS_5_2 = ::T.let(nil, ::T.untyped)
  RAILS_5_2_0 = ::T.let(nil, ::T.untyped)
  RANSACK_SLASH_SEARCHES = ::T.let(nil, ::T.untyped)
  RANSACK_SLASH_SEARCHES_SLASH_SEARCH = ::T.let(nil, ::T.untyped)
  SEARCH = ::T.let(nil, ::T.untyped)
  SEARCHES = ::T.let(nil, ::T.untyped)
  STASHED_JOIN = ::T.let(nil, ::T.untyped)
  STRING_JOIN = ::T.let(nil, ::T.untyped)
  SUFFIXES = ::T.let(nil, ::T.untyped)
  TRUE_VALUES = ::T.let(nil, ::T.untyped)
  TWO_COLONS = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

module Ransack::Constants
  extend ::T::Sig
  def self.escape_wildcards(unescaped); end
end

class Ransack::Context
  def arel_visitor(); end

  def association_path(str, base=T.unsafe(nil)); end

  def auth_object(); end

  def auth_object=(auth_object); end

  def base(); end

  def bind(object, str); end

  def bind_pair_for(key); end

  def chain_scope(scope, args); end

  def contextualize(str); end

  def engine(); end

  def initialize(object, options=T.unsafe(nil)); end

  def klass(); end

  def klassify(obj); end

  def object(); end

  def ransackable_alias(str); end

  def ransackable_association?(str, klass); end

  def ransackable_attribute?(str, klass); end

  def ransackable_scope?(str, klass); end

  def ransackable_scope_skip_sanitize_args?(str, klass); end

  def scope_arity(scope); end

  def search(); end

  def search_key(); end

  def search_key=(search_key); end

  def searchable_associations(str=T.unsafe(nil)); end

  def searchable_attributes(str=T.unsafe(nil)); end

  def sortable_attributes(str=T.unsafe(nil)); end

  def traverse(str, base=T.unsafe(nil)); end

  def unpolymorphize_association(str); end
end

class Ransack::Context
  def self.for(object, options=T.unsafe(nil)); end

  def self.for_class(klass, options=T.unsafe(nil)); end

  def self.for_object(object, options=T.unsafe(nil)); end
end

module Ransack::Helpers
end

class Ransack::Helpers::FormBuilder
  def attribute_fields(*args, &block); end

  def attribute_select(options=T.unsafe(nil), html_options=T.unsafe(nil), action=T.unsafe(nil)); end

  def combinator_select(options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def condition_fields(*args, &block); end

  def grouping_fields(*args, &block); end

  def label(method, *args, &block); end

  def predicate_fields(*args, &block); end

  def predicate_select(options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def search_fields(name, args, block); end

  def sort_direction_select(options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def sort_fields(*args, &block); end

  def sort_link(attribute, *args); end

  def sort_select(options=T.unsafe(nil), html_options=T.unsafe(nil)); end

  def sort_url(attribute, *args); end

  def value_fields(*args, &block); end
end

class Ransack::Helpers::FormBuilder
end

module Ransack::Helpers::FormHelper
  def search_form_for(record, options=T.unsafe(nil), &proc); end

  def sort_link(search_object, attribute, *args, &block); end

  def sort_url(search_object, attribute, *args); end
end

class Ransack::Helpers::FormHelper::SortLink
  def default_arrow(); end

  def down_arrow(); end

  def html_options(args); end

  def initialize(search, attribute, args, params); end

  def name(); end

  def up_arrow(); end

  def url_options(); end
end

class Ransack::Helpers::FormHelper::SortLink
end

module Ransack::Helpers::FormHelper
  extend ::T::Sig
end

module Ransack::Helpers
  extend ::T::Sig
end

class Ransack::Name
  def cache_key(); end

  def collection(); end

  def element(); end

  def human(); end

  def i18n_key(); end

  def initialize(); end

  def param_key(); end

  def partial_path(); end

  def plural(); end

  def route_key(); end

  def singular(); end
end

class Ransack::Name
end

module Ransack::Naming
  def model_name(); end

  def persisted?(); end

  def to_key(); end

  def to_model(); end

  def to_param(); end
end

module Ransack::Naming
  extend ::T::Sig
  def self.included(base); end
end

module Ransack::Nodes
end

class Ransack::Nodes::Attribute
  include ::Ransack::Nodes::Bindable
  def ==(other); end

  def associated_collection?(); end

  def blank?(*args, &block); end

  def engine(*args, &block); end

  def eql?(other); end

  def initialize(context, name=T.unsafe(nil), ransacker_args=T.unsafe(nil)); end

  def name(); end

  def name=(name); end

  def persisted?(); end

  def present?(*args, &block); end

  def ransacker_args(); end

  def type(); end

  def valid?(); end
end

class Ransack::Nodes::Attribute
end

module Ransack::Nodes::Bindable
  def arel_attribute(); end

  def attr(); end

  def attr_name(); end

  def attr_name=(attr_name); end

  def bound?(); end

  def klass(); end

  def parent(); end

  def parent=(parent); end

  def ransacker(); end

  def reset_binding!(); end
end

module Ransack::Nodes::Bindable
  extend ::T::Sig
end

class Ransack::Nodes::Condition
  def ==(other); end

  def a(); end

  def a=(args); end

  def arel_predicate(); end

  def arel_predicate_for_attribute(attr); end

  def attributes(); end

  def attributes=(args); end

  def build(params); end

  def build_attribute(name=T.unsafe(nil), ransacker_args=T.unsafe(nil)); end

  def build_value(val=T.unsafe(nil)); end

  def casted_values_for_attribute(attr); end

  def combinator(); end

  def combinator=(val); end

  def default_type(); end

  def eql?(other); end

  def formatted_values_for_attribute(attr); end

  def key(); end

  def m(); end

  def m=(val); end

  def negative?(); end

  def p(); end

  def p=(name); end

  def persisted?(); end

  def predicate(); end

  def predicate=(predicate); end

  def predicate_name(); end

  def predicate_name=(name); end

  def v(); end

  def v=(args); end

  def valid?(); end

  def valid_arity?(); end

  def validated_values(); end

  def value(); end

  def values(); end

  def values=(args); end
end

class Ransack::Nodes::Condition
  def self.extract(context, key, values); end
end

class Ransack::Nodes::Grouping
  def [](key); end

  def []=(key, value); end

  def attribute_method?(name); end

  def build(params); end

  def build_condition(opts=T.unsafe(nil)); end

  def build_grouping(params=T.unsafe(nil)); end

  def c(); end

  def c=(conditions); end

  def combinator(); end

  def combinator=(combinator); end

  def conditions(); end

  def conditions=(conditions); end

  def each(*args, &block); end

  def g(); end

  def g=(groupings); end

  def groupings(); end

  def groupings=(groupings); end

  def initialize(context, combinator=T.unsafe(nil)); end

  def m(); end

  def m=(m); end

  def method_missing(method_id, *args); end

  def new_condition(opts=T.unsafe(nil)); end

  def new_grouping(params=T.unsafe(nil)); end

  def persisted?(); end

  def respond_to?(method_id); end

  def values(); end
end

class Ransack::Nodes::Grouping
end

class Ransack::Nodes::Node
  def context(); end

  def contextualize(*args, &block); end

  def i18n_aliases(); end

  def i18n_aliases=(val); end

  def i18n_aliases?(); end

  def i18n_words(); end

  def i18n_words=(val); end

  def i18n_words?(); end

  def initialize(context); end

  def translate(key, options=T.unsafe(nil)); end
end

class Ransack::Nodes::Node
  def self.i18n_alias(opts=T.unsafe(nil)); end

  def self.i18n_aliases(); end

  def self.i18n_aliases=(val); end

  def self.i18n_aliases?(); end

  def self.i18n_word(*args); end

  def self.i18n_words(); end

  def self.i18n_words=(val); end

  def self.i18n_words?(); end
end

class Ransack::Nodes::Sort
  include ::Ransack::Nodes::Bindable
  def build(params); end

  def dir(); end

  def dir=(dir); end

  def name(); end

  def name=(name); end

  def ransacker_args(); end

  def ransacker_args=(ransack_args); end

  def valid?(); end
end

class Ransack::Nodes::Sort
  def self.extract(context, str); end
end

class Ransack::Nodes::Value
  def ==(other); end

  def array_of_arrays?(val); end

  def blank?(*args, &block); end

  def cast(type); end

  def cast_to_boolean(val); end

  def cast_to_date(val); end

  def cast_to_decimal(val); end

  def cast_to_float(val); end

  def cast_to_integer(val); end

  def cast_to_money(val); end

  def cast_to_string(val); end

  def cast_to_time(val); end

  def eql?(other); end

  def initialize(context, value=T.unsafe(nil)); end

  def persisted?(); end

  def present?(*args, &block); end

  def value(); end

  def value=(value); end
end

class Ransack::Nodes::Value
end

module Ransack::Nodes
  extend ::T::Sig
end

class Ransack::Predicate
  def ==(other); end

  def arel_predicate(); end

  def compound(); end

  def eql?(other); end

  def format(val); end

  def formatter(); end

  def initialize(opts=T.unsafe(nil)); end

  def name(); end

  def negative?(); end

  def type(); end

  def validate(vals, type=T.unsafe(nil)); end

  def validator(); end

  def wants_array(); end
end

class Ransack::Predicate
  def self.detect_and_strip_from_string!(str); end

  def self.detect_from_string(str, chomp: T.unsafe(nil)); end

  def self.named(name); end

  def self.names(); end
end

class Ransack::Ransacker
  def args(); end

  def attr_from(bindable); end

  def call(*args, &block); end

  def formatter(); end

  def initialize(klass, name, opts=T.unsafe(nil), &block); end

  def name(); end

  def type(); end
end

class Ransack::Ransacker
end

class Ransack::Search
  include ::Ransack::Naming
  def base(); end

  def build(params); end

  def build_condition(*args, &block); end

  def build_grouping(*args, &block); end

  def build_sort(opts=T.unsafe(nil)); end

  def context(); end

  def initialize(object, params=T.unsafe(nil), options=T.unsafe(nil)); end

  def klass(*args, &block); end

  def method_missing(method_id, *args); end

  def new_condition(*args, &block); end

  def new_grouping(*args, &block); end

  def new_sort(opts=T.unsafe(nil)); end

  def object(*args, &block); end

  def result(opts=T.unsafe(nil)); end

  def s(); end

  def s=(args); end

  def sorts(); end

  def sorts=(args); end

  def translate(*args, &block); end
end

class Ransack::Search
  extend ::Ransack::ClassMethods
end

module Ransack::Translate
end

module Ransack::Translate
  extend ::T::Sig
  def self.associated_attribute(associated_class); end

  def self.association(key, options=T.unsafe(nil)); end

  def self.association_name(); end

  def self.attr_fallback_name(associated_class); end

  def self.attribute(key, options=T.unsafe(nil)); end

  def self.attribute_name(context, name, include_associations=T.unsafe(nil)); end

  def self.build_interpolations(associated_class); end

  def self.default_attribute_name(); end

  def self.default_interpolation(associated_class); end

  def self.fallback_args(); end

  def self.fallback_class(associated_class); end

  def self.i18n_key(klass); end

  def self.predicate(key, options=T.unsafe(nil)); end

  def self.translated_ancestor_attributes(); end

  def self.translated_attribute(associated_class); end

  def self.word(key, options=T.unsafe(nil)); end
end

class Ransack::UntraversableAssociationError
end

class Ransack::UntraversableAssociationError
end

class Ransack::Visitor
  def accept(object); end

  def can_accept?(object); end

  def quoted?(object); end

  def visit(object); end

  def visit_Array(object); end

  def visit_Ransack_Nodes_Condition(object); end

  def visit_Ransack_Nodes_Grouping(object); end

  def visit_Ransack_Nodes_Sort(object); end

  def visit_and(object); end

  def visit_or(object); end
  DISPATCH = ::T.let(nil, ::T.untyped)
end

class Ransack::Visitor
end

module Ransack
  extend ::Ransack::Configuration
  extend ::T::Sig
end

class Rational
  def to_d(precision); end
end

class Rational
  extend ::T::Sig
end

module Raven
  AVAILABLE_INTEGRATIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Raven::Backtrace
  def ==(other); end

  def initialize(lines); end

  def lines(); end
  APP_DIRS_PATTERN = ::T.let(nil, ::T.untyped)
end

class Raven::Backtrace::Line
  def ==(other); end

  def file(); end

  def in_app(); end

  def initialize(file, number, method, module_name); end

  def method(); end

  def module_name(); end

  def number(); end
  JAVA_INPUT_FORMAT = ::T.let(nil, ::T.untyped)
  RB_EXTENSION = ::T.let(nil, ::T.untyped)
  RUBY_INPUT_FORMAT = ::T.let(nil, ::T.untyped)
end

class Raven::Backtrace::Line
  def self.in_app_pattern(); end

  def self.parse(unparsed_line); end
end

class Raven::Backtrace
  def self.parse(backtrace, opts=T.unsafe(nil)); end
end

class Raven::Breadcrumb
  def category(); end

  def category=(category); end

  def data(); end

  def data=(data); end

  def level(); end

  def level=(level); end

  def message(); end

  def message=(message); end

  def timestamp(); end

  def timestamp=(timestamp); end

  def to_hash(); end

  def type(); end

  def type=(type); end
end

class Raven::Breadcrumb
end

class Raven::BreadcrumbBuffer
  include ::Enumerable
  def buffer(); end

  def buffer=(buffer); end

  def each(&block); end

  def empty?(); end

  def initialize(size=T.unsafe(nil)); end

  def members(); end

  def peek(); end

  def record(crumb=T.unsafe(nil)); end

  def to_hash(); end
end

class Raven::BreadcrumbBuffer
  def self.clear!(); end

  def self.current(); end
end

class Raven::CLI
end

class Raven::CLI
  def self.test(dsn=T.unsafe(nil), silent=T.unsafe(nil), config=T.unsafe(nil)); end
end

class Raven::Client
  def configuration(); end

  def configuration=(configuration); end

  def initialize(configuration); end

  def send_event(event); end

  def transport(); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  PROTOCOL_VERSION = ::T.let(nil, ::T.untyped)
  USER_AGENT = ::T.let(nil, ::T.untyped)
end

class Raven::Client
end

class Raven::ClientState
  def failed?(); end

  def failure(retry_after=T.unsafe(nil)); end

  def reset(); end

  def should_try?(); end

  def success(); end
end

class Raven::ClientState
end

class Raven::Configuration
  def [](option); end

  def app_dirs_pattern(); end

  def app_dirs_pattern=(app_dirs_pattern); end

  def async(); end

  def async=(value); end

  def async?(); end

  def capture_allowed?(message_or_exc=T.unsafe(nil)); end

  def context_lines(); end

  def context_lines=(context_lines); end

  def current_environment(); end

  def current_environment=(environment); end

  def dsn=(value); end

  def encoding(); end

  def encoding=(encoding); end

  def environments(); end

  def environments=(environments); end

  def error_messages(); end

  def errors(); end

  def exception_class_allowed?(exc); end

  def exclude_loggers(); end

  def exclude_loggers=(exclude_loggers); end

  def excluded_exceptions(); end

  def excluded_exceptions=(excluded_exceptions); end

  def faraday_builder(); end

  def faraday_builder=(faraday_builder); end

  def host(); end

  def host=(host); end

  def http_adapter(); end

  def http_adapter=(http_adapter); end

  def linecache(); end

  def linecache=(linecache); end

  def logger(); end

  def logger=(logger); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def path(); end

  def path=(path); end

  def port(); end

  def port=(port); end

  def processors(); end

  def processors=(processors); end

  def project_id(); end

  def project_id=(project_id); end

  def project_root(); end

  def project_root=(root_dir); end

  def proxy(); end

  def proxy=(proxy); end

  def public_key(); end

  def public_key=(public_key); end

  def rails_activesupport_breadcrumbs(); end

  def rails_activesupport_breadcrumbs=(rails_activesupport_breadcrumbs); end

  def rails_report_rescued_exceptions(); end

  def rails_report_rescued_exceptions=(rails_report_rescued_exceptions); end

  def release(); end

  def release=(release); end

  def sample_rate(); end

  def sample_rate=(sample_rate); end

  def sanitize_credit_cards(); end

  def sanitize_credit_cards=(sanitize_credit_cards); end

  def sanitize_fields(); end

  def sanitize_fields=(sanitize_fields); end

  def sanitize_fields_excluded(); end

  def sanitize_fields_excluded=(sanitize_fields_excluded); end

  def sanitize_http_headers(); end

  def sanitize_http_headers=(sanitize_http_headers); end

  def scheme(); end

  def scheme=(scheme); end

  def secret_key(); end

  def secret_key=(secret_key); end

  def send_modules(); end

  def send_modules=(send_modules); end

  def sending_allowed?(message_or_exc=T.unsafe(nil)); end

  def server(); end

  def server=(value); end

  def server_name(); end

  def server_name=(server_name); end

  def should_capture(); end

  def should_capture=(value); end

  def silence_ready(); end

  def silence_ready=(silence_ready); end

  def ssl(); end

  def ssl=(ssl); end

  def ssl_ca_file(); end

  def ssl_ca_file=(ssl_ca_file); end

  def ssl_verification(); end

  def ssl_verification=(ssl_verification); end

  def tags(); end

  def tags=(tags); end

  def timeout(); end

  def timeout=(timeout); end

  def transport_failure_callback(); end

  def transport_failure_callback=(value); end
  DEFAULT_PROCESSORS = ::T.let(nil, ::T.untyped)
  IGNORE_DEFAULT = ::T.let(nil, ::T.untyped)
  LOG_PREFIX = ::T.let(nil, ::T.untyped)
  MODULE_SEPARATOR = ::T.let(nil, ::T.untyped)
end

class Raven::Configuration
end

class Raven::Context
  def extra(); end

  def extra=(extra); end

  def rack_env(); end

  def rack_env=(rack_env); end

  def runtime(); end

  def runtime=(runtime); end

  def server_os(); end

  def server_os=(server_os); end

  def tags(); end

  def tags=(tags); end

  def transaction(); end

  def transaction=(transaction); end

  def user(); end

  def user=(user); end
end

class Raven::Context
  def self.clear!(); end

  def self.current(); end

  def self.os_context(); end

  def self.runtime_context(); end
end

class Raven::Error
end

class Raven::Error
end

class Raven::Event
  def [](key); end

  def []=(key, value); end

  def add_exception_interface(exc); end

  def backtrace(); end

  def backtrace=(backtrace); end

  def breadcrumbs(); end

  def breadcrumbs=(breadcrumbs); end

  def checksum(); end

  def checksum=(checksum); end

  def configuration(); end

  def configuration=(configuration); end

  def context(); end

  def context=(context); end

  def environment(); end

  def environment=(environment); end

  def event_id(); end

  def extra(); end

  def extra=(extra); end

  def fingerprint(); end

  def fingerprint=(fingerprint); end

  def id(); end

  def id=(id); end

  def initialize(init=T.unsafe(nil)); end

  def interface(name, value=T.unsafe(nil), &block); end

  def level(); end

  def level=(new_level); end

  def logger(); end

  def logger=(logger); end

  def message(); end

  def message=(args); end

  def modules(); end

  def modules=(modules); end

  def platform(); end

  def platform=(platform); end

  def release(); end

  def release=(release); end

  def runtime(); end

  def runtime=(runtime); end

  def sdk(); end

  def sdk=(sdk); end

  def server_name(); end

  def server_name=(server_name); end

  def server_os(); end

  def server_os=(server_os); end

  def stacktrace_interface_from(backtrace); end

  def tags(); end

  def tags=(tags); end

  def time_spent(); end

  def time_spent=(time); end

  def timestamp(); end

  def timestamp=(time); end

  def to_hash(); end

  def to_json_compatible(); end

  def transaction(); end

  def transaction=(transaction); end

  def user(); end

  def user=(user); end
  MAX_MESSAGE_SIZE_IN_BYTES = ::T.let(nil, ::T.untyped)
  SDK = ::T.let(nil, ::T.untyped)
end

class Raven::Event
  def self.captureException(exc, options=T.unsafe(nil), &block); end

  def self.captureMessage(message, options=T.unsafe(nil)); end

  def self.capture_exception(exc, options=T.unsafe(nil), &block); end

  def self.capture_message(message, options=T.unsafe(nil)); end

  def self.from_exception(exc, options=T.unsafe(nil), &block); end

  def self.from_message(message, options=T.unsafe(nil)); end
end

class Raven::ExceptionInterface
  def to_hash(*args); end

  def values(); end

  def values=(values); end
end

class Raven::ExceptionInterface
  def self.sentry_alias(); end
end

class Raven::HttpInterface
  include ::Raven::RackInterface
  def cookies(); end

  def cookies=(cookies); end

  def data(); end

  def data=(data); end

  def env(); end

  def env=(env); end

  def headers(); end

  def headers=(headers); end

  def initialize(*arguments); end

  def method(); end

  def method=(method); end

  def query_string(); end

  def query_string=(query_string); end

  def url(); end

  def url=(url); end
end

class Raven::HttpInterface
  def self.sentry_alias(); end
end

class Raven::Instance
  def annotate_exception(exc, options=T.unsafe(nil)); end

  def breadcrumbs(); end

  def capture(options=T.unsafe(nil)); end

  def capture_exception(obj, options=T.unsafe(nil)); end

  def capture_message(obj, options=T.unsafe(nil)); end

  def capture_type(obj, options=T.unsafe(nil)); end

  def client(); end

  def client=(client); end

  def configuration(); end

  def configuration=(configuration); end

  def configure(); end

  def context(); end

  def extra_context(options=T.unsafe(nil)); end

  def initialize(context=T.unsafe(nil), config=T.unsafe(nil)); end

  def last_event_id(); end

  def logger(); end

  def rack_context(env); end

  def report_status(); end

  def send_event(event); end

  def tags_context(options=T.unsafe(nil)); end

  def user_context(options=T.unsafe(nil)); end
end

class Raven::Instance
end

class Raven::Interface
  def initialize(attributes=T.unsafe(nil)); end

  def to_hash(); end
end

class Raven::Interface
  def self.inherited(klass); end

  def self.registered(); end
end

class Raven::LineCache
  def get_file_context(filename, lineno, context); end
end

class Raven::LineCache
end

class Raven::Logger
  def initialize(*_); end
  LOG_PREFIX = ::T.let(nil, ::T.untyped)
  PROGNAME = ::T.let(nil, ::T.untyped)
end

class Raven::Logger
end

class Raven::MessageInterface
  def initialize(*arguments); end

  def message(); end

  def message=(message); end

  def params(); end

  def params=(params); end

  def unformatted_message(); end
end

class Raven::MessageInterface
  def self.sentry_alias(); end
end

class Raven::Processor
  def initialize(client=T.unsafe(nil)); end

  def process(_data); end
  INT_MASK = ::T.let(nil, ::T.untyped)
  REGEX_SPECIAL_CHARACTERS = ::T.let(nil, ::T.untyped)
  STRING_MASK = ::T.let(nil, ::T.untyped)
end

class Raven::Processor::Cookies
  def process(data); end
end

class Raven::Processor::Cookies
end

class Raven::Processor::HTTPHeaders
  def initialize(client); end

  def process(data); end

  def sanitize_http_headers(); end

  def sanitize_http_headers=(sanitize_http_headers); end
  DEFAULT_FIELDS = ::T.let(nil, ::T.untyped)
end

class Raven::Processor::HTTPHeaders
end

class Raven::Processor::PostData
  def process(data); end
end

class Raven::Processor::PostData
end

class Raven::Processor::RemoveCircularReferences
  def process(value, visited=T.unsafe(nil)); end
end

class Raven::Processor::RemoveCircularReferences
end

class Raven::Processor::SanitizeData
  def initialize(client); end

  def process(value, key=T.unsafe(nil)); end

  def sanitize_credit_cards(); end

  def sanitize_credit_cards=(sanitize_credit_cards); end

  def sanitize_fields(); end

  def sanitize_fields=(sanitize_fields); end

  def sanitize_fields_excluded(); end

  def sanitize_fields_excluded=(sanitize_fields_excluded); end
  CREDIT_CARD_RE = ::T.let(nil, ::T.untyped)
  DEFAULT_FIELDS = ::T.let(nil, ::T.untyped)
  JSON_STARTS_WITH = ::T.let(nil, ::T.untyped)
  QUERY_STRING = ::T.let(nil, ::T.untyped)
end

class Raven::Processor::SanitizeData
end

class Raven::Processor::UTF8Conversion
  def process(value); end
  REPLACE = ::T.let(nil, ::T.untyped)
end

class Raven::Processor::UTF8Conversion
end

class Raven::Processor
end

class Raven::Rack
  def call(env); end

  def initialize(app); end
end

class Raven::Rack
  def self.capture_exception(exception, env, options=T.unsafe(nil)); end

  def self.capture_message(exception, env, options=T.unsafe(nil)); end

  def self.capture_type(exception, env, options=T.unsafe(nil)); end
end

module Raven::RackInterface
  def from_rack(env_hash); end
end

module Raven::RackInterface
  extend ::T::Sig
end

class Raven::Rails
end

module Raven::Rails::ActiveJobExtensions
  def already_supported_by_specific_integration?(job); end

  def capture_and_reraise_with_sentry(job, block); end

  def raven_context(job); end
  ALREADY_SUPPORTED_SENTRY_ADAPTERS = ::T.let(nil, ::T.untyped)
end

module Raven::Rails::ActiveJobExtensions
  extend ::T::Sig
  def self.included(base); end
end

module Raven::Rails::ControllerMethods
  def capture_exception(exception, options=T.unsafe(nil)); end

  def capture_message(message, options=T.unsafe(nil)); end
end

module Raven::Rails::ControllerMethods
  extend ::T::Sig
end

module Raven::Rails::ControllerTransaction
end

module Raven::Rails::ControllerTransaction
  extend ::T::Sig
  def self.included(base); end
end

module Raven::Rails::Overrides
end

module Raven::Rails::Overrides::DebugExceptionsCatcher
  def render_exception(env_or_request, exception); end
end

module Raven::Rails::Overrides::DebugExceptionsCatcher
  extend ::T::Sig
end

module Raven::Rails::Overrides::OldDebugExceptionsCatcher
  def render_exception_with_raven(env_or_request, exception); end
end

module Raven::Rails::Overrides::OldDebugExceptionsCatcher
  extend ::T::Sig
  def self.included(base); end
end

module Raven::Rails::Overrides::OldStreamingReporter
  def log_error_with_raven(exception); end
end

module Raven::Rails::Overrides::OldStreamingReporter
  extend ::T::Sig
  def self.included(base); end
end

module Raven::Rails::Overrides::StreamingReporter
  def log_error(exception); end
end

module Raven::Rails::Overrides::StreamingReporter
  extend ::T::Sig
end

module Raven::Rails::Overrides
  extend ::T::Sig
end

class Raven::Rails
end

class Raven::SidekiqCleanupMiddleware
  def call(_worker, job, queue); end
end

class Raven::SidekiqCleanupMiddleware
end

class Raven::SidekiqErrorHandler
  def call(ex, context); end
  ACTIVEJOB_RESERVED_PREFIX = ::T.let(nil, ::T.untyped)
  HAS_GLOBALID = ::T.let(nil, ::T.untyped)
end

class Raven::SidekiqErrorHandler
end

class Raven::SingleExceptionInterface
  def module(); end

  def module=(_); end

  def stacktrace(); end

  def stacktrace=(stacktrace); end

  def to_hash(*args); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
end

class Raven::SingleExceptionInterface
end

class Raven::StacktraceInterface
  def frames(); end

  def frames=(frames); end

  def initialize(*arguments); end

  def to_hash(*args); end
end

class Raven::StacktraceInterface::Frame
  def abs_path(); end

  def abs_path=(abs_path); end

  def context_line(); end

  def context_line=(context_line); end

  def filename(); end

  def function(); end

  def function=(function); end

  def in_app(); end

  def in_app=(in_app); end

  def initialize(*arguments); end

  def lineno(); end

  def lineno=(lineno); end

  def module(); end

  def module=(_); end

  def post_context(); end

  def post_context=(post_context); end

  def pre_context(); end

  def pre_context=(pre_context); end

  def to_hash(*args); end

  def vars(); end

  def vars=(vars); end
end

class Raven::StacktraceInterface::Frame
end

class Raven::StacktraceInterface
  def self.sentry_alias(); end
end

module Raven::Transports
end

class Raven::Transports::HTTP
  def adapter(); end

  def adapter=(adapter); end

  def conn(); end

  def conn=(conn); end

  def initialize(*args); end

  def send_event(auth_header, data, options=T.unsafe(nil)); end
end

class Raven::Transports::HTTP
end

class Raven::Transports::Transport
  def configuration(); end

  def configuration=(configuration); end

  def initialize(configuration); end

  def send_event(); end
end

class Raven::Transports::Transport
end

module Raven::Transports
  extend ::T::Sig
end

module Raven::Utils
end

module Raven::Utils::DeepMergeHash
end

module Raven::Utils::DeepMergeHash
  extend ::T::Sig
  def self.deep_merge(hash, other_hash, &block); end

  def self.deep_merge!(hash, other_hash, &block); end
end

class Raven::Utils::RealIp
  def calculate_ip(); end

  def filter_local_addresses(ips); end

  def initialize(ip_addresses); end

  def ip(); end

  def ip=(ip); end

  def ip_addresses(); end

  def ip_addresses=(ip_addresses); end

  def ips_from(header); end
  LOCAL_ADDRESSES = ::T.let(nil, ::T.untyped)
end

class Raven::Utils::RealIp
end

module Raven::Utils
  extend ::T::Sig
end

module Raven
  extend ::T::Sig
  def self.annotate(*args, &block); end

  def self.annotateException(*args, &block); end

  def self.annotate_exception(*args, &block); end

  def self.breadcrumbs(*args, &block); end

  def self.capture(*args, &block); end

  def self.captureException(*args, &block); end

  def self.captureMessage(*args, &block); end

  def self.capture_exception(*args, &block); end

  def self.capture_message(*args, &block); end

  def self.capture_type(*args, &block); end

  def self.client(*args, &block); end

  def self.client=(*args, &block); end

  def self.configuration(*args, &block); end

  def self.configuration=(*args, &block); end

  def self.configure(*args, &block); end

  def self.context(*args, &block); end

  def self.extra_context(*args, &block); end

  def self.inject(); end

  def self.inject_only(*only_integrations); end

  def self.inject_without(*exclude_integrations); end

  def self.instance(); end

  def self.last_event_id(*args, &block); end

  def self.load_integration(integration); end

  def self.logger(*args, &block); end

  def self.rack_context(*args, &block); end

  def self.report_ready(*args, &block); end

  def self.report_status(*args, &block); end

  def self.safely_prepend(module_name, opts=T.unsafe(nil)); end

  def self.send_event(*args, &block); end

  def self.sys_command(command); end

  def self.tags_context(*args, &block); end

  def self.user_context(*args, &block); end
end

module RbConfig
  extend ::T::Sig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

module Readline
  FILENAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  HISTORY = ::T.let(nil, ::T.untyped)
  USERNAME_COMPLETION_PROC = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Readline
  extend ::T::Sig
  def self.basic_quote_characters(); end

  def self.basic_quote_characters=(basic_quote_characters); end

  def self.basic_word_break_characters(); end

  def self.basic_word_break_characters=(basic_word_break_characters); end

  def self.completer_quote_characters(); end

  def self.completer_quote_characters=(completer_quote_characters); end

  def self.completer_word_break_characters(); end

  def self.completer_word_break_characters=(completer_word_break_characters); end

  def self.completion_append_character(); end

  def self.completion_append_character=(completion_append_character); end

  def self.completion_case_fold(); end

  def self.completion_case_fold=(completion_case_fold); end

  def self.completion_proc(); end

  def self.completion_proc=(completion_proc); end

  def self.delete_text(*_); end

  def self.emacs_editing_mode(); end

  def self.emacs_editing_mode?(); end

  def self.filename_quote_characters(); end

  def self.filename_quote_characters=(filename_quote_characters); end

  def self.get_screen_size(); end

  def self.input=(input); end

  def self.insert_text(_); end

  def self.line_buffer(); end

  def self.output=(output); end

  def self.point(); end

  def self.point=(point); end

  def self.pre_input_hook(); end

  def self.pre_input_hook=(pre_input_hook); end

  def self.quoting_detection_proc(); end

  def self.quoting_detection_proc=(quoting_detection_proc); end

  def self.redisplay(); end

  def self.refresh_line(); end

  def self.set_screen_size(_, _1); end

  def self.special_prefixes(); end

  def self.special_prefixes=(special_prefixes); end

  def self.vi_editing_mode(); end

  def self.vi_editing_mode?(); end
end

class Redis
  include ::MonitorMixin
  include ::ActiveSupport::Cache::ConnectionPoolLike
  def _bpop(cmd, args); end

  def _client(); end

  def _eval(cmd, args); end

  def _scan(command, cursor, args, options=T.unsafe(nil), &block); end

  def append(key, value); end

  def auth(password); end

  def bgrewriteaof(); end

  def bgsave(); end

  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, options=T.unsafe(nil)); end

  def call(*command); end

  def client(subcommand=T.unsafe(nil), *args); end

  def close(); end

  def commit(); end

  def config(action, *args); end

  def connected?(); end

  def connection(); end

  def dbsize(); end

  def debug(*args); end

  def decr(key); end

  def decrby(key, decrement); end

  def del(*keys); end

  def discard(); end

  def disconnect!(); end

  def dump(key); end

  def echo(value); end

  def eval(*args); end

  def evalsha(*args); end

  def exec(); end

  def exists(key); end

  def expire(key, seconds); end

  def expireat(key, unix_time); end

  def flushall(options=T.unsafe(nil)); end

  def flushdb(options=T.unsafe(nil)); end

  def geoadd(key, *member); end

  def geodist(key, member1, member2, unit=T.unsafe(nil)); end

  def geohash(key, member); end

  def geopos(key, member); end

  def georadius(*args, **geoptions); end

  def georadiusbymember(*args, **geoptions); end

  def get(key); end

  def getbit(key, offset); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields, &blk); end

  def hmset(key, *attrs); end

  def hscan(key, cursor, options=T.unsafe(nil)); end

  def hscan_each(key, options=T.unsafe(nil), &block); end

  def hset(key, field, value); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def id(); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def info(cmd=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def keys(pattern=T.unsafe(nil)); end

  def lastsave(); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lpop(key); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end

  def mapped_mget(*keys); end

  def mapped_mset(hash); end

  def mapped_msetnx(hash); end

  def method_missing(command, *args); end

  def mget(*keys, &blk); end

  def migrate(key, options); end

  def monitor(&block); end

  def move(key, db); end

  def mset(*args); end

  def msetnx(*args); end

  def multi(); end

  def object(*args); end

  def persist(key); end

  def pexpire(key, milliseconds); end

  def pexpireat(key, ms_unix_time); end

  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end

  def ping(message=T.unsafe(nil)); end

  def pipelined(); end

  def psetex(key, ttl, value); end

  def psubscribe(*channels, &block); end

  def psubscribe_with_timeout(timeout, *channels, &block); end

  def pttl(key); end

  def publish(channel, message); end

  def pubsub(subcommand, *args); end

  def punsubscribe(*channels); end

  def queue(*command); end

  def quit(); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, options=T.unsafe(nil)); end

  def rpop(key); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end

  def sadd(key, member); end

  def save(); end

  def scan(cursor, options=T.unsafe(nil)); end

  def scan_each(options=T.unsafe(nil), &block); end

  def scard(key); end

  def script(subcommand, *args); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def select(db); end

  def sentinel(subcommand, *args); end

  def set(key, value, options=T.unsafe(nil)); end

  def setbit(key, offset, value); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def shutdown(); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def slaveof(host, port); end

  def slowlog(subcommand, length=T.unsafe(nil)); end

  def smembers(key); end

  def smove(source, destination, member); end

  def sort(key, options=T.unsafe(nil)); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, member); end

  def sscan(key, cursor, options=T.unsafe(nil)); end

  def sscan_each(key, options=T.unsafe(nil), &block); end

  def strlen(key); end

  def subscribe(*channels, &block); end

  def subscribe_with_timeout(timeout, *channels, &block); end

  def subscribed?(); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end

  def sync(); end

  def time(); end

  def ttl(key); end

  def type(key); end

  def unlink(*keys); end

  def unsubscribe(*channels); end

  def unwatch(); end

  def watch(*keys); end

  def with_reconnect(val=T.unsafe(nil), &blk); end

  def without_reconnect(&blk); end

  def zadd(key, *args); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zincrby(key, increment, member); end

  def zinterstore(destination, keys, options=T.unsafe(nil)); end

  def zlexcount(key, min, max); end

  def zrange(key, start, stop, options=T.unsafe(nil)); end

  def zrangebylex(key, min, max, options=T.unsafe(nil)); end

  def zrangebyscore(key, min, max, options=T.unsafe(nil)); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, options=T.unsafe(nil)); end

  def zrevrangebylex(key, max, min, options=T.unsafe(nil)); end

  def zrevrangebyscore(key, max, min, options=T.unsafe(nil)); end

  def zrevrank(key, member); end

  def zscan(key, cursor, options=T.unsafe(nil)); end

  def zscan_each(key, options=T.unsafe(nil), &block); end

  def zscore(key, member); end

  def zunionstore(destination, keys, options=T.unsafe(nil)); end
  Boolify = ::T.let(nil, ::T.untyped)
  BoolifySet = ::T.let(nil, ::T.untyped)
  Floatify = ::T.let(nil, ::T.untyped)
  FloatifyPairs = ::T.let(nil, ::T.untyped)
  Hashify = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Redis::BaseConnectionError
end

class Redis::BaseConnectionError
end

class Redis::BaseError
end

class Redis::BaseError
end

class Redis::CannotConnectError
end

class Redis::CannotConnectError
end

class Redis::Client
  def _parse_driver(driver); end

  def _parse_options(options); end

  def call(*args, &block); end

  def call_loop(command, timeout=T.unsafe(nil)); end

  def call_pipeline(*args, &block); end

  def call_pipeline_without_datadog(pipeline); end

  def call_pipelined(commands); end

  def call_with_timeout(command, timeout, &blk); end

  def call_without_datadog(command); end

  def call_without_timeout(command, &blk); end

  def command_map(); end

  def connect(); end

  def connect_timeout(); end

  def connected?(); end

  def connection(); end

  def db(); end

  def db=(db); end

  def disconnect(); end

  def driver(); end

  def ensure_connected(); end

  def establish_connection(); end

  def host(); end

  def id(); end

  def inherit_socket?(); end

  def initialize(*args); end

  def io(); end

  def location(); end

  def logger(); end

  def logger=(logger); end

  def logging(commands); end

  def options(); end

  def password(); end

  def path(); end

  def port(); end

  def process(commands); end

  def read(); end

  def read_timeout(); end

  def reconnect(); end

  def scheme(); end

  def timeout(); end

  def with_reconnect(val=T.unsafe(nil)); end

  def with_socket_timeout(timeout); end

  def without_reconnect(&blk); end

  def without_socket_timeout(&blk); end

  def write(command); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Redis::Client::Connector
  def check(client); end

  def initialize(options); end

  def resolve(); end
end

class Redis::Client::Connector::Sentinel
  def resolve_master(); end

  def resolve_slave(); end

  def sentinel_detect(); end
end

class Redis::Client::Connector::Sentinel
end

class Redis::Client::Connector
end

class Redis::Client
end

class Redis::CommandError
end

class Redis::CommandError
end

module Redis::Connection
end

module Redis::Connection::CommandHelper
  def build_command(args); end

  def encode(string); end
  COMMAND_DELIMITER = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::CommandHelper
  extend ::T::Sig
end

class Redis::Connection::Ruby
  include ::Redis::Connection::CommandHelper
  def connected?(); end

  def disconnect(); end

  def format_bulk_reply(line); end

  def format_error_reply(line); end

  def format_integer_reply(line); end

  def format_multi_bulk_reply(line); end

  def format_reply(reply_type, line); end

  def format_status_reply(line); end

  def get_tcp_keepalive(); end

  def initialize(sock); end

  def read(); end

  def set_tcp_keepalive(keepalive); end

  def timeout=(timeout); end

  def write(command); end

  def write_timeout=(timeout); end
  ASTERISK = ::T.let(nil, ::T.untyped)
  COLON = ::T.let(nil, ::T.untyped)
  DOLLAR = ::T.let(nil, ::T.untyped)
  MINUS = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
end

class Redis::Connection::Ruby
  def self.connect(config); end
end

class Redis::Connection::SSLSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::SSLSocket
  def self.connect(host, port, timeout, ssl_params); end
end

module Redis::Connection::SocketMixin
  def _read_from_socket(nbytes); end

  def _write_to_socket(data); end

  def gets(); end

  def initialize(*args); end

  def read(nbytes); end

  def timeout=(timeout); end

  def write(data); end

  def write_timeout=(timeout); end
  CRLF = ::T.let(nil, ::T.untyped)
end

module Redis::Connection::SocketMixin
  extend ::T::Sig
end

class Redis::Connection::TCPSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::TCPSocket
  def self.connect(host, port, timeout); end

  def self.connect_addrinfo(ai, port, timeout); end
end

class Redis::Connection::UNIXSocket
  include ::Redis::Connection::SocketMixin
end

class Redis::Connection::UNIXSocket
  def self.connect(path, timeout); end
end

module Redis::Connection
  extend ::T::Sig
  def self.drivers(); end
end

class Redis::ConnectionError
end

class Redis::ConnectionError
end

class Redis::Distributed
  include ::ActiveSupport::Cache::ConnectionPoolLike
  def [](key); end

  def []=(key, value); end

  def _bpop(cmd, args); end

  def _eval(cmd, args); end

  def add_node(options); end

  def append(key, value); end

  def bgsave(); end

  def bitcount(key, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def bitop(operation, destkey, *keys); end

  def bitpos(key, bit, start=T.unsafe(nil), stop=T.unsafe(nil)); end

  def blpop(*args); end

  def brpop(*args); end

  def brpoplpush(source, destination, options=T.unsafe(nil)); end

  def dbsize(); end

  def decr(key); end

  def decrby(key, decrement); end

  def del(*args); end

  def discard(); end

  def dump(key); end

  def echo(value); end

  def ensure_same_node(command, keys); end

  def eval(*args); end

  def evalsha(*args); end

  def exec(); end

  def exists(key); end

  def expire(key, seconds); end

  def expireat(key, unix_time); end

  def flushall(); end

  def flushdb(); end

  def get(key); end

  def getbit(key, offset); end

  def getrange(key, start, stop); end

  def getset(key, value); end

  def hdel(key, *fields); end

  def hexists(key, field); end

  def hget(key, field); end

  def hgetall(key); end

  def hincrby(key, field, increment); end

  def hincrbyfloat(key, field, increment); end

  def hkeys(key); end

  def hlen(key); end

  def hmget(key, *fields); end

  def hmset(key, *attrs); end

  def hset(key, field, value); end

  def hsetnx(key, field, value); end

  def hvals(key); end

  def incr(key); end

  def incrby(key, increment); end

  def incrbyfloat(key, increment); end

  def info(cmd=T.unsafe(nil)); end

  def initialize(node_configs, options=T.unsafe(nil)); end

  def key_tag(key); end

  def keys(glob=T.unsafe(nil)); end

  def lastsave(); end

  def lindex(key, index); end

  def linsert(key, where, pivot, value); end

  def llen(key); end

  def lpop(key); end

  def lpush(key, value); end

  def lpushx(key, value); end

  def lrange(key, start, stop); end

  def lrem(key, count, value); end

  def lset(key, index, value); end

  def ltrim(key, start, stop); end

  def mapped_hmget(key, *fields); end

  def mapped_hmset(key, hash); end

  def mapped_mget(*keys); end

  def mapped_mset(hash); end

  def mapped_msetnx(hash); end

  def mget(*keys); end

  def migrate(key, options); end

  def monitor(); end

  def move(key, db); end

  def mset(*args); end

  def msetnx(*args); end

  def multi(); end

  def node_for(key); end

  def node_index_for(key); end

  def nodes(); end

  def on_each_node(command, *args); end

  def persist(key); end

  def pexpire(key, milliseconds); end

  def pexpireat(key, ms_unix_time); end

  def pfadd(key, member); end

  def pfcount(*keys); end

  def pfmerge(dest_key, *source_key); end

  def ping(); end

  def pipelined(); end

  def psetex(key, ttl, value); end

  def psubscribe(*channels, &block); end

  def pttl(key); end

  def publish(channel, message); end

  def punsubscribe(*channels); end

  def quit(); end

  def randomkey(); end

  def rename(old_name, new_name); end

  def renamenx(old_name, new_name); end

  def restore(key, ttl, serialized_value, options=T.unsafe(nil)); end

  def ring(); end

  def rpop(key); end

  def rpoplpush(source, destination); end

  def rpush(key, value); end

  def rpushx(key, value); end

  def sadd(key, member); end

  def save(); end

  def scard(key); end

  def script(subcommand, *args); end

  def sdiff(*keys); end

  def sdiffstore(destination, *keys); end

  def select(db); end

  def set(key, value, options=T.unsafe(nil)); end

  def setbit(key, offset, value); end

  def setex(key, ttl, value); end

  def setnx(key, value); end

  def setrange(key, offset, value); end

  def sinter(*keys); end

  def sinterstore(destination, *keys); end

  def sismember(key, member); end

  def smembers(key); end

  def smove(source, destination, member); end

  def sort(key, options=T.unsafe(nil)); end

  def spop(key, count=T.unsafe(nil)); end

  def srandmember(key, count=T.unsafe(nil)); end

  def srem(key, member); end

  def sscan(key, cursor, options=T.unsafe(nil)); end

  def sscan_each(key, options=T.unsafe(nil), &block); end

  def strlen(key); end

  def subscribe(channel, *channels, &block); end

  def subscribed?(); end

  def sunion(*keys); end

  def sunionstore(destination, *keys); end

  def time(); end

  def ttl(key); end

  def type(key); end

  def unlink(*args); end

  def unsubscribe(*channels); end

  def unwatch(); end

  def watch(*keys); end

  def zadd(key, *args); end

  def zcard(key); end

  def zcount(key, min, max); end

  def zincrby(key, increment, member); end

  def zinterstore(destination, keys, options=T.unsafe(nil)); end

  def zrange(key, start, stop, options=T.unsafe(nil)); end

  def zrangebyscore(key, min, max, options=T.unsafe(nil)); end

  def zrank(key, member); end

  def zrem(key, member); end

  def zremrangebyrank(key, start, stop); end

  def zremrangebyscore(key, min, max); end

  def zrevrange(key, start, stop, options=T.unsafe(nil)); end

  def zrevrangebyscore(key, max, min, options=T.unsafe(nil)); end

  def zrevrank(key, member); end

  def zscore(key, member); end

  def zunionstore(destination, keys, options=T.unsafe(nil)); end
end

class Redis::Distributed::CannotDistribute
  def initialize(command); end
end

class Redis::Distributed::CannotDistribute
end

class Redis::Distributed
end

class Redis::Future
  def _command(); end

  def _set(object); end

  def class(); end

  def initialize(command, transformation); end

  def inspect(); end

  def is_a?(other); end

  def value(); end
  FutureNotReady = ::T.let(nil, ::T.untyped)
end

class Redis::Future
end

class Redis::FutureNotReady
  def initialize(); end
end

class Redis::FutureNotReady
end

class Redis::HashRing
  def add_node(node); end

  def get_node(key); end

  def get_node_pos(key); end

  def initialize(nodes=T.unsafe(nil), replicas=T.unsafe(nil)); end

  def iter_nodes(key); end

  def nodes(); end

  def remove_node(node); end

  def replicas(); end

  def ring(); end

  def sorted_keys(); end
  POINTS_PER_SERVER = ::T.let(nil, ::T.untyped)
end

class Redis::HashRing
  def self.binary_search(ary, value, &block); end
end

class Redis::InheritedError
end

class Redis::InheritedError
end

class Redis::Pipeline
  def call(command, &block); end

  def call_pipeline(pipeline); end

  def commands(); end

  def db(); end

  def db=(db); end

  def empty?(); end

  def finish(replies, &blk); end

  def futures(); end

  def shutdown?(); end

  def with_reconnect(val=T.unsafe(nil)); end

  def with_reconnect?(); end

  def without_reconnect(&blk); end

  def without_reconnect?(); end
end

class Redis::Pipeline::Multi
  def finish(replies); end
end

class Redis::Pipeline::Multi
end

class Redis::Pipeline
end

class Redis::ProtocolError
  def initialize(reply_type); end
end

class Redis::ProtocolError
end

class Redis::SubscribedClient
  def call(command); end

  def initialize(client); end

  def psubscribe(*channels, &block); end

  def psubscribe_with_timeout(timeout, *channels, &block); end

  def punsubscribe(*channels); end

  def subscribe(*channels, &block); end

  def subscribe_with_timeout(timeout, *channels, &block); end

  def subscription(start, stop, channels, block, timeout=T.unsafe(nil)); end

  def unsubscribe(*channels); end
end

class Redis::SubscribedClient
end

class Redis::Subscription
  def callbacks(); end

  def message(&block); end

  def pmessage(&block); end

  def psubscribe(&block); end

  def punsubscribe(&block); end

  def subscribe(&block); end

  def unsubscribe(&block); end
end

class Redis::Subscription
end

class Redis::TimeoutError
end

class Redis::TimeoutError
end

class Redis
  def self.current(); end

  def self.current=(redis); end
end

class Regexp
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def match?(*_); end

  def multiline?(); end
  TOKEN_KEYS = ::T.let(nil, ::T.untyped)
end

module Regexp::Expression
end

class Regexp::Expression::Alternation
  def alternatives(); end
end

Regexp::Expression::Alternation::OPERAND = Regexp::Expression::Alternative

class Regexp::Expression::Alternation
end

class Regexp::Expression::Alternative
end

class Regexp::Expression::Alternative
end

module Regexp::Expression::Anchor
end

Regexp::Expression::Anchor::BOL = Regexp::Expression::Anchor::BeginningOfLine

Regexp::Expression::Anchor::BOS = Regexp::Expression::Anchor::BeginningOfString

class Regexp::Expression::Anchor::Base
end

class Regexp::Expression::Anchor::Base
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfLine
end

class Regexp::Expression::Anchor::BeginningOfString
end

class Regexp::Expression::Anchor::BeginningOfString
end

Regexp::Expression::Anchor::EOL = Regexp::Expression::Anchor::EndOfLine

Regexp::Expression::Anchor::EOS = Regexp::Expression::Anchor::EndOfString

Regexp::Expression::Anchor::EOSobEOL = Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfLine
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfString
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::EndOfStringOrBeforeEndOfLine
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::MatchStart
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::NonWordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

class Regexp::Expression::Anchor::WordBoundary
end

module Regexp::Expression::Anchor
  extend ::T::Sig
end

module Regexp::Expression::Assertion
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Base
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookahead
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::Lookbehind
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookahead
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

class Regexp::Expression::Assertion::NegativeLookbehind
end

module Regexp::Expression::Assertion
  extend ::T::Sig
end

module Regexp::Expression::Backreference
end

class Regexp::Expression::Backreference::Base
end

class Regexp::Expression::Backreference::Base
end

class Regexp::Expression::Backreference::Name
  def name(); end
end

class Regexp::Expression::Backreference::Name
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameCall
end

class Regexp::Expression::Backreference::NameRecursionLevel
  def name(); end

  def recursion_level(); end
end

class Regexp::Expression::Backreference::NameRecursionLevel
end

class Regexp::Expression::Backreference::Number
  def number(); end
end

class Regexp::Expression::Backreference::Number
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCall
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberCallRelative
end

class Regexp::Expression::Backreference::NumberRecursionLevel
  def number(); end

  def recursion_level(); end
end

class Regexp::Expression::Backreference::NumberRecursionLevel
end

class Regexp::Expression::Backreference::NumberRelative
end

class Regexp::Expression::Backreference::NumberRelative
end

module Regexp::Expression::Backreference
  extend ::T::Sig
end

class Regexp::Expression::Base
  def =~(string, offset); end

  def a?(); end

  def ascii_classes?(); end

  def attributes(); end

  def case_insensitive?(); end

  def coded_offset(); end

  def conditional_level(); end

  def conditional_level=(conditional_level); end

  def d?(); end

  def default_classes?(); end

  def extended?(); end

  def free_spacing?(); end

  def full_length(); end

  def greedy?(); end

  def i?(); end

  def ignore_case?(); end

  def initialize(token, options=T.unsafe(nil)); end

  def is?(test_token, test_type=T.unsafe(nil)); end

  def lazy?(); end

  def level(); end

  def level=(level); end

  def m?(); end

  def match(string, offset); end

  def matches?(string); end

  def multiline?(); end

  def nesting_level(); end

  def nesting_level=(nesting_level); end

  def offset(); end

  def one_of?(scope, top=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def possessive?(); end

  def quantified?(); end

  def quantifier(); end

  def quantifier=(quantifier); end

  def quantifier_affix(expression_format); end

  def quantify(token, text, min=T.unsafe(nil), max=T.unsafe(nil), mode=T.unsafe(nil)); end

  def quantity(); end

  def reluctant?(); end

  def set_level(); end

  def set_level=(set_level); end

  def starts_at(); end

  def strfre(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def strfregexp(format=T.unsafe(nil), indent_offset=T.unsafe(nil), index=T.unsafe(nil)); end

  def terminal?(); end

  def text(); end

  def text=(text); end

  def to_h(); end

  def to_re(format=T.unsafe(nil)); end

  def to_s(format=T.unsafe(nil)); end

  def token(); end

  def token=(token); end

  def ts(); end

  def ts=(ts); end

  def type(); end

  def type=(type); end

  def type?(test_type); end

  def u?(); end

  def unicode_classes?(); end

  def x?(); end
end

class Regexp::Expression::Base
end

class Regexp::Expression::CharacterSet
  def close(); end

  def closed(); end

  def closed=(closed); end

  def closed?(); end

  def negate(); end

  def negated?(); end

  def negative(); end

  def negative=(negative); end

  def negative?(); end
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::IntersectedSequence
end

class Regexp::Expression::CharacterSet::Intersection
end

Regexp::Expression::CharacterSet::Intersection::OPERAND = Regexp::Expression::CharacterSet::IntersectedSequence

class Regexp::Expression::CharacterSet::Intersection
end

class Regexp::Expression::CharacterSet::Range
  def complete?(); end

  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::CharacterSet::Range
end

class Regexp::Expression::CharacterSet
end

module Regexp::Expression::CharacterType
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Any
end

class Regexp::Expression::CharacterType::Base
end

class Regexp::Expression::CharacterType::Base
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::Digit
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::ExtendedGrapheme
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Hex
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::Linebreak
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonDigit
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonHex
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonSpace
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::NonWord
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Space
end

class Regexp::Expression::CharacterType::Word
end

class Regexp::Expression::CharacterType::Word
end

module Regexp::Expression::CharacterType
  extend ::T::Sig
end

class Regexp::Expression::Comment
end

class Regexp::Expression::Comment
end

module Regexp::Expression::Conditional
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Branch
end

class Regexp::Expression::Conditional::Condition
  def reference(); end
end

class Regexp::Expression::Conditional::Condition
end

class Regexp::Expression::Conditional::Expression
  def add_sequence(); end

  def branch(); end

  def branches(); end

  def condition(); end

  def condition=(exp); end

  def reference(); end
end

class Regexp::Expression::Conditional::Expression
end

class Regexp::Expression::Conditional::TooManyBranches
  def initialize(); end
end

class Regexp::Expression::Conditional::TooManyBranches
end

module Regexp::Expression::Conditional
  extend ::T::Sig
end

module Regexp::Expression::EscapeSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AbstractMetaControlSequence
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::AsciiEscape
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Backspace
end

class Regexp::Expression::EscapeSequence::Base
  def char(); end

  def codepoint(); end
end

class Regexp::Expression::EscapeSequence::Base
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Bell
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::Codepoint
end

class Regexp::Expression::EscapeSequence::CodepointList
  def chars(); end

  def codepoints(); end
end

class Regexp::Expression::EscapeSequence::CodepointList
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::Control
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::FormFeed
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Hex
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Literal
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::Meta
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::MetaControl
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Newline
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Octal
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Return
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::Tab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

class Regexp::Expression::EscapeSequence::VerticalTab
end

module Regexp::Expression::EscapeSequence
  extend ::T::Sig
end

class Regexp::Expression::FreeSpace
end

class Regexp::Expression::FreeSpace
end

module Regexp::Expression::Group
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Absence
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Atomic
end

class Regexp::Expression::Group::Base
  def capturing?(); end

  def comment?(); end
end

class Regexp::Expression::Group::Base
end

class Regexp::Expression::Group::Capture
  def number(); end

  def number=(number); end

  def number_at_level(); end

  def number_at_level=(number_at_level); end
end

class Regexp::Expression::Group::Capture
end

class Regexp::Expression::Group::Comment
  def to_s(_format=T.unsafe(nil)); end
end

class Regexp::Expression::Group::Comment
end

class Regexp::Expression::Group::Named
  def name(); end
end

class Regexp::Expression::Group::Named
end

class Regexp::Expression::Group::Options
  def option_changes(); end

  def option_changes=(option_changes); end
end

class Regexp::Expression::Group::Options
end

class Regexp::Expression::Group::Passive
end

class Regexp::Expression::Group::Passive
end

module Regexp::Expression::Group
  extend ::T::Sig
end

module Regexp::Expression::Keep
end

class Regexp::Expression::Keep::Mark
end

class Regexp::Expression::Keep::Mark
end

module Regexp::Expression::Keep
  extend ::T::Sig
end

class Regexp::Expression::Literal
end

class Regexp::Expression::Literal
end

class Regexp::Expression::PosixClass
  def name(); end

  def negative?(); end
end

class Regexp::Expression::PosixClass
end

class Regexp::Expression::Quantifier
  def greedy?(); end

  def initialize(token, text, min, max, mode); end

  def lazy?(); end

  def max(); end

  def min(); end

  def mode(); end

  def possessive?(); end

  def reluctant?(); end

  def text(); end

  def to_h(); end

  def to_str(); end

  def token(); end
  MODES = ::T.let(nil, ::T.untyped)
end

class Regexp::Expression::Quantifier
end

class Regexp::Expression::Root
  def initialize(*args); end
end

class Regexp::Expression::Root
  def self.build(options=T.unsafe(nil)); end

  def self.build_token(); end
end

class Regexp::Expression::Sequence
  def initialize(*args); end
end

class Regexp::Expression::Sequence
  def self.add_to(subexpression, options=T.unsafe(nil)); end

  def self.at_levels(level, set_level, conditional_level); end
end

class Regexp::Expression::SequenceOperation
  def add_sequence(); end

  def operands(); end

  def operator(); end

  def sequences(); end
end

class Regexp::Expression::SequenceOperation
end

class Regexp::Expression::Subexpression
  include ::Enumerable
  def <<(exp); end

  def [](*args, &block); end

  def at(*args, &block); end

  def dig(*indices); end

  def each(*args, &block); end

  def each_expression(include_self=T.unsafe(nil), &block); end

  def empty?(*args, &block); end

  def expressions(); end

  def expressions=(expressions); end

  def fetch(*args, &block); end

  def flat_map(include_self=T.unsafe(nil), &block); end

  def index(*args, &block); end

  def join(*args, &block); end

  def last(*args, &block); end

  def length(*args, &block); end

  def strfre_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def strfregexp_tree(format=T.unsafe(nil), include_self=T.unsafe(nil), separator=T.unsafe(nil)); end

  def te(); end

  def to_h(); end

  def traverse(include_self=T.unsafe(nil), &block); end

  def values_at(*args, &block); end

  def walk(include_self=T.unsafe(nil), &block); end
end

class Regexp::Expression::Subexpression
end

module Regexp::Expression::UnicodeProperty
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Age
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alnum
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Alpha
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Any
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Ascii
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Assigned
end

class Regexp::Expression::UnicodeProperty::Base
  def name(); end

  def negative?(); end

  def shortcut(); end
end

class Regexp::Expression::UnicodeProperty::Base
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Blank
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Block
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

class Regexp::Expression::UnicodeProperty::Cntrl
end

module Regexp::Expression::UnicodeProperty::Codepoint
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Any
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Base
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Control
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::Format
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::PrivateUse
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Surrogate
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

class Regexp::Expression::UnicodeProperty::Codepoint::Unassigned
end

module Regexp::Expression::UnicodeProperty::Codepoint
  extend ::T::Sig
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Derived
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Digit
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Emoji
end

class Regexp::Expression::UnicodeProperty::Graph
end

class Regexp::Expression::UnicodeProperty::Graph
end

module Regexp::Expression::UnicodeProperty::Letter
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Any
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Base
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Cased
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Lowercase
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Modifier
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Other
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Titlecase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

class Regexp::Expression::UnicodeProperty::Letter::Uppercase
end

module Regexp::Expression::UnicodeProperty::Letter
  extend ::T::Sig
end

class Regexp::Expression::UnicodeProperty::Lower
end

class Regexp::Expression::UnicodeProperty::Lower
end

module Regexp::Expression::UnicodeProperty::Mark
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Any
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Base
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Combining
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Enclosing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Nonspacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

class Regexp::Expression::UnicodeProperty::Mark::Spacing
end

module Regexp::Expression::UnicodeProperty::Mark
  extend ::T::Sig
end

class Regexp::Expression::UnicodeProperty::Newline
end

class Regexp::Expression::UnicodeProperty::Newline
end

module Regexp::Expression::UnicodeProperty::Number
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Any
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Base
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Decimal
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Letter
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

class Regexp::Expression::UnicodeProperty::Number::Other
end

module Regexp::Expression::UnicodeProperty::Number
  extend ::T::Sig
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Print
end

class Regexp::Expression::UnicodeProperty::Punct
end

class Regexp::Expression::UnicodeProperty::Punct
end

module Regexp::Expression::UnicodeProperty::Punctuation
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Any
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Base
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Close
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Connector
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Dash
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Final
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Initial
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Open
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

class Regexp::Expression::UnicodeProperty::Punctuation::Other
end

module Regexp::Expression::UnicodeProperty::Punctuation
  extend ::T::Sig
end

class Regexp::Expression::UnicodeProperty::Script
end

class Regexp::Expression::UnicodeProperty::Script
end

module Regexp::Expression::UnicodeProperty::Separator
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Any
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Base
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Line
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Paragraph
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

class Regexp::Expression::UnicodeProperty::Separator::Space
end

module Regexp::Expression::UnicodeProperty::Separator
  extend ::T::Sig
end

class Regexp::Expression::UnicodeProperty::Space
end

class Regexp::Expression::UnicodeProperty::Space
end

module Regexp::Expression::UnicodeProperty::Symbol
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Any
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Base
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Currency
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Math
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Modifier
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

class Regexp::Expression::UnicodeProperty::Symbol::Other
end

module Regexp::Expression::UnicodeProperty::Symbol
  extend ::T::Sig
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Upper
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::Word
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::XPosixPunct
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

class Regexp::Expression::UnicodeProperty::Xdigit
end

module Regexp::Expression::UnicodeProperty
  extend ::T::Sig
end

class Regexp::Expression::WhiteSpace
  def merge(exp); end
end

class Regexp::Expression::WhiteSpace
end

module Regexp::Expression
  extend ::T::Sig
  def self.parsed(exp); end
end

class Regexp::Lexer
  def lex(input, syntax=T.unsafe(nil), &block); end
  CLOSING_TOKENS = ::T.let(nil, ::T.untyped)
  OPENING_TOKENS = ::T.let(nil, ::T.untyped)
end

class Regexp::Lexer
  def self.lex(input, syntax=T.unsafe(nil), &block); end

  def self.scan(input, syntax=T.unsafe(nil), &block); end
end

class Regexp::Parser
  include ::Regexp::Expression
  include ::Regexp::Syntax
  include ::Regexp::Expression::UnicodeProperty
  def parse(input, syntax=T.unsafe(nil), &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::ParserError
end

class Regexp::Parser::UnknownTokenError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenError
end

class Regexp::Parser::UnknownTokenTypeError
  def initialize(type, token); end
end

class Regexp::Parser::UnknownTokenTypeError
end

class Regexp::Parser
  def self.parse(input, syntax=T.unsafe(nil), &block); end
end

class Regexp::Scanner
  def emit(type, token, text, ts, te); end

  def scan(input_object, &block); end
  PROP_MAPS_DIR = ::T.let(nil, ::T.untyped)
end

class Regexp::Scanner::InvalidBackrefError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidBackrefError
end

class Regexp::Scanner::InvalidGroupError
  def initialize(what, reason); end
end

class Regexp::Scanner::InvalidGroupError
end

class Regexp::Scanner::InvalidGroupOption
  def initialize(option, text); end
end

class Regexp::Scanner::InvalidGroupOption
end

class Regexp::Scanner::InvalidSequenceError
  def initialize(what=T.unsafe(nil), where=T.unsafe(nil)); end
end

class Regexp::Scanner::InvalidSequenceError
end

class Regexp::Scanner::PrematureEndError
  def initialize(where=T.unsafe(nil)); end
end

class Regexp::Scanner::PrematureEndError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::ScannerError
end

class Regexp::Scanner::UnknownUnicodePropertyError
  def initialize(name); end
end

class Regexp::Scanner::UnknownUnicodePropertyError
end

class Regexp::Scanner::ValidationError
  def initialize(reason); end
end

class Regexp::Scanner::ValidationError
end

class Regexp::Scanner
  def self.long_prop_map(); end

  def self.scan(input_object, &block); end

  def self.short_prop_map(); end
end

module Regexp::Syntax
  VERSION_CONST_REGEXP = ::T.let(nil, ::T.untyped)
  VERSION_FORMAT = ::T.let(nil, ::T.untyped)
  VERSION_REGEXP = ::T.let(nil, ::T.untyped)
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Any
end

class Regexp::Syntax::Base
  include ::Regexp::Syntax::Token
  def check!(type, token); end

  def check?(type, token); end

  def excludes(type, tokens); end

  def implementations(type); end

  def implements(type, tokens); end

  def implements!(type, token); end

  def implements?(type, token); end

  def normalize(type, token); end

  def normalize_backref(type, token); end

  def normalize_group(type, token); end
end

class Regexp::Syntax::Base
end

class Regexp::Syntax::InvalidVersionNameError
  def initialize(name); end
end

class Regexp::Syntax::InvalidVersionNameError
end

class Regexp::Syntax::NotImplementedError
  def initialize(syntax, type, token); end
end

class Regexp::Syntax::NotImplementedError
end

class Regexp::Syntax::SyntaxError
end

class Regexp::Syntax::SyntaxError
end

module Regexp::Syntax::Token
  All = ::T.let(nil, ::T.untyped)
  Map = ::T.let(nil, ::T.untyped)
  Types = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  MatchStart = ::T.let(nil, ::T.untyped)
  String = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Anchor
  extend ::T::Sig
end

module Regexp::Syntax::Token::Assertion
  All = ::T.let(nil, ::T.untyped)
  Lookahead = ::T.let(nil, ::T.untyped)
  Lookbehind = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Assertion
  extend ::T::Sig
end

module Regexp::Syntax::Token::Backreference
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  RecursionLevel = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Backreference
  extend ::T::Sig
end

module Regexp::Syntax::Token::CharacterSet
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  OpenClose = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterSet
  extend ::T::Sig
end

module Regexp::Syntax::Token::CharacterType
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Clustered = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::CharacterType
  extend ::T::Sig
end

module Regexp::Syntax::Token::Conditional
  All = ::T.let(nil, ::T.untyped)
  Condition = ::T.let(nil, ::T.untyped)
  Delimiters = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Conditional
  extend ::T::Sig
end

module Regexp::Syntax::Token::Escape
  ASCII = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  Backreference = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Control = ::T.let(nil, ::T.untyped)
  Hex = ::T.let(nil, ::T.untyped)
  Meta = ::T.let(nil, ::T.untyped)
  Octal = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  Unicode = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Escape
  extend ::T::Sig
end

module Regexp::Syntax::Token::FreeSpace
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::FreeSpace
  extend ::T::Sig
end

module Regexp::Syntax::Token::Group
  All = ::T.let(nil, ::T.untyped)
  Atomic = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Comment = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Named = ::T.let(nil, ::T.untyped)
  Passive = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  V1_8_6 = ::T.let(nil, ::T.untyped)
  V2_4_1 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Group
  extend ::T::Sig
end

module Regexp::Syntax::Token::Keep
  All = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Keep
  extend ::T::Sig
end

module Regexp::Syntax::Token::Literal
  All = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Literal
  extend ::T::Sig
end

module Regexp::Syntax::Token::Meta
  All = ::T.let(nil, ::T.untyped)
  Basic = ::T.let(nil, ::T.untyped)
  Extended = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Meta
  extend ::T::Sig
end

module Regexp::Syntax::Token::PosixClass
  All = ::T.let(nil, ::T.untyped)
  Extensions = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  Standard = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::PosixClass
  extend ::T::Sig
end

module Regexp::Syntax::Token::Quantifier
  All = ::T.let(nil, ::T.untyped)
  Greedy = ::T.let(nil, ::T.untyped)
  Interval = ::T.let(nil, ::T.untyped)
  IntervalAll = ::T.let(nil, ::T.untyped)
  IntervalPossessive = ::T.let(nil, ::T.untyped)
  IntervalReluctant = ::T.let(nil, ::T.untyped)
  Possessive = ::T.let(nil, ::T.untyped)
  Reluctant = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::Quantifier
  extend ::T::Sig
end

module Regexp::Syntax::Token::SubexpressionCall
  All = ::T.let(nil, ::T.untyped)
  Name = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::SubexpressionCall
  extend ::T::Sig
end

module Regexp::Syntax::Token::UnicodeProperty
  Age = ::T.let(nil, ::T.untyped)
  Age_V1_9_3 = ::T.let(nil, ::T.untyped)
  Age_V2_0_0 = ::T.let(nil, ::T.untyped)
  Age_V2_2_0 = ::T.let(nil, ::T.untyped)
  Age_V2_3_0 = ::T.let(nil, ::T.untyped)
  Age_V2_4_0 = ::T.let(nil, ::T.untyped)
  Age_V2_5_0 = ::T.let(nil, ::T.untyped)
  All = ::T.let(nil, ::T.untyped)
  CharType_V1_9_0 = ::T.let(nil, ::T.untyped)
  CharType_V2_5_0 = ::T.let(nil, ::T.untyped)
  Derived = ::T.let(nil, ::T.untyped)
  Derived_V1_9_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_0_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_4_0 = ::T.let(nil, ::T.untyped)
  Derived_V2_5_0 = ::T.let(nil, ::T.untyped)
  Emoji = ::T.let(nil, ::T.untyped)
  Emoji_V2_5_0 = ::T.let(nil, ::T.untyped)
  NonType = ::T.let(nil, ::T.untyped)
  POSIX = ::T.let(nil, ::T.untyped)
  Script = ::T.let(nil, ::T.untyped)
  Script_V1_9_0 = ::T.let(nil, ::T.untyped)
  Script_V1_9_3 = ::T.let(nil, ::T.untyped)
  Script_V2_0_0 = ::T.let(nil, ::T.untyped)
  Script_V2_2_0 = ::T.let(nil, ::T.untyped)
  Script_V2_3_0 = ::T.let(nil, ::T.untyped)
  Script_V2_4_0 = ::T.let(nil, ::T.untyped)
  Script_V2_5_0 = ::T.let(nil, ::T.untyped)
  Type = ::T.let(nil, ::T.untyped)
  UnicodeBlock = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V1_9_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_0_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_2_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_3_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_4_0 = ::T.let(nil, ::T.untyped)
  UnicodeBlock_V2_5_0 = ::T.let(nil, ::T.untyped)
  V1_9_0 = ::T.let(nil, ::T.untyped)
  V1_9_3 = ::T.let(nil, ::T.untyped)
  V2_0_0 = ::T.let(nil, ::T.untyped)
  V2_2_0 = ::T.let(nil, ::T.untyped)
  V2_3_0 = ::T.let(nil, ::T.untyped)
  V2_4_0 = ::T.let(nil, ::T.untyped)
  V2_5_0 = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  All = ::T.let(nil, ::T.untyped)
  Codepoint = ::T.let(nil, ::T.untyped)
  Letter = ::T.let(nil, ::T.untyped)
  Mark = ::T.let(nil, ::T.untyped)
  Number = ::T.let(nil, ::T.untyped)
  Punctuation = ::T.let(nil, ::T.untyped)
  Separator = ::T.let(nil, ::T.untyped)
  Symbol = ::T.let(nil, ::T.untyped)
end

module Regexp::Syntax::Token::UnicodeProperty::Category
  extend ::T::Sig
end

module Regexp::Syntax::Token::UnicodeProperty
  extend ::T::Sig
end

module Regexp::Syntax::Token
  extend ::T::Sig
end

class Regexp::Syntax::UnknownSyntaxNameError
  def initialize(name); end
end

class Regexp::Syntax::UnknownSyntaxNameError
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_8_6
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_1
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V1_9_3
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_0_0
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_1
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_2_0
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_3_0
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_0
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_4_1
end

class Regexp::Syntax::V2_5_0
end

class Regexp::Syntax::V2_5_0
end

module Regexp::Syntax
  extend ::T::Sig
  def self.comparable_version(name); end

  def self.fallback_version_class(version); end

  def self.inherit_from_version(parent_version, new_version); end

  def self.new(name); end

  def self.specified_versions(); end

  def self.supported?(name); end

  def self.version_class(version); end

  def self.version_const_name(version_string); end

  def self.warn_if_future_version(const_name); end
end

class Regexp::Token
  def conditional_level(); end

  def conditional_level=(_); end

  def level(); end

  def level=(_); end

  def next(); end

  def next=(_); end

  def offset(); end

  def previous(); end

  def previous=(previous); end

  def set_level(); end

  def set_level=(_); end

  def te(); end

  def te=(_); end

  def text(); end

  def text=(_); end

  def token(); end

  def token=(_); end

  def ts(); end

  def ts=(_); end

  def type(); end

  def type=(_); end
end

class Regexp::Token
  def self.[](*_); end

  def self.members(); end
end

class Regexp
  extend ::T::Sig
  def self.union(*_); end
end

class RegexpError
  extend ::T::Sig
end

module RequestStore
  VERSION = ::T.let(nil, ::T.untyped)
end

class RequestStore::Middleware
  def call(env); end

  def initialize(app); end
end

class RequestStore::Middleware
end

class RequestStore::Railtie
end

class RequestStore::Railtie
end

module RequestStore
  extend ::T::Sig
  def self.[](key); end

  def self.[]=(key, value); end

  def self.active?(); end

  def self.begin!(); end

  def self.clear!(); end

  def self.delete(key, &block); end

  def self.end!(); end

  def self.exist?(key); end

  def self.fetch(key); end

  def self.read(key); end

  def self.store(); end

  def self.write(key, value); end
end

module RequestValidator
  extend ::T::Sig
end

class Resolv::DNS
  def extract_resources(msg, name, typeclass); end

  def fetch_resource(name, typeclass); end

  def lazy_initialize(); end

  def make_tcp_requester(host, port); end

  def make_udp_requester(); end
  RequestID = ::T.let(nil, ::T.untyped)
  RequestIDMutex = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config
  def generate_candidates(name); end

  def generate_timeouts(); end

  def initialize(config_info=T.unsafe(nil)); end

  def lazy_initialize(); end

  def nameserver_port(); end

  def resolv(name); end

  def single?(); end

  def timeouts=(values); end
  InitialTimeout = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::NXDomain
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config::OtherResolvError
end

class Resolv::DNS::Config
  def self.default_config_hash(filename=T.unsafe(nil)); end

  def self.parse_resolv_conf(filename); end
end

module Resolv::DNS::Label
end

class Resolv::DNS::Label::Str
  def ==(other); end

  def downcase(); end

  def eql?(other); end

  def initialize(string); end

  def string(); end
end

class Resolv::DNS::Label::Str
end

module Resolv::DNS::Label
  extend ::T::Sig
  def self.split(arg); end
end

class Resolv::DNS::Message
  def ==(other); end

  def aa(); end

  def aa=(aa); end

  def add_additional(name, ttl, data); end

  def add_answer(name, ttl, data); end

  def add_authority(name, ttl, data); end

  def add_question(name, typeclass); end

  def additional(); end

  def answer(); end

  def authority(); end

  def each_additional(); end

  def each_answer(); end

  def each_authority(); end

  def each_question(); end

  def each_resource(); end

  def encode(); end

  def id(); end

  def id=(id); end

  def initialize(id=T.unsafe(nil)); end

  def opcode(); end

  def opcode=(opcode); end

  def qr(); end

  def qr=(qr); end

  def question(); end

  def ra(); end

  def ra=(ra); end

  def rcode(); end

  def rcode=(rcode); end

  def rd(); end

  def rd=(rd); end

  def tc(); end

  def tc=(tc); end
end

class Resolv::DNS::Message::MessageDecoder
  def get_bytes(len=T.unsafe(nil)); end

  def get_label(); end

  def get_labels(); end

  def get_length16(); end

  def get_name(); end

  def get_question(); end

  def get_rr(); end

  def get_string(); end

  def get_string_list(); end

  def get_unpack(template); end

  def initialize(data); end
end

class Resolv::DNS::Message::MessageDecoder
end

class Resolv::DNS::Message::MessageEncoder
  def put_bytes(d); end

  def put_label(d); end

  def put_labels(d); end

  def put_length16(); end

  def put_name(d); end

  def put_pack(template, *d); end

  def put_string(d); end

  def put_string_list(ds); end
end

class Resolv::DNS::Message::MessageEncoder
end

class Resolv::DNS::Message
  def self.decode(m); end
end

class Resolv::DNS::Name
  def ==(other); end

  def [](i); end

  def eql?(other); end

  def length(); end

  def to_a(); end
end

module Resolv::DNS::OpCode
  IQuery = ::T.let(nil, ::T.untyped)
  Notify = ::T.let(nil, ::T.untyped)
  Query = ::T.let(nil, ::T.untyped)
  Status = ::T.let(nil, ::T.untyped)
  Update = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::OpCode
  extend ::T::Sig
end

class Resolv::DNS::Query
  def encode_rdata(msg); end
end

class Resolv::DNS::Query
  def self.decode_rdata(msg); end
end

module Resolv::DNS::RCode
  BADALG = ::T.let(nil, ::T.untyped)
  BADKEY = ::T.let(nil, ::T.untyped)
  BADMODE = ::T.let(nil, ::T.untyped)
  BADNAME = ::T.let(nil, ::T.untyped)
  BADSIG = ::T.let(nil, ::T.untyped)
  BADTIME = ::T.let(nil, ::T.untyped)
  BADVERS = ::T.let(nil, ::T.untyped)
  FormErr = ::T.let(nil, ::T.untyped)
  NXDomain = ::T.let(nil, ::T.untyped)
  NXRRSet = ::T.let(nil, ::T.untyped)
  NoError = ::T.let(nil, ::T.untyped)
  NotAuth = ::T.let(nil, ::T.untyped)
  NotImp = ::T.let(nil, ::T.untyped)
  NotZone = ::T.let(nil, ::T.untyped)
  Refused = ::T.let(nil, ::T.untyped)
  ServFail = ::T.let(nil, ::T.untyped)
  YXDomain = ::T.let(nil, ::T.untyped)
  YXRRSet = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::RCode
  extend ::T::Sig
end

class Resolv::DNS::Requester
  def close(); end

  def request(sender, tout); end

  def sender_for(addr, msg); end
end

class Resolv::DNS::Requester::ConnectedUDP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::ConnectedUDP::Sender
end

class Resolv::DNS::Requester::ConnectedUDP
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::MDNSOneShot
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::RequestError
end

class Resolv::DNS::Requester::Sender
  def initialize(msg, data, sock); end
end

class Resolv::DNS::Requester::Sender
end

class Resolv::DNS::Requester::TCP
  def initialize(host, port=T.unsafe(nil)); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host=T.unsafe(nil), port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::TCP::Sender
  def data(); end

  def send(); end
end

class Resolv::DNS::Requester::TCP::Sender
end

class Resolv::DNS::Requester::TCP
end

class Resolv::DNS::Requester::UnconnectedUDP
  def initialize(*nameserver_port); end

  def recv_reply(readable_socks); end

  def sender(msg, data, host, port=T.unsafe(nil)); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
  def data(); end

  def initialize(msg, data, sock, host, port); end

  def send(); end
end

class Resolv::DNS::Requester::UnconnectedUDP::Sender
end

class Resolv::DNS::Requester::UnconnectedUDP
end

class Resolv::DNS::Requester
end

class Resolv::DNS::Resource
  def ==(other); end

  def eql?(other); end
  ClassHash = ::T.let(nil, ::T.untyped)
  ClassInsensitiveTypes = ::T.let(nil, ::T.untyped)
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::ANY
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::CNAME
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::Generic
  def self.create(type_value, class_value); end
end

class Resolv::DNS::Resource::HINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  ClassValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::A
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::AAAA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::ANY
end

class Resolv::DNS::Resource::IN::CNAME
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::CNAME
end

class Resolv::DNS::Resource::IN::HINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::HINFO
end

class Resolv::DNS::Resource::IN::LOC
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::LOC
end

class Resolv::DNS::Resource::IN::MINFO
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MINFO
end

class Resolv::DNS::Resource::IN::MX
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::MX
end

class Resolv::DNS::Resource::IN::NS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::NS
end

class Resolv::DNS::Resource::IN::PTR
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::PTR
end

class Resolv::DNS::Resource::IN::SOA
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::SOA
end

class Resolv::DNS::Resource::IN::SRV
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::IN::TXT
end

class Resolv::DNS::Resource::IN::WKS
  ClassValue = ::T.let(nil, ::T.untyped)
  TypeValue = ::T.let(nil, ::T.untyped)
end

module Resolv::DNS::Resource::IN
  extend ::T::Sig
end

class Resolv::DNS::Resource::LOC
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MINFO
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::MX
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::NS
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::PTR
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::SOA
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource::TXT
  TypeValue = ::T.let(nil, ::T.untyped)
end

class Resolv::DNS::Resource
  def self.get_class(type_value, class_value); end
end

class Resolv::DNS
  def self.allocate_request_id(host, port); end

  def self.bind_random_port(udpsock, bind_host=T.unsafe(nil)); end

  def self.free_request_id(host, port, id); end

  def self.random(arg); end

  def self.rangerand(range); end
end

class Resolv::Hosts
  def lazy_initialize(); end
end

class Resolv::IPv4
  def ==(other); end

  def eql?(other); end
end

class Resolv::IPv6
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Alt
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Coord
  def ==(other); end

  def eql?(other); end
end

class Resolv::LOC::Size
  def ==(other); end

  def eql?(other); end
end

module Resolv::LOC
  extend ::T::Sig
end

module Responders
end

module Responders::CollectionResponder
  def navigation_location(); end
end

module Responders::CollectionResponder
  extend ::T::Sig
end

module Responders::ControllerMethod
  def responders(*responders); end
end

module Responders::ControllerMethod
  extend ::T::Sig
end

module Responders::FlashResponder
  def controller_interpolation_options(); end

  def flash_defaults_by_namespace(status); end

  def initialize(controller, resources, options=T.unsafe(nil)); end

  def mount_i18n_options(status); end

  def resource_name(); end

  def set_flash(key, value); end

  def set_flash_message!(); end

  def set_flash_message?(); end

  def set_flash_now?(); end

  def to_html(); end

  def to_js(); end
end

module Responders::FlashResponder
  extend ::T::Sig
  def self.flash_keys(); end

  def self.flash_keys=(flash_keys); end

  def self.helper(); end

  def self.helper=(helper); end

  def self.namespace_lookup(); end

  def self.namespace_lookup=(namespace_lookup); end
end

module Responders::HttpCacheResponder
  def do_http_cache!(); end

  def do_http_cache?(); end

  def initialize(controller, resources, options=T.unsafe(nil)); end

  def persisted?(); end

  def to_format(); end
end

module Responders::HttpCacheResponder
  extend ::T::Sig
end

module Responders::LocationResponder
end

module Responders::LocationResponder
  extend ::T::Sig
  def self.included(_base); end
end

class Responders::Railtie
end

class Responders::Railtie
end

module Responders
  extend ::T::Sig
end

module RuboCop
end

module RuboCop::AST
end

class RuboCop::AST::AndNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::AndNode
end

class RuboCop::AST::ArgsNode
  include ::RuboCop::AST::CollectionNode
  def empty_and_without_delimiters?(); end
end

class RuboCop::AST::ArgsNode
end

class RuboCop::AST::ArrayNode
  def bracketed?(); end

  def percent_literal?(type=T.unsafe(nil)); end

  def square_brackets?(); end

  def values(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::ArrayNode
end

module RuboCop::AST::BasicLiteralNode
  def value(); end
end

module RuboCop::AST::BasicLiteralNode
  extend ::T::Sig
end

module RuboCop::AST::BinaryOperatorNode
  def conditions(); end

  def lhs(); end

  def rhs(); end
end

module RuboCop::AST::BinaryOperatorNode
  extend ::T::Sig
end

class RuboCop::AST::BlockNode
  def arguments(); end

  def arguments?(); end

  def body(); end

  def braces?(); end

  def closing_delimiter(); end

  def delimiters(); end

  def keywords?(); end

  def lambda?(); end

  def method_name(); end

  def opening_delimiter(); end

  def send_node(); end

  def void_context?(); end
  VOID_CONTEXT_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::BlockNode
end

class RuboCop::AST::Builder
  NODE_MAP = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Builder
end

class RuboCop::AST::CaseNode
  include ::RuboCop::AST::ConditionalNode
  def each_when(); end

  def else?(); end

  def else_branch(); end

  def keyword(); end

  def when_branches(); end
end

class RuboCop::AST::CaseNode
end

module RuboCop::AST::CollectionNode
  def &(*args, &block); end

  def *(*args, &block); end

  def +(*args, &block); end

  def -(*args, &block); end

  def <<(*args, &block); end

  def [](*args, &block); end

  def []=(*args, &block); end

  def all?(*args, &block); end

  def any?(*args, &block); end

  def append(*args, &block); end

  def assoc(*args, &block); end

  def at(*args, &block); end

  def bsearch(*args, &block); end

  def bsearch_index(*args, &block); end

  def butfirst(*args, &block); end

  def chunk(*args, &block); end

  def chunk_while(*args, &block); end

  def clear(*args, &block); end

  def collect(*args, &block); end

  def collect!(*args, &block); end

  def collect_concat(*args, &block); end

  def combination(*args, &block); end

  def compact(*args, &block); end

  def compact!(*args, &block); end

  def concat(*args, &block); end

  def count(*args, &block); end

  def cycle(*args, &block); end

  def delete(*args, &block); end

  def delete_at(*args, &block); end

  def delete_if(*args, &block); end

  def detect(*args, &block); end

  def dig(*args, &block); end

  def drop(*args, &block); end

  def drop_last(*args, &block); end

  def drop_while(*args, &block); end

  def each(*args, &block); end

  def each_cons(*args, &block); end

  def each_entry(*args, &block); end

  def each_index(*args, &block); end

  def each_slice(*args, &block); end

  def each_with_index(*args, &block); end

  def each_with_object(*args, &block); end

  def empty?(*args, &block); end

  def entries(*args, &block); end

  def exclude?(*args, &block); end

  def extract_options!(*args, &block); end

  def fetch(*args, &block); end

  def fifth(*args, &block); end

  def fill(*args, &block); end

  def find(*args, &block); end

  def find_all(*args, &block); end

  def find_index(*args, &block); end

  def first(*args, &block); end

  def flat_map(*args, &block); end

  def flatten(*args, &block); end

  def flatten!(*args, &block); end

  def forty_two(*args, &block); end

  def fourth(*args, &block); end

  def from(*args, &block); end

  def grep(*args, &block); end

  def grep_v(*args, &block); end

  def group_by(*args, &block); end

  def in_groups(*args, &block); end

  def in_groups_of(*args, &block); end

  def include?(*args, &block); end

  def index(*args, &block); end

  def index_by(*args, &block); end

  def inject(*args, &block); end

  def inquiry(*args, &block); end

  def insert(*args, &block); end

  def join(*args, &block); end

  def keep_if(*args, &block); end

  def last(*args, &block); end

  def lazy(*args, &block); end

  def length(*args, &block); end

  def many?(*args, &block); end

  def map(*args, &block); end

  def map!(*args, &block); end

  def max(*args, &block); end

  def max_by(*args, &block); end

  def member?(*args, &block); end

  def min(*args, &block); end

  def min_by(*args, &block); end

  def minmax(*args, &block); end

  def minmax_by(*args, &block); end

  def none?(*args, &block); end

  def one?(*args, &block); end

  def pack(*args, &block); end

  def partition(*args, &block); end

  def permutation(*args, &block); end

  def pluck(*args, &block); end

  def pop(*args, &block); end

  def prepend(*args, &block); end

  def product(*args, &block); end

  def push(*args, &block); end

  def rassoc(*args, &block); end

  def reduce(*args, &block); end

  def reject(*args, &block); end

  def reject!(*args, &block); end

  def repeated_combination(*args, &block); end

  def repeated_permutation(*args, &block); end

  def replace(*args, &block); end

  def reverse(*args, &block); end

  def reverse!(*args, &block); end

  def reverse_each(*args, &block); end

  def rindex(*args, &block); end

  def rotate(*args, &block); end

  def rotate!(*args, &block); end

  def sample(*args, &block); end

  def second(*args, &block); end

  def second_to_last(*args, &block); end

  def select(*args, &block); end

  def select!(*args, &block); end

  def shelljoin(*args, &block); end

  def shift(*args, &block); end

  def shuffle(*args, &block); end

  def shuffle!(*args, &block); end

  def size(*args, &block); end

  def slice(*args, &block); end

  def slice!(*args, &block); end

  def slice_after(*args, &block); end

  def slice_before(*args, &block); end

  def slice_when(*args, &block); end

  def sort(*args, &block); end

  def sort!(*args, &block); end

  def sort_by(*args, &block); end

  def sort_by!(*args, &block); end

  def split(*args, &block); end

  def sum(*args, &block); end

  def take(*args, &block); end

  def take_while(*args, &block); end

  def third(*args, &block); end

  def third_to_last(*args, &block); end

  def to(*args, &block); end

  def to_ary(*args, &block); end

  def to_default_s(*args, &block); end

  def to_formatted_s(*args, &block); end

  def to_h(*args, &block); end

  def to_msgpack(*args, &block); end

  def to_sentence(*args, &block); end

  def to_set(*args, &block); end

  def to_xml(*args, &block); end

  def transpose(*args, &block); end

  def uniq(*args, &block); end

  def uniq!(*args, &block); end

  def unshift(*args, &block); end

  def values_at(*args, &block); end

  def without(*args, &block); end

  def zip(*args, &block); end

  def |(*args, &block); end
  ARRAY_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::CollectionNode
  extend ::Forwardable
  extend ::T::Sig
end

module RuboCop::AST::ConditionalNode
  def body(); end

  def condition(); end

  def multiline_condition?(); end

  def single_line_condition?(); end
end

module RuboCop::AST::ConditionalNode
  extend ::T::Sig
end

class RuboCop::AST::DefNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def arguments(); end

  def body(); end

  def method_name(); end

  def receiver(); end

  def void_context?(); end
end

class RuboCop::AST::DefNode
end

class RuboCop::AST::DefinedNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::DefinedNode
end

class RuboCop::AST::EnsureNode
  def body(); end
end

class RuboCop::AST::EnsureNode
end

class RuboCop::AST::ForNode
  def body(); end

  def collection(); end

  def do?(); end

  def keyword(); end

  def variable(); end

  def void_context?(); end
end

class RuboCop::AST::ForNode
end

module RuboCop::AST::HashElementNode
  def delimiter_delta(other); end

  def key(); end

  def key_delta(other, alignment=T.unsafe(nil)); end

  def same_line?(other); end

  def value(); end

  def value_delta(other); end
end

module RuboCop::AST::HashElementNode
  extend ::T::Sig
end

class RuboCop::AST::HashNode
  def braces?(); end

  def each_key(); end

  def each_pair(); end

  def each_value(); end

  def empty?(); end

  def keys(); end

  def mixed_delimiters?(); end

  def pairs(); end

  def pairs_on_same_line?(); end

  def values(); end
end

class RuboCop::AST::HashNode
end

class RuboCop::AST::IfNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def else?(); end

  def else_branch(); end

  def elsif?(); end

  def elsif_conditional?(); end

  def if?(); end

  def if_branch(); end

  def inverse_keyword(); end

  def keyword(); end

  def nested_conditional?(); end

  def ternary?(); end

  def unless?(); end
end

class RuboCop::AST::IfNode
end

class RuboCop::AST::KeywordSplatNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def hash_rocket?(); end

  def operator(); end
  DOUBLE_SPLAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::KeywordSplatNode
end

module RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
  def access_modifier?(); end

  def adjacent_def_modifier?(node=T.unsafe(nil)); end

  def arguments(); end

  def arithmetic_operation?(); end

  def assignment?(); end

  def bare_access_modifier?(); end

  def bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def block_literal?(); end

  def block_node(); end

  def command?(name); end

  def const_receiver?(); end

  def def_modifier?(); end

  def dot?(); end

  def double_colon?(); end

  def implicit_call?(); end

  def lambda?(); end

  def lambda_literal?(); end

  def macro?(); end

  def macro_scope?(node=T.unsafe(nil)); end

  def method_name(); end

  def non_bare_access_modifier?(); end

  def non_bare_access_modifier_declaration?(node=T.unsafe(nil)); end

  def receiver(); end

  def self_receiver?(); end

  def setter_method?(); end
  ARITHMETIC_OPERATORS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodDispatchNode
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

module RuboCop::AST::MethodIdentifierPredicates
  def assignment_method?(); end

  def bang_method?(); end

  def camel_case_method?(); end

  def comparison_method?(); end

  def const_receiver?(); end

  def enumerator_method?(); end

  def method?(name); end

  def negation_method?(); end

  def operator_method?(); end

  def predicate_method?(); end

  def prefix_bang?(); end

  def prefix_not?(); end

  def self_receiver?(); end
  ENUMERATOR_METHODS = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::MethodIdentifierPredicates
  extend ::T::Sig
end

module RuboCop::AST::ModifierNode
  def modifier_form?(); end
end

module RuboCop::AST::ModifierNode
  extend ::T::Sig
end

class RuboCop::AST::Node
  include ::RuboCop::AST::Sexp
  def __ENCODING___type?(); end

  def __FILE___type?(); end

  def __LINE___type?(); end

  def alias_type?(); end

  def ancestors(); end

  def and_asgn_type?(); end

  def and_type?(); end

  def arg_expr_type?(); end

  def arg_type?(); end

  def args_type?(); end

  def argument?(); end

  def array_type?(); end

  def asgn_rhs(node=T.unsafe(nil)); end

  def assignment?(node=T.unsafe(nil)); end

  def assignment_or_similar?(node=T.unsafe(nil)); end

  def back_ref_type?(); end

  def basic_literal?(); end

  def begin_type?(); end

  def binary_operation?(); end

  def block_pass_type?(); end

  def block_type?(); end

  def blockarg_type?(); end

  def break_type?(); end

  def case_type?(); end

  def casgn_type?(); end

  def cbase_type?(); end

  def chained?(); end

  def child_nodes(); end

  def class_constructor?(node=T.unsafe(nil)); end

  def class_type?(); end

  def complete!(); end

  def complete?(); end

  def complex_type?(); end

  def const_name(); end

  def const_type?(); end

  def csend_type?(); end

  def cvar_type?(); end

  def cvasgn_type?(); end

  def def_type?(); end

  def defined_module(); end

  def defined_module_name(); end

  def defined_type?(); end

  def defs_type?(); end

  def descendants(); end

  def dstr_type?(); end

  def dsym_type?(); end

  def each_ancestor(*types, &block); end

  def each_child_node(*types); end

  def each_descendant(*types, &block); end

  def each_node(*types, &block); end

  def eflipflop_type?(); end

  def empty_source?(); end

  def ensure_type?(); end

  def equals_asgn?(node=T.unsafe(nil)); end

  def erange_type?(); end

  def false_type?(); end

  def falsey_literal?(); end

  def first_line(); end

  def float_type?(); end

  def for_type?(); end

  def guard_clause?(node=T.unsafe(nil)); end

  def gvar_type?(); end

  def gvasgn_type?(); end

  def hash_type?(); end

  def if_type?(); end

  def iflipflop_type?(); end

  def immutable_literal?(); end

  def int_type?(); end

  def irange_type?(); end

  def ivar_type?(); end

  def ivasgn_type?(); end

  def keyword?(); end

  def kwarg_type?(); end

  def kwbegin_type?(); end

  def kwoptarg_type?(); end

  def kwrestarg_type?(); end

  def kwsplat_type?(); end

  def lambda?(node=T.unsafe(nil)); end

  def lambda_or_proc?(node=T.unsafe(nil)); end

  def last_line(); end

  def line_count(); end

  def literal?(); end

  def lvar_type?(); end

  def lvasgn_type?(); end

  def masgn_type?(); end

  def match_current_line_type?(); end

  def match_with_lvasgn_type?(); end

  def mlhs_type?(); end

  def module_definition?(node=T.unsafe(nil)); end

  def module_type?(); end

  def multiline?(); end

  def mutable_literal?(); end

  def new_class_or_module_block?(node=T.unsafe(nil)); end

  def next_type?(); end

  def nil_type?(); end

  def node_parts(); end

  def nonempty_line_count(); end

  def not_type?(); end

  def nth_ref_type?(); end

  def numeric_type?(); end

  def op_asgn_type?(); end

  def operator_keyword?(); end

  def optarg_type?(); end

  def or_asgn_type?(); end

  def or_type?(); end

  def pair_type?(); end

  def parent(); end

  def parent=(node); end

  def parent_module_name(); end

  def parenthesized_call?(); end

  def postexe_type?(); end

  def preexe_type?(); end

  def proc?(node=T.unsafe(nil)); end

  def pure?(); end

  def rational_type?(); end

  def receiver(node=T.unsafe(nil)); end

  def recursive_basic_literal?(); end

  def recursive_literal?(); end

  def redo_type?(); end

  def reference?(); end

  def regexp_type?(); end

  def regopt_type?(); end

  def resbody_type?(); end

  def rescue_type?(); end

  def restarg_type?(); end

  def retry_type?(); end

  def return_type?(); end

  def sclass_type?(); end

  def self_type?(); end

  def send_type?(); end

  def shadowarg_type?(); end

  def shorthand_asgn?(node=T.unsafe(nil)); end

  def sibling_index(); end

  def single_line?(); end

  def source(); end

  def source_length(); end

  def source_range(); end

  def special_keyword?(); end

  def splat_type?(); end

  def str_content(node=T.unsafe(nil)); end

  def str_type?(); end

  def super_type?(); end

  def sym_type?(); end

  def true_type?(); end

  def truthy_literal?(); end

  def unary_operation?(); end

  def undef_type?(); end

  def until_post_type?(); end

  def until_type?(); end

  def value_used?(); end

  def variable?(); end

  def visit_descendants(types, &block); end

  def when_type?(); end

  def while_post_type?(); end

  def while_type?(); end

  def xstr_type?(); end

  def yield_type?(); end

  def zsuper_type?(); end
  BASIC_LITERALS = ::T.let(nil, ::T.untyped)
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  COMPOSITE_LITERALS = ::T.let(nil, ::T.untyped)
  FALSEY_LITERALS = ::T.let(nil, ::T.untyped)
  IMMUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  LITERALS = ::T.let(nil, ::T.untyped)
  MUTABLE_LITERALS = ::T.let(nil, ::T.untyped)
  OPERATOR_KEYWORDS = ::T.let(nil, ::T.untyped)
  REFERENCES = ::T.let(nil, ::T.untyped)
  SPECIAL_KEYWORDS = ::T.let(nil, ::T.untyped)
  TRUTHY_LITERALS = ::T.let(nil, ::T.untyped)
  VARIABLES = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::Node
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::AST::OrNode
  include ::RuboCop::AST::BinaryOperatorNode
  include ::RuboCop::AST::PredicateOperatorNode
  def alternate_operator(); end

  def inverse_operator(); end
end

class RuboCop::AST::OrNode
end

class RuboCop::AST::PairNode
  include ::RuboCop::AST::HashElementNode
  def colon?(); end

  def delimiter(with_spacing=T.unsafe(nil)); end

  def hash_rocket?(); end

  def inverse_delimiter(with_spacing=T.unsafe(nil)); end
  COLON = ::T.let(nil, ::T.untyped)
  HASH_ROCKET = ::T.let(nil, ::T.untyped)
  SPACED_COLON = ::T.let(nil, ::T.untyped)
  SPACED_HASH_ROCKET = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::PairNode
end

module RuboCop::AST::ParameterizedNode
  def arguments?(); end

  def block_argument?(); end

  def first_argument(); end

  def last_argument(); end

  def parenthesized?(); end

  def rest_argument?(); end

  def splat_argument?(); end
end

module RuboCop::AST::ParameterizedNode
  extend ::T::Sig
end

module RuboCop::AST::PredicateOperatorNode
  def logical_operator?(); end

  def operator(); end

  def semantic_operator?(); end
  LOGICAL_AND = ::T.let(nil, ::T.untyped)
  LOGICAL_OR = ::T.let(nil, ::T.untyped)
  SEMANTIC_AND = ::T.let(nil, ::T.untyped)
  SEMANTIC_OR = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::PredicateOperatorNode
  extend ::T::Sig
end

class RuboCop::AST::RegexpNode
  def content(); end

  def regopt(); end

  def to_regexp(); end
  OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::AST::RegexpNode
end

class RuboCop::AST::ResbodyNode
  def body(); end
end

class RuboCop::AST::ResbodyNode
end

class RuboCop::AST::SendNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SendNode
end

module RuboCop::AST::Sexp
  def s(type, *children); end
end

module RuboCop::AST::Sexp
  extend ::T::Sig
end

class RuboCop::AST::StrNode
  include ::RuboCop::AST::BasicLiteralNode
  def heredoc?(); end
end

class RuboCop::AST::StrNode
end

class RuboCop::AST::SuperNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::SuperNode
end

class RuboCop::AST::SymbolNode
  include ::RuboCop::AST::BasicLiteralNode
end

class RuboCop::AST::SymbolNode
end

module RuboCop::AST::Traversal
  def on_alias(node); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_arg(node); end

  def on_arg_expr(node); end

  def on_args(node); end

  def on_array(node); end

  def on_back_ref(node); end

  def on_begin(node); end

  def on_block(node); end

  def on_block_pass(node); end

  def on_blockarg(node); end

  def on_break(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cbase(node); end

  def on_class(node); end

  def on_complex(node); end

  def on_const(node); end

  def on_csend(node); end

  def on_cvar(node); end

  def on_cvasgn(node); end

  def on_def(node); end

  def on_defined?(node); end

  def on_defs(node); end

  def on_dstr(node); end

  def on_dsym(node); end

  def on_eflipflop(node); end

  def on_ensure(node); end

  def on_erange(node); end

  def on_false(node); end

  def on_float(node); end

  def on_for(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def on_hash(node); end

  def on_if(node); end

  def on_iflipflop(node); end

  def on_int(node); end

  def on_irange(node); end

  def on_ivar(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwbegin(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_kwsplat(node); end

  def on_lambda(node); end

  def on_lvar(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_match_current_line(node); end

  def on_match_with_lvasgn(node); end

  def on_mlhs(node); end

  def on_module(node); end

  def on_next(node); end

  def on_nil(node); end

  def on_not(node); end

  def on_nth_ref(node); end

  def on_op_asgn(node); end

  def on_optarg(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_rational(node); end

  def on_redo(node); end

  def on_regexp(node); end

  def on_regopt(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_restarg(node); end

  def on_retry(node); end

  def on_return(node); end

  def on_sclass(node); end

  def on_self(node); end

  def on_send(node); end

  def on_shadowarg(node); end

  def on_splat(node); end

  def on_str(node); end

  def on_super(node); end

  def on_sym(node); end

  def on_true(node); end

  def on_undef(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_when(node); end

  def on_while(node); end

  def on_while_post(node); end

  def on_xstr(node); end

  def on_yield(node); end

  def on_zsuper(node); end

  def walk(node); end
  MANY_CHILD_NODES = ::T.let(nil, ::T.untyped)
  NO_CHILD_NODES = ::T.let(nil, ::T.untyped)
  ONE_CHILD_NODE = ::T.let(nil, ::T.untyped)
  SECOND_CHILD_ONLY = ::T.let(nil, ::T.untyped)
end

module RuboCop::AST::Traversal
  extend ::T::Sig
end

class RuboCop::AST::UntilNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::UntilNode
end

class RuboCop::AST::WhenNode
  def body(); end

  def branch_index(); end

  def conditions(); end

  def each_condition(); end

  def then?(); end
end

class RuboCop::AST::WhenNode
end

class RuboCop::AST::WhileNode
  include ::RuboCop::AST::ConditionalNode
  include ::RuboCop::AST::ModifierNode
  def do?(); end

  def inverse_keyword(); end

  def keyword(); end
end

class RuboCop::AST::WhileNode
end

class RuboCop::AST::YieldNode
  include ::RuboCop::AST::ParameterizedNode
  include ::RuboCop::AST::MethodDispatchNode
  include ::RuboCop::AST::MethodIdentifierPredicates
end

class RuboCop::AST::YieldNode
end

module RuboCop::AST
  extend ::T::Sig
end

class RuboCop::CLI
  include ::RuboCop::Formatter::TextUtil
  def config_store(); end

  def options(); end

  def run(args=T.unsafe(nil)); end

  def trap_interrupt(runner); end
  SKIPPED_PHASE_1 = ::T.let(nil, ::T.untyped)
  STATUS_ERROR = ::T.let(nil, ::T.untyped)
  STATUS_OFFENSES = ::T.let(nil, ::T.untyped)
  STATUS_SUCCESS = ::T.let(nil, ::T.untyped)
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI::Finished
end

class RuboCop::CLI
end

class RuboCop::CachedData
  def from_json(text); end

  def initialize(filename); end

  def to_json(offenses); end
end

class RuboCop::CachedData
end

class RuboCop::CommentConfig
  def cop_disabled_line_ranges(); end

  def cop_enabled_at_line?(cop, line_number); end

  def extra_enabled_comments(); end

  def initialize(processed_source); end

  def processed_source(); end
  COMMENT_DIRECTIVE_REGEXP = ::T.let(nil, ::T.untyped)
  COPS_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAMES_PATTERN = ::T.let(nil, ::T.untyped)
  COP_NAME_PATTERN = ::T.let(nil, ::T.untyped)
  UNNEEDED_DISABLE = ::T.let(nil, ::T.untyped)
end

class RuboCop::CommentConfig::CopAnalysis
  def line_ranges(); end

  def line_ranges=(_); end

  def start_line_number(); end

  def start_line_number=(_); end
end

class RuboCop::CommentConfig::CopAnalysis
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::CommentConfig
end

class RuboCop::Config
  include ::RuboCop::PathUtil
  include ::RuboCop::FileFinder
  def [](key); end

  def []=(key, value); end

  def add_excludes_from_higher_level(highest_config); end

  def allowed_camel_case_file?(file); end

  def base_dir_for_path_parameters(); end

  def check(); end

  def delete(key); end

  def deprecation_check(); end

  def each(&block); end

  def each_key(&block); end

  def file_to_exclude?(file); end

  def file_to_include?(file); end

  def for_all_cops(); end

  def for_cop(cop); end

  def initialize(hash=T.unsafe(nil), loaded_path=T.unsafe(nil)); end

  def key?(key); end

  def keys(); end

  def loaded_path(); end

  def make_excludes_absolute(); end

  def map(&block); end

  def merge(other_hash); end

  def path_relative_to_config(path); end

  def patterns_to_exclude(); end

  def patterns_to_include(); end

  def possibly_include_hidden?(); end

  def signature(); end

  def target_rails_version(); end

  def target_ruby_version(); end

  def to_h(); end

  def to_hash(); end

  def validate(); end
  COMMON_PARAMS = ::T.let(nil, ::T.untyped)
  DEFAULT_RAILS_VERSION = ::T.let(nil, ::T.untyped)
  DEFAULT_RUBY_VERSION = ::T.let(nil, ::T.untyped)
  KNOWN_RUBIES = ::T.let(nil, ::T.untyped)
  OBSOLETE_COPS = ::T.let(nil, ::T.untyped)
  OBSOLETE_PARAMETERS = ::T.let(nil, ::T.untyped)
  OBSOLETE_RUBIES = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_FILENAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Config
  def self.create(hash, path); end
end

class RuboCop::ConfigLoader
  AUTO_GENERATED_FILE = ::T.let(nil, ::T.untyped)
  DEFAULT_FILE = ::T.let(nil, ::T.untyped)
  DOTFILE = ::T.let(nil, ::T.untyped)
  RUBOCOP_HOME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ConfigLoader
  extend ::RuboCop::FileFinder
  def self.add_excludes_from_files(config, config_file); end

  def self.add_inheritance_from_auto_generated_file(); end

  def self.add_missing_namespaces(path, hash); end

  def self.auto_gen_config(); end

  def self.auto_gen_config=(auto_gen_config); end

  def self.auto_gen_config?(); end

  def self.clear_options(); end

  def self.configuration_file_for(target_dir); end

  def self.configuration_from_file(config_file); end

  def self.debug(); end

  def self.debug=(debug); end

  def self.debug?(); end

  def self.default_configuration(); end

  def self.default_configuration=(default_configuration); end

  def self.ignore_parent_exclusion(); end

  def self.ignore_parent_exclusion=(ignore_parent_exclusion); end

  def self.ignore_parent_exclusion?(); end

  def self.load_file(file); end

  def self.merge(base_hash, derived_hash); end

  def self.merge_with_default(config, config_file); end

  def self.target_ruby_version_to_f!(hash); end
end

class RuboCop::ConfigLoaderResolver
  def merge(base_hash, derived_hash, **opts); end

  def merge_with_default(config, config_file); end

  def resolve_inheritance(path, hash, file, debug); end

  def resolve_inheritance_from_gems(hash, gems); end

  def resolve_requires(path, hash); end
end

class RuboCop::ConfigLoaderResolver
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigNotFoundError
end

class RuboCop::ConfigStore
  def for(file_or_dir); end

  def force_default_config!(); end

  def options_config=(options_config); end
end

class RuboCop::ConfigStore
end

module RuboCop::Cop
end

module RuboCop::Cop::Alignment
  SPACE = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Alignment
  extend ::T::Sig
end

class RuboCop::Cop::AlignmentCorrector
end

class RuboCop::Cop::AlignmentCorrector
  extend ::RuboCop::Cop::RangeHelp
  extend ::RuboCop::Cop::Alignment
  def self.align_end(processed_source, node, align_to); end

  def self.correct(processed_source, node, column_delta); end

  def self.processed_source(); end
end

class RuboCop::Cop::AmbiguousCopName
  def initialize(name, origin, badges); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::AmbiguousCopName
end

module RuboCop::Cop::ArrayHashIndentation
end

module RuboCop::Cop::ArrayHashIndentation
  extend ::T::Sig
end

module RuboCop::Cop::ArrayMinSize
end

module RuboCop::Cop::ArrayMinSize
  extend ::T::Sig
end

module RuboCop::Cop::ArraySyntax
end

module RuboCop::Cop::ArraySyntax
  extend ::T::Sig
end

module RuboCop::Cop::AutocorrectLogic
  def autocorrect?(); end

  def autocorrect_enabled?(); end

  def autocorrect_requested?(); end

  def support_autocorrect?(); end
end

module RuboCop::Cop::AutocorrectLogic
  extend ::T::Sig
end

class RuboCop::Cop::Badge
  def ==(other); end

  def cop_name(); end

  def department(); end

  def eql?(other); end

  def initialize(department, cop_name); end

  def match?(other); end

  def qualified?(); end

  def with_department(department); end
end

class RuboCop::Cop::Badge::InvalidBadge
  def initialize(token); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Badge::InvalidBadge
end

class RuboCop::Cop::Badge
  def self.for(class_name); end

  def self.parse(identifier); end
end

module RuboCop::Cop::Bundler
end

class RuboCop::Cop::Bundler::DuplicatedGem
  include ::RuboCop::Cop::RangeHelp
  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::DuplicatedGem
end

class RuboCop::Cop::Bundler::GemComment
  include ::RuboCop::Cop::DefNode
  def gem_declaration?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::GemComment
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def insecure_protocol_source?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::InsecureProtocolSource
end

class RuboCop::Cop::Bundler::OrderedGems
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def gem_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Bundler::OrderedGems
end

module RuboCop::Cop::Bundler
  extend ::T::Sig
end

module RuboCop::Cop::CheckAssignment
  def on_and_asgn(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
end

module RuboCop::Cop::CheckAssignment
  extend ::T::Sig
  def self.extract_rhs(node); end
end

module RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ClassishLength
  extend ::T::Sig
end

module RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::CodeLength
  extend ::T::Sig
end

class RuboCop::Cop::Commissioner
  include ::RuboCop::AST::Traversal
  def errors(); end

  def initialize(cops, forces=T.unsafe(nil), options=T.unsafe(nil)); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Commissioner::CopError
  def column(); end

  def column=(_); end

  def error(); end

  def error=(_); end

  def line(); end

  def line=(_); end
end

class RuboCop::Cop::Commissioner::CopError
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Commissioner
end

class RuboCop::Cop::ConditionCorrector
end

class RuboCop::Cop::ConditionCorrector
  def self.correct_negative_condition(node); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  def alternative_style(); end

  def alternative_styles(); end

  def ambiguous_style_detected(*possibilities); end

  def conflicting_styles_detected(); end

  def correct_style_detected(); end

  def detected_style(); end

  def detected_style=(style); end

  def no_acceptable_style!(); end

  def no_acceptable_style?(); end

  def opposite_style_detected(); end

  def style(); end

  def style_detected(detected); end

  def style_parameter_name(); end

  def supported_styles(); end

  def unexpected_style_detected(unexpected); end

  def unrecognized_style_detected(); end
end

module RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::T::Sig
end

module RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def check_name(node, name, name_range); end

  def class_emitter_method?(node, name); end

  def report_opposing_styles(node, name); end

  def valid_name?(node, name, given_style=T.unsafe(nil)); end
end

module RuboCop::Cop::ConfigurableFormatting
  extend ::T::Sig
end

module RuboCop::Cop::ConfigurableMax
end

module RuboCop::Cop::ConfigurableMax
  extend ::T::Sig
end

module RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNaming
  extend ::T::Sig
end

module RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  FORMATS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::ConfigurableNumbering
  extend ::T::Sig
end

class RuboCop::Cop::Cop
  include ::RuboCop::AST::Sexp
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  include ::RuboCop::Cop::IgnoredNode
  include ::RuboCop::Cop::AutocorrectLogic
  def add_offense(node, location: T.unsafe(nil), message: T.unsafe(nil), severity: T.unsafe(nil)); end

  def config(); end

  def config_to_allow_offenses(); end

  def config_to_allow_offenses=(hash); end

  def cop_config(); end

  def cop_name(); end

  def correct(node); end

  def corrections(); end

  def duplicate_location?(location); end

  def excluded_file?(file); end

  def find_location(node, loc); end

  def initialize(config=T.unsafe(nil), options=T.unsafe(nil)); end

  def join_force?(_force_class); end

  def message(_node=T.unsafe(nil)); end

  def name(); end

  def offenses(); end

  def parse(source, path=T.unsafe(nil)); end

  def processed_source(); end

  def processed_source=(processed_source); end

  def relevant_file?(file); end

  def target_rails_version(); end

  def target_ruby_version(); end
end

class RuboCop::Cop::Cop
  extend ::RuboCop::AST::Sexp
  extend ::RuboCop::NodePattern::Macros
  def self.all(); end

  def self.autocorrect_incompatible_with(); end

  def self.badge(); end

  def self.cop_name(); end

  def self.department(); end

  def self.inherited(subclass); end

  def self.lint?(); end

  def self.match?(given_names); end

  def self.non_rails(); end

  def self.qualified_cop_name(name, origin); end

  def self.registry(); end
end

class RuboCop::Cop::Corrector
  def corrections(); end

  def diagnostics(); end

  def initialize(source_buffer, corrections=T.unsafe(nil)); end

  def insert_after(range, content); end

  def insert_before(range, content); end

  def remove(range); end

  def remove_leading(range, size); end

  def remove_preceding(range, size); end

  def remove_trailing(range, size); end

  def replace(range, content); end

  def rewrite(); end
end

class RuboCop::Cop::Corrector
end

module RuboCop::Cop::DefNode
  def non_public_modifier?(node=T.unsafe(nil)); end
  NON_PUBLIC_MODIFIERS = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::DefNode
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

module RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def constant_definition?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::DocumentationComment
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

module RuboCop::Cop::Duplication
end

module RuboCop::Cop::Duplication
  extend ::T::Sig
end

class RuboCop::Cop::EmptyLineCorrector
end

class RuboCop::Cop::EmptyLineCorrector
  def self.correct(node); end

  def self.insert_before(node); end
end

module RuboCop::Cop::EmptyParameter
  def empty_arguments?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::EmptyParameter
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

module RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  BYTE_ORDER_MARK = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::EndKeywordAlignment
  extend ::T::Sig
end

module RuboCop::Cop::EnforceSuperclass
  def on_class(node); end

  def on_send(node); end
end

module RuboCop::Cop::EnforceSuperclass
  extend ::T::Sig
  def self.included(base); end
end

module RuboCop::Cop::FirstElementLineBreak
end

module RuboCop::Cop::FirstElementLineBreak
  extend ::T::Sig
end

class RuboCop::Cop::Force
  def cops(); end

  def initialize(cops); end

  def investigate(_processed_source); end

  def name(); end

  def run_hook(method_name, *args); end
end

class RuboCop::Cop::Force
  def self.all(); end

  def self.force_name(); end

  def self.inherited(subclass); end
end

module RuboCop::Cop::FrozenStringLiteral
  FROZEN_STRING_LITERAL = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_ENABLED = ::T.let(nil, ::T.untyped)
  FROZEN_STRING_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::FrozenStringLiteral
  extend ::T::Sig
  def self.frozen_string_literal_comment_exists?(); end
end

module RuboCop::Cop::Gemspec
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
  include ::RuboCop::Cop::RangeHelp
  def assignment_method_declarations(node0); end

  def gem_specification(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::DuplicatedAssignment
end

class RuboCop::Cop::Gemspec::OrderedDependencies
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::OrderedGemNode
  def autocorrect(node); end

  def dependency_declarations(node0); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::OrderedDependencies
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
  def investigate(processed_source); end

  def required_ruby_version(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Gemspec::RequiredRubyVersion
end

module RuboCop::Cop::Gemspec
  extend ::T::Sig
end

class RuboCop::Cop::Generator
  def initialize(name, github_user, output: T.unsafe(nil)); end

  def inject_config(config_file_path: T.unsafe(nil)); end

  def inject_require(root_file_path: T.unsafe(nil)); end

  def todo(); end

  def write_source(); end

  def write_spec(); end
  SOURCE_TEMPLATE = ::T.let(nil, ::T.untyped)
  SPEC_TEMPLATE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
  def initialize(source_path:, root_file_path:, output: T.unsafe(nil)); end

  def inject(); end
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Generator::RequireFileInjector
end

class RuboCop::Cop::Generator
end

module RuboCop::Cop::HashAlignment
end

class RuboCop::Cop::HashAlignment::KeyAlignment
  def checkable_layout?(_node); end

  def deltas(first_pair, current_pair); end

  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignment::KeyAlignment
end

class RuboCop::Cop::HashAlignment::SeparatorAlignment
  include ::RuboCop::Cop::HashAlignment::ValueAlignment
  def deltas_for_first_pair(*_nodes); end
end

class RuboCop::Cop::HashAlignment::SeparatorAlignment
end

class RuboCop::Cop::HashAlignment::TableAlignment
  include ::RuboCop::Cop::HashAlignment::ValueAlignment
  def deltas_for_first_pair(first_pair, node); end
end

class RuboCop::Cop::HashAlignment::TableAlignment
end

module RuboCop::Cop::HashAlignment::ValueAlignment
  def checkable_layout?(node); end

  def deltas(first_pair, current_pair); end
end

module RuboCop::Cop::HashAlignment::ValueAlignment
  extend ::T::Sig
end

module RuboCop::Cop::HashAlignment
  extend ::T::Sig
end

module RuboCop::Cop::Heredoc
  def on_dstr(node); end

  def on_heredoc(_node); end

  def on_str(node); end

  def on_xstr(node); end
  OPENING_DELIMITER = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Heredoc
  extend ::T::Sig
end

module RuboCop::Cop::IgnoredMethods
end

module RuboCop::Cop::IgnoredMethods
  extend ::T::Sig
end

module RuboCop::Cop::IgnoredNode
  def ignore_node(node); end

  def ignored_node?(node); end

  def part_of_ignored_node?(node); end
end

module RuboCop::Cop::IgnoredNode
  extend ::T::Sig
end

module RuboCop::Cop::IgnoredPattern
end

module RuboCop::Cop::IgnoredPattern
  extend ::T::Sig
end

module RuboCop::Cop::IntegerNode
end

module RuboCop::Cop::IntegerNode
  extend ::T::Sig
end

module RuboCop::Cop::Layout
end

class RuboCop::Cop::Layout::AccessModifierIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AccessModifierIndentation
end

class RuboCop::Cop::Layout::AlignArray
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignArray
end

class RuboCop::Cop::Layout::AlignHash
  include ::RuboCop::Cop::HashAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignHash
end

class RuboCop::Cop::Layout::AlignParameters
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  ALIGN_PARAMS_MSG = ::T.let(nil, ::T.untyped)
  FIXED_INDENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::AlignParameters
end

class RuboCop::Cop::Layout::BlockAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def block_end_align_target?(node=T.unsafe(nil), param1); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockAlignment
end

class RuboCop::Cop::Layout::BlockEndNewline
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::BlockEndNewline
end

class RuboCop::Cop::Layout::CaseIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CaseIndentation
end

class RuboCop::Cop::Layout::ClassStructure
  def autocorrect(node); end

  def on_class(class_node); end

  def visibility_block?(node=T.unsafe(nil)); end
  HUMANIZED_NODE_TYPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  VISIBILITY_SCOPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClassStructure
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
  include ::RuboCop::Cop::Heredoc
  def autocorrect(node); end

  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ARG = ::T.let(nil, ::T.untyped)
  SIMPLE_HEREDOC = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingHeredocIndentation
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_begin(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG_ALIGN = ::T.let(nil, ::T.untyped)
  MSG_INDENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ClosingParenthesisIndentation
end

class RuboCop::Cop::Layout::CommentIndentation
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::CommentIndentation
end

class RuboCop::Cop::Layout::ConditionPosition
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ConditionPosition
end

class RuboCop::Cop::Layout::DefEndAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::DefEndAlignment
end

class RuboCop::Cop::Layout::DotPosition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
end

class RuboCop::Cop::Layout::DotPosition
end

class RuboCop::Cop::Layout::ElseAlignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  def autocorrect(node); end

  def on_case(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ElseAlignment
end

class RuboCop::Cop::Layout::EmptyComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyComment
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  END_OF_HEREDOC_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterGuardClause
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(source); end
  BLANK_LINE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineAfterMagicComment
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_defs(nodes); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLineBetweenDefs
end

class RuboCop::Cop::Layout::EmptyLines
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  LINE_OFFSET = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLines
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def on_send(node); end
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE_AND_AFTER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundAccessModifier
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundArguments
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_kwbegin(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBeginBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundBlockBody
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def constant_definition?(node=T.unsafe(nil)); end

  def empty_line_required?(node=T.unsafe(nil)); end
  MSG_DEFERRED = ::T.let(nil, ::T.untyped)
  MSG_EXTRA = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Layout::EmptyLinesAroundBody
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_sclass(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundClassBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundExceptionHandlingKeywords
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundMethodBody
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
  include ::RuboCop::Cop::Layout::EmptyLinesAroundBody
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_module(node); end
  KIND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EmptyLinesAroundModuleBody
end

class RuboCop::Cop::Layout::EndAlignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_class(node); end

  def on_if(node); end

  def on_module(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Layout::EndAlignment
end

class RuboCop::Cop::Layout::EndOfLine
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end

  def offense_message(line); end

  def unimportant_missing_cr?(index, last_line, line); end
  MSG_DETECTED = ::T.let(nil, ::T.untyped)
  MSG_MISSING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::EndOfLine
end

class RuboCop::Cop::Layout::ExtraSpacing
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG_UNALIGNED_ASGN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::ExtraSpacing
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstArrayElementLineBreak
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstHashElementLineBreak
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodArgumentLineBreak
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
  include ::RuboCop::Cop::FirstElementLineBreak
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstMethodParameterLineBreak
end

class RuboCop::Cop::Layout::FirstParameterIndentation
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def eligible_method_call?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::FirstParameterIndentation
end

class RuboCop::Cop::Layout::IndentArray
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ArrayHashIndentation
  def autocorrect(node); end

  def on_array(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentArray
end

class RuboCop::Cop::Layout::IndentAssignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def check_assignment(node, rhs); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentAssignment
end

class RuboCop::Cop::Layout::IndentHash
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::ArrayHashIndentation
  def autocorrect(node); end

  def on_hash(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentHash
end

class RuboCop::Cop::Layout::IndentHeredoc
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SafeMode
  def autocorrect(node); end

  def on_heredoc(node); end
  LIBRARY_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_TYPE_MSG = ::T.let(nil, ::T.untyped)
  RUBY23_WIDTH_MSG = ::T.let(nil, ::T.untyped)
  STRIP_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentHeredoc
end

class RuboCop::Cop::Layout::IndentationConsistency
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationConsistency
end

class RuboCop::Cop::Layout::IndentationWidth
  include ::RuboCop::Cop::EndKeywordAlignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def on_case(case_node); end

  def on_class(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node, base=T.unsafe(nil)); end

  def on_kwbegin(node); end

  def on_module(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_until(node, base=T.unsafe(nil)); end

  def on_while(node, base=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SPECIAL_MODIFIERS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::IndentationWidth
end

class RuboCop::Cop::Layout::InitialIndentation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(_processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::InitialIndentation
end

class RuboCop::Cop::Layout::LeadingBlankLines
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingBlankLines
end

class RuboCop::Cop::Layout::LeadingCommentSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::LeadingCommentSpace
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineArrayBraceLayout
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
  include ::RuboCop::Cop::CheckAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_assignment(node, rhs); end

  def check_by_enforced_style(node, rhs); end

  def check_new_line_offense(node, rhs); end

  def check_same_line_offense(node, rhs); end
  NEW_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
  SAME_LINE_OFFENSE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineAssignmentLayout
end

class RuboCop::Cop::Layout::MultilineBlockLayout
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  ARG_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineBlockLayout
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_hash(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineHashBraceLayout
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodCallBraceLayout
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineMethodCallIndentation
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
  include ::RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  ALWAYS_NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  ALWAYS_SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  NEW_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
  SAME_LINE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::MultilineMethodDefinitionBraceLayout
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::MultilineExpressionIndentation
  def autocorrect(node); end

  def on_and(node); end

  def on_or(node); end

  def validate_config(); end
end

class RuboCop::Cop::Layout::MultilineOperationIndentation
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end

  def on_ensure(node); end

  def on_resbody(node); end
  ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RUBY_2_5_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::RescueEnsureAlignment
end

class RuboCop::Cop::Layout::SpaceAfterColon
  def autocorrect(range); end

  def on_kwoptarg(node); end

  def on_pair(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterColon
end

class RuboCop::Cop::Layout::SpaceAfterComma
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(comma); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterComma
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(pos_before_left_paren); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterMethodName
end

class RuboCop::Cop::Layout::SpaceAfterNot
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def whitespace_after_operator?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAfterNot
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
  include ::RuboCop::Cop::SpaceAfterPunctuation
  def autocorrect(semicolon); end

  def kind(token); end

  def space_style_before_rcurly(); end
end

class RuboCop::Cop::Layout::SpaceAfterSemicolon
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceAroundBlockParameters
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundEqualsInParameterDefault
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
  def autocorrect(range); end

  def on_and(node); end

  def on_block(node); end

  def on_break(node); end

  def on_case(node); end

  def on_defined?(node); end

  def on_ensure(node); end

  def on_for(node); end

  def on_if(node); end

  def on_kwbegin(node); end

  def on_next(node); end

  def on_or(node); end

  def on_postexe(node); end

  def on_preexe(node); end

  def on_resbody(node); end

  def on_rescue(node); end

  def on_return(node); end

  def on_send(node); end

  def on_super(node); end

  def on_until(node); end

  def on_when(node); end

  def on_while(node); end

  def on_yield(node); end

  def on_zsuper(node); end
  ACCEPT_LEFT_PAREN = ::T.let(nil, ::T.untyped)
  ACCEPT_LEFT_SQUARE_BRACKET = ::T.let(nil, ::T.untyped)
  DO = ::T.let(nil, ::T.untyped)
  MSG_AFTER = ::T.let(nil, ::T.untyped)
  MSG_BEFORE = ::T.let(nil, ::T.untyped)
  SAFE_NAVIGATION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundKeyword
end

class RuboCop::Cop::Layout::SpaceAroundOperators
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_and(node); end

  def on_and_asgn(node); end

  def on_binary(node); end

  def on_casgn(node); end

  def on_class(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or(node); end

  def on_or_asgn(node); end

  def on_pair(node); end

  def on_resbody(node); end

  def on_send(node); end

  def on_special_asgn(node); end
  IRREGULAR_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceAroundOperators
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
  DETECTED_MSG = ::T.let(nil, ::T.untyped)
  MISSING_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeBlockBraces
end

class RuboCop::Cop::Layout::SpaceBeforeComma
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeComma
end

class RuboCop::Cop::Layout::SpaceBeforeComment
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeComment
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
  include ::RuboCop::Cop::PrecedingFollowingAlignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceBeforeFirstArg
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
  include ::RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(space); end

  def kind(token); end
end

class RuboCop::Cop::Layout::SpaceBeforeSemicolon
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(lambda_node); end

  def on_send(node); end
  ARROW = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_NO_SPACE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInLambdaLiteral
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_array(node); end
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayLiteralBrackets
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTIPLE_SPACES_BETWEEN_ITEMS_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideArrayPercentLiteral
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_block(node); end
end

class RuboCop::Cop::Layout::SpaceInsideBlockBraces
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideHashLiteralBraces
end

class RuboCop::Cop::Layout::SpaceInsideParens
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SPACE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideParens
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
  include ::RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end

  def on_xstr(node); end
  BEGIN_REGEX = ::T.let(nil, ::T.untyped)
  END_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsidePercentLiteralDelimiters
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
  def autocorrect(node); end

  def on_erange(node); end

  def on_irange(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideRangeLiteral
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  BRACKET_METHODS = ::T.let(nil, ::T.untyped)
  EMPTY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideReferenceBrackets
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_dstr(node); end
  NO_SPACE_MSG = ::T.let(nil, ::T.untyped)
  SPACE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::SpaceInsideStringInterpolation
end

class RuboCop::Cop::Layout::Tab
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::Tab
end

class RuboCop::Cop::Layout::TrailingBlankLines
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
end

class RuboCop::Cop::Layout::TrailingBlankLines
end

class RuboCop::Cop::Layout::TrailingWhitespace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Layout::TrailingWhitespace
end

module RuboCop::Cop::Layout
  extend ::T::Sig
end

class RuboCop::Cop::LineBreakCorrector
end

class RuboCop::Cop::LineBreakCorrector
  extend ::RuboCop::Cop::Alignment
  extend ::RuboCop::Cop::TrailingBody
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.break_line_before(range:, node:, corrector:, configured_width:, indent_steps: T.unsafe(nil)); end

  def self.correct_trailing_body(configured_width:, corrector:, node:, processed_source:); end

  def self.move_comment(eol_comment:, node:, corrector:); end

  def self.processed_source(); end
end

module RuboCop::Cop::Lint
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousBlockAssociation
end

class RuboCop::Cop::Lint::AmbiguousOperator
  include ::RuboCop::Cop::ParserDiagnostic
  AMBIGUITIES = ::T.let(nil, ::T.untyped)
  MSG_FORMAT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousOperator
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AmbiguousRegexpLiteral
end

class RuboCop::Cop::Lint::AssignmentInCondition
  include ::RuboCop::Cop::SafeAssignment
  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
  ASGN_TYPES = ::T.let(nil, ::T.untyped)
  MSG_WITHOUT_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
  MSG_WITH_SAFE_ASSIGNMENT_ALLOWED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::AssignmentInCondition
end

class RuboCop::Cop::Lint::BigDecimalNew
  def autocorrect(node); end

  def big_decimal_new(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BigDecimalNew
end

class RuboCop::Cop::Lint::BooleanSymbol
  def boolean_symbol?(node=T.unsafe(nil)); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::BooleanSymbol
end

class RuboCop::Cop::Lint::CircularArgumentReference
  def on_kwoptarg(node); end

  def on_optarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::CircularArgumentReference
end

class RuboCop::Cop::Lint::Debugger
  def binding_irb_call?(node=T.unsafe(nil)); end

  def debugger_call?(node=T.unsafe(nil)); end

  def kernel?(node=T.unsafe(nil)); end

  def on_send(node); end

  def pry_rescue?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Debugger
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
  def autocorrect(node); end

  def on_send(node); end
  DEPRECATED_METHODS_OBJECT = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
  include ::RuboCop::AST::Sexp
  def class_constant(); end

  def class_nodes(); end

  def deprecated_method(); end

  def initialize(class_constant, deprecated_method, replacement_method); end

  def replacement_method(); end
end

class RuboCop::Cop::Lint::DeprecatedClassMethods::DeprecatedClassMethod
end

class RuboCop::Cop::Lint::DeprecatedClassMethods
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateCaseCondition
end

class RuboCop::Cop::Lint::DuplicateMethods
  def alias_method?(node=T.unsafe(nil)); end

  def attr?(node=T.unsafe(nil)); end

  def method_alias?(node=T.unsafe(nil)); end

  def on_alias(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def sym_name(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicateMethods
end

class RuboCop::Cop::Lint::DuplicatedKey
  include ::RuboCop::Cop::Duplication
  def on_hash(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::DuplicatedKey
end

class RuboCop::Cop::Lint::EachWithObjectArgument
  def each_with_object?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EachWithObjectArgument
end

class RuboCop::Cop::Lint::ElseLayout
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ElseLayout
end

class RuboCop::Cop::Lint::EmptyEnsure
  def autocorrect(node); end

  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyEnsure
end

class RuboCop::Cop::Lint::EmptyExpression
  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyExpression
end

class RuboCop::Cop::Lint::EmptyInterpolation
  def autocorrect(node); end

  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyInterpolation
end

class RuboCop::Cop::Lint::EmptyWhen
  def on_case(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EmptyWhen
end

class RuboCop::Cop::Lint::EndInMethod
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EndInMethod
end

class RuboCop::Cop::Lint::EnsureReturn
  def on_ensure(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::EnsureReturn
end

class RuboCop::Cop::Lint::ErbNewArguments
  def correct_arguments?(arguments); end

  def erb_new_with_non_keyword_arguments(node=T.unsafe(nil)); end

  def on_send(node); end
  MESSAGES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ErbNewArguments
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::FloatOutOfRange
  def on_float(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FloatOutOfRange
end

class RuboCop::Cop::Lint::FormatParameterMismatch
  def on_send(node); end
  FIELD_REGEX = ::T.let(nil, ::T.untyped)
  KERNEL = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NAMED_FIELD_REGEX = ::T.let(nil, ::T.untyped)
  NAMED_INTERPOLATION = ::T.let(nil, ::T.untyped)
  PERCENT = ::T.let(nil, ::T.untyped)
  PERCENT_PERCENT = ::T.let(nil, ::T.untyped)
  SHOVEL = ::T.let(nil, ::T.untyped)
  STRING_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::FormatParameterMismatch
end

class RuboCop::Cop::Lint::HandleExceptions
  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::HandleExceptions
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
  def on_dstr(node); end
  FOR_ARRAY = ::T.let(nil, ::T.untyped)
  FOR_METHOD = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ImplicitStringConcatenation
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
  def on_class(node); end

  def on_module(node); end

  def private_class_methods(node0); end
  ALTERNATIVE_PRIVATE = ::T.let(nil, ::T.untyped)
  ALTERNATIVE_PROTECTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::IneffectiveAccessModifier
end

class RuboCop::Cop::Lint::InheritException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_class(node); end
  ILLEGAL_CLASSES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PREFERRED_BASE_CLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InheritException
end

class RuboCop::Cop::Lint::InterpolationCheck
  def heredoc?(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::InterpolationCheck
end

class RuboCop::Cop::Lint::LiteralAsCondition
  def message(node); end

  def on_case(case_node); end

  def on_if(node); end

  def on_send(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralAsCondition
end

class RuboCop::Cop::Lint::LiteralInInterpolation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_dstr(node); end
  COMPOSITE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::LiteralInInterpolation
end

class RuboCop::Cop::Lint::Loop
  def on_until_post(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Loop
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_BOUND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MissingCopEnableDirective
end

class RuboCop::Cop::Lint::MultipleCompare
  def autocorrect(node); end

  def multiple_compare?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::MultipleCompare
end

class RuboCop::Cop::Lint::NestedMethodDefinition
  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def eval_call?(node=T.unsafe(nil)); end

  def exec_call?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedMethodDefinition
end

class RuboCop::Cop::Lint::NestedPercentLiteral
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
  REGEXES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NestedPercentLiteral
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
  def on_block(node); end

  def on_body_of_reduce(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NextWithoutAccumulator
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NonLocalExitFromIterator
end

class RuboCop::Cop::Lint::NumberConversion
  def on_send(node); end

  def to_method(node=T.unsafe(nil)); end
  CONVERSION_METHOD_CLASS_MAPPING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::NumberConversion
end

class RuboCop::Cop::Lint::OrderedMagicComments
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(_node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::OrderedMagicComments
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ParenthesesAsGroupedExpression
end

class RuboCop::Cop::Lint::PercentStringArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  LEADING_QUOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTES_AND_COMMAS = ::T.let(nil, ::T.untyped)
  TRAILING_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentStringArray
end

class RuboCop::Cop::Lint::PercentSymbolArray
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end

  def on_percent_literal(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::PercentSymbolArray
end

class RuboCop::Cop::Lint::RandOne
  def on_send(node); end

  def rand_one?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RandOne
end

class RuboCop::Cop::Lint::RedundantWithIndex
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_index?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_INDEX = ::T.let(nil, ::T.untyped)
  MSG_WITH_INDEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithIndex
end

class RuboCop::Cop::Lint::RedundantWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_with_object?(node=T.unsafe(nil)); end
  MSG_EACH_WITH_OBJECT = ::T.let(nil, ::T.untyped)
  MSG_WITH_OBJECT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RedundantWithObject
end

class RuboCop::Cop::Lint::RegexpAsCondition
  def on_match_current_line(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RegexpAsCondition
end

class RuboCop::Cop::Lint::RequireParentheses
  include ::RuboCop::Cop::RangeHelp
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RequireParentheses
end

class RuboCop::Cop::Lint::RescueException
  def on_resbody(node); end

  def targets_exception?(rescue_arg_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueException
end

class RuboCop::Cop::Lint::RescueType
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  INVALID_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::RescueType
end

class RuboCop::Cop::Lint::ReturnInVoidContext
  def on_return(return_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ReturnInVoidContext
end

class RuboCop::Cop::Lint::SafeNavigationChain
  include ::RuboCop::Cop::NilMethods
  def bad_method?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationChain
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
  include ::RuboCop::Cop::NilMethods
  def autocorrect(node); end

  def check(node); end

  def on_csend(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::SafeNavigationConsistency
end

class RuboCop::Cop::Lint::ScriptPermission
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ScriptPermission
end

class RuboCop::Cop::Lint::ShadowedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end

  def uses_var?(node0, param1); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedArgument
end

class RuboCop::Cop::Lint::ShadowedException
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::RangeHelp
  def on_rescue(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowedException
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
  def before_declaring_variable(variable, variable_table); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::ShadowingOuterLocalVariable
end

class RuboCop::Cop::Lint::StringConversionInInterpolation
  def autocorrect(node); end

  def on_dstr(node); end

  def to_s_without_args?(node=T.unsafe(nil)); end
  MSG_DEFAULT = ::T.let(nil, ::T.untyped)
  MSG_SELF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::StringConversionInInterpolation
end

class RuboCop::Cop::Lint::Syntax
  def add_offense_from_diagnostic(diagnostic, ruby_version); end

  def add_offense_from_error(error); end
  ERROR_SOURCE_RANGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def begin_pos(); end

  def begin_pos=(_); end

  def column(); end

  def column=(_); end

  def end_pos(); end

  def end_pos=(_); end

  def line(); end

  def line=(_); end

  def source_line(); end

  def source_line=(_); end
end

class RuboCop::Cop::Lint::Syntax::PseudoSourceRange
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Lint::Syntax
  def self.offenses_from_processed_source(processed_source, config, options); end
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
  def after_leaving_scope(scope, _variable_table); end

  def check_variable(variable); end

  def join_force?(force_class); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnderscorePrefixedVariableName
end

class RuboCop::Cop::Lint::UnifiedInteger
  def autocorrect(node); end

  def fixnum_or_bignum_const(node=T.unsafe(nil)); end

  def on_const(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnifiedInteger
end

class RuboCop::Cop::Lint::UnneededCopDisableDirective
  include ::RuboCop::NameSimilarity
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(args); end

  def check(offenses, cop_disabled_line_ranges, comments); end
  COP_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededCopDisableDirective
end

class RuboCop::Cop::Lint::UnneededCopEnableDirective
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment_and_name); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededCopEnableDirective
end

class RuboCop::Cop::Lint::UnneededRequireStatement
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def unnecessary_require_statement?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededRequireStatement
end

class RuboCop::Cop::Lint::UnneededSplatExpansion
  def array_new?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def literal_expansion(node=T.unsafe(nil)); end

  def on_splat(node); end
  ARRAY_PARAM_MSG = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_I = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_W = ::T.let(nil, ::T.untyped)
  PERCENT_I = ::T.let(nil, ::T.untyped)
  PERCENT_W = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnneededSplatExpansion
end

class RuboCop::Cop::Lint::UnreachableCode
  def flow_command?(node=T.unsafe(nil)); end

  def on_begin(node); end

  def on_kwbegin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UnreachableCode
end

module RuboCop::Cop::Lint::UnusedArgument
  def after_leaving_scope(scope, _variable_table); end

  def join_force?(force_class); end
end

module RuboCop::Cop::Lint::UnusedArgument
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

class RuboCop::Cop::Lint::UnusedBlockArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedBlockArgument
end

class RuboCop::Cop::Lint::UnusedMethodArgument
  include ::RuboCop::Cop::Lint::UnusedArgument
  def autocorrect(node); end
end

class RuboCop::Cop::Lint::UnusedMethodArgument
end

class RuboCop::Cop::Lint::UriEscapeUnescape
  def on_send(node); end

  def uri_escape_unescape?(node=T.unsafe(nil)); end
  ALTERNATE_METHODS_OF_URI_ESCAPE = ::T.let(nil, ::T.untyped)
  ALTERNATE_METHODS_OF_URI_UNESCAPE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriEscapeUnescape
end

class RuboCop::Cop::Lint::UriRegexp
  def autocorrect(node); end

  def on_send(node); end

  def uri_regexp_with_argument?(node=T.unsafe(nil)); end

  def uri_regexp_without_argument?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UriRegexp
end

class RuboCop::Cop::Lint::UselessAccessModifier
  def class_or_instance_eval?(node=T.unsafe(nil)); end

  def class_or_module_or_struct_new_call?(node=T.unsafe(nil)); end

  def dynamic_method_definition?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_class(node); end

  def on_module(node); end

  def on_sclass(node); end

  def static_method_definition?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAccessModifier
end

class RuboCop::Cop::Lint::UselessAssignment
  include ::RuboCop::NameSimilarity
  def after_leaving_scope(scope, _variable_table); end

  def check_for_unused_assignments(variable); end

  def collect_variable_like_names(scope); end

  def join_force?(force_class); end

  def message_for_useless_assignment(assignment); end

  def message_specification(assignment, variable); end

  def multiple_assignment_message(variable_name); end

  def operator_assignment_message(scope, assignment); end

  def return_value_node_of_scope(scope); end

  def similar_name_message(variable); end

  def variable_like_method_invocation?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessAssignment
end

class RuboCop::Cop::Lint::UselessComparison
  def on_send(node); end

  def useless_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessComparison
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
  include ::RuboCop::Cop::ParserDiagnostic
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessElseWithoutRescue
end

class RuboCop::Cop::Lint::UselessSetterCall
  def on_def(node); end

  def on_defs(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
  def constructor?(node); end

  def contain_local_object?(variable_name); end

  def initialize(body_node); end

  def process_assignment(asgn_node, rhs_node); end

  def process_assignment_node(node); end

  def process_binary_operator_assignment(op_asgn_node); end

  def process_logical_operator_assignment(asgn_node); end

  def process_multiple_assignment(masgn_node); end

  def scan(node, &block); end
end

class RuboCop::Cop::Lint::UselessSetterCall::MethodVariableTracker
end

class RuboCop::Cop::Lint::UselessSetterCall
end

class RuboCop::Cop::Lint::Void
  def on_begin(node); end

  def on_block(node); end

  def on_kwbegin(node); end
  BINARY_OPERATORS = ::T.let(nil, ::T.untyped)
  DEFINED_MSG = ::T.let(nil, ::T.untyped)
  LIT_MSG = ::T.let(nil, ::T.untyped)
  NONMUTATING_METHODS = ::T.let(nil, ::T.untyped)
  NONMUTATING_MSG = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OP_MSG = ::T.let(nil, ::T.untyped)
  SELF_MSG = ::T.let(nil, ::T.untyped)
  UNARY_OPERATORS = ::T.let(nil, ::T.untyped)
  VAR_MSG = ::T.let(nil, ::T.untyped)
  VOID_CONTEXT_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Lint::Void
end

module RuboCop::Cop::Lint
  extend ::T::Sig
end

module RuboCop::Cop::MatchRange
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::MatchRange
  extend ::T::Sig
end

class RuboCop::Cop::MessageAnnotator
  def annotate(message, name); end

  def config(); end

  def cop_config(); end

  def initialize(config, cop_config, options); end

  def options(); end

  def urls(); end
end

class RuboCop::Cop::MessageAnnotator
  def self.style_guide_urls(); end
end

module RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  def define_method?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
end

module RuboCop::Cop::MethodComplexity
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

module RuboCop::Cop::MethodPreference
end

module RuboCop::Cop::MethodPreference
  extend ::T::Sig
end

module RuboCop::Cop::Metrics
end

class RuboCop::Cop::Metrics::AbcSize
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  BRANCH_NODES = ::T.let(nil, ::T.untyped)
  CONDITION_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::AbcSize
end

class RuboCop::Cop::Metrics::BlockLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockLength
end

class RuboCop::Cop::Metrics::BlockNesting
  include ::RuboCop::Cop::ConfigurableMax
  def investigate(processed_source); end
  NESTING_BLOCKS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::BlockNesting
end

class RuboCop::Cop::Metrics::ClassLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def class_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_class(node); end
end

class RuboCop::Cop::Metrics::ClassLength
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::CyclomaticComplexity
end

class RuboCop::Cop::Metrics::LineLength
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IgnoredPattern
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::LineLength
end

class RuboCop::Cop::Metrics::MethodLength
  include ::RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  LABEL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::MethodLength
end

class RuboCop::Cop::Metrics::ModuleLength
  include ::RuboCop::Cop::ClassishLength
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  def module_definition?(node=T.unsafe(nil)); end

  def on_casgn(node); end

  def on_module(node); end
end

class RuboCop::Cop::Metrics::ModuleLength
end

class RuboCop::Cop::Metrics::ParameterLists
  include ::RuboCop::Cop::ConfigurableMax
  def argument_to_lambda_or_proc?(node=T.unsafe(nil)); end

  def on_args(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::ParameterLists
end

class RuboCop::Cop::Metrics::PerceivedComplexity
  include ::RuboCop::Cop::MethodComplexity
  include ::RuboCop::Cop::ConfigurableMax
  COUNTED_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Metrics::PerceivedComplexity
end

module RuboCop::Cop::Metrics
  extend ::T::Sig
end

module RuboCop::Cop::MinBodyLength
end

module RuboCop::Cop::MinBodyLength
  extend ::T::Sig
end

module RuboCop::Cop::MultilineExpressionIndentation
  def on_send(node); end
  ASSIGNMENT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  ASSIGNMENT_RHS_TYPES = ::T.let(nil, ::T.untyped)
  DEFAULT_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  KEYWORD_ANCESTOR_TYPES = ::T.let(nil, ::T.untyped)
  KEYWORD_MESSAGE_TAIL = ::T.let(nil, ::T.untyped)
  UNALIGNED_RHS_TYPES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::MultilineExpressionIndentation
  extend ::T::Sig
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
end

class RuboCop::Cop::MultilineLiteralBraceCorrector
  extend ::RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::RuboCop::Cop::ConfigurableEnforcedStyle
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(processed_source, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
end

module RuboCop::Cop::MultilineLiteralBraceLayout
  extend ::T::Sig
end

module RuboCop::Cop::Naming
end

class RuboCop::Cop::Naming::AccessorMethodName
  def on_def(node); end

  def on_defs(node); end
  MSG_READER = ::T.let(nil, ::T.untyped)
  MSG_WRITER = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AccessorMethodName
end

class RuboCop::Cop::Naming::AsciiIdentifiers
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::AsciiIdentifiers
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
  def on_def(node); end

  def op_method_candidate?(node=T.unsafe(nil)); end
  BLACKLISTED = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OP_LIKE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::BinaryOperatorParameterName
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ClassAndModuleCamelCase
end

class RuboCop::Cop::Naming::ConstantName
  def class_or_struct_return_method?(node=T.unsafe(nil)); end

  def on_casgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::ConstantName
end

class RuboCop::Cop::Naming::FileName
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG_NO_DEFINITION = ::T.let(nil, ::T.untyped)
  MSG_REGEX = ::T.let(nil, ::T.untyped)
  MSG_SNAKE_CASE = ::T.let(nil, ::T.untyped)
  SNAKE_CASE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::FileName
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
  include ::RuboCop::Cop::Heredoc
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterCase
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
  include ::RuboCop::Cop::Heredoc
  def on_heredoc(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::HeredocDelimiterNaming
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def memoized?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE_REQUIRED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MemoizedInstanceVariableName
end

class RuboCop::Cop::Naming::MethodName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::MethodName
end

class RuboCop::Cop::Naming::PredicateName
  def dynamic_method_define(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end
end

class RuboCop::Cop::Naming::PredicateName
end

class RuboCop::Cop::Naming::UncommunicativeBlockParamName
  include ::RuboCop::Cop::UncommunicativeName
  def on_block(node); end
end

class RuboCop::Cop::Naming::UncommunicativeBlockParamName
end

class RuboCop::Cop::Naming::UncommunicativeMethodParamName
  include ::RuboCop::Cop::UncommunicativeName
  def on_def(node); end

  def on_defs(node); end
end

class RuboCop::Cop::Naming::UncommunicativeMethodParamName
end

class RuboCop::Cop::Naming::VariableName
  include ::RuboCop::Cop::ConfigurableNaming
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_blockarg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_kwarg(node); end

  def on_kwoptarg(node); end

  def on_kwrestarg(node); end

  def on_lvasgn(node); end

  def on_optarg(node); end

  def on_restarg(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableName
end

class RuboCop::Cop::Naming::VariableNumber
  include ::RuboCop::Cop::ConfigurableNumbering
  include ::RuboCop::Cop::ConfigurableFormatting
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_arg(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Naming::VariableNumber
end

module RuboCop::Cop::Naming
  extend ::T::Sig
end

module RuboCop::Cop::NegativeConditional
  def empty_condition?(node=T.unsafe(nil)); end

  def single_negative?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::NegativeConditional
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

module RuboCop::Cop::NilMethods
end

module RuboCop::Cop::NilMethods
  extend ::T::Sig
end

class RuboCop::Cop::Offense
  include ::Comparable
  def ==(other); end

  def column(); end

  def column_length(); end

  def column_range(); end

  def cop_name(); end

  def corrected(); end

  def corrected?(); end

  def disabled?(); end

  def eql?(other); end

  def first_line(); end

  def highlighted_area(); end

  def initialize(severity, location, message, cop_name, status=T.unsafe(nil)); end

  def last_column(); end

  def last_line(); end

  def line(); end

  def location(); end

  def message(); end

  def real_column(); end

  def severity(); end

  def source_line(); end

  def status(); end
  COMPARISON_ATTRIBUTES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Offense
end

module RuboCop::Cop::OnNormalIfUnless
  def on_if(node); end
end

module RuboCop::Cop::OnNormalIfUnless
  extend ::T::Sig
end

class RuboCop::Cop::OrderedGemCorrector
end

class RuboCop::Cop::OrderedGemCorrector
  extend ::RuboCop::Cop::OrderedGemNode
  def self.comments_as_separators(); end

  def self.correct(processed_source, node, previous_declaration, comments_as_separators); end

  def self.processed_source(); end
end

module RuboCop::Cop::OrderedGemNode
end

module RuboCop::Cop::OrderedGemNode
  extend ::T::Sig
end

module RuboCop::Cop::Parentheses
end

module RuboCop::Cop::Parentheses
  extend ::T::Sig
end

class RuboCop::Cop::ParenthesesCorrector
end

class RuboCop::Cop::ParenthesesCorrector
  def self.correct(node); end
end

module RuboCop::Cop::ParserDiagnostic
  def investigate(processed_source); end
end

module RuboCop::Cop::ParserDiagnostic
  extend ::T::Sig
end

module RuboCop::Cop::PercentArray
end

module RuboCop::Cop::PercentArray
  extend ::T::Sig
end

module RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::PercentLiteral
  extend ::T::Sig
end

class RuboCop::Cop::PercentLiteralCorrector
  include ::RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  def config(); end

  def correct(node, char); end

  def initialize(config, preferred_delimiters); end

  def preferred_delimiters(); end
end

class RuboCop::Cop::PercentLiteralCorrector
end

module RuboCop::Cop::Performance
end

class RuboCop::Cop::Performance::Caller
  def caller_with_scope_method?(node=T.unsafe(nil)); end

  def on_send(node); end

  def slow_caller?(node=T.unsafe(nil)); end
  MSG_BRACE = ::T.let(nil, ::T.untyped)
  MSG_FIRST = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Caller
end

class RuboCop::Cop::Performance::CaseWhenSplat
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(when_node); end

  def on_case(case_node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::CaseWhenSplat
end

class RuboCop::Cop::Performance::Casecmp
  def autocorrect(node); end

  def downcase_downcase(node=T.unsafe(nil)); end

  def downcase_eq(node=T.unsafe(nil)); end

  def eq_downcase(node=T.unsafe(nil)); end

  def on_send(node); end
  CASE_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Casecmp
end

class RuboCop::Cop::Performance::ChainArrayAllocation
  include ::RuboCop::Cop::RangeHelp
  def flat_map_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  ALWAYS_RETURNS_NEW_ARRAY = ::T.let(nil, ::T.untyped)
  HAS_MUTATION_ALTERNATIVE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  RETURNS_NEW_ARRAY_WHEN_NO_BLOCK = ::T.let(nil, ::T.untyped)
  RETURN_NEW_ARRAY_WHEN_ARGS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ChainArrayAllocation
end

class RuboCop::Cop::Performance::CompareWithBlock
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def compare?(node=T.unsafe(nil)); end

  def on_block(node); end

  def replaceable_body?(node=T.unsafe(nil), param1, param2); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::CompareWithBlock
end

class RuboCop::Cop::Performance::Count
  include ::RuboCop::Cop::SafeMode
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def count_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Count
end

class RuboCop::Cop::Performance::Detect
  include ::RuboCop::Cop::SafeMode
  def autocorrect(node); end

  def detect_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  REVERSE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Detect
end

class RuboCop::Cop::Performance::DoubleStartEndWith
  def autocorrect(node); end

  def check_with_active_support_aliases(node=T.unsafe(nil)); end

  def on_or(node); end

  def two_start_end_with_calls(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::DoubleStartEndWith
end

class RuboCop::Cop::Performance::EndWith
  def autocorrect(node); end

  def literal_at_end?(regex_str); end

  def on_send(node); end

  def redundant_regex?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::EndWith
end

class RuboCop::Cop::Performance::FixedSize
  def counter(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::FixedSize
end

class RuboCop::Cop::Performance::FlatMap
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def flat_map_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  FLATTEN_MULTIPLE_LEVELS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::FlatMap
end

class RuboCop::Cop::Performance::InefficientHashSearch
  def autocorrect(node); end

  def inefficient_include?(node=T.unsafe(nil)); end

  def on_send(node); end
end

class RuboCop::Cop::Performance::InefficientHashSearch
end

class RuboCop::Cop::Performance::LstripRstrip
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def lstrip_rstrip(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::LstripRstrip
end

class RuboCop::Cop::Performance::RangeInclude
  def autocorrect(node); end

  def on_send(node); end

  def range_include(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RangeInclude
end

class RuboCop::Cop::Performance::RedundantBlockCall
  def autocorrect(node); end

  def blockarg_assigned?(node0, param1); end

  def blockarg_calls(node0, param1); end

  def blockarg_def(node=T.unsafe(nil)); end

  def on_def(node); end
  CLOSE_PAREN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OPEN_PAREN = ::T.let(nil, ::T.untyped)
  SPACE = ::T.let(nil, ::T.untyped)
  YIELD = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantBlockCall
end

class RuboCop::Cop::Performance::RedundantMatch
  def autocorrect(node); end

  def match_call?(node=T.unsafe(nil)); end

  def on_send(node); end

  def only_truthiness_matters?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantMatch
end

class RuboCop::Cop::Performance::RedundantMerge
  def autocorrect(node); end

  def modifier_flow_control?(node=T.unsafe(nil)); end

  def on_send(node); end

  def redundant_merge_candidate(node=T.unsafe(nil)); end
  AREF_ASGN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantMerge::EachWithObjectInspector
  def each_with_object_node(node=T.unsafe(nil)); end

  def initialize(node, receiver); end

  def value_used?(); end
end

class RuboCop::Cop::Performance::RedundantMerge::EachWithObjectInspector
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Performance::RedundantMerge
end

class RuboCop::Cop::Performance::RedundantSortBy
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end

  def redundant_sort_by(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RedundantSortBy
end

class RuboCop::Cop::Performance::RegexpMatch
  def autocorrect(node); end

  def last_matches(node0); end

  def match_method?(node=T.unsafe(nil)); end

  def match_node?(node=T.unsafe(nil)); end

  def match_operator?(node=T.unsafe(nil)); end

  def match_threequals?(node=T.unsafe(nil)); end

  def match_with_lvasgn?(node); end

  def on_case(node); end

  def on_if(node); end

  def search_match_nodes(node0); end
  MATCH_NODE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  TYPES_IMPLEMENTING_MATCH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::RegexpMatch
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Performance::ReverseEach
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def reverse_each?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::ReverseEach
end

class RuboCop::Cop::Performance::Sample
  def autocorrect(node); end

  def on_send(node); end

  def sample_candidate?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Sample
end

class RuboCop::Cop::Performance::Size
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::Size
end

class RuboCop::Cop::Performance::StartWith
  def autocorrect(node); end

  def literal_at_start?(regex_str); end

  def on_send(node); end

  def redundant_regex?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::StartWith
end

class RuboCop::Cop::Performance::StringReplacement
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def replace_method(node, first, second, first_param, replacement); end

  def string_replacement?(node=T.unsafe(nil)); end
  BANG = ::T.let(nil, ::T.untyped)
  DELETE = ::T.let(nil, ::T.untyped)
  DETERMINISTIC_REGEX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  TR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::StringReplacement
end

class RuboCop::Cop::Performance::TimesMap
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end

  def times_map_call(node=T.unsafe(nil)); end
  MESSAGE = ::T.let(nil, ::T.untyped)
  MESSAGE_ONLY_IF = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::TimesMap
end

class RuboCop::Cop::Performance::UnfreezeString
  def dup_string?(node=T.unsafe(nil)); end

  def on_send(node); end

  def string_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::UnfreezeString
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Performance::UnneededSort
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def unneeded_sort?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::UnneededSort
end

class RuboCop::Cop::Performance::UriDefaultParser
  def autocorrect(node); end

  def on_send(node); end

  def uri_parser_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Performance::UriDefaultParser
end

module RuboCop::Cop::Performance
  extend ::T::Sig
end

module RuboCop::Cop::PrecedingFollowingAlignment
end

module RuboCop::Cop::PrecedingFollowingAlignment
  extend ::T::Sig
end

class RuboCop::Cop::PreferredDelimiters
  def config(); end

  def delimiters(); end

  def initialize(type, config, preferred_delimiters); end

  def type(); end
  PERCENT_LITERAL_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::PreferredDelimiters
end

class RuboCop::Cop::PunctuationCorrector
end

class RuboCop::Cop::PunctuationCorrector
  def self.add_space(token); end

  def self.remove_space(space_before); end

  def self.swap_comma(range); end
end

module RuboCop::Cop::Rails
end

class RuboCop::Cop::Rails::ActionFilter
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  ACTION_METHODS = ::T.let(nil, ::T.untyped)
  FILTER_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActionFilter
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::ActiveRecordAliases
  def autocorrect(node); end

  def on_send(node); end
  ALIASES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveRecordAliases
end

class RuboCop::Cop::Rails::ActiveSupportAliases
  def append(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def ends_with?(node=T.unsafe(nil)); end

  def on_send(node); end

  def prepend(node=T.unsafe(nil)); end

  def starts_with?(node=T.unsafe(nil)); end
  ALIASES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ActiveSupportAliases
end

class RuboCop::Cop::Rails::ApplicationJob
  include ::RuboCop::Cop::EnforceSuperclass
  def autocorrect(node); end

  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
  BASE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPERCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ApplicationJob
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::ApplicationRecord
  include ::RuboCop::Cop::EnforceSuperclass
  def autocorrect(node); end

  def class_definition(node=T.unsafe(nil)); end

  def class_new_definition(node=T.unsafe(nil)); end
  BASE_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SUPERCLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ApplicationRecord
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::AssertNot
  def autocorrect(node); end

  def offensive?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::AssertNot
end

class RuboCop::Cop::Rails::Blank
  def autocorrect(node); end

  def nil_or_empty?(node=T.unsafe(nil)); end

  def not_present?(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_or(node); end

  def on_send(node); end

  def unless_present?(node=T.unsafe(nil)); end
  MSG_NIL_OR_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NOT_PRESENT = ::T.let(nil, ::T.untyped)
  MSG_UNLESS_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Blank
end

class RuboCop::Cop::Rails::BulkChangeTable
  def on_def(node); end

  def on_send(node); end
  COMBINABLE_ALTER_METHODS = ::T.let(nil, ::T.untyped)
  COMBINABLE_TRANSFORMATIONS = ::T.let(nil, ::T.untyped)
  MIGRATION_METHODS = ::T.let(nil, ::T.untyped)
  MSG_FOR_ALTER_METHODS = ::T.let(nil, ::T.untyped)
  MSG_FOR_CHANGE_TABLE = ::T.let(nil, ::T.untyped)
  MYSQL = ::T.let(nil, ::T.untyped)
  MYSQL_COMBINABLE_ALTER_METHODS = ::T.let(nil, ::T.untyped)
  MYSQL_COMBINABLE_TRANSFORMATIONS = ::T.let(nil, ::T.untyped)
  POSTGRESQL = ::T.let(nil, ::T.untyped)
  POSTGRESQL_COMBINABLE_ALTER_METHODS = ::T.let(nil, ::T.untyped)
  POSTGRESQL_COMBINABLE_TRANSFORMATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
  def flush(); end

  def offensive_nodes(); end

  def process(new_node); end
end

class RuboCop::Cop::Rails::BulkChangeTable::AlterMethodsRecorder
end

class RuboCop::Cop::Rails::BulkChangeTable
end

class RuboCop::Cop::Rails::CreateTableWithTimestamps
  def create_table_with_block?(node=T.unsafe(nil)); end

  def create_table_with_timestamps_proc?(node=T.unsafe(nil)); end

  def created_at_or_updated_at_included?(node0); end

  def on_send(node); end

  def timestamps_included?(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::CreateTableWithTimestamps
end

class RuboCop::Cop::Rails::Date
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_const(node); end

  def on_send(node); end
  BAD_DAYS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Date
end

class RuboCop::Cop::Rails::Delegate
  def autocorrect(node); end

  def delegate?(node=T.unsafe(nil)); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Delegate
end

class RuboCop::Cop::Rails::DelegateAllowBlank
  def allow_blank_option?(node=T.unsafe(nil)); end

  def autocorrect(pair_node); end

  def delegate_options(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DelegateAllowBlank
end

class RuboCop::Cop::Rails::DynamicFindBy
  def autocorrect(node); end

  def on_send(node); end
  METHOD_PATTERN = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::DynamicFindBy
end

class RuboCop::Cop::Rails::EnumUniqueness
  include ::RuboCop::Cop::Duplication
  def enum_declaration(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnumUniqueness
end

class RuboCop::Cop::Rails::EnvironmentComparison
  def autocorrect(node); end

  def environment_str_comparison?(node=T.unsafe(nil)); end

  def environment_sym_comparison?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  SYM_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::EnvironmentComparison
end

class RuboCop::Cop::Rails::Exit
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  EXPLICIT_RECEIVERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Exit
end

class RuboCop::Cop::Rails::FilePath
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def file_join_nodes?(node=T.unsafe(nil)); end

  def on_dstr(node); end

  def on_send(node); end

  def rails_root_join_nodes?(node=T.unsafe(nil)); end

  def rails_root_nodes?(node0); end
  MSG_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FilePath
end

class RuboCop::Cop::Rails::FindBy
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def where_first?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindBy
end

class RuboCop::Cop::Rails::FindEach
  def autocorrect(node); end

  def on_send(node); end
  IGNORED_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SCOPE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::FindEach
end

class RuboCop::Cop::Rails::HasAndBelongsToMany
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HasAndBelongsToMany
end

class RuboCop::Cop::Rails::HasManyOrHasOneDependent
  def active_resource_class?(node0); end

  def association_with_options?(node=T.unsafe(nil)); end

  def association_without_options?(node=T.unsafe(nil)); end

  def dependent_option?(node=T.unsafe(nil)); end

  def on_send(node); end

  def present_option?(node=T.unsafe(nil)); end

  def with_options_block(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HasManyOrHasOneDependent
end

class RuboCop::Cop::Rails::HttpPositionalArguments
  def autocorrect(node); end

  def http_request?(node=T.unsafe(nil)); end

  def on_send(node); end
  HTTP_METHODS = ::T.let(nil, ::T.untyped)
  KEYWORD_ARGS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpPositionalArguments
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::HttpStatus
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def http_status(node=T.unsafe(nil)); end

  def on_send(node); end

  def status_pair?(node=T.unsafe(nil)); end
  RACK_LOADED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
  def initialize(node); end

  def message(); end

  def node(); end

  def offensive?(); end

  def preferred_style(); end
  DEFAULT_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  WHITELIST_STATUS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpStatus::NumericStyleChecker
end

class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
  def initialize(node); end

  def message(); end

  def node(); end

  def offensive?(); end

  def preferred_style(); end
  DEFAULT_MSG = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::HttpStatus::SymbolicStyleChecker
end

class RuboCop::Cop::Rails::HttpStatus
end

class RuboCop::Cop::Rails::InverseOf
  def as_option?(node=T.unsafe(nil)); end

  def association_recv_arguments(node=T.unsafe(nil)); end

  def conditions_option?(node=T.unsafe(nil)); end

  def foreign_key_option?(node=T.unsafe(nil)); end

  def inverse_of_nil_option?(node=T.unsafe(nil)); end

  def inverse_of_option?(node=T.unsafe(nil)); end

  def on_send(node); end

  def options_contain_inverse_of?(options); end

  def options_from_argument(node=T.unsafe(nil)); end

  def options_ignoring_inverse_of?(options); end

  def options_requiring_inverse_of?(options); end

  def polymorphic_option?(node=T.unsafe(nil)); end

  def same_context_in_with_options?(arg, recv); end

  def scope?(arguments); end

  def through_option?(node=T.unsafe(nil)); end

  def with_options_arguments(recv, node); end
  NIL_MSG = ::T.let(nil, ::T.untyped)
  SPECIFY_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::InverseOf
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::LexicallyScopedActionFilter
  def on_send(node); end

  def only_or_except_filter_methods(node=T.unsafe(nil)); end
  FILTERS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::LexicallyScopedActionFilter
end

class RuboCop::Cop::Rails::NotNullColumn
  def add_not_null_column?(node=T.unsafe(nil)); end

  def add_not_null_reference?(node=T.unsafe(nil)); end

  def default_option?(node=T.unsafe(nil)); end

  def null_false?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::NotNullColumn
end

class RuboCop::Cop::Rails::Output
  def on_send(node); end

  def output?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Output
end

class RuboCop::Cop::Rails::OutputSafety
  def on_csend(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::OutputSafety
end

class RuboCop::Cop::Rails::PluralizationGrammar
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  PLURAL_DURATION_METHODS = ::T.let(nil, ::T.untyped)
  SINGULAR_DURATION_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::PluralizationGrammar
end

class RuboCop::Cop::Rails::Presence
  def autocorrect(node); end

  def on_if(node); end

  def redundant_negative_receiver_and_other(node=T.unsafe(nil)); end

  def redundant_receiver_and_other(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Presence
end

class RuboCop::Cop::Rails::Present
  def autocorrect(node); end

  def exists_and_not_empty?(node=T.unsafe(nil)); end

  def not_blank?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_send(node); end

  def unless_blank?(node=T.unsafe(nil)); end
  MSG_EXISTS_AND_NOT_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NOT_BLANK = ::T.let(nil, ::T.untyped)
  MSG_UNLESS_BLANK = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Present
end

class RuboCop::Cop::Rails::ReadWriteAttribute
  def autocorrect(node); end

  def on_send(node); end

  def read_write_attribute?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ReadWriteAttribute
end

class RuboCop::Cop::Rails::RedundantReceiverInWithOptions
  include ::RuboCop::Cop::RangeHelp
  def all_block_nodes_in(node0); end

  def all_send_nodes_in(node0); end

  def autocorrect(node); end

  def on_block(node); end

  def with_options?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RedundantReceiverInWithOptions
  extend ::RuboCop::Cop::TargetRailsVersion
end

class RuboCop::Cop::Rails::RefuteMethods
  def autocorrect(node); end

  def offensive?(node=T.unsafe(nil)); end

  def on_send(node); end
  CORRECTIONS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  OFFENSIVE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RefuteMethods
end

class RuboCop::Cop::Rails::RelativeDateConstant
  def autocorrect(node); end

  def on_casgn(node); end

  def on_masgn(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  RELATIVE_DATE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RelativeDateConstant
end

class RuboCop::Cop::Rails::RequestReferer
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end

  def referer?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::RequestReferer
end

class RuboCop::Cop::Rails::ReversibleMigration
  def change_column_default_call(node=T.unsafe(nil)); end

  def change_table_call(node=T.unsafe(nil)); end

  def drop_table_call(node=T.unsafe(nil)); end

  def irreversible_schema_statement_call(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end

  def remove_column_call(node=T.unsafe(nil)); end

  def remove_foreign_key_call(node=T.unsafe(nil)); end
  IRREVERSIBLE_CHANGE_TABLE_CALLS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ReversibleMigration
end

class RuboCop::Cop::Rails::SafeNavigation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def try_call(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SafeNavigation
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Rails::SaveBang
  include ::RuboCop::Cop::NegativeConditional
  def after_leaving_scope(scope, _variable_table); end

  def autocorrect(node); end

  def check_assignment(assignment); end

  def join_force?(force_class); end

  def on_send(node); end
  CREATE_CONDITIONAL_MSG = ::T.let(nil, ::T.untyped)
  CREATE_MSG = ::T.let(nil, ::T.untyped)
  CREATE_PERSIST_METHODS = ::T.let(nil, ::T.untyped)
  MODIFY_PERSIST_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERSIST_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SaveBang
end

class RuboCop::Cop::Rails::ScopeArgs
  def on_send(node); end

  def scope?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::ScopeArgs
end

class RuboCop::Cop::Rails::SkipsModelValidations
  def good_touch?(node=T.unsafe(nil)); end

  def on_send(node); end
  METHODS_WITH_ARGUMENTS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::SkipsModelValidations
end

class RuboCop::Cop::Rails::TimeZone
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_const(node); end
  ACCEPTED_METHODS = ::T.let(nil, ::T.untyped)
  DANGEROUS_METHODS = ::T.let(nil, ::T.untyped)
  GOOD_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  MSG_ACCEPTABLE = ::T.let(nil, ::T.untyped)
  MSG_CURRENT = ::T.let(nil, ::T.untyped)
  MSG_LOCALTIME = ::T.let(nil, ::T.untyped)
  TIMECLASS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::TimeZone
end

class RuboCop::Cop::Rails::UniqBeforePluck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def aggressive_node_match(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def conservative_node_match(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PATTERN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UniqBeforePluck
end

class RuboCop::Cop::Rails::UnknownEnv
  include ::RuboCop::NameSimilarity
  def on_send(node); end

  def unknown_environment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_SIMILAR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::UnknownEnv
end

class RuboCop::Cop::Rails::Validation
  def autocorrect(node); end

  def on_send(node); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
  WHITELIST = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Rails::Validation
end

module RuboCop::Cop::Rails
  extend ::T::Sig
end

module RuboCop::Cop::RangeHelp
end

module RuboCop::Cop::RangeHelp
  extend ::T::Sig
end

class RuboCop::Cop::Registry
  def ==(other); end

  def contains_cop_matching?(names); end

  def cops(); end

  def departments(); end

  def each(&block); end

  def enabled(config, only); end

  def enlist(cop); end

  def find_by_cop_name(cop_name); end

  def initialize(cops=T.unsafe(nil)); end

  def length(); end

  def names(); end

  def qualified_cop_name(name, path); end

  def select(&block); end

  def sort!(); end

  def to_h(); end

  def with_department(department); end

  def without_department(department); end
end

class RuboCop::Cop::Registry
end

module RuboCop::Cop::RescueNode
  def investigate(processed_source); end
end

module RuboCop::Cop::RescueNode
  extend ::T::Sig
end

module RuboCop::Cop::SafeAssignment
  def empty_condition?(node=T.unsafe(nil)); end

  def safe_assignment?(node=T.unsafe(nil)); end

  def setter_method?(node=T.unsafe(nil)); end
end

module RuboCop::Cop::SafeAssignment
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

module RuboCop::Cop::SafeMode
end

module RuboCop::Cop::SafeMode
  extend ::T::Sig
end

module RuboCop::Cop::Security
end

class RuboCop::Cop::Security::Eval
  def eval?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Eval
end

class RuboCop::Cop::Security::JSONLoad
  def autocorrect(node); end

  def json_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::JSONLoad
end

class RuboCop::Cop::Security::MarshalLoad
  def marshal_load(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::MarshalLoad
end

class RuboCop::Cop::Security::Open
  def on_send(node); end

  def open?(node=T.unsafe(nil)); end

  def safe?(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::Open
end

class RuboCop::Cop::Security::YAMLLoad
  def autocorrect(node); end

  def on_send(node); end

  def yaml_load(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Security::YAMLLoad
end

module RuboCop::Cop::Security
  extend ::T::Sig
end

class RuboCop::Cop::Severity
  include ::Comparable
  def ==(other); end

  def code(); end

  def initialize(name_or_code); end

  def level(); end

  def name(); end
  CODE_TABLE = ::T.let(nil, ::T.untyped)
  NAMES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Severity
  def self.name_from_code(code); end
end

module RuboCop::Cop::SpaceAfterPunctuation
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceAfterPunctuation
  extend ::T::Sig
end

module RuboCop::Cop::SpaceBeforePunctuation
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SpaceBeforePunctuation
  extend ::T::Sig
end

class RuboCop::Cop::SpaceCorrector
end

class RuboCop::Cop::SpaceCorrector
  extend ::RuboCop::Cop::SurroundingSpace
  extend ::RuboCop::Cop::RangeHelp
  def self.add_space(processed_source, corrector, left_token, right_token); end

  def self.empty_corrections(processed_source, corrector, empty_config, left_token, right_token); end

  def self.processed_source(); end

  def self.remove_space(processed_source, corrector, left_token, right_token); end
end

module RuboCop::Cop::StatementModifier
end

module RuboCop::Cop::StatementModifier
  extend ::T::Sig
end

module RuboCop::Cop::StringHelp
  def on_regexp(node); end

  def on_str(node); end
end

module RuboCop::Cop::StringHelp
  extend ::T::Sig
end

class RuboCop::Cop::StringLiteralCorrector
end

class RuboCop::Cop::StringLiteralCorrector
  extend ::RuboCop::Cop::Util
  extend ::RuboCop::PathUtil
  def self.correct(node, style); end
end

module RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
end

module RuboCop::Cop::StringLiteralsHelp
  extend ::T::Sig
end

module RuboCop::Cop::Style
end

class RuboCop::Cop::Style::AccessModifierDeclarations
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_send(node); end
  GROUP_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
  INLINE_STYLE_MESSAGE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AccessModifierDeclarations
end

class RuboCop::Cop::Style::Alias
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_alias(node); end

  def on_send(node); end
  MSG_ALIAS = ::T.let(nil, ::T.untyped)
  MSG_ALIAS_METHOD = ::T.let(nil, ::T.untyped)
  MSG_SYMBOL_ARGS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Alias
end

class RuboCop::Cop::Style::AndOr
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_and(node); end

  def on_if(node); end

  def on_or(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AndOr
end

module RuboCop::Cop::Style::AnnotationComment
end

module RuboCop::Cop::Style::AnnotationComment
  extend ::T::Sig
end

class RuboCop::Cop::Style::ArrayJoin
  def autocorrect(node); end

  def join_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ArrayJoin
end

class RuboCop::Cop::Style::AsciiComments
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AsciiComments
end

class RuboCop::Cop::Style::Attr
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Attr
end

class RuboCop::Cop::Style::AutoResourceCleanup
  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  TARGET_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::AutoResourceCleanup
end

class RuboCop::Cop::Style::BarePercentLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BarePercentLiterals
end

class RuboCop::Cop::Style::BeginBlock
  def on_preexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BeginBlock
end

class RuboCop::Cop::Style::BlockComments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  BEGIN_LENGTH = ::T.let(nil, ::T.untyped)
  END_LENGTH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BlockComments
end

class RuboCop::Cop::Style::BlockDelimiters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::BlockDelimiters
end

class RuboCop::Cop::Style::BracesAroundHashParameters
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(send_node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::BracesAroundHashParameters
end

class RuboCop::Cop::Style::CaseCorrector
end

class RuboCop::Cop::Style::CaseCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::CaseEquality
  def case_equality?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CaseEquality
end

class RuboCop::Cop::Style::CharacterLiteral
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CharacterLiteral
end

class RuboCop::Cop::Style::ClassAndModuleChildren
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  NESTED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassAndModuleChildren
end

class RuboCop::Cop::Style::ClassCheck
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def class_check?(node=T.unsafe(nil)); end

  def message(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassCheck
end

class RuboCop::Cop::Style::ClassMethods
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassMethods
end

class RuboCop::Cop::Style::ClassVars
  def message(node); end

  def on_cvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ClassVars
end

class RuboCop::Cop::Style::CollectionMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CollectionMethods
end

class RuboCop::Cop::Style::ColonMethodCall
  def autocorrect(node); end

  def java_type_node?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodCall
end

class RuboCop::Cop::Style::ColonMethodDefinition
  def autocorrect(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ColonMethodDefinition
end

class RuboCop::Cop::Style::CommandLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_xstr(node); end
  MSG_USE_BACKTICKS = ::T.let(nil, ::T.untyped)
  MSG_USE_PERCENT_X = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommandLiteral
end

class RuboCop::Cop::Style::CommentAnnotation
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(comment); end

  def investigate(processed_source); end
  MISSING_NOTE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentAnnotation
end

class RuboCop::Cop::Style::CommentedKeyword
  include ::RuboCop::Cop::RangeHelp
  def investigate(processed_source); end
  ALLOWED_COMMENTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::CommentedKeyword
end

class RuboCop::Cop::Style::ConditionalAssignment
  include ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def assignment_type?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def candidate_condition?(node=T.unsafe(nil)); end

  def condition?(node=T.unsafe(nil)); end

  def on_and_asgn(node); end

  def on_case(node); end

  def on_casgn(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def on_masgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  ASSIGN_TO_CONDITION_MSG = ::T.let(nil, ::T.untyped)
  ENABLED = ::T.let(nil, ::T.untyped)
  INDENTATION_WIDTH = ::T.let(nil, ::T.untyped)
  LINE_LENGTH = ::T.let(nil, ::T.untyped)
  MAX = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_CONDITIONS_ONLY = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  WIDTH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ConditionalAssignment
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  def end_with_eq?(sym); end

  def expand_elses(branch); end

  def expand_when_branches(when_branches); end

  def indent(cop, source); end

  def lhs(node); end

  def tail(branch); end
  ALIGN_WITH = ::T.let(nil, ::T.untyped)
  END_ALIGNMENT = ::T.let(nil, ::T.untyped)
  EQUAL = ::T.let(nil, ::T.untyped)
  KEYWORD = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::NodePattern::Macros
  extend ::T::Sig
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  def assignment(node); end

  def correct_branches(corrector, branches); end

  def correct_if_branches(corrector, cop, node); end

  def remove_whitespace_in_branches(corrector, branch, condition, column); end

  def replace_branch_assignment(corrector, branch); end

  def white_space_range(node, column); end
end

module RuboCop::Cop::Style::ConditionalCorrectorHelper
  extend ::T::Sig
end

class RuboCop::Cop::Style::Copyright
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(token); end

  def investigate(processed_source); end
  AUTOCORRECT_EMPTY_WARNING = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Copyright
end

class RuboCop::Cop::Style::DateTime
  def date_time?(node=T.unsafe(nil)); end

  def historic_date?(node=T.unsafe(nil)); end

  def on_send(node); end

  def to_datetime?(node=T.unsafe(nil)); end
  CLASS_MSG = ::T.let(nil, ::T.untyped)
  COERCION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DateTime
end

class RuboCop::Cop::Style::DefWithParentheses
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DefWithParentheses
end

class RuboCop::Cop::Style::Dir
  def autocorrect(node); end

  def dir_replacement?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Dir
end

class RuboCop::Cop::Style::Documentation
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  def on_class(node); end

  def on_module(node); end

  def outer_module(node0); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Documentation
end

class RuboCop::Cop::Style::DocumentationMethod
  include ::RuboCop::Cop::DocumentationComment
  include ::RuboCop::Cop::Style::AnnotationComment
  include ::RuboCop::Cop::DefNode
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DocumentationMethod
end

class RuboCop::Cop::Style::DoubleNegation
  def double_negative?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::DoubleNegation
end

class RuboCop::Cop::Style::EachForSimpleLoop
  def autocorrect(node); end

  def offending_each_range(node=T.unsafe(nil)); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachForSimpleLoop
end

class RuboCop::Cop::Style::EachWithObject
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def each_with_object_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end
  METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EachWithObject
end

class RuboCop::Cop::Style::EmptyBlockParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyBlockParameter
end

class RuboCop::Cop::Style::EmptyCaseCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(case_node); end

  def on_case(case_node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyCaseCondition
end

class RuboCop::Cop::Style::EmptyElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyElse
end

class RuboCop::Cop::Style::EmptyLambdaParameter
  include ::RuboCop::Cop::EmptyParameter
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLambdaParameter
end

class RuboCop::Cop::Style::EmptyLiteral
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def array_node(node=T.unsafe(nil)); end

  def array_with_block(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def hash_node(node=T.unsafe(nil)); end

  def hash_with_block(node=T.unsafe(nil)); end

  def on_send(node); end

  def str_node(node=T.unsafe(nil)); end
  ARR_MSG = ::T.let(nil, ::T.untyped)
  HASH_MSG = ::T.let(nil, ::T.untyped)
  STR_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyLiteral
end

class RuboCop::Cop::Style::EmptyMethod
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_COMPACT = ::T.let(nil, ::T.untyped)
  MSG_EXPANDED = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EmptyMethod
end

class RuboCop::Cop::Style::Encoding
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end
  ENCODING_PATTERN = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Encoding
end

class RuboCop::Cop::Style::EndBlock
  def on_postexe(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EndBlock
end

class RuboCop::Cop::Style::EvalWithLocation
  def eval_without_location?(node=T.unsafe(nil)); end

  def line_with_offset?(node=T.unsafe(nil), param1, param2); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_INCORRECT_LINE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvalWithLocation
end

class RuboCop::Cop::Style::EvenOdd
  def autocorrect(node); end

  def even_odd_candidate?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::EvenOdd
end

class RuboCop::Cop::Style::ExpandPathArguments
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def file_expand_path(node=T.unsafe(nil)); end

  def on_send(node); end

  def pathname_new_parent_expand_path(node=T.unsafe(nil)); end

  def pathname_parent_expand_path(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_MSG = ::T.let(nil, ::T.untyped)
  PATHNAME_NEW_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ExpandPathArguments
end

class RuboCop::Cop::Style::FlipFlop
  def on_eflipflop(node); end

  def on_iflipflop(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FlipFlop
end

class RuboCop::Cop::Style::For
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def deconstruct_each(node=T.unsafe(nil)); end

  def deconstruct_for(node=T.unsafe(nil)); end

  def extract_variables(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_for(node); end
  EACH_LENGTH = ::T.let(nil, ::T.untyped)
  PREFER_EACH = ::T.let(nil, ::T.untyped)
  PREFER_FOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::For
end

class RuboCop::Cop::Style::FormatString
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def formatter(node=T.unsafe(nil)); end

  def message(detected_style); end

  def method_name(style_name); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatString
end

class RuboCop::Cop::Style::FormatStringToken
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_str(node); end
  FIELD_CHARACTERS = ::T.let(nil, ::T.untyped)
  FORMAT_STRING_METHODS = ::T.let(nil, ::T.untyped)
  STYLE_PATTERNS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FormatStringToken
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::FrozenStringLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_UNNECESSARY = ::T.let(nil, ::T.untyped)
  SHEBANG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::FrozenStringLiteralComment
end

class RuboCop::Cop::Style::GlobalVars
  def allowed_var?(global_var); end

  def check(node); end

  def on_gvar(node); end

  def on_gvasgn(node); end

  def user_vars(); end
  BUILT_IN_VARS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GlobalVars
end

class RuboCop::Cop::Style::GuardClause
  include ::RuboCop::Cop::MinBodyLength
  def on_def(node); end

  def on_defs(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::GuardClause
end

class RuboCop::Cop::Style::HashSyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def hash_rockets_check(pairs); end

  def no_mixed_keys_check(pairs); end

  def on_hash(node); end

  def ruby19_check(pairs); end

  def ruby19_no_mixed_keys_check(pairs); end
  MSG_19 = ::T.let(nil, ::T.untyped)
  MSG_HASH_ROCKETS = ::T.let(nil, ::T.untyped)
  MSG_NO_MIXED_KEYS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::HashSyntax
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
  def on_case(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IdenticalConditionalBranches
end

class RuboCop::Cop::Style::IfCorrector
end

class RuboCop::Cop::Style::IfCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::IfInsideElse
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfInsideElse
end

class RuboCop::Cop::Style::IfUnlessModifier
  include ::RuboCop::Cop::StatementModifier
  def autocorrect(node); end

  def on_if(node); end
  ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NAMED_CAPTURE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifier
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
  include ::RuboCop::Cop::StatementModifier
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfUnlessModifierOfIfUnless
end

class RuboCop::Cop::Style::IfWithSemicolon
  include ::RuboCop::Cop::OnNormalIfUnless
  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IfWithSemicolon
end

class RuboCop::Cop::Style::ImplicitRuntimeError
  def implicit_runtime_error_raise_or_fail(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ImplicitRuntimeError
end

class RuboCop::Cop::Style::InfiniteLoop
  def autocorrect(node); end

  def on_until(node); end

  def on_until_post(node); end

  def on_while(node); end

  def on_while_post(node); end
  LEADING_SPACE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InfiniteLoop
end

class RuboCop::Cop::Style::InlineComment
  def investigate(processed_source); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InlineComment
end

class RuboCop::Cop::Style::InverseMethods
  def autocorrect(node); end

  def correct_inverse_block(node); end

  def correct_inverse_selector(block, corrector); end

  def inverse_block?(node=T.unsafe(nil)); end

  def inverse_candidate?(node=T.unsafe(nil)); end

  def on_block(node); end

  def on_send(node); end
  CAMEL_CASE = ::T.let(nil, ::T.untyped)
  CLASS_COMPARISON_METHODS = ::T.let(nil, ::T.untyped)
  EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NEGATED_EQUALITY_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::InverseMethods
end

class RuboCop::Cop::Style::IpAddresses
  include ::RuboCop::Cop::StringHelp
  def correct_style_detected(); end

  def offense?(node); end

  def opposite_style_detected(); end
  IPV6_MAX_SIZE = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::IpAddresses
end

class RuboCop::Cop::Style::Lambda
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def lambda_node?(node=T.unsafe(nil)); end

  def on_block(node); end
  LITERAL_MESSAGE = ::T.let(nil, ::T.untyped)
  METHOD_MESSAGE = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Lambda
end

class RuboCop::Cop::Style::LambdaCall
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
end

class RuboCop::Cop::Style::LambdaCall
end

class RuboCop::Cop::Style::LineEndConcatenation
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(operator_range); end

  def investigate(processed_source); end
  COMPLEX_STRING_EDGE_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  CONCAT_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  HIGH_PRECEDENCE_OP_TOKEN_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  QUOTE_DELIMITERS = ::T.let(nil, ::T.untyped)
  SIMPLE_STRING_TOKEN_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::LineEndConcatenation
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_send(node); end

  def on_super(node); end

  def on_yield(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithArgsParentheses
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_send(node); end
  ASGN_NODES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCallWithoutArgsParentheses
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodCalledOnDoEndBlock
end

class RuboCop::Cop::Style::MethodDefParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG_MISSING = ::T.let(nil, ::T.untyped)
  MSG_PRESENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodDefParentheses
end

class RuboCop::Cop::Style::MethodMissingSuper
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MethodMissingSuper
end

class RuboCop::Cop::Style::MinMax
  def autocorrect(node); end

  def min_max_candidate(node=T.unsafe(nil)); end

  def on_array(node); end

  def on_return(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MinMax
end

class RuboCop::Cop::Style::MissingElse
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def on_case(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_EMPTY = ::T.let(nil, ::T.untyped)
  MSG_NIL = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingElse
end

class RuboCop::Cop::Style::MissingRespondToMissing
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MissingRespondToMissing
end

class RuboCop::Cop::Style::MixinGrouping
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_class(node); end

  def on_module(node); end
  MIXIN_METHODS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinGrouping
end

class RuboCop::Cop::Style::MixinUsage
  def include_statement(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MixinUsage
end

class RuboCop::Cop::Style::ModuleFunction
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def extend_self_node?(node=T.unsafe(nil)); end

  def module_function_node?(node=T.unsafe(nil)); end

  def on_module(node); end
  EXTEND_SELF_MSG = ::T.let(nil, ::T.untyped)
  MODULE_FUNCTION_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ModuleFunction
end

class RuboCop::Cop::Style::MultilineBlockChain
  include ::RuboCop::Cop::RangeHelp
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineBlockChain
end

class RuboCop::Cop::Style::MultilineIfModifier
  include ::RuboCop::Cop::StatementModifier
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfModifier
end

class RuboCop::Cop::Style::MultilineIfThen
  include ::RuboCop::Cop::OnNormalIfUnless
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
  NON_MODIFIER_THEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineIfThen
end

class RuboCop::Cop::Style::MultilineMemoization
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_or_asgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMemoization
end

class RuboCop::Cop::Style::MultilineMethodSignature
  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineMethodSignature
end

class RuboCop::Cop::Style::MultilineTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultilineTernaryOperator
end

class RuboCop::Cop::Style::MultipleComparison
  def on_or(node); end

  def simple_comparison?(node=T.unsafe(nil)); end

  def simple_double_comparison?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MultipleComparison
end

class RuboCop::Cop::Style::MutableConstant
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(node); end

  def on_casgn(node); end

  def on_or_asgn(node); end

  def splat_value(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::MutableConstant
end

class RuboCop::Cop::Style::NegatedIf
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_if(node); end
end

class RuboCop::Cop::Style::NegatedIf
end

class RuboCop::Cop::Style::NegatedWhile
  include ::RuboCop::Cop::NegativeConditional
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::NegatedWhile
end

class RuboCop::Cop::Style::NestedModifier
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check(node); end

  def left_hand_operand(node, operator); end

  def modifier?(node); end

  def new_expression(outer_node, inner_node); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end

  def replacement_operator(keyword); end

  def requires_parens?(node); end

  def right_hand_operand(node, left_hand_keyword); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedModifier
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(nested); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedParenthesizedCalls
end

class RuboCop::Cop::Style::NestedTernaryOperator
  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NestedTernaryOperator
end

class RuboCop::Cop::Style::Next
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::MinBodyLength
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def investigate(_processed_source); end

  def on_block(node); end

  def on_for(node); end

  def on_until(node); end

  def on_while(node); end
  EXIT_TYPES = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Next
end

class RuboCop::Cop::Style::NilComparison
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def nil_comparison?(node=T.unsafe(nil)); end

  def on_send(node); end
  EXPLICIT_MSG = ::T.let(nil, ::T.untyped)
  PREDICATE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NilComparison
end

class RuboCop::Cop::Style::NonNilCheck
  def autocorrect(node); end

  def nil_check?(node=T.unsafe(nil)); end

  def not_and_nil_check?(node=T.unsafe(nil)); end

  def not_equal_to_nil?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end

  def on_send(node); end

  def unless_check?(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::NonNilCheck
end

class RuboCop::Cop::Style::Not
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPPOSITE_METHODS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Not
end

class RuboCop::Cop::Style::NumericLiteralPrefix
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_int(node); end
  BINARY_MSG = ::T.let(nil, ::T.untyped)
  BINARY_REGEX = ::T.let(nil, ::T.untyped)
  DECIMAL_MSG = ::T.let(nil, ::T.untyped)
  DECIMAL_REGEX = ::T.let(nil, ::T.untyped)
  HEX_MSG = ::T.let(nil, ::T.untyped)
  HEX_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_REGEX = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_MSG = ::T.let(nil, ::T.untyped)
  OCTAL_ZERO_ONLY_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiteralPrefix
end

class RuboCop::Cop::Style::NumericLiterals
  include ::RuboCop::Cop::ConfigurableMax
  include ::RuboCop::Cop::IntegerNode
  def autocorrect(node); end

  def on_float(node); end

  def on_int(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericLiterals
end

class RuboCop::Cop::Style::NumericPredicate
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def comparison(node=T.unsafe(nil)); end

  def inverted_comparison(node=T.unsafe(nil)); end

  def on_send(node); end

  def predicate(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  REPLACEMENTS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::NumericPredicate
end

class RuboCop::Cop::Style::OneLineConditional
  include ::RuboCop::Cop::OnNormalIfUnless
  def autocorrect(node); end

  def on_normal_if_unless(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OneLineConditional
end

class RuboCop::Cop::Style::OptionHash
  def on_args(node); end

  def option_hash(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionHash
end

class RuboCop::Cop::Style::OptionalArguments
  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OptionalArguments
end

class RuboCop::Cop::Style::OrAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_gvasgn(node); end

  def on_if(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end

  def ternary_assignment?(node=T.unsafe(nil)); end

  def unless_assignment?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::OrAssignment
end

class RuboCop::Cop::Style::ParallelAssignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def implicit_self_getter?(node=T.unsafe(nil)); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  include ::TSort
  def accesses?(rhs, lhs); end

  def dependency?(lhs, rhs); end

  def initialize(assignments); end

  def matching_calls(node0, param1, param2); end

  def tsort_each_child(assignment); end

  def uses_var?(node0, param1); end

  def var_name(node=T.unsafe(nil)); end
end

class RuboCop::Cop::Style::ParallelAssignment::AssignmentSorter
  extend ::RuboCop::NodePattern::Macros
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
  include ::RuboCop::Cop::Alignment
  def assignment(); end

  def config(); end

  def correction(); end

  def correction_range(); end

  def initialize(node, config, new_elements); end

  def node(); end
end

class RuboCop::Cop::Style::ParallelAssignment::GenericCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::ModifierCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment::RescueCorrector
end

class RuboCop::Cop::Style::ParallelAssignment
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::Parentheses
  def autocorrect(node); end

  def control_op_condition(node=T.unsafe(nil)); end

  def on_if(node); end

  def on_until(node); end

  def on_while(node); end
end

class RuboCop::Cop::Style::ParenthesesAroundCondition
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def message(node); end

  def on_array(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_str(node); end

  def on_sym(node); end

  def on_xstr(node); end
end

class RuboCop::Cop::Style::PercentLiteralDelimiters
end

class RuboCop::Cop::Style::PercentQLiterals
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_str(node); end
  LOWER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
  UPPER_CASE_Q_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PercentQLiterals
end

class RuboCop::Cop::Style::PerlBackrefs
  def autocorrect(node); end

  def on_nth_ref(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PerlBackrefs
end

class RuboCop::Cop::Style::PreferredHashMethods
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OFFENDING_SELECTORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::PreferredHashMethods
end

class RuboCop::Cop::Style::Proc
  def autocorrect(node); end

  def on_block(node); end

  def proc_new?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Proc
end

class RuboCop::Cop::Style::RaiseArgs
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  COMPACT_MSG = ::T.let(nil, ::T.untyped)
  EXPLODED_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RaiseArgs
end

class RuboCop::Cop::Style::RandomWithOffset
  def autocorrect(node); end

  def integer_op_rand?(node=T.unsafe(nil)); end

  def on_send(node); end

  def rand_modified?(node=T.unsafe(nil)); end

  def rand_op_integer?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RandomWithOffset
end

class RuboCop::Cop::Style::RedundantBegin
  def autocorrect(node); end

  def on_block(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantBegin
end

class RuboCop::Cop::Style::RedundantConditional
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_if(node); end

  def redundant_condition?(node=T.unsafe(nil)); end

  def redundant_condition_inverted?(node=T.unsafe(nil)); end
  COMPARISON_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantConditional
end

class RuboCop::Cop::Style::RedundantException
  def autocorrect(node); end

  def compact?(node=T.unsafe(nil)); end

  def exploded?(node=T.unsafe(nil)); end

  def on_send(node); end
  MSG_1 = ::T.let(nil, ::T.untyped)
  MSG_2 = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantException
end

class RuboCop::Cop::Style::RedundantFreeze
  include ::RuboCop::Cop::FrozenStringLiteral
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantFreeze
end

class RuboCop::Cop::Style::RedundantParentheses
  include ::RuboCop::Cop::Parentheses
  def arg_in_call_with_block?(node=T.unsafe(nil)); end

  def autocorrect(node); end

  def first_send_argument?(node=T.unsafe(nil)); end

  def first_super_argument?(node=T.unsafe(nil)); end

  def method_node_and_args(node=T.unsafe(nil)); end

  def on_begin(node); end

  def range_end?(node=T.unsafe(nil)); end

  def rescue?(node=T.unsafe(nil)); end

  def square_brackets?(node=T.unsafe(nil)); end
  ALLOWED_LITERALS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantParentheses
end

class RuboCop::Cop::Style::RedundantReturn
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MULTI_RETURN_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantReturn
end

class RuboCop::Cop::Style::RedundantSelf
  def autocorrect(node); end

  def on_and_asgn(node); end

  def on_args(node); end

  def on_block(node); end

  def on_blockarg(node); end

  def on_def(node); end

  def on_defs(node); end

  def on_lvasgn(node); end

  def on_op_asgn(node); end

  def on_or_asgn(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RedundantSelf
end

class RuboCop::Cop::Style::RegexpLiteral
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_regexp(node); end
  MSG_USE_PERCENT_R = ::T.let(nil, ::T.untyped)
  MSG_USE_SLASHES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RegexpLiteral
end

class RuboCop::Cop::Style::RescueModifier
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::RescueNode
  def autocorrect(node); end

  def on_resbody(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueModifier
end

class RuboCop::Cop::Style::RescueStandardError
  include ::RuboCop::Cop::RescueNode
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_resbody(node); end

  def rescue_standard_error?(node=T.unsafe(nil)); end

  def rescue_without_error_class?(node=T.unsafe(nil)); end
  MSG_EXPLICIT = ::T.let(nil, ::T.untyped)
  MSG_IMPLICIT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::RescueStandardError
end

class RuboCop::Cop::Style::ReturnNil
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def chained_send?(node=T.unsafe(nil)); end

  def define_method?(node=T.unsafe(nil)); end

  def on_return(node); end

  def return_nil_node?(node=T.unsafe(nil)); end

  def return_node?(node=T.unsafe(nil)); end
  RETURN_MSG = ::T.let(nil, ::T.untyped)
  RETURN_NIL_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ReturnNil
end

class RuboCop::Cop::Style::SafeNavigation
  include ::RuboCop::Cop::NilMethods
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def check_node(node); end

  def modifier_if_safe_navigation_candidate?(node=T.unsafe(nil)); end

  def not_nil_check?(node=T.unsafe(nil)); end

  def on_and(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SafeNavigation
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::SelfAssignment
  def autocorrect(node); end

  def on_cvasgn(node); end

  def on_ivasgn(node); end

  def on_lvasgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  OPS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SelfAssignment
end

class RuboCop::Cop::Style::Semicolon
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def investigate(processed_source); end

  def on_begin(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Semicolon
end

class RuboCop::Cop::Style::Send
  def on_send(node); end

  def sending?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::Send
end

class RuboCop::Cop::Style::SignalException
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def custom_fail_methods(node0); end

  def investigate(processed_source); end

  def kernel_call?(node=T.unsafe(nil), param1); end

  def on_rescue(node); end

  def on_send(node); end
  FAIL_MSG = ::T.let(nil, ::T.untyped)
  RAISE_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SignalException
end

class RuboCop::Cop::Style::SingleLineBlockParams
  def on_block(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineBlockParams
end

class RuboCop::Cop::Style::SingleLineMethods
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SingleLineMethods
end

class RuboCop::Cop::Style::SpecialGlobalVars
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def message(node); end

  def on_gvar(node); end
  ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  MSG_BOTH = ::T.let(nil, ::T.untyped)
  MSG_ENGLISH = ::T.let(nil, ::T.untyped)
  MSG_REGULAR = ::T.let(nil, ::T.untyped)
  NON_ENGLISH_VARS = ::T.let(nil, ::T.untyped)
  PERL_VARS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SpecialGlobalVars
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  def autocorrect(node); end

  def on_send(node); end
  MSG_NO_REQUIRE = ::T.let(nil, ::T.untyped)
  MSG_REQUIRE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StabbyLambdaParentheses
end

class RuboCop::Cop::Style::StderrPuts
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end

  def stderr_puts?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StderrPuts
end

class RuboCop::Cop::Style::StringHashKeys
  def autocorrect(node); end

  def on_pair(node); end

  def receive_environments_method?(node=T.unsafe(nil)); end

  def string_hash_key?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringHashKeys
end

class RuboCop::Cop::Style::StringLiterals
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG_INCONSISTENT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringLiterals
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::StringLiteralsHelp
  include ::RuboCop::Cop::StringHelp
  def autocorrect(node); end
end

class RuboCop::Cop::Style::StringLiteralsInInterpolation
end

class RuboCop::Cop::Style::StringMethods
  include ::RuboCop::Cop::MethodPreference
  def autocorrect(node); end

  def on_send(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StringMethods
end

class RuboCop::Cop::Style::StructInheritance
  def on_class(node); end

  def struct_constructor?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::StructInheritance
end

class RuboCop::Cop::Style::SymbolArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::SymbolLiteral
  def autocorrect(node); end

  def on_sym(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolLiteral
end

class RuboCop::Cop::Style::SymbolProc
  include ::RuboCop::Cop::RangeHelp
  include ::RuboCop::Cop::IgnoredMethods
  def autocorrect(node); end

  def on_block(node); end

  def proc_node?(node=T.unsafe(nil)); end

  def symbol_proc?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
  SUPER_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::SymbolProc
end

class RuboCop::Cop::Style::TernaryCorrector
end

class RuboCop::Cop::Style::TernaryCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(node); end

  def self.move_assignment_inside_condition(node); end
end

class RuboCop::Cop::Style::TernaryParentheses
  include ::RuboCop::Cop::SafeAssignment
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def method_call_argument(node=T.unsafe(nil)); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  MSG_COMPLEX = ::T.let(nil, ::T.untyped)
  NON_COMPLEX_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TernaryParentheses
end

class RuboCop::Cop::Style::TrailingBodyOnClass
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_class(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnClass
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnMethodDefinition
end

class RuboCop::Cop::Style::TrailingBodyOnModule
  include ::RuboCop::Cop::Alignment
  include ::RuboCop::Cop::TrailingBody
  def autocorrect(node); end

  def on_module(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingBodyOnModule
end

class RuboCop::Cop::Style::TrailingCommaInArguments
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_send(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArguments
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_array(node); end
end

class RuboCop::Cop::Style::TrailingCommaInArrayLiteral
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
  include ::RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(range); end

  def on_hash(node); end
end

class RuboCop::Cop::Style::TrailingCommaInHashLiteral
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
  include ::RuboCop::Cop::Alignment
  def autocorrect(node); end

  def on_def(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingMethodEndStatement
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
  include ::RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_masgn(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNDERSCORE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrailingUnderscoreVariable
end

class RuboCop::Cop::Style::TrivialAccessors
  def autocorrect(node); end

  def looks_like_trivial_writer?(node=T.unsafe(nil)); end

  def on_def(node); end

  def on_defs(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::TrivialAccessors
end

class RuboCop::Cop::Style::UnlessCorrector
end

class RuboCop::Cop::Style::UnlessCorrector
  extend ::RuboCop::Cop::Style::ConditionalAssignmentHelper
  extend ::RuboCop::Cop::Style::ConditionalCorrectorHelper
  def self.correct(cop, node); end
end

class RuboCop::Cop::Style::UnlessElse
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end

  def range_between_condition_and_else(node, condition); end

  def range_between_else_and_end(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnlessElse
end

class RuboCop::Cop::Style::UnneededCapitalW
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_array(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededCapitalW
end

class RuboCop::Cop::Style::UnneededCondition
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_if(node); end
  MSG = ::T.let(nil, ::T.untyped)
  UNNEEDED_CONDITION = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededCondition
end

class RuboCop::Cop::Style::UnneededInterpolation
  include ::RuboCop::Cop::PercentLiteral
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_dstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededInterpolation
end

class RuboCop::Cop::Style::UnneededPercentQ
  def autocorrect(node); end

  def on_dstr(node); end

  def on_str(node); end
  DYNAMIC_MSG = ::T.let(nil, ::T.untyped)
  EMPTY = ::T.let(nil, ::T.untyped)
  ESCAPED_NON_BACKSLASH = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  PERCENT_CAPITAL_Q = ::T.let(nil, ::T.untyped)
  PERCENT_Q = ::T.let(nil, ::T.untyped)
  QUOTE = ::T.let(nil, ::T.untyped)
  SINGLE_QUOTE = ::T.let(nil, ::T.untyped)
  STRING_INTERPOLATION_REGEXP = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnneededPercentQ
end

class RuboCop::Cop::Style::UnpackFirst
  def autocorrect(node); end

  def on_send(node); end

  def unpack_and_first_element?(node=T.unsafe(nil)); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::UnpackFirst
  extend ::RuboCop::Cop::TargetRubyVersion
end

class RuboCop::Cop::Style::VariableInterpolation
  def autocorrect(node); end

  def on_dstr(node); end

  def on_regexp(node); end

  def on_xstr(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::VariableInterpolation
end

class RuboCop::Cop::Style::WhenThen
  def autocorrect(node); end

  def on_when(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhenThen
end

class RuboCop::Cop::Style::WhileUntilDo
  def autocorrect(node); end

  def handle(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilDo
end

class RuboCop::Cop::Style::WhileUntilModifier
  include ::RuboCop::Cop::StatementModifier
  def autocorrect(node); end

  def on_until(node); end

  def on_while(node); end
  MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WhileUntilModifier
end

class RuboCop::Cop::Style::WordArray
  include ::RuboCop::Cop::ArrayMinSize
  include ::RuboCop::Cop::ArraySyntax
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::PercentArray
  def autocorrect(node); end

  def on_array(node); end
  ARRAY_MSG = ::T.let(nil, ::T.untyped)
  PERCENT_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::WordArray
  def self.largest_brackets(); end

  def self.largest_brackets=(largest_brackets); end
end

class RuboCop::Cop::Style::YodaCondition
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  def autocorrect(node); end

  def on_send(node); end
  EQUALITY_OPERATORS = ::T.let(nil, ::T.untyped)
  MSG = ::T.let(nil, ::T.untyped)
  NONCOMMUTATIVE_OPERATORS = ::T.let(nil, ::T.untyped)
  REVERSE_COMPARISON = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::YodaCondition
end

class RuboCop::Cop::Style::ZeroLengthPredicate
  def autocorrect(node); end

  def non_polymorphic_collection?(node=T.unsafe(nil)); end

  def nonzero_length_predicate(node=T.unsafe(nil)); end

  def on_send(node); end

  def other_receiver(node=T.unsafe(nil)); end

  def zero_length_predicate(node=T.unsafe(nil)); end

  def zero_length_receiver(node=T.unsafe(nil)); end
  NONZERO_MSG = ::T.let(nil, ::T.untyped)
  ZERO_MSG = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Style::ZeroLengthPredicate
end

module RuboCop::Cop::Style
  extend ::T::Sig
end

module RuboCop::Cop::SurroundingSpace
  include ::RuboCop::Cop::RangeHelp
  NO_SPACE_COMMAND = ::T.let(nil, ::T.untyped)
  SPACE_COMMAND = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::SurroundingSpace
  extend ::T::Sig
end

module RuboCop::Cop::TargetRailsVersion
  def minimum_target_rails_version(version); end

  def support_target_rails_version?(version); end
end

module RuboCop::Cop::TargetRailsVersion
  extend ::T::Sig
end

module RuboCop::Cop::TargetRubyVersion
  def minimum_target_ruby_version(version); end

  def support_target_ruby_version?(version); end
end

module RuboCop::Cop::TargetRubyVersion
  extend ::T::Sig
end

class RuboCop::Cop::Team
  def autocorrect(buffer, cops); end

  def autocorrect?(); end

  def cops(); end

  def debug?(); end

  def errors(); end

  def forces(); end

  def forces_for(cops); end

  def initialize(cop_classes, config, options=T.unsafe(nil)); end

  def inspect_file(processed_source); end

  def updated_source_file(); end

  def updated_source_file?(); end

  def warnings(); end
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::Team::Investigation
  def errors(); end

  def errors=(_); end

  def offenses(); end

  def offenses=(_); end
end

class RuboCop::Cop::Team::Investigation
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::Team
end

module RuboCop::Cop::TooManyLines
  include ::RuboCop::Cop::CodeLength
  include ::RuboCop::Cop::ConfigurableMax
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TooManyLines
  extend ::T::Sig
end

module RuboCop::Cop::TrailingBody
  def body_on_first_line?(node, body); end

  def first_part_of(body); end

  def trailing_body?(node); end
end

module RuboCop::Cop::TrailingBody
  extend ::T::Sig
end

module RuboCop::Cop::TrailingComma
  include ::RuboCop::Cop::ConfigurableEnforcedStyle
  include ::RuboCop::Cop::RangeHelp
  MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::TrailingComma
  extend ::T::Sig
end

module RuboCop::Cop::UncommunicativeName
  def check(node, args); end
  CASE_MSG = ::T.let(nil, ::T.untyped)
  FORBIDDEN_MSG = ::T.let(nil, ::T.untyped)
  LENGTH_MSG = ::T.let(nil, ::T.untyped)
  NUM_MSG = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::UncommunicativeName
  extend ::T::Sig
end

class RuboCop::Cop::UnusedArgCorrector
end

class RuboCop::Cop::UnusedArgCorrector
  extend ::RuboCop::Cop::RangeHelp
  def self.correct(processed_source, node); end

  def self.processed_source(); end
end

module RuboCop::Cop::Util
  include ::RuboCop::PathUtil
  ASGN_NODES = ::T.let(nil, ::T.untyped)
  CONDITIONAL_NODES = ::T.let(nil, ::T.untyped)
  EQUALS_ASGN_NODES = ::T.let(nil, ::T.untyped)
  LITERAL_REGEX = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_NODES = ::T.let(nil, ::T.untyped)
  MODIFIER_NODES = ::T.let(nil, ::T.untyped)
  OPERATOR_METHODS = ::T.let(nil, ::T.untyped)
  SHORTHAND_ASGN_NODES = ::T.let(nil, ::T.untyped)
end

module RuboCop::Cop::Util
  extend ::RuboCop::AST::Sexp
  extend ::T::Sig
  def self.begins_its_line?(range); end

  def self.comment_line?(line_source); end

  def self.double_quotes_required?(string); end

  def self.escape_string(string); end

  def self.first_part_of_call_chain(node); end

  def self.interpret_string_escapes(string); end

  def self.line_range(node); end

  def self.needs_escaping?(string); end

  def self.on_node(syms, sexp, excludes=T.unsafe(nil), &block); end

  def self.operator?(symbol); end

  def self.parentheses?(node); end

  def self.same_line?(node1, node2); end

  def self.to_string_literal(string); end

  def self.to_supported_styles(enforced_style); end

  def self.tokens(node); end
end

class RuboCop::Cop::VariableForce
  def investigate(processed_source); end

  def process_node(node); end

  def variable_table(); end
  ARGUMENT_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
  LOGICAL_OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  LOOP_TYPES = ::T.let(nil, ::T.untyped)
  MULTIPLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  OPERATOR_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  POST_CONDITION_LOOP_TYPES = ::T.let(nil, ::T.untyped)
  REGEXP_NAMED_CAPTURE_TYPE = ::T.let(nil, ::T.untyped)
  RESCUE_TYPE = ::T.let(nil, ::T.untyped)
  SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  SEND_TYPE = ::T.let(nil, ::T.untyped)
  TWISTED_SCOPE_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPE = ::T.let(nil, ::T.untyped)
  VARIABLE_ASSIGNMENT_TYPES = ::T.let(nil, ::T.untyped)
  VARIABLE_REFERENCE_TYPE = ::T.let(nil, ::T.untyped)
  ZERO_ARITY_SUPER_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
  include ::RuboCop::Cop::VariableForce::Branchable
  def initialize(node, variable); end

  def meta_assignment_node(); end

  def multiple_assignment?(); end

  def name(); end

  def node(); end

  def operator(); end

  def operator_assignment?(); end

  def reference!(node); end

  def referenced(); end

  def referenced?(); end

  def references(); end

  def regexp_named_capture?(); end

  def scope(); end

  def used?(); end

  def variable(); end
  MULTIPLE_LEFT_HAND_SIDE_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Assignment
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def assignment?(); end

  def node(); end

  def node=(_); end
end

class RuboCop::Cop::VariableForce::AssignmentReference
  def self.[](*_); end

  def self.members(); end
end

module RuboCop::Cop::VariableForce::Branch
  CLASSES_BY_TYPE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Branch::And
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::And
end

class RuboCop::Cop::VariableForce::Branch::Base
  def ==(other); end

  def always_run?(); end

  def branched?(); end

  def child_node(); end

  def child_node=(_); end

  def control_node(); end

  def each_ancestor(include_self: T.unsafe(nil), &block); end

  def eql?(other); end

  def exclusive_with?(other); end

  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end

  def parent(); end

  def scope(); end

  def scope=(_); end
end

class RuboCop::Cop::VariableForce::Branch::Base
  def self.[](*_); end

  def self.classes(); end

  def self.define_predicate(name, child_index: T.unsafe(nil)); end

  def self.inherited(subclass); end

  def self.members(); end

  def self.type(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
  def else_body?(); end

  def target?(); end

  def when_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Case
end

class RuboCop::Cop::VariableForce::Branch::Ensure
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def ensure_body?(); end

  def main_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Ensure
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def may_jump_to_other_branch?(); end

  def may_run_incompletely?(); end
end

module RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  extend ::T::Sig
end

class RuboCop::Cop::VariableForce::Branch::For
  def collection?(); end

  def element?(); end

  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::For
end

class RuboCop::Cop::VariableForce::Branch::If
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def falsey_body?(); end

  def truthy_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::If
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def always_run?(); end
end

module RuboCop::Cop::VariableForce::Branch::LogicalOperator
  extend ::T::Sig
end

class RuboCop::Cop::VariableForce::Branch::Or
  include ::RuboCop::Cop::VariableForce::Branch::LogicalOperator
  def left_body?(); end

  def right_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Or
end

class RuboCop::Cop::VariableForce::Branch::Rescue
  include ::RuboCop::Cop::VariableForce::Branch::ExceptionHandler
  def else_body?(); end

  def main_body?(); end

  def rescue_clause?(); end
end

class RuboCop::Cop::VariableForce::Branch::Rescue
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def always_run?(); end

  def conditional_clause?(); end
end

module RuboCop::Cop::VariableForce::Branch::SimpleConditional
  extend ::T::Sig
end

class RuboCop::Cop::VariableForce::Branch::Until
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::Until
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::UntilPost
end

class RuboCop::Cop::VariableForce::Branch::While
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::While
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
  include ::RuboCop::Cop::VariableForce::Branch::SimpleConditional
  def loop_body?(); end
end

class RuboCop::Cop::VariableForce::Branch::WhilePost
end

module RuboCop::Cop::VariableForce::Branch
  extend ::T::Sig
  def self.of(target_node, scope: T.unsafe(nil)); end
end

module RuboCop::Cop::VariableForce::Branchable
  def branch(); end

  def run_exclusively_with?(other); end
end

module RuboCop::Cop::VariableForce::Branchable
  extend ::T::Sig
end

class RuboCop::Cop::VariableForce::Reference
  include ::RuboCop::Cop::VariableForce::Branchable
  def explicit?(); end

  def initialize(node, scope); end

  def node(); end

  def scope(); end
  VARIABLE_REFERENCE_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Reference
end

class RuboCop::Cop::VariableForce::Scope
  def ==(other); end

  def body_node(); end

  def each_node(&block); end

  def include?(target_node); end

  def initialize(node); end

  def naked_top_level(); end

  def naked_top_level?(); end

  def name(); end

  def node(); end

  def variables(); end
  OUTER_SCOPE_CHILD_INDICES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Scope
end

class RuboCop::Cop::VariableForce::Variable
  def argument?(); end

  def assign(node); end

  def assignments(); end

  def block_argument?(); end

  def capture_with_block!(); end

  def captured_by_block(); end

  def captured_by_block?(); end

  def declaration_node(); end

  def explicit_block_local_variable?(); end

  def initialize(name, declaration_node, scope); end

  def keyword_argument?(); end

  def method_argument?(); end

  def name(); end

  def reference!(node); end

  def referenced?(); end

  def references(); end

  def scope(); end

  def should_be_unused?(); end

  def used?(); end
  VARIABLE_DECLARATION_TYPES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Cop::VariableForce::Variable
end

class RuboCop::Cop::VariableForce::VariableReference
  def assignment?(); end

  def name(); end

  def name=(_); end
end

class RuboCop::Cop::VariableForce::VariableReference
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Cop::VariableForce::VariableTable
  def accessible_variables(); end

  def assign_to_variable(name, node); end

  def current_scope(); end

  def current_scope_level(); end

  def declare_variable(name, node); end

  def find_variable(name); end

  def initialize(hook_receiver=T.unsafe(nil)); end

  def invoke_hook(hook_name, *args); end

  def pop_scope(); end

  def push_scope(scope_node); end

  def reference_variable(name, node); end

  def scope_stack(); end

  def variable_exist?(name); end
end

class RuboCop::Cop::VariableForce::VariableTable
end

class RuboCop::Cop::VariableForce
end

module RuboCop::Cop
  extend ::T::Sig
end

class RuboCop::Error
end

class RuboCop::Error
end

module RuboCop::FileFinder
  def find_file_upwards(filename, start_dir, use_home: T.unsafe(nil)); end

  def find_files_upwards(filename, start_dir, use_home: T.unsafe(nil)); end
end

module RuboCop::FileFinder
  extend ::T::Sig
  def self.root_level=(level); end

  def self.root_level?(path); end
end

module RuboCop::Formatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::AutoGenConfigFormatter
end

class RuboCop::Formatter::BaseFormatter
  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(inspected_files); end

  def initialize(output, options=T.unsafe(nil)); end

  def options(); end

  def output(); end

  def started(target_files); end
end

class RuboCop::Formatter::BaseFormatter
end

class RuboCop::Formatter::ClangStyleFormatter
  ELLIPSES = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ClangStyleFormatter
end

module RuboCop::Formatter::Colorizable
  def black(string); end

  def blue(string); end

  def colorize(string, *args); end

  def cyan(string); end

  def green(string); end

  def magenta(string); end

  def rainbow(); end

  def red(string); end

  def white(string); end

  def yellow(string); end
end

module RuboCop::Formatter::Colorizable
  extend ::T::Sig
end

class RuboCop::Formatter::DisabledConfigFormatter
  def file_started(_file, _file_info); end

  def finished(_inspected_files); end
  HEADING = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::DisabledConfigFormatter
  def self.config_to_allow_offenses(); end

  def self.config_to_allow_offenses=(config_to_allow_offenses); end

  def self.detected_styles(); end

  def self.detected_styles=(detected_styles); end
end

class RuboCop::Formatter::DisabledLinesFormatter
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::Colorizable
  def cop_disabled_line_ranges(); end

  def finished(_inspected_files); end

  def started(_target_files); end
end

class RuboCop::Formatter::DisabledLinesFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::EmacsStyleFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FileListFormatter
end

class RuboCop::Formatter::FormatterSet
  def add_formatter(formatter_type, output_path=T.unsafe(nil)); end

  def close_output_files(); end

  def file_finished(file, offenses); end

  def file_started(file, options); end

  def finished(*args); end

  def initialize(options=T.unsafe(nil)); end

  def started(*args); end
  BUILTIN_FORMATTERS_FOR_KEYS = ::T.let(nil, ::T.untyped)
  FORMATTER_APIS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FormatterSet
end

class RuboCop::Formatter::FuubarStyleFormatter
  def initialize(*output); end

  def progressbar_color(); end

  def started(target_files); end

  def with_color(); end
  RESET_SEQUENCE = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::FuubarStyleFormatter
end

class RuboCop::Formatter::HTMLFormatter
  def files(); end

  def render_html(); end

  def summary(); end
  ELLIPSES = ::T.let(nil, ::T.untyped)
  TEMPLATE_PATH = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::Color
  def alpha(); end

  def alpha=(_); end

  def blue(); end

  def blue=(_); end

  def fade_out(amount); end

  def green(); end

  def green=(_); end

  def red(); end

  def red=(_); end
end

class RuboCop::Formatter::HTMLFormatter::Color
  def self.[](*_); end

  def self.members(); end
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
  include ::RuboCop::PathUtil
  include ::RuboCop::Formatter::TextUtil
  def base64_encoded_logo_image(); end

  def decorated_message(offense); end

  def escape(string); end

  def files(); end

  def highlighted_source_line(offense); end

  def hightlight_source_tag(offense); end

  def initialize(files, summary); end

  def possible_ellipses(location); end

  def source_after_highlight(offense); end

  def source_before_highlight(offense); end

  def summary(); end
  LOGO_IMAGE_PATH = ::T.let(nil, ::T.untyped)
  SEVERITY_COLORS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::HTMLFormatter::ERBContext
end

class RuboCop::Formatter::HTMLFormatter
end

class RuboCop::Formatter::JSONFormatter
  include ::RuboCop::PathUtil
  def hash_for_file(file, offenses); end

  def hash_for_location(offense); end

  def hash_for_offense(offense); end

  def metadata_hash(); end

  def output_hash(); end
end

class RuboCop::Formatter::JSONFormatter
end

class RuboCop::Formatter::OffenseCountFormatter
  def file_finished(_file, offenses); end

  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::OffenseCountFormatter
end

class RuboCop::Formatter::ProgressFormatter
  include ::RuboCop::Formatter::TextUtil
  def report_file_as_mark(offenses); end

  def started(target_files); end
  DOT = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::ProgressFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::QuietFormatter
end

class RuboCop::Formatter::SimpleTextFormatter
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::PathUtil
  def report_file(file, offenses); end

  def report_summary(file_count, offense_count, correction_count); end

  def started(_target_files); end
  COLOR_FOR_SEVERITY = ::T.let(nil, ::T.untyped)
end

class RuboCop::Formatter::SimpleTextFormatter::Report
  include ::RuboCop::Formatter::Colorizable
  include ::RuboCop::Formatter::TextUtil
  def initialize(file_count, offense_count, correction_count, rainbow); end

  def summary(); end
end

class RuboCop::Formatter::SimpleTextFormatter::Report
end

class RuboCop::Formatter::SimpleTextFormatter
end

class RuboCop::Formatter::TapFormatter
  def started(target_files); end
end

class RuboCop::Formatter::TapFormatter
end

module RuboCop::Formatter::TextUtil
end

module RuboCop::Formatter::TextUtil
  extend ::T::Sig
  def self.pluralize(number, thing, options=T.unsafe(nil)); end
end

class RuboCop::Formatter::WorstOffendersFormatter
  def finished(_inspected_files); end

  def offense_counts(); end

  def ordered_offense_counts(offense_counts); end

  def report_summary(offense_counts); end

  def total_offense_count(offense_counts); end
end

class RuboCop::Formatter::WorstOffendersFormatter
end

module RuboCop::Formatter
  extend ::T::Sig
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::IncorrectCopNameError
end

class RuboCop::MagicComment
  def any?(); end

  def encoding_specified?(); end

  def frozen_string_literal(); end

  def frozen_string_literal?(); end

  def frozen_string_literal_specified?(); end

  def initialize(comment); end
  TOKEN = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EditorComment
end

class RuboCop::MagicComment::EmacsComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::EmacsComment
end

class RuboCop::MagicComment::SimpleComment
  def encoding(); end
end

class RuboCop::MagicComment::SimpleComment
end

class RuboCop::MagicComment::VimComment
  def encoding(); end
  FORMAT = ::T.let(nil, ::T.untyped)
  OPERATOR = ::T.let(nil, ::T.untyped)
  SEPARATOR = ::T.let(nil, ::T.untyped)
end

class RuboCop::MagicComment::VimComment
end

class RuboCop::MagicComment
  def self.parse(comment); end
end

module RuboCop::NameSimilarity
  def find_similar_name(target_name, scope); end
  MINIMUM_SIMILARITY_TO_SUGGEST = ::T.let(nil, ::T.untyped)
end

module RuboCop::NameSimilarity
  extend ::T::Sig
end

class RuboCop::NodePattern
  def initialize(str); end
end

class RuboCop::NodePattern::Invalid
end

class RuboCop::NodePattern::Invalid
end

module RuboCop::NodePattern::Macros
  def def_node_matcher(method_name, pattern_str); end

  def def_node_search(method_name, pattern_str); end

  def node_search(method_name, compiler, on_match, prelude, called_from); end

  def node_search_all(method_name, compiler, called_from); end

  def node_search_body(method_name, trailing_params, prelude, match_code, on_match); end

  def node_search_first(method_name, compiler, called_from); end
end

module RuboCop::NodePattern::Macros
  extend ::T::Sig
end

class RuboCop::NodePattern
end

class RuboCop::OptionArgumentError
end

class RuboCop::OptionArgumentError
end

class RuboCop::Options
  def parse(command_line_args); end
  DEFAULT_MAXIMUM_EXCLUSION_ITEMS = ::T.let(nil, ::T.untyped)
  EXITING_OPTIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Options
end

module RuboCop::OptionsHelp
  MAX_EXCL = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
end

module RuboCop::OptionsHelp
  extend ::T::Sig
end

class RuboCop::OptionsValidator
  def boolean_or_empty_cache?(); end

  def display_only_fail_level_offenses_with_autocorrect?(); end

  def except_syntax?(); end

  def incompatible_options(); end

  def initialize(options); end

  def only_includes_unneeded_disable?(); end

  def validate_auto_gen_config(); end

  def validate_compatibility(); end

  def validate_exclude_limit_option(); end

  def validate_parallel(); end

  def validate_parallel_with_combo_option(); end
end

class RuboCop::OptionsValidator
  def self.validate_cop_list(names); end
end

module RuboCop::PathUtil
end

module RuboCop::PathUtil
  extend ::T::Sig
  def self.absolute?(path); end

  def self.hidden_dir?(path); end

  def self.hidden_file_in_not_hidden_dir?(pattern, path); end

  def self.match_path?(pattern, path); end

  def self.pwd(); end

  def self.relative_path(path, base_dir=T.unsafe(nil)); end

  def self.reset_pwd(); end

  def self.smart_path(path); end
end

module RuboCop::Platform
end

module RuboCop::Platform
  extend ::T::Sig
  def self.windows?(); end
end

class RuboCop::ProcessedSource
  def [](*args); end

  def ast(); end

  def ast_with_comments(); end

  def buffer(); end

  def checksum(); end

  def comment_config(); end

  def commented?(source_range); end

  def comments(); end

  def comments_before_line(line); end

  def diagnostics(); end

  def disabled_line_ranges(); end

  def each_comment(); end

  def each_token(); end

  def file_path(); end

  def find_comment(); end

  def find_token(); end

  def following_line(token); end

  def initialize(source, ruby_version, path=T.unsafe(nil)); end

  def line_indentation(line_number); end

  def lines(); end

  def parser_error(); end

  def path(); end

  def preceding_line(token); end

  def raw_source(); end

  def ruby_version(); end

  def start_with?(string); end

  def tokens(); end

  def valid_syntax?(); end
  STRING_SOURCE_NAME = ::T.let(nil, ::T.untyped)
end

class RuboCop::ProcessedSource
  def self.from_file(path, ruby_version); end
end

class RuboCop::RemoteConfig
  def file(); end

  def inherit_from_remote(file, path); end

  def initialize(url, base_dir); end

  def uri(); end
  CACHE_LIFETIME = ::T.let(nil, ::T.untyped)
end

class RuboCop::RemoteConfig
end

class RuboCop::ResultCache
  def initialize(file, options, config_store, cache_root=T.unsafe(nil)); end

  def load(); end

  def save(offenses); end

  def valid?(); end
  NON_CHANGING = ::T.let(nil, ::T.untyped)
end

class RuboCop::ResultCache
  def self.allow_symlinks_in_cache_location?(config_store); end

  def self.cache_root(config_store); end

  def self.cleanup(config_store, verbose, cache_root=T.unsafe(nil)); end

  def self.inhibit_cleanup(); end

  def self.inhibit_cleanup=(inhibit_cleanup); end

  def self.source_checksum(); end

  def self.source_checksum=(source_checksum); end
end

class RuboCop::Runner
  def abort(); end

  def aborting(); end

  def aborting?(); end

  def errors(); end

  def initialize(options, config_store); end

  def run(paths); end

  def warnings(); end
  MAX_ITERATIONS = ::T.let(nil, ::T.untyped)
end

class RuboCop::Runner::InfiniteCorrectionLoop
  def initialize(path, offenses); end

  def offenses(); end
end

class RuboCop::Runner::InfiniteCorrectionLoop
end

class RuboCop::Runner
end

class RuboCop::StringInterpreter
  STRING_ESCAPES = ::T.let(nil, ::T.untyped)
  STRING_ESCAPE_REGEX = ::T.let(nil, ::T.untyped)
end

class RuboCop::StringInterpreter
  def self.interpret(string); end
end

module RuboCop::StringUtil
end

module RuboCop::StringUtil
  extend ::T::Sig
  def self.similarity(string_a, string_b); end
end

class RuboCop::TargetFinder
  def all_cops_include(); end

  def configured_include?(file); end

  def debug?(); end

  def excluded_dirs(base_dir); end

  def fail_fast?(); end

  def find(args); end

  def find_files(base_dir, flags); end

  def force_exclusion?(); end

  def included_file?(file); end

  def initialize(config_store, options=T.unsafe(nil)); end

  def process_explicit_path(path); end

  def ruby_executable?(file); end

  def ruby_extension?(file); end

  def ruby_extensions(); end

  def ruby_file?(file); end

  def ruby_filename?(file); end

  def ruby_filenames(); end

  def ruby_interpreters(file); end

  def stdin?(); end

  def target_files_in_dir(base_dir=T.unsafe(nil)); end

  def to_inspect?(file, hidden_files, base_dir_config); end

  def toplevel_dirs(base_dir, flags); end
end

class RuboCop::TargetFinder
end

class RuboCop::Token
  def begin_pos(); end

  def column(); end

  def comma?(); end

  def comment?(); end

  def end?(); end

  def end_pos(); end

  def equal_sign?(); end

  def initialize(pos, type, text); end

  def left_array_bracket?(); end

  def left_brace?(); end

  def left_bracket?(); end

  def left_curly_brace?(); end

  def left_parens?(); end

  def left_ref_bracket?(); end

  def line(); end

  def pos(); end

  def rescue_modifier?(); end

  def right_bracket?(); end

  def right_curly_brace?(); end

  def right_parens?(); end

  def semicolon?(); end

  def space_after?(); end

  def space_before?(); end

  def text(); end

  def type(); end
end

class RuboCop::Token
  def self.from_parser_token(parser_token); end
end

class RuboCop::ValidationError
end

class RuboCop::ValidationError
end

module RuboCop::Version
  MSG = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
end

module RuboCop::Version
  extend ::T::Sig
  def self.version(debug=T.unsafe(nil)); end
end

class RuboCop::Warning
end

class RuboCop::Warning
end

module RuboCop
  extend ::T::Sig
end

module RubyDep
  PROJECT_URL = ::T.let(nil, ::T.untyped)
end

class RubyDep::Logger
  def initialize(device, prefix); end

  def notice(msg); end

  def warning(msg); end
end

class RubyDep::Logger
end

class RubyDep::NullLogger
  def method_missing(method_name, *args, &block); end
  LOG_LEVELS = ::T.let(nil, ::T.untyped)
end

class RubyDep::NullLogger
end

class RubyDep::RubyVersion
  def engine(); end

  def initialize(ruby_version, engine); end

  def recognized?(); end

  def recommended(status); end

  def status(); end

  def version(); end
  VERSION_INFO = ::T.let(nil, ::T.untyped)
end

class RubyDep::RubyVersion
end

class RubyDep::Warning
  def show_warnings(); end

  def silence!(); end
  DISABLING_ENVIRONMENT_VAR = ::T.let(nil, ::T.untyped)
  NOTICE_BUGGY_ALTERNATIVE = ::T.let(nil, ::T.untyped)
  NOTICE_HOW_TO_DISABLE = ::T.let(nil, ::T.untyped)
  NOTICE_OPEN_ISSUE = ::T.let(nil, ::T.untyped)
  NOTICE_RECOMMENDATION = ::T.let(nil, ::T.untyped)
  PREFIX = ::T.let(nil, ::T.untyped)
  WARNING = ::T.let(nil, ::T.untyped)
end

class RubyDep::Warning
end

module RubyDep
  extend ::T::Sig
  def self.logger(); end

  def self.logger=(new_logger); end

  def self.stderr_logger(); end
end

class RubyLex
  include ::RubyToken
  def Fail(err=T.unsafe(nil), *rest); end

  def Raise(err=T.unsafe(nil), *rest); end

  def char_no(); end

  def each_top_level_statement(); end

  def eof?(); end

  def exception_on_syntax_error(); end

  def exception_on_syntax_error=(exception_on_syntax_error); end

  def get_readed(); end

  def getc(); end

  def getc_of_rests(); end

  def gets(); end

  def identify_comment(); end

  def identify_gvar(); end

  def identify_here_document(); end

  def identify_identifier(); end

  def identify_number(); end

  def identify_quotation(); end

  def identify_string(ltype, quoted=T.unsafe(nil)); end

  def identify_string_dvar(); end

  def indent(); end

  def initialize_input(); end

  def lex(); end

  def lex_init(); end

  def lex_int2(); end

  def line_no(); end

  def peek(i=T.unsafe(nil)); end

  def peek_equal?(str); end

  def peek_match?(regexp); end

  def prompt(); end

  def read_escape(); end

  def readed_auto_clean_up(); end

  def readed_auto_clean_up=(readed_auto_clean_up); end

  def seek(); end

  def set_input(io, p=T.unsafe(nil), &block); end

  def set_prompt(p=T.unsafe(nil), &block); end

  def skip_space(); end

  def skip_space=(skip_space); end

  def token(); end

  def ungetc(c=T.unsafe(nil)); end
  DEINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  DLtype2Token = ::T.let(nil, ::T.untyped)
  ENINDENT_CLAUSE = ::T.let(nil, ::T.untyped)
  Ltype2Token = ::T.let(nil, ::T.untyped)
  PERCENT_LTYPE = ::T.let(nil, ::T.untyped)
  PERCENT_PAREN = ::T.let(nil, ::T.untyped)
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::AlreadyDefinedToken
end

class RubyLex::SyntaxError
end

class RubyLex::SyntaxError
end

class RubyLex::TerminateLineInput
end

class RubyLex::TerminateLineInput
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenDuplicateError
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkReading2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex::TkSymbol2TokenNoKey
end

class RubyLex
  extend ::Exception2MessageMapper
  def self.debug?(); end

  def self.debug_level(); end

  def self.debug_level=(debug_level); end

  def self.included(mod); end
end

module RubyToken
  def Token(token, value=T.unsafe(nil)); end
  EXPR_ARG = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CLASS = ::T.let(nil, ::T.untyped)
  EXPR_DOT = ::T.let(nil, ::T.untyped)
  EXPR_END = ::T.let(nil, ::T.untyped)
  EXPR_FNAME = ::T.let(nil, ::T.untyped)
  EXPR_MID = ::T.let(nil, ::T.untyped)
  TkReading2Token = ::T.let(nil, ::T.untyped)
  TkSymbol2Token = ::T.let(nil, ::T.untyped)
  TokenDefinitions = ::T.let(nil, ::T.untyped)
end

class RubyToken::TkALIAS
end

class RubyToken::TkALIAS
end

class RubyToken::TkAMPER
end

class RubyToken::TkAMPER
end

class RubyToken::TkAND
end

class RubyToken::TkAND
end

class RubyToken::TkANDOP
end

class RubyToken::TkANDOP
end

class RubyToken::TkAREF
end

class RubyToken::TkAREF
end

class RubyToken::TkASET
end

class RubyToken::TkASET
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSIGN
end

class RubyToken::TkASSOC
end

class RubyToken::TkASSOC
end

class RubyToken::TkAT
end

class RubyToken::TkAT
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKQUOTE
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACKSLASH
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBACK_REF
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBEGIN
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITAND
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITNOT
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBITXOR
end

class RubyToken::TkBREAK
end

class RubyToken::TkBREAK
end

class RubyToken::TkCASE
end

class RubyToken::TkCASE
end

class RubyToken::TkCLASS
end

class RubyToken::TkCLASS
end

class RubyToken::TkCMP
end

class RubyToken::TkCMP
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON2
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOLON3
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMA
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCOMMENT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCONSTANT
end

class RubyToken::TkCVAR
end

class RubyToken::TkCVAR
end

class RubyToken::TkDEF
end

class RubyToken::TkDEF
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDEFINED
end

class RubyToken::TkDIV
end

class RubyToken::TkDIV
end

class RubyToken::TkDO
end

class RubyToken::TkDO
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOLLAR
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT2
end

class RubyToken::TkDOT3
end

class RubyToken::TkDOT3
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDREGEXP
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkDXSTRING
end

class RubyToken::TkELSE
end

class RubyToken::TkELSE
end

class RubyToken::TkELSIF
end

class RubyToken::TkELSIF
end

class RubyToken::TkEND
end

class RubyToken::TkEND
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkEND_OF_SCRIPT
end

class RubyToken::TkENSURE
end

class RubyToken::TkENSURE
end

class RubyToken::TkEQ
end

class RubyToken::TkEQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkEQQ
end

class RubyToken::TkError
end

class RubyToken::TkError
end

class RubyToken::TkFALSE
end

class RubyToken::TkFALSE
end

class RubyToken::TkFID
end

class RubyToken::TkFID
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFLOAT
end

class RubyToken::TkFOR
end

class RubyToken::TkFOR
end

class RubyToken::TkGEQ
end

class RubyToken::TkGEQ
end

class RubyToken::TkGT
end

class RubyToken::TkGT
end

class RubyToken::TkGVAR
end

class RubyToken::TkGVAR
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIDENTIFIER
end

class RubyToken::TkIF
end

class RubyToken::TkIF
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIF_MOD
end

class RubyToken::TkIN
end

class RubyToken::TkIN
end

class RubyToken::TkINTEGER
end

class RubyToken::TkINTEGER
end

class RubyToken::TkIVAR
end

class RubyToken::TkIVAR
end

class RubyToken::TkId
  def initialize(seek, line_no, char_no, name); end

  def name(); end
end

class RubyToken::TkId
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACE
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLBRACK
end

class RubyToken::TkLEQ
end

class RubyToken::TkLEQ
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLPAREN
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLSHFT
end

class RubyToken::TkLT
end

class RubyToken::TkLT
end

class RubyToken::TkMATCH
end

class RubyToken::TkMATCH
end

class RubyToken::TkMINUS
end

class RubyToken::TkMINUS
end

class RubyToken::TkMOD
end

class RubyToken::TkMOD
end

class RubyToken::TkMODULE
end

class RubyToken::TkMODULE
end

class RubyToken::TkMULT
end

class RubyToken::TkMULT
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEQ
end

class RubyToken::TkNEXT
end

class RubyToken::TkNEXT
end

class RubyToken::TkNIL
end

class RubyToken::TkNIL
end

class RubyToken::TkNL
end

class RubyToken::TkNL
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNMATCH
end

class RubyToken::TkNOT
end

class RubyToken::TkNOT
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNOTOP
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNTH_REF
end

class RubyToken::TkNode
  def node(); end
end

class RubyToken::TkNode
end

class RubyToken::TkOPASGN
  def initialize(seek, line_no, char_no, op); end

  def op(); end
end

class RubyToken::TkOPASGN
end

class RubyToken::TkOR
end

class RubyToken::TkOR
end

class RubyToken::TkOROP
end

class RubyToken::TkOROP
end

class RubyToken::TkOp
  def name(); end

  def name=(name); end
end

class RubyToken::TkOp
end

class RubyToken::TkPLUS
end

class RubyToken::TkPLUS
end

class RubyToken::TkPOW
end

class RubyToken::TkPOW
end

class RubyToken::TkQUESTION
end

class RubyToken::TkQUESTION
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACE
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRBRACK
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkRD_COMMENT
end

class RubyToken::TkREDO
end

class RubyToken::TkREDO
end

class RubyToken::TkREGEXP
end

class RubyToken::TkREGEXP
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRESCUE
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETRY
end

class RubyToken::TkRETURN
end

class RubyToken::TkRETURN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRPAREN
end

class RubyToken::TkRSHFT
end

class RubyToken::TkRSHFT
end

class RubyToken::TkSELF
end

class RubyToken::TkSELF
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSEMICOLON
end

class RubyToken::TkSPACE
end

class RubyToken::TkSPACE
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTAR
end

class RubyToken::TkSTRING
end

class RubyToken::TkSTRING
end

class RubyToken::TkSUPER
end

class RubyToken::TkSUPER
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBEG
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkSYMBOL
end

class RubyToken::TkTHEN
end

class RubyToken::TkTHEN
end

class RubyToken::TkTRUE
end

class RubyToken::TkTRUE
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUMINUS
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNDEF
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNLESS_MOD
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUNTIL_MOD
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUPLUS
end

class RubyToken::TkUnknownChar
  def initialize(seek, line_no, char_no, id); end

  def name(); end
end

class RubyToken::TkUnknownChar
end

class RubyToken::TkVal
  def initialize(seek, line_no, char_no, value=T.unsafe(nil)); end

  def value(); end
end

class RubyToken::TkVal
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHEN
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkWHILE_MOD
end

class RubyToken::TkXSTRING
end

class RubyToken::TkXSTRING
end

class RubyToken::TkYIELD
end

class RubyToken::TkYIELD
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__FILE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::Tk__LINE__
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACE
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLBRACK
end

class RubyToken::TkfLPAREN
end

class RubyToken::TkfLPAREN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklBEGIN
end

class RubyToken::TklEND
end

class RubyToken::TklEND
end

class RubyToken::Token
  def char_no(); end

  def initialize(seek, line_no, char_no); end

  def line_no(); end

  def seek(); end
end

class RubyToken::Token
end

module RubyToken
  extend ::T::Sig
  def self.def_token(token_n, super_token=T.unsafe(nil), reading=T.unsafe(nil), *opts); end
end

class RubyVM
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class RubyVM::InstructionSequence
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def absolute_path(); end

  def base_label(); end

  def disasm(); end

  def disassemble(); end

  def each_child(); end

  def eval(); end

  def first_lineno(); end

  def label(); end

  def path(); end

  def to_a(); end

  def to_binary(*_); end

  def trace_points(); end
end

class RubyVM::InstructionSequence
  extend ::T::Sig
  def self.compile(*_); end

  def self.compile_file(*_); end

  def self.compile_option(); end

  def self.compile_option=(compile_option); end

  def self.disasm(_); end

  def self.disassemble(_); end

  def self.load_from_binary(_); end

  def self.load_from_binary_extra_data(_); end

  def self.of(_); end
end

class RubyVM
  extend ::T::Sig
  def self.stat(*_); end
end

class RuntimeError
  extend ::T::Sig
end

module Sprockets::Autoload::Sass
end

module Sprockets::Autoload::Sass::Script
end

module Sprockets::Autoload::Sass::Script::Value
end

module Sass::Script::Value::Helpers
  def bool(value); end

  def calc?(literal); end

  def hex_color(value, alpha=T.unsafe(nil)); end

  def hsl_color(hue, saturation, lightness, alpha=T.unsafe(nil)); end

  def identifier(str); end

  def list(*elements, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end

  def map(hash); end

  def null(); end

  def number(number, unit_string=T.unsafe(nil)); end

  def parse_complex_selector(value, name=T.unsafe(nil), allow_parent_ref=T.unsafe(nil)); end

  def parse_compound_selector(value, name=T.unsafe(nil), allow_parent_ref=T.unsafe(nil)); end

  def parse_selector(value, name=T.unsafe(nil), allow_parent_ref=T.unsafe(nil)); end

  def quoted_string(str); end

  def rgb_color(red, green, blue, alpha=T.unsafe(nil)); end

  def special_number?(literal); end

  def unquoted_string(str); end

  def var?(literal); end
  VALID_UNIT = ::T.let(nil, ::T.untyped)
end

module Sass::Script::Value::Helpers
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Script::Value
end

module Sprockets::Autoload::Sass::Script
end

module Sprockets::Autoload::Sass
end

module Sawyer
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sawyer::Agent
  def allow_undefined_methods(); end

  def allow_undefined_methods=(allow_undefined_methods); end

  def allow_undefined_methods?(); end

  def call(method, url, data=T.unsafe(nil), options=T.unsafe(nil)); end

  def decode_body(str); end

  def encode_body(data); end

  def expand_url(url, options=T.unsafe(nil)); end

  def initialize(endpoint, options=T.unsafe(nil)); end

  def links_parser(); end

  def links_parser=(links_parser); end

  def marshal_dump(); end

  def marshal_load(dumped); end

  def parse_links(data); end

  def rels(); end

  def root(); end

  def start(); end

  def to_yaml_properties(); end
  NO_BODY = ::T.let(nil, ::T.untyped)
end

class Sawyer::Agent
  def self.decode(data); end

  def self.encode(data); end

  def self.serializer(); end

  def self.serializer=(serializer); end
end

class Sawyer::Error
end

class Sawyer::Error
end

module Sawyer::LinkParsers
end

class Sawyer::LinkParsers::Hal
  def parse(data); end
end

class Sawyer::LinkParsers::Hal
end

class Sawyer::LinkParsers::Simple
  def parse(data); end
  LINK_REGEX = ::T.let(nil, ::T.untyped)
end

class Sawyer::LinkParsers::Simple
end

module Sawyer::LinkParsers
  extend ::T::Sig
end

class Sawyer::Relation
  def agent(); end

  def available_methods(); end

  def call(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def delete(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def get(options=T.unsafe(nil)); end

  def head(options=T.unsafe(nil)); end

  def href_template(); end

  def initialize(agent, name, href, method=T.unsafe(nil)); end

  def method(); end

  def name(); end

  def options(data=T.unsafe(nil), opt=T.unsafe(nil)); end

  def patch(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def post(data=T.unsafe(nil), options=T.unsafe(nil)); end

  def put(data=T.unsafe(nil), options=T.unsafe(nil)); end
end

class Sawyer::Relation::Map
  def <<(rel); end

  def [](key); end

  def keys(); end

  def size(); end

  def to_h(); end

  def to_hash(); end
end

class Sawyer::Relation::Map
end

class Sawyer::Relation
  def self.from_link(agent, name, options); end

  def self.from_links(agent, index, rels=T.unsafe(nil)); end
end

class Sawyer::Resource
  include ::Enumerable
  def [](method); end

  def []=(method, value); end

  def _agent(); end

  def _fields(); end

  def _rels(); end

  def attrs(); end

  def each(&block); end

  def initialize(agent, data=T.unsafe(nil)); end

  def key?(key); end

  def marshal_dump(); end

  def marshal_load(dumped); end

  def method_missing(method, *args); end

  def process_value(value); end

  def to_attrs(); end

  def to_h(); end

  def to_hash(); end

  def to_yaml_properties(); end
  ATTR_PREDICATE = ::T.let(nil, ::T.untyped)
  ATTR_SETTER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHODS = ::T.let(nil, ::T.untyped)
end

class Sawyer::Resource
  def self.attr_accessor(*attrs); end
end

class Sawyer::Response
  def agent(); end

  def data(); end

  def headers(); end

  def initialize(agent, res, options=T.unsafe(nil)); end

  def process_data(data); end

  def process_rels(); end

  def rels(); end

  def status(); end

  def time(); end

  def timing(); end
end

class Sawyer::Response
end

class Sawyer::Serializer
  def decode(data); end

  def decode_hash(hash); end

  def decode_hash_value(key, value); end

  def decode_object(data); end

  def dump(data); end

  def encode(data); end

  def encode_hash(hash); end

  def encode_object(data); end

  def initialize(format, dump_method_name=T.unsafe(nil), load_method_name=T.unsafe(nil)); end

  def load(data); end

  def time_field?(key, value); end
end

class Sawyer::Serializer
  def self.any_json(); end

  def self.json(); end

  def self.message_pack(); end

  def self.multi_json(); end

  def self.yajl(); end
end

module Sawyer
  extend ::T::Sig
end

ScanError = StringScanner::Error

class ScriptError
  extend ::T::Sig
end

module SecureRandom
  BASE58_ALPHABET = ::T.let(nil, ::T.untyped)
end

module SecureRandom
  extend ::Random::Formatter
  extend ::T::Sig
  def self.base58(n=T.unsafe(nil)); end

  def self.bytes(n); end
end

class SecurityError
  extend ::T::Sig
end

module Selenium
end

module Selenium::WebDriver
  VERSION = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::ActionBuilder
  def click(element=T.unsafe(nil)); end

  def click_and_hold(element=T.unsafe(nil)); end

  def context_click(element=T.unsafe(nil)); end

  def double_click(element=T.unsafe(nil)); end

  def drag_and_drop(source, target); end

  def drag_and_drop_by(source, right_by, down_by); end

  def initialize(mouse, keyboard); end

  def key_down(*args); end

  def key_up(*args); end

  def move_by(right_by, down_by); end

  def move_to(element, right_by=T.unsafe(nil), down_by=T.unsafe(nil)); end

  def perform(); end

  def release(element=T.unsafe(nil)); end

  def send_keys(*args); end
end

class Selenium::WebDriver::ActionBuilder
end

class Selenium::WebDriver::Alert
  def accept(); end

  def dismiss(); end

  def initialize(bridge); end

  def send_keys(keys); end

  def text(); end
end

class Selenium::WebDriver::Alert
end

module Selenium::WebDriver::Atoms
end

module Selenium::WebDriver::Atoms
  extend ::T::Sig
end

module Selenium::WebDriver::BridgeHelper
  def element_id_from(id); end

  def parse_cookie_string(str); end

  def unwrap_script_result(arg); end
end

module Selenium::WebDriver::BridgeHelper
  extend ::T::Sig
end

module Selenium::WebDriver::Chrome
end

module Selenium::WebDriver::Chrome::Bridge
  def commands(command); end

  def network_conditions(); end

  def network_conditions=(conditions); end

  def send_command(command_params); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Chrome::Bridge
  extend ::T::Sig
end

class Selenium::WebDriver::Chrome::Driver
  include ::Selenium::WebDriver::DriverExtensions::HasNetworkConditions
  include ::Selenium::WebDriver::DriverExtensions::HasTouchScreen
  include ::Selenium::WebDriver::DriverExtensions::HasWebStorage
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  include ::Selenium::WebDriver::DriverExtensions::DownloadsFiles
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Chrome::Driver
end

class Selenium::WebDriver::Chrome::Options
  def add_argument(arg); end

  def add_emulation(device_name: T.unsafe(nil), device_metrics: T.unsafe(nil), user_agent: T.unsafe(nil)); end

  def add_encoded_extension(encoded); end

  def add_extension(path); end

  def add_option(name, value); end

  def add_preference(name, value); end

  def args(); end

  def as_json(*_); end

  def binary(); end

  def binary=(binary); end

  def emulation(); end

  def encoded_extensions(); end

  def extensions(); end

  def headless!(); end

  def initialize(**opts); end

  def options(); end

  def prefs(); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chrome::Options
end

class Selenium::WebDriver::Chrome::Profile
  include ::Selenium::WebDriver::ProfileHelper
  def [](key); end

  def []=(key, value); end

  def add_encoded_extension(encoded); end

  def add_extension(path); end

  def directory(); end

  def initialize(model=T.unsafe(nil)); end

  def layout_on_disk(); end
end

class Selenium::WebDriver::Chrome::Profile
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods
end

class Selenium::WebDriver::Chrome::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Chrome::Service
end

module Selenium::WebDriver::Chrome
  extend ::T::Sig
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path(); end

  def self.path=(path); end
end

class Selenium::WebDriver::Dimension
  def height(); end

  def height=(_); end

  def width(); end

  def width=(_); end
end

class Selenium::WebDriver::Dimension
  def self.[](*_); end

  def self.members(); end
end

class Selenium::WebDriver::Driver
  include ::Selenium::WebDriver::SearchContext
  def [](sel); end

  def action(); end

  def all(*args); end

  def browser(); end

  def capabilities(); end

  def close(); end

  def current_url(); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def first(*args); end

  def get(url); end

  def initialize(bridge, listener: T.unsafe(nil)); end

  def keyboard(); end

  def manage(); end

  def mouse(); end

  def navigate(); end

  def page_source(); end

  def quit(); end

  def ref(); end

  def script(script, *args); end

  def switch_to(); end

  def title(); end

  def window_handle(); end

  def window_handles(); end
end

class Selenium::WebDriver::Driver
  def self.for(browser, opts=T.unsafe(nil)); end
end

module Selenium::WebDriver::DriverExtensions
end

module Selenium::WebDriver::DriverExtensions::DownloadsFiles
  def download_path=(path); end
end

module Selenium::WebDriver::DriverExtensions::DownloadsFiles
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasAddons
  def install_addon(path, temporary=T.unsafe(nil)); end

  def uninstall_addon(id); end
end

module Selenium::WebDriver::DriverExtensions::HasAddons
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasDebugger
  def attach_debugger(); end
end

module Selenium::WebDriver::DriverExtensions::HasDebugger
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasLocation
  def location(); end

  def location=(loc); end

  def set_location(lat, lon, alt); end
end

module Selenium::WebDriver::DriverExtensions::HasLocation
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConditions
  def network_conditions(); end

  def network_conditions=(conditions); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConditions
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConnection
  def network_connection_type(); end

  def network_connection_type=(connection_type); end
end

module Selenium::WebDriver::DriverExtensions::HasNetworkConnection
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasPermissions
  def permissions(); end

  def permissions=(permissions); end
end

module Selenium::WebDriver::DriverExtensions::HasPermissions
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasRemoteStatus
  def remote_status(); end
end

module Selenium::WebDriver::DriverExtensions::HasRemoteStatus
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasSessionId
  def session_id(); end
end

module Selenium::WebDriver::DriverExtensions::HasSessionId
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasTouchScreen
  def touch(); end
end

module Selenium::WebDriver::DriverExtensions::HasTouchScreen
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::HasWebStorage
  def local_storage(); end

  def session_storage(); end
end

module Selenium::WebDriver::DriverExtensions::HasWebStorage
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::Rotatable
  def orientation(); end

  def rotate(orientation); end

  def rotation=(orientation); end
  ORIENTATIONS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::DriverExtensions::Rotatable
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def save_screenshot(png_path); end

  def screenshot_as(format); end
end

module Selenium::WebDriver::DriverExtensions::TakesScreenshot
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions::UploadsFiles
  def file_detector=(detector); end
end

module Selenium::WebDriver::DriverExtensions::UploadsFiles
  extend ::T::Sig
end

module Selenium::WebDriver::DriverExtensions
  extend ::T::Sig
end

module Selenium::WebDriver::Edge
end

module Selenium::WebDriver::Edge::Bridge
  def commands(command); end

  def maximize_window(handle=T.unsafe(nil)); end

  def reposition_window(x, y, handle=T.unsafe(nil)); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def send_keys_to_active_element(key); end

  def window_handle(); end

  def window_position(handle=T.unsafe(nil)); end

  def window_size(handle=T.unsafe(nil)); end
end

module Selenium::WebDriver::Edge::Bridge
  extend ::T::Sig
end

class Selenium::WebDriver::Edge::Driver
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Edge::Driver
end

class Selenium::WebDriver::Edge::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Edge::Service
end

module Selenium::WebDriver::Edge
  extend ::T::Sig
  def self.driver_path(warning=T.unsafe(nil)); end

  def self.driver_path=(path); end
end

class Selenium::WebDriver::Element
  include ::Selenium::WebDriver::SearchContext
  def ==(other); end

  def [](name); end

  def all(*args); end

  def as_json(*_); end

  def attribute(name); end

  def clear(); end

  def click(); end

  def css_value(prop); end

  def displayed?(); end

  def enabled?(); end

  def eql?(other); end

  def first(*args); end

  def initialize(bridge, id); end

  def location(); end

  def location_once_scrolled_into_view(); end

  def property(name); end

  def rect(); end

  def ref(); end

  def selected?(); end

  def send_key(*args); end

  def send_keys(*args); end

  def size(); end

  def style(prop); end

  def submit(); end

  def tag_name(); end

  def text(); end

  def to_json(*_); end
end

class Selenium::WebDriver::Element
end

module Selenium::WebDriver::Error
  ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Error::ElementClickInterceptedError
end

class Selenium::WebDriver::Error::ElementClickInterceptedError
end

Selenium::WebDriver::Error::ElementNotDisplayedError = Selenium::WebDriver::Error::ElementNotVisibleError

class Selenium::WebDriver::Error::ElementNotInteractableError
end

class Selenium::WebDriver::Error::ElementNotInteractableError
end

class Selenium::WebDriver::Error::ElementNotSelectableError
end

class Selenium::WebDriver::Error::ElementNotSelectableError
end

class Selenium::WebDriver::Error::ElementNotVisibleError
end

class Selenium::WebDriver::Error::ElementNotVisibleError
end

class Selenium::WebDriver::Error::ExpectedError
end

class Selenium::WebDriver::Error::ExpectedError
end

class Selenium::WebDriver::Error::IMEEngineActivationFailedError
end

class Selenium::WebDriver::Error::IMEEngineActivationFailedError
end

class Selenium::WebDriver::Error::IMENotAvailableError
end

class Selenium::WebDriver::Error::IMENotAvailableError
end

class Selenium::WebDriver::Error::IndexOutOfBoundsError
end

class Selenium::WebDriver::Error::IndexOutOfBoundsError
end

class Selenium::WebDriver::Error::InvalidArgumentError
end

class Selenium::WebDriver::Error::InvalidArgumentError
end

class Selenium::WebDriver::Error::InvalidCookieDomainError
end

class Selenium::WebDriver::Error::InvalidCookieDomainError
end

class Selenium::WebDriver::Error::InvalidElementCoordinatesError
end

class Selenium::WebDriver::Error::InvalidElementCoordinatesError
end

class Selenium::WebDriver::Error::InvalidElementStateError
end

class Selenium::WebDriver::Error::InvalidElementStateError
end

class Selenium::WebDriver::Error::InvalidSelectorError
end

class Selenium::WebDriver::Error::InvalidSelectorError
end

class Selenium::WebDriver::Error::InvalidSessionIdError
end

class Selenium::WebDriver::Error::InvalidSessionIdError
end

class Selenium::WebDriver::Error::InvalidXpathSelectorError
end

class Selenium::WebDriver::Error::InvalidXpathSelectorError
end

class Selenium::WebDriver::Error::InvalidXpathSelectorReturnTyperError
end

class Selenium::WebDriver::Error::InvalidXpathSelectorReturnTyperError
end

class Selenium::WebDriver::Error::JavascriptError
end

class Selenium::WebDriver::Error::JavascriptError
end

class Selenium::WebDriver::Error::MoveTargetOutOfBoundsError
end

class Selenium::WebDriver::Error::MoveTargetOutOfBoundsError
end

Selenium::WebDriver::Error::NoAlertOpenError = Selenium::WebDriver::Error::NoAlertPresentError

class Selenium::WebDriver::Error::NoAlertPresentError
end

class Selenium::WebDriver::Error::NoAlertPresentError
end

class Selenium::WebDriver::Error::NoCollectionError
end

class Selenium::WebDriver::Error::NoCollectionError
end

class Selenium::WebDriver::Error::NoScriptResultError
end

class Selenium::WebDriver::Error::NoScriptResultError
end

class Selenium::WebDriver::Error::NoStringError
end

class Selenium::WebDriver::Error::NoStringError
end

class Selenium::WebDriver::Error::NoStringLengthError
end

class Selenium::WebDriver::Error::NoStringLengthError
end

class Selenium::WebDriver::Error::NoStringWrapperError
end

class Selenium::WebDriver::Error::NoStringWrapperError
end

class Selenium::WebDriver::Error::NoSuchAlertError
end

class Selenium::WebDriver::Error::NoSuchAlertError
end

class Selenium::WebDriver::Error::NoSuchCollectionError
end

class Selenium::WebDriver::Error::NoSuchCollectionError
end

class Selenium::WebDriver::Error::NoSuchCookieError
end

class Selenium::WebDriver::Error::NoSuchCookieError
end

class Selenium::WebDriver::Error::NoSuchDocumentError
end

class Selenium::WebDriver::Error::NoSuchDocumentError
end

class Selenium::WebDriver::Error::NoSuchDriverError
end

class Selenium::WebDriver::Error::NoSuchDriverError
end

class Selenium::WebDriver::Error::NoSuchElementError
end

class Selenium::WebDriver::Error::NoSuchElementError
end

class Selenium::WebDriver::Error::NoSuchFrameError
end

class Selenium::WebDriver::Error::NoSuchFrameError
end

class Selenium::WebDriver::Error::NoSuchWindowError
end

class Selenium::WebDriver::Error::NoSuchWindowError
end

class Selenium::WebDriver::Error::NullPointerError
end

class Selenium::WebDriver::Error::NullPointerError
end

Selenium::WebDriver::Error::ObsoleteElementError = Selenium::WebDriver::Error::StaleElementReferenceError

class Selenium::WebDriver::Error::ScriptTimeOutError
end

class Selenium::WebDriver::Error::ScriptTimeOutError
end

Selenium::WebDriver::Error::ScriptTimeoutError = Selenium::WebDriver::Error::ScriptTimeOutError

class Selenium::WebDriver::Error::ServerError
  def initialize(response); end
end

class Selenium::WebDriver::Error::ServerError
end

class Selenium::WebDriver::Error::SessionNotCreatedError
end

class Selenium::WebDriver::Error::SessionNotCreatedError
end

class Selenium::WebDriver::Error::StaleElementReferenceError
end

class Selenium::WebDriver::Error::StaleElementReferenceError
end

class Selenium::WebDriver::Error::TimeOutError
end

class Selenium::WebDriver::Error::TimeOutError
end

Selenium::WebDriver::Error::TimeoutError = Selenium::WebDriver::Error::TimeOutError

class Selenium::WebDriver::Error::UnableToCaptureScreenError
end

class Selenium::WebDriver::Error::UnableToCaptureScreenError
end

class Selenium::WebDriver::Error::UnableToSetCookieError
end

class Selenium::WebDriver::Error::UnableToSetCookieError
end

class Selenium::WebDriver::Error::UnexpectedAlertOpenError
end

class Selenium::WebDriver::Error::UnexpectedAlertOpenError
end

Selenium::WebDriver::Error::UnexpectedJavascriptError = Selenium::WebDriver::Error::JavascriptError

class Selenium::WebDriver::Error::UnhandledAlertError
end

class Selenium::WebDriver::Error::UnhandledAlertError
end

Selenium::WebDriver::Error::UnhandledError = Selenium::WebDriver::Error::UnknownError

class Selenium::WebDriver::Error::UnknownCommandError
end

class Selenium::WebDriver::Error::UnknownCommandError
end

class Selenium::WebDriver::Error::UnknownError
end

class Selenium::WebDriver::Error::UnknownError
end

class Selenium::WebDriver::Error::UnknownMethodError
end

class Selenium::WebDriver::Error::UnknownMethodError
end

class Selenium::WebDriver::Error::UnsupportedOperationError
end

class Selenium::WebDriver::Error::UnsupportedOperationError
end

class Selenium::WebDriver::Error::WebDriverError
end

class Selenium::WebDriver::Error::WebDriverError
end

class Selenium::WebDriver::Error::XPathLookupError
end

class Selenium::WebDriver::Error::XPathLookupError
end

module Selenium::WebDriver::Error
  extend ::T::Sig
  def self.for_code(code); end
end

module Selenium::WebDriver::FileReaper
end

module Selenium::WebDriver::FileReaper
  extend ::T::Sig
  def self.<<(file); end

  def self.reap(file); end

  def self.reap!(); end

  def self.reap=(reap); end

  def self.reap?(); end

  def self.tmp_files(); end
end

module Selenium::WebDriver::Firefox
  DEFAULT_ASSUME_UNTRUSTED_ISSUER = ::T.let(nil, ::T.untyped)
  DEFAULT_ENABLE_NATIVE_EVENTS = ::T.let(nil, ::T.untyped)
  DEFAULT_LOAD_NO_FOCUS_LIB = ::T.let(nil, ::T.untyped)
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
  DEFAULT_SECURE_SSL = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Binary
  def quit(); end

  def start_with(profile, profile_path, *args); end

  def wait(); end
  NO_FOCUS_LIBRARIES = ::T.let(nil, ::T.untyped)
  NO_FOCUS_LIBRARY_NAME = ::T.let(nil, ::T.untyped)
  QUIT_TIMEOUT = ::T.let(nil, ::T.untyped)
  WAIT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Binary
  def self.path(); end

  def self.path=(path); end

  def self.reset_path!(); end

  def self.version(); end
end

module Selenium::WebDriver::Firefox::Driver
end

module Selenium::WebDriver::Firefox::Driver
  extend ::T::Sig
  def self.new(**opts); end
end

class Selenium::WebDriver::Firefox::Extension
  def initialize(path); end

  def write_to(extensions_dir); end
  NAMESPACE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Extension
end

class Selenium::WebDriver::Firefox::Launcher
  def assert_profile(); end

  def connect_until_stable(); end

  def create_profile(); end

  def fetch_profile(); end

  def find_free_port(); end

  def initialize(binary, port, profile=T.unsafe(nil)); end

  def launch(); end

  def quit(); end

  def socket_lock(); end

  def start(); end

  def url(); end
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  STABLE_CONNECTION_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Launcher
end

module Selenium::WebDriver::Firefox::Legacy
end

class Selenium::WebDriver::Firefox::Legacy::Driver
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Firefox::Legacy::Driver
end

module Selenium::WebDriver::Firefox::Legacy
  extend ::T::Sig
end

module Selenium::WebDriver::Firefox::Marionette
end

module Selenium::WebDriver::Firefox::Marionette::Bridge
  def commands(command); end

  def install_addon(path, temporary); end

  def uninstall_addon(id); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Firefox::Marionette::Bridge
  extend ::T::Sig
end

class Selenium::WebDriver::Firefox::Marionette::Driver
  include ::Selenium::WebDriver::DriverExtensions::HasAddons
  include ::Selenium::WebDriver::DriverExtensions::HasWebStorage
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Firefox::Marionette::Driver
end

module Selenium::WebDriver::Firefox::Marionette
  extend ::T::Sig
end

class Selenium::WebDriver::Firefox::Options
  def add_argument(arg); end

  def add_option(name, value); end

  def add_preference(name, value); end

  def args(); end

  def as_json(*_); end

  def binary(); end

  def binary=(binary); end

  def headless!(); end

  def initialize(**opts); end

  def log_level(); end

  def log_level=(log_level); end

  def options(); end

  def prefs(); end

  def profile(); end

  def profile=(profile); end
  KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Options
end

class Selenium::WebDriver::Firefox::Profile
  include ::Selenium::WebDriver::ProfileHelper
  def []=(key, value); end

  def add_extension(path, name=T.unsafe(nil)); end

  def add_webdriver_extension(); end

  def assume_untrusted_certificate_issuer=(bool); end

  def assume_untrusted_certificate_issuer?(); end

  def encoded(); end

  def initialize(model=T.unsafe(nil)); end

  def layout_on_disk(); end

  def load_no_focus_lib=(load_no_focus_lib); end

  def load_no_focus_lib?(); end

  def log_file(); end

  def log_file=(file); end

  def name(); end

  def native_events=(native_events); end

  def native_events?(); end

  def port=(port); end

  def proxy=(proxy); end

  def secure_ssl=(secure_ssl); end

  def secure_ssl?(); end
  VALID_PREFERENCE_TYPES = ::T.let(nil, ::T.untyped)
  WEBDRIVER_EXTENSION_PATH = ::T.let(nil, ::T.untyped)
  WEBDRIVER_PREFS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Profile
  extend ::Selenium::WebDriver::ProfileHelper::ClassMethods
  def self.default_preferences(); end

  def self.from_name(name); end

  def self.ini(); end
end

class Selenium::WebDriver::Firefox::ProfilesIni
  def [](name); end

  def refresh(); end
end

class Selenium::WebDriver::Firefox::ProfilesIni
end

class Selenium::WebDriver::Firefox::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Firefox::Service
end

module Selenium::WebDriver::Firefox::Util
end

module Selenium::WebDriver::Firefox::Util
  extend ::T::Sig
  def self.app_data_path(); end

  def self.stringified?(str); end
end

module Selenium::WebDriver::Firefox
  extend ::T::Sig
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path=(path); end
end

module Selenium::WebDriver::HTML5
end

class Selenium::WebDriver::HTML5::LocalStorage
  include ::Selenium::WebDriver::HTML5::SharedWebStorage
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def initialize(bridge); end

  def keys(); end

  def size(); end
end

class Selenium::WebDriver::HTML5::LocalStorage
end

class Selenium::WebDriver::HTML5::SessionStorage
  include ::Selenium::WebDriver::HTML5::SharedWebStorage
  include ::Enumerable
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def delete(key); end

  def initialize(bridge); end

  def keys(); end

  def size(); end
end

class Selenium::WebDriver::HTML5::SessionStorage
end

module Selenium::WebDriver::HTML5::SharedWebStorage
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def each(); end

  def empty?(); end

  def fetch(key); end

  def has_key?(key); end

  def key?(key); end

  def member?(key); end
end

module Selenium::WebDriver::HTML5::SharedWebStorage
  extend ::T::Sig
end

module Selenium::WebDriver::HTML5
  extend ::T::Sig
end

module Selenium::WebDriver::IE
end

class Selenium::WebDriver::IE::Driver
  include ::Selenium::WebDriver::DriverExtensions::HasWebStorage
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::IE::Driver
end

class Selenium::WebDriver::IE::Options
  def add_argument(arg); end

  def add_option(name, value); end

  def args(); end

  def as_json(*_); end

  def browser_attach_timeout(); end

  def browser_attach_timeout=(value); end

  def element_scroll_behavior(); end

  def element_scroll_behavior=(value); end

  def ensure_clean_session(); end

  def ensure_clean_session=(value); end

  def file_upload_dialog_timeout(); end

  def file_upload_dialog_timeout=(value); end

  def force_create_process_api(); end

  def force_create_process_api=(value); end

  def force_shell_windows_api(); end

  def force_shell_windows_api=(value); end

  def full_page_screenshot(); end

  def full_page_screenshot=(value); end

  def ignore_protected_mode_settings(); end

  def ignore_protected_mode_settings=(value); end

  def ignore_zoom_level(); end

  def ignore_zoom_level=(value); end

  def initial_browser_url(); end

  def initial_browser_url=(value); end

  def initialize(**opts); end

  def native_events(); end

  def native_events=(value); end

  def options(); end

  def persistent_hover(); end

  def persistent_hover=(value); end

  def require_window_focus(); end

  def require_window_focus=(value); end

  def use_per_process_proxy(); end

  def use_per_process_proxy=(value); end

  def validate_cookie_document_type(); end

  def validate_cookie_document_type=(value); end
  CAPABILITIES = ::T.let(nil, ::T.untyped)
  KEY = ::T.let(nil, ::T.untyped)
  SCROLL_BOTTOM = ::T.let(nil, ::T.untyped)
  SCROLL_TOP = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::IE::Options
end

class Selenium::WebDriver::IE::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::IE::Service
end

module Selenium::WebDriver::IE
  extend ::T::Sig
  def self.driver_path(); end

  def self.driver_path=(path); end
end

module Selenium::WebDriver::Interactions
  KEY = ::T.let(nil, ::T.untyped)
  NONE = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  SOURCE_TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::InputDevice
  def actions(); end

  def add_action(action); end

  def clear_actions(); end

  def create_pause(duration=T.unsafe(nil)); end

  def initialize(name=T.unsafe(nil)); end

  def name(); end

  def no_actions?(); end
end

class Selenium::WebDriver::Interactions::InputDevice
end

class Selenium::WebDriver::Interactions::Interaction
  def initialize(source); end

  def source(); end
  PAUSE = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::Interaction
end

class Selenium::WebDriver::Interactions::KeyInput
  def create_key_down(key); end

  def create_key_up(key); end

  def encode(); end

  def type(); end
  SUBTYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::KeyInput::TypingInteraction
  def assert_type(type); end

  def encode(); end

  def initialize(source, type, key); end

  def type(); end
end

class Selenium::WebDriver::Interactions::KeyInput::TypingInteraction
end

class Selenium::WebDriver::Interactions::KeyInput
end

class Selenium::WebDriver::Interactions::NoneInput
  def encode(); end

  def type(); end
end

class Selenium::WebDriver::Interactions::NoneInput
end

class Selenium::WebDriver::Interactions::Pause
  def encode(); end

  def initialize(source, duration=T.unsafe(nil)); end

  def type(); end
end

class Selenium::WebDriver::Interactions::Pause
end

class Selenium::WebDriver::Interactions::PointerCancel
  def encode(); end

  def type(); end
end

class Selenium::WebDriver::Interactions::PointerCancel
end

class Selenium::WebDriver::Interactions::PointerInput
  def assert_kind(pointer); end

  def create_pointer_cancel(); end

  def create_pointer_down(button); end

  def create_pointer_move(duration: T.unsafe(nil), x: T.unsafe(nil), y: T.unsafe(nil), element: T.unsafe(nil), origin: T.unsafe(nil)); end

  def create_pointer_up(button); end

  def encode(); end

  def initialize(kind, name: T.unsafe(nil)); end

  def kind(); end

  def type(); end
  KIND = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerInput
end

class Selenium::WebDriver::Interactions::PointerMove
  def encode(); end

  def initialize(source, duration, x, y, element: T.unsafe(nil), origin: T.unsafe(nil)); end

  def type(); end
  ORIGINS = ::T.let(nil, ::T.untyped)
  POINTER = ::T.let(nil, ::T.untyped)
  VIEWPORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerMove
end

class Selenium::WebDriver::Interactions::PointerPress
  def assert_button(button); end

  def assert_direction(direction); end

  def encode(); end

  def initialize(source, direction, button); end

  def type(); end
  BUTTONS = ::T.let(nil, ::T.untyped)
  DIRECTIONS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Interactions::PointerPress
end

module Selenium::WebDriver::Interactions
  extend ::T::Sig
  def self.key(name); end

  def self.none(name=T.unsafe(nil)); end

  def self.pointer(kind, **kwargs); end
end

module Selenium::WebDriver::KeyActions
  def key_down(*args, device: T.unsafe(nil)); end

  def key_up(*args, device: T.unsafe(nil)); end

  def send_keys(*args, device: T.unsafe(nil)); end
end

module Selenium::WebDriver::KeyActions
  extend ::T::Sig
end

class Selenium::WebDriver::Keyboard
  def initialize(bridge); end

  def press(key); end

  def release(key); end

  def send_keys(*keys); end
  MODIFIERS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Keyboard
end

module Selenium::WebDriver::Keys
  KEYS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Keys
  extend ::T::Sig
  def self.[](key); end

  def self.encode(keys); end

  def self.encode_key(key); end
end

class Selenium::WebDriver::Location
  def altitude(); end

  def altitude=(_); end

  def latitude(); end

  def latitude=(_); end

  def longitude(); end

  def longitude=(_); end
end

class Selenium::WebDriver::Location
  def self.[](*_); end

  def self.members(); end
end

class Selenium::WebDriver::LogEntry
  def as_json(*_); end

  def initialize(level, timestamp, message); end

  def level(); end

  def message(); end

  def time(); end

  def timestamp(); end
end

class Selenium::WebDriver::LogEntry
end

class Selenium::WebDriver::Logger
  include ::Logger::Severity
  def debug(*args, &block); end

  def debug?(*args, &block); end

  def deprecate(old, new=T.unsafe(nil)); end

  def error(*args, &block); end

  def error?(*args, &block); end

  def fatal(*args, &block); end

  def fatal?(*args, &block); end

  def info(*args, &block); end

  def info?(*args, &block); end

  def io(); end

  def level(*args, &block); end

  def level=(severity); end

  def output=(io); end

  def warn(*args, &block); end

  def warn?(*args, &block); end
end

class Selenium::WebDriver::Logger
  extend ::Forwardable
end

class Selenium::WebDriver::Logs
  def available_types(); end

  def get(type); end

  def initialize(bridge); end
end

class Selenium::WebDriver::Logs
end

class Selenium::WebDriver::Mouse
  def click(element=T.unsafe(nil)); end

  def context_click(element=T.unsafe(nil)); end

  def double_click(element=T.unsafe(nil)); end

  def down(element=T.unsafe(nil)); end

  def initialize(bridge); end

  def move_by(right_by, down_by); end

  def move_to(element, right_by=T.unsafe(nil), down_by=T.unsafe(nil)); end

  def up(element=T.unsafe(nil)); end
end

class Selenium::WebDriver::Mouse
end

class Selenium::WebDriver::Navigation
  def back(); end

  def forward(); end

  def initialize(bridge); end

  def refresh(); end

  def to(url); end
end

class Selenium::WebDriver::Navigation
end

class Selenium::WebDriver::Options
  def add_cookie(opts=T.unsafe(nil)); end

  def all_cookies(); end

  def cookie_named(name); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def initialize(bridge); end

  def logs(); end

  def timeouts(); end

  def window(); end
  SECONDS_PER_DAY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Options
end

module Selenium::WebDriver::Platform
end

module Selenium::WebDriver::Platform
  extend ::T::Sig
  def self.assert_executable(path); end

  def self.assert_file(path); end

  def self.bitsize(); end

  def self.ci(); end

  def self.cygwin?(); end

  def self.cygwin_path(path, opts=T.unsafe(nil)); end

  def self.engine(); end

  def self.exit_hook(); end

  def self.find_binary(*binary_names); end

  def self.find_in_program_files(*binary_names); end

  def self.home(); end

  def self.interfaces(); end

  def self.ip(); end

  def self.ironruby?(); end

  def self.jruby?(); end

  def self.linux?(); end

  def self.localhost(); end

  def self.mac?(); end

  def self.make_writable(file); end

  def self.null_device(); end

  def self.os(); end

  def self.ruby_version(); end

  def self.windows?(); end

  def self.wrap_in_quotes_if_necessary(str); end

  def self.wsl?(); end
end

class Selenium::WebDriver::Point
  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Selenium::WebDriver::Point
  def self.[](*_); end

  def self.members(); end
end

module Selenium::WebDriver::PointerActions
  def click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def click_and_hold(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def context_click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def default_move_duration(); end

  def default_move_duration=(default_move_duration); end

  def double_click(element=T.unsafe(nil), device: T.unsafe(nil)); end

  def drag_and_drop(source, target, device: T.unsafe(nil)); end

  def drag_and_drop_by(source, right_by, down_by, device: T.unsafe(nil)); end

  def move_by(right_by, down_by, device: T.unsafe(nil)); end

  def move_to(element, right_by=T.unsafe(nil), down_by=T.unsafe(nil), device: T.unsafe(nil)); end

  def move_to_location(x, y, device: T.unsafe(nil)); end

  def pointer_down(button, device: T.unsafe(nil)); end

  def pointer_up(button, device: T.unsafe(nil)); end

  def release(device: T.unsafe(nil)); end
end

module Selenium::WebDriver::PointerActions
  extend ::T::Sig
end

class Selenium::WebDriver::PortProber
  IGNORED_ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::PortProber
  def self.above(port); end

  def self.free?(port); end

  def self.random(); end
end

module Selenium::WebDriver::ProfileHelper
  def as_json(*_); end

  def to_json(*_); end
end

module Selenium::WebDriver::ProfileHelper::ClassMethods
  def from_json(json); end
end

module Selenium::WebDriver::ProfileHelper::ClassMethods
  extend ::T::Sig
end

module Selenium::WebDriver::ProfileHelper
  extend ::T::Sig
  def self.included(base); end
end

class Selenium::WebDriver::Proxy
  def ==(other); end

  def as_json(*_); end

  def auto_detect(); end

  def auto_detect=(bool); end

  def eql?(other); end

  def ftp(); end

  def ftp=(value); end

  def http(); end

  def http=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def no_proxy(); end

  def no_proxy=(value); end

  def pac(); end

  def pac=(url); end

  def socks(); end

  def socks=(value); end

  def socks_password(); end

  def socks_password=(value); end

  def socks_username(); end

  def socks_username=(value); end

  def ssl(); end

  def ssl=(value); end

  def to_json(*_); end

  def type(); end

  def type=(type); end
  ALLOWED = ::T.let(nil, ::T.untyped)
  TYPES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Proxy
  def self.json_create(data); end
end

class Selenium::WebDriver::Rectangle
  def height(); end

  def height=(_); end

  def width(); end

  def width=(_); end

  def x(); end

  def x=(_); end

  def y(); end

  def y=(_); end
end

class Selenium::WebDriver::Rectangle
  def self.[](*_); end

  def self.members(); end
end

module Selenium::WebDriver::Remote
end

class Selenium::WebDriver::Remote::Bridge
  include ::Selenium::WebDriver::Atoms
  include ::Selenium::WebDriver::BridgeHelper
  def browser(); end

  def capabilities(); end

  def context(); end

  def context=(context); end

  def create_session(desired_capabilities); end

  def dialect(); end

  def file_detector(); end

  def file_detector=(file_detector); end

  def http(); end

  def http=(http); end

  def initialize(opts=T.unsafe(nil)); end

  def session_id(); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Bridge
  def self.handshake(**opts); end
end

class Selenium::WebDriver::Remote::Capabilities
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def as_json(*_); end

  def browser_name(); end

  def browser_name=(value); end

  def capabilities(); end

  def css_selectors_enabled(); end

  def css_selectors_enabled=(value); end

  def css_selectors_enabled?(); end

  def eql?(other); end

  def firefox_profile(); end

  def firefox_profile=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def javascript_enabled(); end

  def javascript_enabled=(value); end

  def javascript_enabled?(); end

  def merge!(other); end

  def native_events(); end

  def native_events=(value); end

  def native_events?(); end

  def platform(); end

  def platform=(value); end

  def proxy(); end

  def proxy=(proxy); end

  def rotatable(); end

  def rotatable=(value); end

  def rotatable?(); end

  def takes_screenshot(); end

  def takes_screenshot=(value); end

  def takes_screenshot?(); end

  def to_json(*_); end

  def version(); end

  def version=(value); end
  DEFAULTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Capabilities
  def self.chrome(opts=T.unsafe(nil)); end

  def self.edge(opts=T.unsafe(nil)); end

  def self.firefox(opts=T.unsafe(nil)); end

  def self.htmlunit(opts=T.unsafe(nil)); end

  def self.htmlunitwithjs(opts=T.unsafe(nil)); end

  def self.ie(opts=T.unsafe(nil)); end

  def self.internet_explorer(opts=T.unsafe(nil)); end

  def self.json_create(data); end

  def self.phantomjs(opts=T.unsafe(nil)); end

  def self.safari(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Remote::Driver
  include ::Selenium::WebDriver::DriverExtensions::UploadsFiles
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  include ::Selenium::WebDriver::DriverExtensions::HasSessionId
  include ::Selenium::WebDriver::DriverExtensions::Rotatable
  include ::Selenium::WebDriver::DriverExtensions::HasRemoteStatus
  include ::Selenium::WebDriver::DriverExtensions::HasWebStorage
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Remote::Driver
end

module Selenium::WebDriver::Remote::Http
end

class Selenium::WebDriver::Remote::Http::Common
  def call(verb, url, command_hash); end

  def close(); end

  def quit_errors(); end

  def server_url=(server_url); end

  def timeout(); end

  def timeout=(timeout); end
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  DEFAULT_HEADERS = ::T.let(nil, ::T.untyped)
  MAX_REDIRECTS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Common
end

class Selenium::WebDriver::Remote::Http::Default
  def initialize(open_timeout: T.unsafe(nil), read_timeout: T.unsafe(nil)); end

  def open_timeout(); end

  def open_timeout=(open_timeout); end

  def proxy=(proxy); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def timeout=(value); end
  MAX_RETRIES = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Http::Default
end

module Selenium::WebDriver::Remote::Http
  extend ::T::Sig
end

module Selenium::WebDriver::Remote::OSS
end

class Selenium::WebDriver::Remote::OSS::Bridge
  def accept_alert(); end

  def action(); end

  def active_element(); end

  def add_cookie(cookie); end

  def alert=(keys); end

  def alert_text(); end

  def authentication(credentials); end

  def available_log_types(); end

  def clear_element(element); end

  def clear_local_storage(); end

  def clear_session_storage(); end

  def click(); end

  def click_element(element); end

  def close(); end

  def context_click(); end

  def cookies(); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def dismiss_alert(); end

  def double_click(); end

  def drag_element(element, right_by, down_by); end

  def element_attribute(element, name); end

  def element_displayed?(element); end

  def element_enabled?(element); end

  def element_location(element); end

  def element_location_once_scrolled_into_view(element); end

  def element_property(element, name); end

  def element_rect(element); end

  def element_selected?(element); end

  def element_size(element); end

  def element_tag_name(element); end

  def element_text(element); end

  def element_value(element); end

  def element_value_of_css_property(element, prop); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def implicit_wait_timeout=(milliseconds); end

  def initialize(capabilities, session_id, **opts); end

  def keyboard(); end

  def local_storage_item(key, value=T.unsafe(nil)); end

  def local_storage_keys(); end

  def local_storage_size(); end

  def location(); end

  def log(type); end

  def maximize_window(handle=T.unsafe(nil)); end

  def mouse(); end

  def mouse_down(); end

  def mouse_move_to(element, x=T.unsafe(nil), y=T.unsafe(nil)); end

  def mouse_up(); end

  def network_connection(); end

  def network_connection=(type); end

  def options(); end

  def page_source(); end

  def quit(); end

  def refresh(); end

  def remove_local_storage_item(key); end

  def remove_session_storage_item(key); end

  def reposition_window(x, y, handle=T.unsafe(nil)); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def screen_orientation(); end

  def screen_orientation=(orientation); end

  def screenshot(); end

  def script_timeout=(milliseconds); end

  def send_keys_to_active_element(key); end

  def send_keys_to_element(element, keys); end

  def session_capabilities(); end

  def session_storage_item(key, value=T.unsafe(nil)); end

  def session_storage_keys(); end

  def session_storage_size(); end

  def set_location(lat, lon, alt); end

  def status(); end

  def submit_element(element); end

  def switch_to_active_element(); end

  def switch_to_default_content(); end

  def switch_to_frame(id); end

  def switch_to_parent_frame(); end

  def switch_to_window(name); end

  def timeout(type, milliseconds); end

  def title(); end

  def touch_double_tap(element); end

  def touch_down(x, y); end

  def touch_element_flick(element, right_by, down_by, speed); end

  def touch_flick(xspeed, yspeed); end

  def touch_long_press(element); end

  def touch_move(x, y); end

  def touch_scroll(element, x, y); end

  def touch_single_tap(element); end

  def touch_up(x, y); end

  def upload(local_file); end

  def url(); end

  def window_handle(); end

  def window_handles(); end

  def window_position(handle=T.unsafe(nil)); end

  def window_size(handle=T.unsafe(nil)); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::OSS::Bridge
end

module Selenium::WebDriver::Remote::OSS
  extend ::T::Sig
end

class Selenium::WebDriver::Remote::Response
  def [](key); end

  def code(); end

  def error(); end

  def error_message(); end

  def initialize(code, payload=T.unsafe(nil)); end

  def payload(); end

  def payload=(payload); end
  STACKTRACE_KEY = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::Response
end

module Selenium::WebDriver::Remote::W3C
end

class Selenium::WebDriver::Remote::W3C::Bridge
  def accept_alert(); end

  def action(async=T.unsafe(nil)); end

  def actions(async=T.unsafe(nil)); end

  def active_element(); end

  def add_cookie(cookie); end

  def alert=(keys); end

  def alert_text(); end

  def clear_element(element); end

  def clear_local_storage(); end

  def clear_session_storage(); end

  def click_element(element); end

  def close(); end

  def cookie(name); end

  def cookies(); end

  def delete_all_cookies(); end

  def delete_cookie(name); end

  def dismiss_alert(); end

  def drag_element(element, right_by, down_by); end

  def element_attribute(element, name); end

  def element_displayed?(element); end

  def element_enabled?(element); end

  def element_location(element); end

  def element_location_once_scrolled_into_view(element); end

  def element_property(element, name); end

  def element_rect(element); end

  def element_selected?(element); end

  def element_size(element); end

  def element_tag_name(element); end

  def element_text(element); end

  def element_value(element); end

  def element_value_of_css_property(element, prop); end

  def execute_async_script(script, *args); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def full_screen_window(); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def implicit_wait_timeout=(milliseconds); end

  def initialize(capabilities, session_id, **opts); end

  def keyboard(); end

  def local_storage_item(key, value=T.unsafe(nil)); end

  def local_storage_keys(); end

  def local_storage_size(); end

  def location(); end

  def maximize_window(handle=T.unsafe(nil)); end

  def minimize_window(); end

  def mouse(); end

  def network_connection(); end

  def network_connection=(_type); end

  def options(); end

  def page_source(); end

  def quit(); end

  def refresh(); end

  def release_actions(); end

  def remove_local_storage_item(key); end

  def remove_session_storage_item(key); end

  def reposition_window(x, y); end

  def resize_window(width, height, handle=T.unsafe(nil)); end

  def screen_orientation(); end

  def screen_orientation=(orientation); end

  def screenshot(); end

  def script_timeout=(milliseconds); end

  def send_actions(data); end

  def send_keys_to_element(element, keys); end

  def session_storage_item(key, value=T.unsafe(nil)); end

  def session_storage_keys(); end

  def session_storage_size(); end

  def set_location(_lat, _lon, _alt); end

  def set_window_rect(x: T.unsafe(nil), y: T.unsafe(nil), width: T.unsafe(nil), height: T.unsafe(nil)); end

  def status(); end

  def submit_element(element); end

  def switch_to_active_element(); end

  def switch_to_default_content(); end

  def switch_to_frame(id); end

  def switch_to_parent_frame(); end

  def switch_to_window(name); end

  def timeout(type, milliseconds); end

  def title(); end

  def touch_double_tap(element); end

  def touch_down(x, y); end

  def touch_element_flick(element, right_by, down_by, speed); end

  def touch_flick(xspeed, yspeed); end

  def touch_long_press(element); end

  def touch_move(x, y); end

  def touch_scroll(element, x, y); end

  def touch_single_tap(element); end

  def touch_up(x, y); end

  def upload(local_file); end

  def url(); end

  def window_handle(); end

  def window_handles(); end

  def window_position(); end

  def window_rect(); end

  def window_size(handle=T.unsafe(nil)); end
  COMMANDS = ::T.let(nil, ::T.untyped)
  ESCAPE_CSS_REGEXP = ::T.let(nil, ::T.untyped)
  QUIT_ERRORS = ::T.let(nil, ::T.untyped)
  UNICODE_CODE_POINT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::W3C::Bridge
end

class Selenium::WebDriver::Remote::W3C::Capabilities
  def ==(other); end

  def [](key); end

  def []=(key, value); end

  def accept_insecure_certs(); end

  def accept_insecure_certs=(value); end

  def accessibility_checks(); end

  def accessibility_checks=(value); end

  def as_json(*_); end

  def browser_name(); end

  def browser_name=(value); end

  def browser_version(); end

  def browser_version=(value); end

  def capabilities(); end

  def device(); end

  def device=(value); end

  def eql?(other); end

  def implicit_timeout(); end

  def implicit_timeout=(value); end

  def initialize(opts=T.unsafe(nil)); end

  def merge!(other); end

  def page_load_strategy(); end

  def page_load_strategy=(value); end

  def page_load_timeout(); end

  def page_load_timeout=(value); end

  def platform(); end

  def platform=(value); end

  def platform_name(); end

  def platform_name=(value); end

  def proxy(); end

  def proxy=(proxy); end

  def remote_session_id(); end

  def remote_session_id=(value); end

  def script_timeout(); end

  def script_timeout=(value); end

  def set_window_rect(); end

  def set_window_rect=(value); end

  def timeouts(); end

  def timeouts=(value); end

  def to_json(*_); end

  def unhandled_prompt_behavior(); end

  def unhandled_prompt_behavior=(value); end

  def version(); end

  def version=(value); end
  EXTENSION_CAPABILITY_PATTERN = ::T.let(nil, ::T.untyped)
  KNOWN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Remote::W3C::Capabilities
  def self.edge(opts=T.unsafe(nil)); end

  def self.ff(opts=T.unsafe(nil)); end

  def self.firefox(opts=T.unsafe(nil)); end

  def self.from_oss(oss_capabilities); end

  def self.json_create(data); end
end

module Selenium::WebDriver::Remote::W3C
  extend ::T::Sig
end

module Selenium::WebDriver::Remote
  extend ::T::Sig
end

module Selenium::WebDriver::Safari
end

module Selenium::WebDriver::Safari::Bridge
  def attach_debugger(); end

  def commands(command); end

  def permissions(); end

  def permissions=(permissions); end
  COMMANDS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Safari::Bridge
  extend ::T::Sig
end

class Selenium::WebDriver::Safari::Driver
  include ::Selenium::WebDriver::DriverExtensions::HasDebugger
  include ::Selenium::WebDriver::DriverExtensions::HasPermissions
  include ::Selenium::WebDriver::DriverExtensions::TakesScreenshot
  def initialize(opts=T.unsafe(nil)); end
end

class Selenium::WebDriver::Safari::Driver
end

class Selenium::WebDriver::Safari::Service
  DEFAULT_PORT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Safari::Service
end

module Selenium::WebDriver::Safari
  extend ::T::Sig
  def self.driver_path(); end

  def self.driver_path=(path); end

  def self.path(); end

  def self.path=(path); end

  def self.technology_preview(); end

  def self.technology_preview!(); end
end

module Selenium::WebDriver::SearchContext
  def find_element(*args); end

  def find_elements(*args); end
  FINDERS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::SearchContext
  extend ::T::Sig
end

class Selenium::WebDriver::Service
  def binary_path(path); end

  def extract_service_args(driver_opts); end

  def host(); end

  def host=(host); end

  def initialize(executable_path, port, driver_opts); end

  def start(); end

  def stop(); end

  def uri(); end
  SOCKET_LOCK_TIMEOUT = ::T.let(nil, ::T.untyped)
  START_TIMEOUT = ::T.let(nil, ::T.untyped)
  STOP_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Service
  def self.executable(); end

  def self.missing_text(); end
end

class Selenium::WebDriver::SocketLock
  def initialize(port, timeout); end

  def locked(); end
end

class Selenium::WebDriver::SocketLock
end

class Selenium::WebDriver::SocketPoller
  def closed?(); end

  def connected?(); end

  def initialize(host, port, timeout=T.unsafe(nil), interval=T.unsafe(nil)); end
  CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
  CONNECT_TIMEOUT = ::T.let(nil, ::T.untyped)
  NOT_CONNECTED_ERRORS = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::SocketPoller
end

module Selenium::WebDriver::Support
end

class Selenium::WebDriver::Support::AbstractEventListener
  def after_change_value_of(element, driver); end

  def after_click(element, driver); end

  def after_close(driver); end

  def after_execute_script(script, driver); end

  def after_find(by, what, driver); end

  def after_navigate_back(driver); end

  def after_navigate_forward(driver); end

  def after_navigate_to(url, driver); end

  def after_quit(driver); end

  def before_change_value_of(element, driver); end

  def before_click(element, driver); end

  def before_close(driver); end

  def before_execute_script(script, driver); end

  def before_find(by, what, driver); end

  def before_navigate_back(driver); end

  def before_navigate_forward(driver); end

  def before_navigate_to(url, driver); end

  def before_quit(driver); end
end

class Selenium::WebDriver::Support::AbstractEventListener
end

class Selenium::WebDriver::Support::BlockEventListener
  def initialize(callback); end

  def method_missing(meth, *args); end
end

class Selenium::WebDriver::Support::BlockEventListener
end

class Selenium::WebDriver::Support::Color
  def ==(other); end

  def alpha(); end

  def blue(); end

  def eql?(other); end

  def green(); end

  def hex(); end

  def initialize(red, green, blue, alpha=T.unsafe(nil)); end

  def red(); end

  def rgb(); end

  def rgba(); end
  HEX3_PATTERN = ::T.let(nil, ::T.untyped)
  HEX_PATTERN = ::T.let(nil, ::T.untyped)
  HSLA_PATTERN = ::T.let(nil, ::T.untyped)
  HSL_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PATTERN = ::T.let(nil, ::T.untyped)
  RGBA_PCT_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PATTERN = ::T.let(nil, ::T.untyped)
  RGB_PCT_PATTERN = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Support::Color
  def self.from_hsl(h, s, l, a); end

  def self.from_string(str); end

  def self.hue_to_rgb(lum1, lum2, hue); end
end

module Selenium::WebDriver::Support::Escaper
end

module Selenium::WebDriver::Support::Escaper
  extend ::T::Sig
  def self.escape(str); end
end

class Selenium::WebDriver::Support::EventFiringBridge
  def clear_element(ref); end

  def click_element(ref); end

  def close(); end

  def execute_script(script, *args); end

  def find_element_by(how, what, parent=T.unsafe(nil)); end

  def find_elements_by(how, what, parent=T.unsafe(nil)); end

  def get(url); end

  def go_back(); end

  def go_forward(); end

  def initialize(delegate, listener); end

  def quit(); end

  def send_keys_to_element(ref, keys); end
end

class Selenium::WebDriver::Support::EventFiringBridge
end

class Selenium::WebDriver::Support::Select
  def deselect_all(); end

  def deselect_by(how, what); end

  def first_selected_option(); end

  def initialize(element); end

  def multiple?(); end

  def options(); end

  def select_all(); end

  def select_by(how, what); end

  def selected_options(); end
end

class Selenium::WebDriver::Support::Select
end

module Selenium::WebDriver::Support
  extend ::T::Sig
end

class Selenium::WebDriver::TargetLocator
  def active_element(); end

  def alert(); end

  def default_content(); end

  def frame(id); end

  def initialize(bridge); end

  def parent_frame(); end

  def window(id); end
end

class Selenium::WebDriver::TargetLocator
end

class Selenium::WebDriver::Timeouts
  def implicit_wait=(seconds); end

  def initialize(bridge); end

  def page_load=(seconds); end

  def script_timeout=(seconds); end
end

class Selenium::WebDriver::Timeouts
end

class Selenium::WebDriver::TouchActionBuilder
  def double_tap(element); end

  def down(x, y=T.unsafe(nil)); end

  def flick(*args); end

  def initialize(mouse, keyboard, touch_screen); end

  def long_press(element); end

  def move(x, y=T.unsafe(nil)); end

  def scroll(*args); end

  def single_tap(element); end

  def up(x, y=T.unsafe(nil)); end
end

class Selenium::WebDriver::TouchActionBuilder
end

class Selenium::WebDriver::TouchScreen
  def double_tap(element); end

  def down(x, y=T.unsafe(nil)); end

  def flick(*args); end

  def initialize(bridge); end

  def long_press(element); end

  def move(x, y=T.unsafe(nil)); end

  def scroll(*args); end

  def single_tap(element); end

  def up(x, y=T.unsafe(nil)); end
  FLICK_SPEED = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::TouchScreen
end

class Selenium::WebDriver::W3CActionBuilder
  include ::Selenium::WebDriver::KeyActions
  include ::Selenium::WebDriver::PointerActions
  def add_key_input(name); end

  def add_pointer_input(kind, name); end

  def clear_all_actions(); end

  def devices(); end

  def get_device(name); end

  def initialize(bridge, mouse, keyboard, async=T.unsafe(nil)); end

  def key_inputs(); end

  def pause(device, duration=T.unsafe(nil)); end

  def pauses(device, number, duration=T.unsafe(nil)); end

  def perform(); end

  def pointer_inputs(); end

  def release_actions(); end
end

class Selenium::WebDriver::W3CActionBuilder
end

class Selenium::WebDriver::W3COptions
end

class Selenium::WebDriver::W3COptions
end

class Selenium::WebDriver::Wait
  def initialize(opts=T.unsafe(nil)); end

  def until(); end
  DEFAULT_INTERVAL = ::T.let(nil, ::T.untyped)
  DEFAULT_TIMEOUT = ::T.let(nil, ::T.untyped)
end

class Selenium::WebDriver::Wait
end

class Selenium::WebDriver::Window
  def full_screen(); end

  def initialize(bridge); end

  def maximize(); end

  def minimize(); end

  def move_to(x, y); end

  def position(); end

  def position=(point); end

  def rect(); end

  def rect=(rectangle); end

  def resize_to(width, height); end

  def size(); end

  def size=(dimension); end
end

class Selenium::WebDriver::Window
end

module Selenium::WebDriver::Zipper
  EXTENSIONS = ::T.let(nil, ::T.untyped)
end

module Selenium::WebDriver::Zipper
  extend ::T::Sig
  def self.unzip(path); end

  def self.zip(path); end

  def self.zip_file(path); end
end

module Selenium::WebDriver
  extend ::T::Sig
  def self.for(*args); end

  def self.logger(); end

  def self.root(); end
end

module Selenium
  extend ::T::Sig
end

class Set
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class Set
  extend ::T::Sig
end

module Shellwords
end

module Shellwords
  extend ::T::Sig
  def self.escape(str); end

  def self.join(array); end

  def self.shellescape(str); end

  def self.shelljoin(array); end

  def self.shellsplit(line); end

  def self.shellwords(line); end

  def self.split(line); end
end

module Sidekiq
  DEFAULTS = ::T.let(nil, ::T.untyped)
  DEFAULT_WORKER_OPTIONS = ::T.let(nil, ::T.untyped)
  FAKE_INFO = ::T.let(nil, ::T.untyped)
  LICENSE = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Client
  def initialize(redis_pool=T.unsafe(nil)); end

  def middleware(&block); end

  def push(item); end

  def push_bulk(items); end

  def redis_pool(); end

  def redis_pool=(redis_pool); end
end

class Sidekiq::Client
  def self.enqueue(klass, *args); end

  def self.enqueue_in(interval, klass, *args); end

  def self.enqueue_to(queue, klass, *args); end

  def self.enqueue_to_in(queue, interval, klass, *args); end

  def self.push(item); end

  def self.push_bulk(items); end

  def self.via(pool); end
end

class Sidekiq::DeadSet
  def initialize(); end

  def kill(message, opts=T.unsafe(nil)); end

  def retry_all(); end
end

class Sidekiq::DeadSet
  def self.max_jobs(); end

  def self.timeout(); end
end

module Sidekiq::Extensions
end

module Sidekiq::Extensions::PsychAutoload
  def resolve_class(klass_name); end
end

module Sidekiq::Extensions::PsychAutoload
  extend ::T::Sig
end

module Sidekiq::Extensions
  extend ::T::Sig
  def self.enable_delay!(); end
end

class Sidekiq::Job
  def [](name); end

  def args(); end

  def created_at(); end

  def delete(); end

  def display_args(); end

  def display_class(); end

  def enqueued_at(); end

  def initialize(item, queue_name=T.unsafe(nil)); end

  def item(); end

  def jid(); end

  def klass(); end

  def latency(); end

  def parse(item); end

  def queue(); end

  def value(); end
end

class Sidekiq::Job
end

class Sidekiq::JobSet
  def delete(score, jid); end

  def delete_by_jid(score, jid); end

  def delete_by_value(name, value); end

  def each(); end

  def fetch(score, jid=T.unsafe(nil)); end

  def find_job(jid); end

  def schedule(timestamp, message); end
end

class Sidekiq::JobSet
end

module Sidekiq::Logging
  def logger(); end
end

class Sidekiq::Logging::Pretty
  def call(severity, time, program_name, message); end

  def context(); end
  SPACE = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Logging::Pretty
end

class Sidekiq::Logging::WithoutTimestamp
end

class Sidekiq::Logging::WithoutTimestamp
end

module Sidekiq::Logging
  extend ::T::Sig
  def self.initialize_logger(log_target=T.unsafe(nil)); end

  def self.job_hash_context(job_hash); end

  def self.logger(); end

  def self.logger=(log); end

  def self.reopen_logs(); end

  def self.tid(); end

  def self.with_context(msg); end

  def self.with_job_hash_context(job_hash, &block); end
end

module Sidekiq::Middleware
end

class Sidekiq::Middleware::Chain
  include ::Enumerable
  def add(klass, *args); end

  def clear(); end

  def each(&block); end

  def entries(); end

  def exists?(klass); end

  def insert_after(oldklass, newklass, *args); end

  def insert_before(oldklass, newklass, *args); end

  def invoke(*args); end

  def prepend(klass, *args); end

  def remove(klass); end

  def retrieve(); end
end

class Sidekiq::Middleware::Chain
end

class Sidekiq::Middleware::Entry
  def initialize(klass, *args); end

  def klass(); end

  def make_new(); end
end

class Sidekiq::Middleware::Entry
end

module Sidekiq::Middleware
  extend ::T::Sig
end

module Sidekiq::Paginator
  def page(key, pageidx=T.unsafe(nil), page_size=T.unsafe(nil), opts=T.unsafe(nil)); end
end

module Sidekiq::Paginator
  extend ::T::Sig
end

class Sidekiq::Process
  def [](key); end

  def dump_threads(); end

  def identity(); end

  def initialize(hash); end

  def labels(); end

  def quiet!(); end

  def stop!(); end

  def stopping?(); end

  def tag(); end
end

class Sidekiq::Process
end

class Sidekiq::ProcessSet
  include ::Enumerable
  include ::Sidekiq::RedisScanner
  def cleanup(); end

  def each(); end

  def initialize(clean_plz=T.unsafe(nil)); end

  def leader(); end

  def size(); end
end

class Sidekiq::ProcessSet
end

class Sidekiq::Queue
  include ::Enumerable
  def clear(); end

  def each(); end

  def find_job(jid); end

  def initialize(name=T.unsafe(nil)); end

  def latency(); end

  def name(); end

  def paused?(); end

  def size(); end
end

class Sidekiq::Queue
  extend ::Sidekiq::RedisScanner
  def self.all(); end
end

class Sidekiq::Rails
end

class Sidekiq::Rails::Reloader
  def call(); end

  def initialize(app=T.unsafe(nil)); end
end

class Sidekiq::Rails::Reloader
end

class Sidekiq::Rails
end

class Sidekiq::RedisConnection
end

class Sidekiq::RedisConnection
  def self.create(options=T.unsafe(nil)); end
end

module Sidekiq::RedisScanner
  def sscan(conn, key); end
end

module Sidekiq::RedisScanner
  extend ::T::Sig
end

class Sidekiq::RetrySet
  def initialize(); end

  def kill_all(); end

  def retry_all(); end
end

class Sidekiq::RetrySet
end

class Sidekiq::ScheduledSet
  def initialize(); end
end

class Sidekiq::ScheduledSet
end

class Sidekiq::Shutdown
end

class Sidekiq::Shutdown
end

class Sidekiq::SortedEntry
  def add_to_queue(); end

  def at(); end

  def error?(); end

  def initialize(parent, score, item); end

  def kill(); end

  def parent(); end

  def reschedule(at); end

  def retry(); end

  def score(); end
end

class Sidekiq::SortedEntry
end

class Sidekiq::SortedSet
  include ::Enumerable
  def clear(); end

  def initialize(name); end

  def name(); end

  def size(); end
end

class Sidekiq::SortedSet
end

class Sidekiq::Stats
  include ::Sidekiq::RedisScanner
  def dead_size(); end

  def default_queue_latency(); end

  def enqueued(); end

  def failed(); end

  def fetch_stats!(); end

  def processed(); end

  def processes_size(); end

  def queues(); end

  def reset(*stats); end

  def retry_size(); end

  def scheduled_size(); end

  def workers_size(); end
end

class Sidekiq::Stats::History
  def failed(); end

  def initialize(days_previous, start_date=T.unsafe(nil)); end

  def processed(); end
end

class Sidekiq::Stats::History
end

class Sidekiq::Stats::Queues
  include ::Sidekiq::RedisScanner
  def lengths(); end
end

class Sidekiq::Stats::Queues
end

class Sidekiq::Stats
end

class Sidekiq::Web
  def app(); end

  def call(env); end

  def disable(*opts); end

  def enable(*opts); end

  def middlewares(); end

  def sessions(); end

  def sessions=(sessions); end

  def set(attribute, value); end

  def settings(); end

  def use(*middleware_args, &block); end
  ASSETS = ::T.let(nil, ::T.untyped)
  DEFAULT_TABS = ::T.let(nil, ::T.untyped)
  LAYOUT = ::T.let(nil, ::T.untyped)
  LOCALES = ::T.let(nil, ::T.untyped)
  ROOT = ::T.let(nil, ::T.untyped)
  VIEWS = ::T.let(nil, ::T.untyped)
end

class Sidekiq::Web
  def self.app_url(); end

  def self.app_url=(app_url); end

  def self.call(env); end

  def self.custom_tabs(); end

  def self.default_tabs(); end

  def self.disable(*opts); end

  def self.enable(*opts); end

  def self.inherited(child); end

  def self.locales(); end

  def self.locales=(locales); end

  def self.middlewares(); end

  def self.redis_pool(); end

  def self.redis_pool=(redis_pool); end

  def self.register(extension); end

  def self.session_secret(); end

  def self.session_secret=(session_secret); end

  def self.sessions(); end

  def self.sessions=(sessions); end

  def self.set(attribute, value); end

  def self.settings(); end

  def self.tabs(); end

  def self.use(*middleware_args, &block); end

  def self.views(); end

  def self.views=(views); end
end

class Sidekiq::WebAction
  include ::Sidekiq::WebHelpers
  include ::Sidekiq::Paginator
  def _render(); end

  def block(); end

  def block=(block); end

  def env(); end

  def env=(env); end

  def erb(content, options=T.unsafe(nil)); end

  def halt(res); end

  def initialize(env, block); end

  def json(payload); end

  def params(); end

  def redirect(location); end

  def render(engine, content, options=T.unsafe(nil)); end

  def request(); end

  def route_params(); end

  def session(); end

  def settings(); end

  def type(); end

  def type=(type); end
  RACK_SESSION = ::T.let(nil, ::T.untyped)
end

class Sidekiq::WebAction
end

class Sidekiq::WebApplication
  def call(env); end

  def initialize(klass); end

  def settings(); end
  CONTENT_LENGTH = ::T.let(nil, ::T.untyped)
  CONTENT_TYPE = ::T.let(nil, ::T.untyped)
  CSP_HEADER = ::T.let(nil, ::T.untyped)
  REDIS_KEYS = ::T.let(nil, ::T.untyped)
end

class Sidekiq::WebApplication
  extend ::Sidekiq::WebRouter
  def self.after(path=T.unsafe(nil), &block); end

  def self.afters(); end

  def self.before(path=T.unsafe(nil), &block); end

  def self.befores(); end

  def self.helpers(mod=T.unsafe(nil), &block); end

  def self.run_afters(app, action); end

  def self.run_befores(app, action); end

  def self.run_hooks(hooks, app, action); end

  def self.set(key, val); end

  def self.settings(); end

  def self.tabs(); end
end

module Sidekiq::WebHelpers
  def add_to_head(); end

  def available_locales(); end

  def clear_caches(); end

  def csrf_tag(); end

  def current_path(); end

  def current_status(); end

  def delete_or_add_queue(job, params); end

  def display_args(args, truncate_after_chars=T.unsafe(nil)); end

  def display_custom_head(); end

  def environment_title_prefix(); end

  def filtering(*_); end

  def find_locale_files(lang); end

  def get_locale(); end

  def h(text); end

  def job_params(job, score); end

  def locale(); end

  def locale_files(); end

  def namespace(); end

  def number_with_delimiter(number); end

  def parse_params(params); end

  def poll_path(); end

  def processes(); end

  def product_version(); end

  def qparams(options); end

  def redirect_with_query(url); end

  def redis_connection(); end

  def redis_connection_and_namespace(); end

  def redis_info(); end

  def relative_time(time); end

  def retries_with_score(score); end

  def retry_extra_items(retry_job); end

  def retry_or_delete_or_kill(job, params); end

  def root_path(); end

  def rtl?(); end

  def server_utc_time(); end

  def stats(); end

  def strings(lang); end

  def t(msg, options=T.unsafe(nil)); end

  def text_direction(); end

  def to_display(arg); end

  def truncate(text, truncate_after_chars=T.unsafe(nil)); end

  def unfiltered?(); end

  def user_preferred_languages(); end

  def workers(); end
  RETRY_JOB_KEYS = ::T.let(nil, ::T.untyped)
  SAFE_QPARAMS = ::T.let(nil, ::T.untyped)
end

module Sidekiq::WebHelpers
  extend ::T::Sig
end

class Sidekiq::WebRoute
  def block(); end

  def block=(block); end

  def compile(); end

  def initialize(request_method, pattern, block); end

  def match(request_method, path); end

  def matcher(); end

  def name(); end

  def name=(name); end

  def pattern(); end

  def pattern=(pattern); end

  def request_method(); end

  def request_method=(request_method); end
  NAMED_SEGMENTS_PATTERN = ::T.let(nil, ::T.untyped)
end

class Sidekiq::WebRoute
end

module Sidekiq::WebRouter
  def delete(path, &block); end

  def get(path, &block); end

  def match(env); end

  def patch(path, &block); end

  def post(path, &block); end

  def put(path, &block); end

  def route(method, path, &block); end
  DELETE = ::T.let(nil, ::T.untyped)
  GET = ::T.let(nil, ::T.untyped)
  HEAD = ::T.let(nil, ::T.untyped)
  PATCH = ::T.let(nil, ::T.untyped)
  PATH_INFO = ::T.let(nil, ::T.untyped)
  POST = ::T.let(nil, ::T.untyped)
  PUT = ::T.let(nil, ::T.untyped)
  REQUEST_METHOD = ::T.let(nil, ::T.untyped)
  ROUTE_PARAMS = ::T.let(nil, ::T.untyped)
end

module Sidekiq::WebRouter
  extend ::T::Sig
end

module Sidekiq::Worker
  def jid(); end

  def jid=(jid); end

  def logger(); end
end

module Sidekiq::Worker
  extend ::T::Sig
  def self.included(base); end
end

class Sidekiq::Workers
  include ::Enumerable
  include ::Sidekiq::RedisScanner
  def each(); end

  def size(); end
end

class Sidekiq::Workers
end

module Sidekiq
  extend ::T::Sig
  def self.average_scheduled_poll_interval=(interval); end

  def self.client_middleware(); end

  def self.configure_client(); end

  def self.configure_server(); end

  def self.death_handlers(); end

  def self.default_retries_exhausted=(prok); end

  def self.default_server_middleware(); end

  def self.default_worker_options(); end

  def self.default_worker_options=(hash); end

  def self.dump_json(object); end

  def self.error_handlers(); end

  def self.load_json(string); end

  def self.logger(); end

  def self.logger=(log); end

  def self.on(event, &block); end

  def self.options(); end

  def self.options=(opts); end

  def self.redis(); end

  def self.redis=(hash); end

  def self.redis_info(); end

  def self.redis_pool(); end

  def self.server?(); end

  def self.server_middleware(); end
end

module Signal
  extend ::T::Sig
end

class SignalException
  def signm(); end

  def signo(); end
end

class SignalException
  extend ::T::Sig
end

class SignedGlobalID
  def expires_at(); end

  def purpose(); end

  def to_h(); end

  def to_s(); end

  def verifier(); end
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID::ExpiredMessage
end

class SignedGlobalID
  def self.expires_in(); end

  def self.expires_in=(expires_in); end

  def self.parse(sgid, options=T.unsafe(nil)); end

  def self.pick_purpose(options); end

  def self.pick_verifier(options); end

  def self.verifier(); end

  def self.verifier=(verifier); end
end

class SimpleDelegator
  extend ::T::Sig
end

module SingleForwardable
  def def_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_delegators(accessor, *methods); end

  def def_single_delegator(accessor, method, ali=T.unsafe(nil)); end

  def def_single_delegators(accessor, *methods); end

  def delegate(hash); end

  def single_delegate(hash); end
end

module SingleForwardable
  extend ::T::Sig
end

module Singleton
  def _dump(depth=T.unsafe(nil)); end

  def clone(); end

  def dup(); end
end

module Singleton::SingletonClassMethods
  def _load(str); end

  def clone(); end
end

module Singleton::SingletonClassMethods
  extend ::T::Sig
end

module Singleton
  extend ::T::Sig
  def self.__init__(klass); end
end

SizedQueue = Thread::SizedQueue

class Socket
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

class Socket::AncillaryData
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Socket::AncillaryData
  extend ::T::Sig
end

module Socket::Constants
  AF_CCITT = ::T.let(nil, ::T.untyped)
  AF_CHAOS = ::T.let(nil, ::T.untyped)
  AF_CNT = ::T.let(nil, ::T.untyped)
  AF_COIP = ::T.let(nil, ::T.untyped)
  AF_DATAKIT = ::T.let(nil, ::T.untyped)
  AF_DLI = ::T.let(nil, ::T.untyped)
  AF_E164 = ::T.let(nil, ::T.untyped)
  AF_ECMA = ::T.let(nil, ::T.untyped)
  AF_HYLINK = ::T.let(nil, ::T.untyped)
  AF_IMPLINK = ::T.let(nil, ::T.untyped)
  AF_ISO = ::T.let(nil, ::T.untyped)
  AF_LAT = ::T.let(nil, ::T.untyped)
  AF_LINK = ::T.let(nil, ::T.untyped)
  AF_NATM = ::T.let(nil, ::T.untyped)
  AF_NDRV = ::T.let(nil, ::T.untyped)
  AF_NETBIOS = ::T.let(nil, ::T.untyped)
  AF_NS = ::T.let(nil, ::T.untyped)
  AF_OSI = ::T.let(nil, ::T.untyped)
  AF_PPP = ::T.let(nil, ::T.untyped)
  AF_PUP = ::T.let(nil, ::T.untyped)
  AF_SIP = ::T.let(nil, ::T.untyped)
  AF_SYSTEM = ::T.let(nil, ::T.untyped)
  AI_DEFAULT = ::T.let(nil, ::T.untyped)
  AI_MASK = ::T.let(nil, ::T.untyped)
  AI_V4MAPPED_CFG = ::T.let(nil, ::T.untyped)
  EAI_BADHINTS = ::T.let(nil, ::T.untyped)
  EAI_MAX = ::T.let(nil, ::T.untyped)
  EAI_PROTOCOL = ::T.let(nil, ::T.untyped)
  IFF_ALTPHYS = ::T.let(nil, ::T.untyped)
  IFF_LINK0 = ::T.let(nil, ::T.untyped)
  IFF_LINK1 = ::T.let(nil, ::T.untyped)
  IFF_LINK2 = ::T.let(nil, ::T.untyped)
  IFF_OACTIVE = ::T.let(nil, ::T.untyped)
  IFF_SIMPLEX = ::T.let(nil, ::T.untyped)
  IPPROTO_EON = ::T.let(nil, ::T.untyped)
  IPPROTO_GGP = ::T.let(nil, ::T.untyped)
  IPPROTO_HELLO = ::T.let(nil, ::T.untyped)
  IPPROTO_MAX = ::T.let(nil, ::T.untyped)
  IPPROTO_ND = ::T.let(nil, ::T.untyped)
  IPPROTO_XTP = ::T.let(nil, ::T.untyped)
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_USE_MIN_MTU = ::T.let(nil, ::T.untyped)
  IP_PORTRANGE = ::T.let(nil, ::T.untyped)
  IP_RECVDSTADDR = ::T.let(nil, ::T.untyped)
  IP_RECVIF = ::T.let(nil, ::T.untyped)
  LOCAL_PEERCRED = ::T.let(nil, ::T.untyped)
  MSG_EOF = ::T.let(nil, ::T.untyped)
  MSG_FLUSH = ::T.let(nil, ::T.untyped)
  MSG_HAVEMORE = ::T.let(nil, ::T.untyped)
  MSG_HOLD = ::T.let(nil, ::T.untyped)
  MSG_RCVMORE = ::T.let(nil, ::T.untyped)
  MSG_SEND = ::T.let(nil, ::T.untyped)
  PF_CCITT = ::T.let(nil, ::T.untyped)
  PF_CHAOS = ::T.let(nil, ::T.untyped)
  PF_CNT = ::T.let(nil, ::T.untyped)
  PF_COIP = ::T.let(nil, ::T.untyped)
  PF_DATAKIT = ::T.let(nil, ::T.untyped)
  PF_DLI = ::T.let(nil, ::T.untyped)
  PF_ECMA = ::T.let(nil, ::T.untyped)
  PF_HYLINK = ::T.let(nil, ::T.untyped)
  PF_IMPLINK = ::T.let(nil, ::T.untyped)
  PF_ISO = ::T.let(nil, ::T.untyped)
  PF_LAT = ::T.let(nil, ::T.untyped)
  PF_LINK = ::T.let(nil, ::T.untyped)
  PF_NATM = ::T.let(nil, ::T.untyped)
  PF_NDRV = ::T.let(nil, ::T.untyped)
  PF_NETBIOS = ::T.let(nil, ::T.untyped)
  PF_NS = ::T.let(nil, ::T.untyped)
  PF_OSI = ::T.let(nil, ::T.untyped)
  PF_PIP = ::T.let(nil, ::T.untyped)
  PF_PPP = ::T.let(nil, ::T.untyped)
  PF_PUP = ::T.let(nil, ::T.untyped)
  PF_RTIP = ::T.let(nil, ::T.untyped)
  PF_SIP = ::T.let(nil, ::T.untyped)
  PF_SYSTEM = ::T.let(nil, ::T.untyped)
  PF_XTP = ::T.let(nil, ::T.untyped)
  SCM_CREDS = ::T.let(nil, ::T.untyped)
  SO_DONTTRUNC = ::T.let(nil, ::T.untyped)
  SO_NKE = ::T.let(nil, ::T.untyped)
  SO_NOSIGPIPE = ::T.let(nil, ::T.untyped)
  SO_NREAD = ::T.let(nil, ::T.untyped)
  SO_USELOOPBACK = ::T.let(nil, ::T.untyped)
  SO_WANTMORE = ::T.let(nil, ::T.untyped)
  SO_WANTOOBFLAG = ::T.let(nil, ::T.untyped)
  TCP_NOOPT = ::T.let(nil, ::T.untyped)
  TCP_NOPUSH = ::T.let(nil, ::T.untyped)
end

module Socket::Constants
  extend ::T::Sig
end

class Socket::Ifaddr
  extend ::T::Sig
end

class Socket::Option
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Socket::Option
  extend ::T::Sig
end

class Socket::UDPSource
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Socket::UDPSource
  extend ::T::Sig
end

class Socket
  extend ::T::Sig
end

class SocketError
  include ::REST::Error::Connection
  include ::REST::Error
end

class SocketError
  extend ::T::Sig
end

class Sorbet
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Sorbet::Private::ConstantLookupCache
  def all_module_aliases(); end

  def all_module_names(); end

  def all_named_modules(); end

  def class_by_name(name); end

  def name_by_class(klass); end
  DEPRECATED_CONSTANTS = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def aliases(); end

  def aliases=(_); end

  def const(); end

  def const=(_); end

  def const_name(); end

  def const_name=(_); end

  def found_name(); end

  def found_name=(_); end

  def owner(); end

  def owner=(_); end

  def primary_name(); end

  def primary_name=(_); end
end

class Sorbet::Private::ConstantLookupCache::ConstantEntry
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::ConstantLookupCache
end

class Sorbet::Private::CreateConfig
  include ::Sorbet::Private::StepInterface
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::CreateConfig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::FetchRBIs
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  SORBET_CONFIG_FILE = ::T.let(nil, ::T.untyped)
  SORBET_DIR = ::T.let(nil, ::T.untyped)
  SORBET_RBI_LIST = ::T.let(nil, ::T.untyped)
  SORBET_RBI_SORBET_TYPED = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REPO = ::T.let(nil, ::T.untyped)
  SORBET_TYPED_REVISION = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FetchRBIs
  def self.fetch_sorbet_typed(); end

  def self.main(); end

  def self.matching_version_directories(root, version); end

  def self.output_file(); end

  def self.paths_for_gem_version(gemspec); end

  def self.paths_for_ruby_version(ruby_version); end

  def self.vendor_rbis_within_paths(vendor_paths); end
end

class Sorbet::Private::FindGemRBIs
  include ::Sorbet::Private::StepInterface
  GEM_DIR = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  RBI_CACHE_DIR = ::T.let(nil, ::T.untyped)
  XDG_CACHE_HOME = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::FindGemRBIs
  def self.main(); end

  def self.output_file(); end

  def self.paths_within_gem_sources(gemspec); end
end

module Sorbet::Private::GemGeneratorTracepoint
  include ::Sorbet::Private::StepInterface
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def defs(); end

  def defs=(_); end

  def id(); end

  def id=(_); end

  def klass(); end

  def klass=(_); end
end

class Sorbet::Private::GemGeneratorTracepoint::ClassDefinition
  def self.[](*_); end

  def self.members(); end
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
  def initialize(files:, delegate_classes:); end

  def serialize(output_dir); end
  BAD_METHODS = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemGeneratorTracepoint::TracepointSerializer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
end

class Sorbet::Private::GemGeneratorTracepoint::Tracer
  def self.add_to_context(item); end

  def self.disable_tracepoints(); end

  def self.finish(); end

  def self.install_tracepoints(); end

  def self.method_added(mod, method, singleton); end

  def self.module_created(mod); end

  def self.module_extended(extended, extender); end

  def self.module_included(included, includer); end

  def self.pre_cache_module_methods(); end

  def self.register_delegate_class(klass, delegate); end

  def self.start(); end

  def self.trace(); end

  def self.trace_results(); end
end

module Sorbet::Private::GemGeneratorTracepoint
  extend ::T::Sig
  def self.main(output_dir=T.unsafe(nil)); end

  def self.output_file(); end
end

class Sorbet::Private::GemLoader
  GEM_LOADER = ::T.let(nil, ::T.untyped)
  NO_GEM = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::GemLoader
  def self.my_require(gem); end

  def self.require_all_gems(); end

  def self.require_gem(gem); end
end

class Sorbet::Private::HiddenMethodFinder
  include ::Sorbet::Private::StepInterface
  def all_modules_and_aliases(); end

  def capture_stderr(); end

  def constant_cache(); end

  def gen_source_rbi(classes, aliases); end

  def looks_like_stub_name(name); end

  def main(); end

  def mk_dir(); end

  def read_constants(); end

  def real_name(mod); end

  def require_everything(); end

  def rm_dir(); end

  def serialize_alias(source_entry, rbi_entry, my_klass, source_symbols, rbi_symbols); end

  def serialize_class(source_entry, rbi_entry, klass, source_symbols, rbi_symbols, source_by_name); end

  def serialize_constants(source, rbi, klass, is_singleton, source_symbols, rbi_symbols); end

  def symbols_id_to_name(entry, prefix); end

  def write_constants(); end

  def write_diff(source, rbi); end
  BLACKLIST = ::T.let(nil, ::T.untyped)
  DIFF_RBI = ::T.let(nil, ::T.untyped)
  ERRORS_RBI = ::T.let(nil, ::T.untyped)
  HEADER = ::T.let(nil, ::T.untyped)
  HIDDEN_RBI = ::T.let(nil, ::T.untyped)
  PATH = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS = ::T.let(nil, ::T.untyped)
  RBI_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS = ::T.let(nil, ::T.untyped)
  SOURCE_CONSTANTS_ERR = ::T.let(nil, ::T.untyped)
  TMP_PATH = ::T.let(nil, ::T.untyped)
  TMP_RBI = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::HiddenMethodFinder
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private::Main
end

module Sorbet::Private::Main
  extend ::T::Sig
  def self.cyan(msg); end

  def self.emojify(emoji, msg); end

  def self.main(argv); end

  def self.make_step(step); end

  def self.parse_command(argv); end

  def self.yellow(msg); end
end

module Sorbet::Private::RealStdlib
end

module Sorbet::Private::RealStdlib
  extend ::T::Sig
  def self.real_ancestors(mod); end

  def self.real_autoload?(o, klass); end

  def self.real_const_get(obj, const, arg); end

  def self.real_constants(mod); end

  def self.real_eqeq(obj, other); end

  def self.real_hash(o); end

  def self.real_instance_methods(mod, arg); end

  def self.real_is_a?(o, klass); end

  def self.real_name(o); end

  def self.real_object_id(o); end

  def self.real_private_instance_methods(mod, arg); end

  def self.real_singleton_class(obj); end

  def self.real_singleton_methods(mod, arg); end

  def self.real_spaceship(obj, arg); end

  def self.real_superclass(o); end
end

class Sorbet::Private::RequireEverything
end

class Sorbet::Private::RequireEverything
  def self.excluded_rails_files(); end

  def self.load_bundler(); end

  def self.load_rails(); end

  def self.my_require(abs_path, numerator, denominator); end

  def self.patch_kernel(); end

  def self.rails?(); end

  def self.require_all_files(); end

  def self.require_everything(); end
end

class Sorbet::Private::Serialize
  def alias(base, other_name); end

  def ancestor_has_method(method, klass); end

  def blacklisted_method(method); end

  def class_or_module(class_name); end

  def comparable?(value); end

  def constant(const, value); end

  def from_method(method); end

  def initialize(constant_cache); end

  def serialize_method(method, static=T.unsafe(nil), with_sig: T.unsafe(nil)); end

  def serialize_sig(parameters); end

  def to_sig(kind, name); end

  def valid_class_name(name); end

  def valid_method_name(name); end
  BLACKLIST_CONSTANTS = ::T.let(nil, ::T.untyped)
  KEYWORDS = ::T.let(nil, ::T.untyped)
  SPECIAL_METHOD_NAMES = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::Serialize
  def self.header(typed=T.unsafe(nil), subcommand=T.unsafe(nil)); end
end

module Sorbet::Private::Status
end

module Sorbet::Private::Status
  extend ::T::Sig
  def self.done(); end

  def self.say(message, print_without_tty: T.unsafe(nil)); end
end

module Sorbet::Private::StepInterface
end

module Sorbet::Private::StepInterface
  extend ::T::Sig
  def self.main(); end

  def self.output_file(); end
end

class Sorbet::Private::SuggestTyped
  include ::Sorbet::Private::StepInterface
end

class Sorbet::Private::SuggestTyped
  def self.main(); end

  def self.output_file(); end

  def self.suggest_typed(); end
end

class Sorbet::Private::TodoRBI
  include ::Sorbet::Private::StepInterface
  HEADER = ::T.let(nil, ::T.untyped)
  OUTPUT = ::T.let(nil, ::T.untyped)
end

class Sorbet::Private::TodoRBI
  def self.main(); end

  def self.output_file(); end
end

module Sorbet::Private
  extend ::T::Sig
end

class Sorbet
  extend ::T::Sig
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  extend ::T::Sig
  def self.setup(); end
end

class SourceAnnotationExtractor
  def display(results, options=T.unsafe(nil)); end

  def extract_annotations_from(file, pattern); end

  def find(dirs); end

  def find_in(dir); end

  def initialize(tag); end

  def tag(); end
end

class SourceAnnotationExtractor::Annotation
  def line(); end

  def line=(_); end

  def tag(); end

  def tag=(_); end

  def text(); end

  def text=(_); end

  def to_s(options=T.unsafe(nil)); end
end

class SourceAnnotationExtractor::Annotation
  def self.[](*_); end

  def self.directories(); end

  def self.extensions(); end

  def self.members(); end

  def self.register_directories(*dirs); end

  def self.register_extensions(*exts, &block); end
end

class SourceAnnotationExtractor
  def self.enumerate(tag, options=T.unsafe(nil)); end
end

module Sprockets
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ArgumentError
end

class Sprockets::ArgumentError
end

class Sprockets::Asset
  def ==(other); end

  def base64digest(); end

  def bytesize(); end

  def charset(); end

  def content_type(); end

  def dependencies(); end

  def digest(); end

  def digest_path(); end

  def each(); end

  def eql?(other); end

  def etag(); end

  def filename(); end

  def hexdigest(); end

  def id(); end

  def included(); end

  def initialize(environment, attributes=T.unsafe(nil)); end

  def integrity(); end

  def length(); end

  def links(); end

  def logical_path(); end

  def metadata(); end

  def mtime(); end

  def pathname(); end

  def source(); end

  def to_a(); end

  def to_hash(); end

  def uri(); end

  def write_to(filename); end
end

class Sprockets::Asset
end

module Sprockets::Autoload
end

Sprockets::Autoload::CoffeeScript = CoffeeScript

module Sprockets::Autoload::Sass
  ROOT_DIR = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::BaseEnvironment
  def _function(name); end

  def _mixin(name); end

  def _var(name); end

  def caller(); end

  def caller=(caller); end

  def content(); end

  def content=(content); end

  def function(name); end

  def global?(); end

  def global_env(); end

  def initialize(parent=T.unsafe(nil), options=T.unsafe(nil)); end

  def is_function_global?(name); end

  def is_mixin_global?(name); end

  def is_var_global?(name); end

  def mixin(name); end

  def options(); end

  def selector(); end

  def selector=(selector); end

  def stack(); end

  def var(name); end
end

class Sprockets::Autoload::Sass::BaseEnvironment
  def self.inherited_hash_accessor(name); end

  def self.inherited_hash_reader(name); end

  def self.inherited_hash_writer(name); end
end

module Sprockets::Autoload::Sass::CacheStores
end

class Sprockets::Autoload::Sass::CacheStores::Base
  def _retrieve(key, version, sha); end

  def _store(key, version, sha, contents); end

  def key(sass_dirname, sass_basename); end

  def retrieve(key, sha); end

  def store(key, sha, root); end
end

class Sprockets::Autoload::Sass::CacheStores::Base
end

class Sprockets::Autoload::Sass::CacheStores::Chain
  def initialize(*caches); end

  def store(key, sha, obj); end
end

class Sprockets::Autoload::Sass::CacheStores::Chain
end

class Sprockets::Autoload::Sass::CacheStores::Filesystem
  def cache_location(); end

  def cache_location=(cache_location); end

  def initialize(cache_location); end
end

class Sprockets::Autoload::Sass::CacheStores::Filesystem
end

class Sprockets::Autoload::Sass::CacheStores::Memory
  def _dump(depth); end

  def reset!(); end

  def store(key, sha, obj); end
end

class Sprockets::Autoload::Sass::CacheStores::Memory
  def self._load(repr); end
end

module Sprockets::Autoload::Sass::CacheStores
  extend ::T::Sig
end

class Sprockets::Autoload::Sass::Callable
  def args(); end

  def args=(_); end

  def environment(); end

  def environment=(_); end

  def has_content(); end

  def has_content=(_); end

  def name(); end

  def name=(_); end

  def origin(); end

  def origin=(_); end

  def splat(); end

  def splat=(_); end

  def tree(); end

  def tree=(_); end

  def type(); end

  def type=(_); end
end

class Sprockets::Autoload::Sass::Callable
  def self.[](*_); end

  def self.members(); end
end

class Sprockets::Autoload::Sass::Deprecation
  def warn(filename, line, column_or_message, message=T.unsafe(nil)); end
end

class Sprockets::Autoload::Sass::Deprecation
  def self.allow_double_warnings(); end
end

class Sprockets::Autoload::Sass::Engine
  def _dependencies(seen, engines); end

  def dependencies(); end

  def initialize(template, options=T.unsafe(nil)); end

  def options(); end

  def render(); end

  def render_with_sourcemap(sourcemap_uri); end

  def source_encoding(); end

  def to_css(); end

  def to_tree(); end
  COMMENT_CHAR = ::T.let(nil, ::T.untyped)
  CONTENT_RE = ::T.let(nil, ::T.untyped)
  CSS_COMMENT_CHAR = ::T.let(nil, ::T.untyped)
  DEFAULT_OPTIONS = ::T.let(nil, ::T.untyped)
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  DIRECTIVE_CHAR = ::T.let(nil, ::T.untyped)
  ESCAPE_CHAR = ::T.let(nil, ::T.untyped)
  FUNCTION_RE = ::T.let(nil, ::T.untyped)
  MIXIN_DEFINITION_CHAR = ::T.let(nil, ::T.untyped)
  MIXIN_DEF_RE = ::T.let(nil, ::T.untyped)
  MIXIN_INCLUDE_CHAR = ::T.let(nil, ::T.untyped)
  MIXIN_INCLUDE_RE = ::T.let(nil, ::T.untyped)
  PROPERTY_CHAR = ::T.let(nil, ::T.untyped)
  PROPERTY_OLD = ::T.let(nil, ::T.untyped)
  SASS_COMMENT_CHAR = ::T.let(nil, ::T.untyped)
  SASS_LOUD_COMMENT_CHAR = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Engine::Line
  def comment?(); end
end

class Sprockets::Autoload::Sass::Engine::Line
end

class Sprockets::Autoload::Sass::Engine
  def self.for_file(filename, options); end

  def self.normalize_options(options); end

  def self.parse_interp(text, line, offset, options); end
end

class Sprockets::Autoload::Sass::Environment
  def parent(); end

  def set_function(name, value); end

  def set_global_function(name, value); end

  def set_global_mixin(name, value); end

  def set_global_var(name, value); end

  def set_local_function(name, value); end

  def set_local_mixin(name, value); end

  def set_local_var(name, value); end

  def set_mixin(name, value); end

  def set_var(name, value); end

  def try_set_function(name, value); end

  def try_set_mixin(name, value); end

  def try_set_var(name, value); end
end

class Sprockets::Autoload::Sass::Environment
end

module Sprockets::Autoload::Sass::Features
  def add_feature(feature_name); end

  def has_feature?(feature_name); end
  KNOWN_FEATURES = ::T.let(nil, ::T.untyped)
end

module Sprockets::Autoload::Sass::Features
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Importers
end

class Sprockets::Autoload::Sass::Importers::Base
  def directories_to_watch(); end

  def find(uri, options); end

  def find_relative(uri, base, options); end

  def key(uri, options); end

  def mtime(uri, options); end

  def public_url(uri, sourcemap_directory); end

  def watched_file?(filename); end
end

class Sprockets::Autoload::Sass::Importers::Base
end

class Sprockets::Autoload::Sass::Importers::DeprecatedPath
  def deprecation_warning(); end

  def find(*args); end
end

class Sprockets::Autoload::Sass::Importers::DeprecatedPath
end

class Sprockets::Autoload::Sass::Importers::Filesystem
  def eql?(other); end

  def escape_glob_characters(name); end

  def extensions(); end

  def find(name, options); end

  def find_real_file(dir, name, options); end

  def find_relative(name, base, options); end

  def initialize(root); end

  def key(name, options); end

  def mtime(name, options); end

  def possible_files(name); end

  def public_url(name, sourcemap_directory); end

  def remove_root(name); end

  def root(); end

  def root=(root); end

  def split(name); end
  REDUNDANT_DIRECTORY = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Importers::Filesystem
end

module Sprockets::Autoload::Sass::Importers
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Logger
end

class Sprockets::Autoload::Sass::Logger::Base
  include ::Sprockets::Autoload::Sass::Logger::LogLevel
  def _log(level, message); end

  def capture(); end

  def debug(message); end

  def disabled(); end

  def disabled=(disabled); end

  def error(message); end

  def info(message); end

  def initialize(log_level=T.unsafe(nil), io=T.unsafe(nil)); end

  def io(); end

  def io=(io); end

  def log(level, message); end

  def log_level(); end

  def log_level=(log_level); end

  def logging_level?(level); end

  def trace(message); end

  def warn(message); end
end

class Sprockets::Autoload::Sass::Logger::Base
  extend ::Sprockets::Autoload::Sass::Logger::LogLevel::ClassMethods
end

class Sprockets::Autoload::Sass::Logger::Delayed
  def flush(); end

  def initialize(inner); end

  def uninstall!(); end
end

class Sprockets::Autoload::Sass::Logger::Delayed
  def self.install!(); end
end

module Sprockets::Autoload::Sass::Logger::LogLevel
end

module Sprockets::Autoload::Sass::Logger::LogLevel::ClassMethods
  def define_logger(name, options=T.unsafe(nil)); end

  def inherited(subclass); end

  def log_level(name, options=T.unsafe(nil)); end

  def log_level?(level, min_level); end

  def log_levels(); end

  def log_levels=(log_levels); end
end

module Sprockets::Autoload::Sass::Logger::LogLevel::ClassMethods
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Logger::LogLevel
  extend ::T::Sig
  def self.included(base); end
end

module Sprockets::Autoload::Sass::Logger
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Media
end

class Sprockets::Autoload::Sass::Media::Query
  def deep_copy(); end

  def expressions(); end

  def expressions=(expressions); end

  def initialize(modifier, type, expressions); end

  def merge(other); end

  def modifier(); end

  def modifier=(modifier); end

  def resolved_modifier(); end

  def resolved_type(); end

  def to_a(); end

  def to_css(); end

  def to_src(options); end

  def type(); end

  def type=(type); end
end

class Sprockets::Autoload::Sass::Media::Query
end

class Sprockets::Autoload::Sass::Media::QueryList
  def deep_copy(); end

  def initialize(queries); end

  def merge(other); end

  def queries(); end

  def queries=(queries); end

  def to_a(); end

  def to_css(); end

  def to_src(options); end
end

class Sprockets::Autoload::Sass::Media::QueryList
end

module Sprockets::Autoload::Sass::Media
  extend ::T::Sig
  def self._interp_to_src(interp, options); end
end

class Sprockets::Autoload::Sass::ReadOnlyEnvironment
end

class Sprockets::Autoload::Sass::ReadOnlyEnvironment
end

module Sprockets::Autoload::Sass::SCSS
end

class Sprockets::Autoload::Sass::SCSS::CssParser
end

class Sprockets::Autoload::Sass::SCSS::CssParser
end

class Sprockets::Autoload::Sass::SCSS::Parser
  include ::Sprockets::Autoload::Sass::SCSS::RX
  def initialize(str, filename, importer, line=T.unsafe(nil), offset=T.unsafe(nil)); end

  def offset(); end

  def offset=(offset); end

  def parse(); end

  def parse_at_root_query(); end

  def parse_declaration_value(); end

  def parse_interp_ident(); end

  def parse_media_query_list(); end

  def parse_supports_clause(); end

  def parse_supports_condition(); end
  DIRECTIVES = ::T.let(nil, ::T.untyped)
  EXPR_NAMES = ::T.let(nil, ::T.untyped)
  NEWLINE = ::T.let(nil, ::T.untyped)
  PREFIXED_DIRECTIVES = ::T.let(nil, ::T.untyped)
  TOK_NAMES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::SCSS::Parser
  def self.expected(scanner, expected, line); end

  def self.sass_script_parser(); end

  def self.sass_script_parser=(sass_script_parser); end
end

module Sprockets::Autoload::Sass::SCSS::RX
  ANY = ::T.let(nil, ::T.untyped)
  CDC = ::T.let(nil, ::T.untyped)
  CDO = ::T.let(nil, ::T.untyped)
  COMMENT = ::T.let(nil, ::T.untyped)
  DASHMATCH = ::T.let(nil, ::T.untyped)
  DOMAIN = ::T.let(nil, ::T.untyped)
  ESCAPE = ::T.let(nil, ::T.untyped)
  FUNCTION = ::T.let(nil, ::T.untyped)
  GREATER = ::T.let(nil, ::T.untyped)
  H = ::T.let(nil, ::T.untyped)
  HASH = ::T.let(nil, ::T.untyped)
  HEXCOLOR = ::T.let(nil, ::T.untyped)
  IDENT = ::T.let(nil, ::T.untyped)
  IDENT_HYPHEN_INTERP = ::T.let(nil, ::T.untyped)
  IDENT_START = ::T.let(nil, ::T.untyped)
  IMPORTANT = ::T.let(nil, ::T.untyped)
  INCLUDES = ::T.let(nil, ::T.untyped)
  INTERP_START = ::T.let(nil, ::T.untyped)
  NAME = ::T.let(nil, ::T.untyped)
  NL = ::T.let(nil, ::T.untyped)
  NMCHAR = ::T.let(nil, ::T.untyped)
  NMSTART = ::T.let(nil, ::T.untyped)
  NONASCII = ::T.let(nil, ::T.untyped)
  NOT = ::T.let(nil, ::T.untyped)
  NUMBER = ::T.let(nil, ::T.untyped)
  OPTIONAL = ::T.let(nil, ::T.untyped)
  PERCENTAGE = ::T.let(nil, ::T.untyped)
  PLUS = ::T.let(nil, ::T.untyped)
  PREFIXMATCH = ::T.let(nil, ::T.untyped)
  RANGE = ::T.let(nil, ::T.untyped)
  S = ::T.let(nil, ::T.untyped)
  SINGLE_LINE_COMMENT = ::T.let(nil, ::T.untyped)
  STATIC_COMPONENT = ::T.let(nil, ::T.untyped)
  STATIC_SELECTOR = ::T.let(nil, ::T.untyped)
  STATIC_VALUE = ::T.let(nil, ::T.untyped)
  STRING = ::T.let(nil, ::T.untyped)
  STRING1 = ::T.let(nil, ::T.untyped)
  STRING1_NOINTERP = ::T.let(nil, ::T.untyped)
  STRING2 = ::T.let(nil, ::T.untyped)
  STRING2_NOINTERP = ::T.let(nil, ::T.untyped)
  STRING_NOINTERP = ::T.let(nil, ::T.untyped)
  SUBSTRINGMATCH = ::T.let(nil, ::T.untyped)
  SUFFIXMATCH = ::T.let(nil, ::T.untyped)
  TILDE = ::T.let(nil, ::T.untyped)
  UNICODE = ::T.let(nil, ::T.untyped)
  UNICODERANGE = ::T.let(nil, ::T.untyped)
  UNIT = ::T.let(nil, ::T.untyped)
  UNITLESS_NUMBER = ::T.let(nil, ::T.untyped)
  URI = ::T.let(nil, ::T.untyped)
  URL = ::T.let(nil, ::T.untyped)
  URLCHAR = ::T.let(nil, ::T.untyped)
  URL_PREFIX = ::T.let(nil, ::T.untyped)
  VARIABLE = ::T.let(nil, ::T.untyped)
  W = ::T.let(nil, ::T.untyped)
end

module Sprockets::Autoload::Sass::SCSS::RX
  extend ::T::Sig
  def self.escape_char(c); end

  def self.escape_ident(str); end

  def self.quote(str, flags=T.unsafe(nil)); end
end

class Sprockets::Autoload::Sass::SCSS::StaticParser
  def initialize(str, filename, importer, line=T.unsafe(nil), offset=T.unsafe(nil), allow_parent_ref=T.unsafe(nil)); end

  def parse_keyframes_selector(); end

  def parse_selector(); end

  def parse_static_at_root_query(); end
  PREFIXED_SELECTOR_PSEUDO_CLASSES = ::T.let(nil, ::T.untyped)
  SELECTOR_PSEUDO_CLASSES = ::T.let(nil, ::T.untyped)
  SELECTOR_PSEUDO_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::SCSS::StaticParser
end

module Sprockets::Autoload::Sass::SCSS
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Script
  CONST_RENAMES = ::T.let(nil, ::T.untyped)
  MATCH = ::T.let(nil, ::T.untyped)
  VALIDATE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Script::CssLexer
end

class Sprockets::Autoload::Sass::Script::CssLexer
end

class Sprockets::Autoload::Sass::Script::CssParser
  def div(); end
end

class Sprockets::Autoload::Sass::Script::CssParser
end

module Sprockets::Autoload::Sass::Script::Functions
  def abs(number); end

  def adjust_color(color, kwargs); end

  def adjust_hue(color, degrees); end

  def alpha(*args); end

  def append(list, val, separator=T.unsafe(nil)); end

  def blue(color); end

  def call(name, *args); end

  def ceil(number); end

  def change_color(color, kwargs); end

  def comparable(number1, number2); end

  def complement(color); end

  def content_exists(); end

  def counter(*args); end

  def counters(*args); end

  def darken(color, amount); end

  def desaturate(color, amount); end

  def fade_in(color, amount); end

  def fade_out(color, amount); end

  def feature_exists(feature); end

  def floor(number); end

  def function_exists(name); end

  def get_function(name, kwargs=T.unsafe(nil)); end

  def global_variable_exists(name); end

  def grayscale(color); end

  def green(color); end

  def hsl(hue, saturation=T.unsafe(nil), lightness=T.unsafe(nil)); end

  def hsla(hue, saturation=T.unsafe(nil), lightness=T.unsafe(nil), alpha=T.unsafe(nil)); end

  def hue(color); end

  def ie_hex_str(color); end

  def if(condition, if_true, if_false); end

  def index(list, value); end

  def inspect(value); end

  def invert(color, weight=T.unsafe(nil)); end

  def is_bracketed(list); end

  def is_superselector(sup, sub); end

  def join(list1, list2, separator=T.unsafe(nil), bracketed=T.unsafe(nil), kwargs=T.unsafe(nil), *rest); end

  def keywords(args); end

  def length(list); end

  def lighten(color, amount); end

  def lightness(color); end

  def list_separator(list); end

  def map_get(map, key); end

  def map_has_key(map, key); end

  def map_keys(map); end

  def map_merge(map1, map2); end

  def map_remove(map, *keys); end

  def map_values(map); end

  def max(*values); end

  def min(*numbers); end

  def mix(color1, color2, weight=T.unsafe(nil)); end

  def mixin_exists(name); end

  def nth(list, n); end

  def opacify(color, amount); end

  def opacity(color); end

  def percentage(number); end

  def quote(string); end

  def random(limit=T.unsafe(nil)); end

  def red(color); end

  def rgb(red, green=T.unsafe(nil), blue=T.unsafe(nil)); end

  def rgba(*args); end

  def round(number); end

  def saturate(color, amount=T.unsafe(nil)); end

  def saturation(color); end

  def scale_color(color, kwargs); end

  def selector_append(*selectors); end

  def selector_extend(selector, extendee, extender); end

  def selector_nest(*selectors); end

  def selector_parse(selector); end

  def selector_replace(selector, original, replacement); end

  def selector_unify(selector1, selector2); end

  def set_nth(list, n, value); end

  def simple_selectors(selector); end

  def str_index(string, substring); end

  def str_insert(original, insert, index); end

  def str_length(string); end

  def str_slice(string, start_at, end_at=T.unsafe(nil)); end

  def to_lower_case(string); end

  def to_upper_case(string); end

  def transparentize(color, amount); end

  def type_of(value); end

  def unique_id(); end

  def unit(number); end

  def unitless(number); end

  def unquote(string); end

  def variable_exists(name); end

  def zip(*lists); end
end

class Sprockets::Autoload::Sass::Script::Functions::EvaluationContext
  include ::Sprockets::Autoload::Sass::Script::Functions
  include ::Sass::Script::Value::Helpers
  def assert_integer(number, name=T.unsafe(nil)); end

  def assert_type(value, type, name=T.unsafe(nil)); end

  def assert_unit(number, unit, name=T.unsafe(nil)); end

  def environment(); end

  def initialize(environment); end

  def options(); end

  def perform(node, env=T.unsafe(nil)); end
  TYPE_NAMES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Script::Functions::EvaluationContext
end

class Sprockets::Autoload::Sass::Script::Functions::Signature
  def args(); end

  def args=(_); end

  def delayed_args(); end

  def delayed_args=(_); end

  def deprecated(); end

  def deprecated=(_); end

  def var_args(); end

  def var_args=(_); end

  def var_kwargs(); end

  def var_kwargs=(_); end
end

class Sprockets::Autoload::Sass::Script::Functions::Signature
  def self.[](*_); end

  def self.members(); end
end

module Sprockets::Autoload::Sass::Script::Functions
  extend ::T::Sig
  def self.callable?(_); end

  def self.declare(method_name, args, options=T.unsafe(nil)); end

  def self.random_number_generator(); end

  def self.random_seed=(seed); end

  def self.signature(method_name, arg_arity, kwarg_arity); end
end

class Sprockets::Autoload::Sass::Script::Lexer
  include ::Sprockets::Autoload::Sass::SCSS::RX
  def after_interpolation?(); end

  def char(pos=T.unsafe(nil)); end

  def done?(); end

  def expected!(name); end

  def initialize(str, line, offset, options); end

  def line(); end

  def next(); end

  def offset(); end

  def peek(); end

  def str(); end

  def unpeek!(); end

  def whitespace?(tok=T.unsafe(nil)); end
  IDENT_OP_NAMES = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  OPERATORS_REVERSE = ::T.let(nil, ::T.untyped)
  OP_NAMES = ::T.let(nil, ::T.untyped)
  PARSEABLE_NUMBER = ::T.let(nil, ::T.untyped)
  REGULAR_EXPRESSIONS = ::T.let(nil, ::T.untyped)
  STRING_REGULAR_EXPRESSIONS = ::T.let(nil, ::T.untyped)
  TOKEN_NAMES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Script::Lexer::Token
  def pos(); end

  def pos=(_); end

  def source_range(); end

  def source_range=(_); end

  def type(); end

  def type=(_); end

  def value(); end

  def value=(_); end
end

class Sprockets::Autoload::Sass::Script::Lexer::Token
  def self.[](*_); end

  def self.members(); end
end

class Sprockets::Autoload::Sass::Script::Lexer
end

class Sprockets::Autoload::Sass::Script::Parser
  def and_expr(); end

  def eq_or_neq(); end

  def equals(); end

  def initialize(str, line, offset, options=T.unsafe(nil)); end

  def line(); end

  def offset(); end

  def or_expr(); end

  def parse(); end

  def parse_function_definition_arglist(); end

  def parse_interpolated(warn_for_color=T.unsafe(nil)); end

  def parse_mixin_definition_arglist(); end

  def parse_mixin_include_arglist(); end

  def parse_string(); end

  def parse_until(tokens); end

  def plus_or_minus(); end

  def relational(); end

  def times_div_or_mod(); end

  def unary_div(); end

  def unary_minus(); end

  def unary_not(); end

  def unary_plus(); end
  ASSOCIATIVE = ::T.let(nil, ::T.untyped)
  EXPR_NAMES = ::T.let(nil, ::T.untyped)
  PRECEDENCE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Script::Parser
  def self.associative?(op); end

  def self.parse(*args); end

  def self.precedence_of(op); end
end

module Sprockets::Autoload::Sass::Script::Tree
end

class Sprockets::Autoload::Sass::Script::Tree::Funcall
  def args(); end

  def callable(); end

  def initialize(name_or_callable, args, keywords, splat, kwarg_splat); end

  def keywords(); end

  def kwarg_splat(); end

  def kwarg_splat=(kwarg_splat); end

  def name(); end

  def splat(); end

  def splat=(splat); end

  def to_literal(args); end

  def to_value(args); end
end

class Sprockets::Autoload::Sass::Script::Tree::Funcall
end

class Sprockets::Autoload::Sass::Script::Tree::Interpolation
  def after(); end

  def before(); end

  def deprecation(); end

  def initialize(before, mid, after, wb, wa, opts=T.unsafe(nil)); end

  def mid(); end

  def originally_text(); end

  def to_quoted_equivalent(); end

  def to_string_interpolation(node_or_interp); end

  def warn_for_color(); end

  def whitespace_after(); end

  def whitespace_before(); end
end

class Sprockets::Autoload::Sass::Script::Tree::Interpolation
end

class Sprockets::Autoload::Sass::Script::Tree::ListLiteral
  def bracketed(); end

  def elements(); end

  def initialize(elements, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end

  def separator(); end
end

class Sprockets::Autoload::Sass::Script::Tree::ListLiteral
end

class Sprockets::Autoload::Sass::Script::Tree::Literal
  def initialize(value); end

  def value(); end
end

class Sprockets::Autoload::Sass::Script::Tree::Literal
end

class Sprockets::Autoload::Sass::Script::Tree::MapLiteral
  def initialize(pairs); end

  def inspect(opts=T.unsafe(nil)); end

  def pairs(); end
end

class Sprockets::Autoload::Sass::Script::Tree::MapLiteral
end

class Sprockets::Autoload::Sass::Script::Tree::Node
  def _perform(environment); end

  def children(); end

  def dasherize(s, opts); end

  def deep_copy(); end

  def filename(); end

  def filename=(filename); end

  def force_division!(); end

  def line(); end

  def line=(line); end

  def options(); end

  def options=(options); end

  def opts(value); end

  def perform(environment); end

  def source_range(); end

  def source_range=(source_range); end

  def to_sass(opts=T.unsafe(nil)); end
end

class Sprockets::Autoload::Sass::Script::Tree::Node
end

class Sprockets::Autoload::Sass::Script::Tree::Operation
  def initialize(operand1, operand2, operator); end

  def operand1(); end

  def operand2(); end

  def operator(); end
end

class Sprockets::Autoload::Sass::Script::Tree::Operation
end

class Sprockets::Autoload::Sass::Script::Tree::Selector
end

class Sprockets::Autoload::Sass::Script::Tree::Selector
end

class Sprockets::Autoload::Sass::Script::Tree::StringInterpolation
  def after(); end

  def before(); end

  def initialize(before, mid, after); end

  def mid(); end

  def quote(); end

  def type(); end
end

class Sprockets::Autoload::Sass::Script::Tree::StringInterpolation
end

class Sprockets::Autoload::Sass::Script::Tree::UnaryOperation
  def initialize(operand, operator); end

  def operand(); end

  def operator(); end
end

class Sprockets::Autoload::Sass::Script::Tree::UnaryOperation
end

class Sprockets::Autoload::Sass::Script::Tree::Variable
  def initialize(name); end

  def inspect(opts=T.unsafe(nil)); end

  def name(); end

  def underscored_name(); end
end

class Sprockets::Autoload::Sass::Script::Tree::Variable
end

module Sprockets::Autoload::Sass::Script::Tree
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Script::Value
end

class Sprockets::Autoload::Sass::Script::Value::ArgList
  def initialize(value, keywords, separator); end

  def keywords(); end

  def keywords_accessed(); end

  def keywords_accessed=(keywords_accessed); end
end

class Sprockets::Autoload::Sass::Script::Value::ArgList
end

class Sprockets::Autoload::Sass::Script::Value::Base
  def ==(other); end

  def _perform(environment); end

  def assert_int!(); end

  def bracketed(); end

  def div(other); end

  def eq(other); end

  def eql?(other); end

  def initialize(value=T.unsafe(nil)); end

  def minus(other); end

  def neq(other); end

  def null?(); end

  def options(); end

  def options=(options); end

  def plus(other); end

  def separator(); end

  def single_eq(other); end

  def source_range(); end

  def source_range=(source_range); end

  def to_a(); end

  def to_bool(); end

  def to_h(); end

  def to_i(); end

  def to_s(opts=T.unsafe(nil)); end

  def to_sass(opts=T.unsafe(nil)); end

  def unary_div(); end

  def unary_minus(); end

  def unary_not(); end

  def unary_plus(); end

  def value(); end

  def with_contents(contents, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end
end

class Sprockets::Autoload::Sass::Script::Value::Base
end

class Sprockets::Autoload::Sass::Script::Value::Bool
  FALSE = ::T.let(nil, ::T.untyped)
  TRUE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Script::Value::Bool
  def self.new(value); end
end

class Sprockets::Autoload::Sass::Script::Value::Callable
  def initialize(callable); end

  def to_sass(); end
end

class Sprockets::Autoload::Sass::Script::Value::Callable
end

class Sprockets::Autoload::Sass::Script::Value::Color
  def alpha(); end

  def alpha?(); end

  def blue(); end

  def green(); end

  def hsl(); end

  def hsla(); end

  def hue(); end

  def initialize(attrs, representation=T.unsafe(nil), allow_both_rgb_and_hsl=T.unsafe(nil)); end

  def lightness(); end

  def mod(other); end

  def name(); end

  def red(); end

  def representation(); end

  def rgb(); end

  def rgba(); end

  def saturation(); end

  def times(other); end

  def with(attrs); end
  ALTERNATE_COLOR_NAMES = ::T.let(nil, ::T.untyped)
  COLOR_NAMES = ::T.let(nil, ::T.untyped)
  COLOR_NAMES_REVERSE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Script::Value::Color
  def self.from_hex(hex_string, alpha=T.unsafe(nil)); end

  def self.int_to_rgba(color); end
end

class Sprockets::Autoload::Sass::Script::Value::Function
  def initialize(function); end
end

class Sprockets::Autoload::Sass::Script::Value::Function
end

Sprockets::Autoload::Sass::Script::Value::Helpers = Sass::Script::Value::Helpers

class Sprockets::Autoload::Sass::Script::Value::List
  def initialize(value, separator: T.unsafe(nil), bracketed: T.unsafe(nil)); end

  def options=(options); end
end

class Sprockets::Autoload::Sass::Script::Value::List
  def self.assert_valid_index(list, n); end
end

class Sprockets::Autoload::Sass::Script::Value::Map
  def initialize(hash); end

  def inspect(opts=T.unsafe(nil)); end

  def options=(options); end
end

class Sprockets::Autoload::Sass::Script::Value::Map
end

class Sprockets::Autoload::Sass::Script::Value::Null
  NULL = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Script::Value::Null
  def self.new(); end
end

class Sprockets::Autoload::Sass::Script::Value::Number
  def coerce(num_units, den_units); end

  def comparable_to?(other); end

  def denominator_units(); end

  def gt(other); end

  def gte(other); end

  def initialize(value, numerator_units=T.unsafe(nil), denominator_units=T.unsafe(nil)); end

  def inspect(opts=T.unsafe(nil)); end

  def int?(); end

  def is_unit?(unit); end

  def legal_units?(); end

  def lt(other); end

  def lte(other); end

  def mod(other); end

  def numerator_units(); end

  def original(); end

  def original=(original); end

  def times(other); end

  def unit_str(); end

  def unitless?(); end
  CONVERSION_TABLE = ::T.let(nil, ::T.untyped)
  MUTUALLY_CONVERTIBLE = ::T.let(nil, ::T.untyped)
  NO_UNITS = ::T.let(nil, ::T.untyped)
  OPERATIONS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Script::Value::Number
  def self.basically_equal?(num1, num2); end

  def self.epsilon(); end

  def self.precision(); end

  def self.precision=(digits); end

  def self.precision_factor(); end

  def self.round(num); end
end

class Sprockets::Autoload::Sass::Script::Value::String
  def check_deprecated_interp(); end

  def initialize(value, type=T.unsafe(nil), deprecated_interp_equivalent=T.unsafe(nil)); end

  def type(); end
end

class Sprockets::Autoload::Sass::Script::Value::String
  def self.quote(contents, opts=T.unsafe(nil)); end

  def self.value(contents); end
end

module Sprockets::Autoload::Sass::Script::Value
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Script
  extend ::T::Sig
  def self.const_missing(name); end

  def self.parse(value, line, offset, options=T.unsafe(nil)); end
end

module Sprockets::Autoload::Sass::Selector
  SPECIFICITY_BASE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Selector::AbstractSequence
  def ==(other); end

  def _specificity(arr); end

  def eql?(other); end

  def filename(); end

  def filename=(filename); end

  def invisible?(); end

  def line(); end

  def line=(line); end

  def specificity(); end

  def to_s(opts=T.unsafe(nil)); end
end

class Sprockets::Autoload::Sass::Selector::AbstractSequence
end

class Sprockets::Autoload::Sass::Selector::Attribute
  def flags(); end

  def initialize(name, namespace, operator, value, flags); end

  def name(); end

  def namespace(); end

  def operator(); end

  def specificity(); end

  def value(); end
end

class Sprockets::Autoload::Sass::Selector::Attribute
end

class Sprockets::Autoload::Sass::Selector::Class
  def initialize(name); end

  def name(); end

  def specificity(); end
end

class Sprockets::Autoload::Sass::Selector::Class
end

class Sprockets::Autoload::Sass::Selector::CommaSequence
  def contains_parent_ref?(); end

  def do_extend(extends, parent_directives=T.unsafe(nil), replace=T.unsafe(nil), seen=T.unsafe(nil), original=T.unsafe(nil)); end

  def initialize(seqs); end

  def members(); end

  def populate_extends(extends, extendee, extend_node=T.unsafe(nil), parent_directives=T.unsafe(nil), allow_compound_target=T.unsafe(nil)); end

  def resolve_parent_refs(super_cseq, implicit_parent=T.unsafe(nil)); end

  def superselector?(cseq); end

  def to_sass_script(); end

  def unify(other); end
end

class Sprockets::Autoload::Sass::Selector::CommaSequence
end

class Sprockets::Autoload::Sass::Selector::Element
  def initialize(name, namespace); end

  def name(); end

  def namespace(); end

  def specificity(); end
end

class Sprockets::Autoload::Sass::Selector::Element
end

class Sprockets::Autoload::Sass::Selector::Id
  def initialize(name); end

  def name(); end

  def specificity(); end
end

class Sprockets::Autoload::Sass::Selector::Id
end

class Sprockets::Autoload::Sass::Selector::Parent
  def initialize(suffix=T.unsafe(nil)); end

  def suffix(); end
end

class Sprockets::Autoload::Sass::Selector::Parent
end

class Sprockets::Autoload::Sass::Selector::Placeholder
  def initialize(name); end

  def name(); end

  def specificity(); end
end

class Sprockets::Autoload::Sass::Selector::Placeholder
end

class Sprockets::Autoload::Sass::Selector::Pseudo
  def arg(); end

  def initialize(syntactic_type, name, arg, selector); end

  def invisible?(); end

  def name(); end

  def normalized_name(); end

  def selector(); end

  def specificity(); end

  def superselector?(their_sseq, parents=T.unsafe(nil)); end

  def syntactic_type(); end

  def type(); end

  def with_selector(new_selector); end
  ACTUALLY_ELEMENTS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Selector::Pseudo
end

class Sprockets::Autoload::Sass::Selector::Sequence
  def add_sources!(sources); end

  def contains_parent_ref?(); end

  def do_extend(extends, parent_directives, replace, seen, original); end

  def initialize(seqs_and_ops); end

  def members(); end

  def resolve_parent_refs(super_cseq, implicit_parent); end

  def subjectless(); end

  def superselector?(seq); end

  def unify(other); end
end

class Sprockets::Autoload::Sass::Selector::Sequence
end

class Sprockets::Autoload::Sass::Selector::Simple
  def ==(other); end

  def eql?(other); end

  def equality_key(); end

  def filename(); end

  def filename=(filename); end

  def line(); end

  def line=(line); end

  def to_s(opts=T.unsafe(nil)); end

  def unify(sels); end

  def unify_namespaces(ns1, ns2); end

  def unique?(); end
end

class Sprockets::Autoload::Sass::Selector::Simple
end

class Sprockets::Autoload::Sass::Selector::SimpleSequence
  def base(); end

  def do_extend(extends, parent_directives, replace, seen); end

  def initialize(selectors, subject, source_range=T.unsafe(nil)); end

  def members(); end

  def members=(members); end

  def pseudo_elements(); end

  def resolve_parent_refs(super_cseq); end

  def rest(); end

  def selector_pseudo_classes(); end

  def source_range(); end

  def source_range=(source_range); end

  def sources(); end

  def sources=(sources); end

  def subject=(subject); end

  def subject?(); end

  def superselector?(their_sseq, parents=T.unsafe(nil)); end

  def unify(other); end

  def with_more_sources(sources); end
end

class Sprockets::Autoload::Sass::Selector::SimpleSequence
end

class Sprockets::Autoload::Sass::Selector::Universal
  def initialize(namespace); end

  def namespace(); end

  def specificity(); end
end

class Sprockets::Autoload::Sass::Selector::Universal
end

module Sprockets::Autoload::Sass::Selector
  extend ::T::Sig
end

class Sprockets::Autoload::Sass::SemiGlobalEnvironment
end

class Sprockets::Autoload::Sass::SemiGlobalEnvironment
end

module Sprockets::Autoload::Sass::Shared
  def balance(scanner, start, finish, count=T.unsafe(nil)); end

  def handle_interpolation(str); end

  def human_indentation(indentation, was=T.unsafe(nil)); end
end

module Sprockets::Autoload::Sass::Shared
  extend ::Sprockets::Autoload::Sass::Shared
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Source
end

class Sprockets::Autoload::Sass::Source::Map
  def add(input, output); end

  def data(); end

  def shift_output_lines(delta); end

  def shift_output_offsets(delta); end

  def to_json(options); end
end

class Sprockets::Autoload::Sass::Source::Map::Mapping
end

class Sprockets::Autoload::Sass::Source::Map::Mapping
end

class Sprockets::Autoload::Sass::Source::Map
end

class Sprockets::Autoload::Sass::Source::Position
  def after(str); end

  def initialize(line, offset); end

  def line(); end

  def line=(line); end

  def offset(); end

  def offset=(offset); end
end

class Sprockets::Autoload::Sass::Source::Position
end

class Sprockets::Autoload::Sass::Source::Range
  def end_pos(); end

  def end_pos=(end_pos); end

  def file(); end

  def file=(file); end

  def importer(); end

  def importer=(importer); end

  def initialize(start_pos, end_pos, file, importer=T.unsafe(nil)); end

  def start_pos(); end

  def start_pos=(start_pos); end
end

class Sprockets::Autoload::Sass::Source::Range
end

module Sprockets::Autoload::Sass::Source
  extend ::T::Sig
end

class Sprockets::Autoload::Sass::Stack
  def frames(); end

  def with_base(filename, line); end

  def with_directive(filename, line, name); end

  def with_function(filename, line, name); end

  def with_import(filename, line); end

  def with_mixin(filename, line, name); end
end

class Sprockets::Autoload::Sass::Stack::Frame
  def filename(); end

  def initialize(filename, line, type, name=T.unsafe(nil)); end

  def is_base?(); end

  def is_import?(); end

  def is_mixin?(); end

  def line(); end

  def name(); end

  def type(); end
end

class Sprockets::Autoload::Sass::Stack::Frame
end

class Sprockets::Autoload::Sass::Stack
end

module Sprockets::Autoload::Sass::Supports
end

class Sprockets::Autoload::Sass::Supports::Condition
  def deep_copy(); end

  def options=(options); end

  def perform(environment); end

  def to_css(); end

  def to_src(options); end
end

class Sprockets::Autoload::Sass::Supports::Condition
end

class Sprockets::Autoload::Sass::Supports::Declaration
  def initialize(name, value); end

  def name(); end

  def name=(name); end

  def perform(env); end

  def resolved_name(); end

  def resolved_name=(resolved_name); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def value(); end

  def value=(value); end
end

class Sprockets::Autoload::Sass::Supports::Declaration
end

class Sprockets::Autoload::Sass::Supports::Interpolation
  def initialize(value); end

  def perform(env); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def value(); end

  def value=(value); end
end

class Sprockets::Autoload::Sass::Supports::Interpolation
end

class Sprockets::Autoload::Sass::Supports::Negation
  def condition(); end

  def condition=(condition); end

  def initialize(condition); end

  def perform(env); end
end

class Sprockets::Autoload::Sass::Supports::Negation
end

class Sprockets::Autoload::Sass::Supports::Operator
  def initialize(left, right, op); end

  def left(); end

  def left=(left); end

  def op(); end

  def op=(op); end

  def perform(env); end

  def right(); end

  def right=(right); end
end

class Sprockets::Autoload::Sass::Supports::Operator
end

module Sprockets::Autoload::Sass::Supports
  extend ::T::Sig
end

class Sprockets::Autoload::Sass::SyntaxError
  def add_backtrace(attrs); end

  def initialize(msg, attrs=T.unsafe(nil)); end

  def modify_backtrace(attrs); end

  def sass_backtrace(); end

  def sass_backtrace=(sass_backtrace); end

  def sass_backtrace_str(default_filename=T.unsafe(nil)); end

  def sass_filename(); end

  def sass_line(); end

  def sass_mixin(); end

  def sass_template(); end

  def sass_template=(sass_template); end
end

class Sprockets::Autoload::Sass::SyntaxError
  def self.exception_to_css(e, line_offset=T.unsafe(nil)); end
end

module Sprockets::Autoload::Sass::Tree
end

class Sprockets::Autoload::Sass::Tree::AtRootNode
  def exclude?(directive); end

  def exclude_node?(node); end

  def group_end(); end

  def group_end=(group_end); end

  def initialize(query=T.unsafe(nil)); end

  def query(); end

  def query=(query); end

  def resolved_type(); end

  def resolved_type=(resolved_type); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def tabs(); end

  def tabs=(tabs); end
end

class Sprockets::Autoload::Sass::Tree::AtRootNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::CharsetNode
  def initialize(name); end

  def name(); end

  def name=(name); end
end

class Sprockets::Autoload::Sass::Tree::CharsetNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::CommentNode
  def initialize(value, type); end

  def lines(); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def type(); end

  def type=(type); end

  def value(); end

  def value=(value); end
end

class Sprockets::Autoload::Sass::Tree::CommentNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::ContentNode
end

class Sprockets::Autoload::Sass::Tree::ContentNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::CssImportNode
  def initialize(uri, query=T.unsafe(nil), supports_condition=T.unsafe(nil)); end

  def query(); end

  def query=(query); end

  def resolved_query(); end

  def resolved_query=(resolved_query); end

  def resolved_uri(); end

  def resolved_uri=(resolved_uri); end

  def supports_condition(); end

  def supports_condition=(supports_condition); end

  def uri(); end

  def uri=(uri); end
end

class Sprockets::Autoload::Sass::Tree::CssImportNode
  def self.resolved(uri); end
end

class Sprockets::Autoload::Sass::Tree::DebugNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sprockets::Autoload::Sass::Tree::DebugNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::DirectiveNode
  def group_end(); end

  def group_end=(group_end); end

  def initialize(value); end

  def name(); end

  def normalized_name(); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def tabs(); end

  def tabs=(tabs); end

  def value(); end

  def value=(value); end
end

class Sprockets::Autoload::Sass::Tree::DirectiveNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.resolved(value); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::EachNode
  def initialize(vars, list); end

  def list(); end

  def list=(list); end

  def vars(); end
end

class Sprockets::Autoload::Sass::Tree::EachNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::ErrorNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sprockets::Autoload::Sass::Tree::ErrorNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::ExtendNode
  def initialize(selector, optional, selector_source_range); end

  def optional?(); end

  def resolved_selector(); end

  def resolved_selector=(resolved_selector); end

  def selector(); end

  def selector=(selector); end

  def selector_source_range(); end

  def selector_source_range=(selector_source_range); end
end

class Sprockets::Autoload::Sass::Tree::ExtendNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::ForNode
  def exclusive(); end

  def from(); end

  def from=(from); end

  def initialize(var, from, to, exclusive); end

  def to(); end

  def to=(to); end

  def var(); end
end

class Sprockets::Autoload::Sass::Tree::ForNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::FunctionNode
  def args(); end

  def args=(args); end

  def initialize(name, args, splat); end

  def name(); end

  def normalized_name(); end

  def splat(); end

  def splat=(splat); end
end

class Sprockets::Autoload::Sass::Tree::FunctionNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::IfNode
  def _dump(f); end

  def add_else(node); end

  def else(); end

  def else=(_); end

  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sprockets::Autoload::Sass::Tree::IfNode
  def self._load(data); end

  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::ImportNode
  def css_import?(); end

  def imported_file(); end

  def imported_file=(imported_file); end

  def imported_filename(); end

  def initialize(imported_filename); end
end

class Sprockets::Autoload::Sass::Tree::ImportNode
end

class Sprockets::Autoload::Sass::Tree::KeyframeRuleNode
  def initialize(resolved_value); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end
end

class Sprockets::Autoload::Sass::Tree::KeyframeRuleNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::MediaNode
  def initialize(query); end

  def query(); end

  def query=(query); end

  def resolved_query(); end

  def resolved_query=(resolved_query); end
end

class Sprockets::Autoload::Sass::Tree::MediaNode
end

class Sprockets::Autoload::Sass::Tree::MixinDefNode
  def args(); end

  def args=(args); end

  def has_content(); end

  def has_content=(has_content); end

  def initialize(name, args, splat); end

  def name(); end

  def splat(); end

  def splat=(splat); end
end

class Sprockets::Autoload::Sass::Tree::MixinDefNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::MixinNode
  def args(); end

  def args=(args); end

  def initialize(name, args, keywords, splat, kwarg_splat); end

  def keywords(); end

  def keywords=(keywords); end

  def kwarg_splat(); end

  def kwarg_splat=(kwarg_splat); end

  def name(); end

  def splat(); end

  def splat=(splat); end
end

class Sprockets::Autoload::Sass::Tree::MixinNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::Node
  include ::Enumerable
  def <<(child); end

  def ==(other); end

  def balance(*args); end

  def bubbles?(); end

  def children(); end

  def children=(children); end

  def css(); end

  def css_with_sourcemap(); end

  def deep_copy(); end

  def each(); end

  def filename(); end

  def filename=(filename); end

  def has_children(); end

  def has_children=(has_children); end

  def invisible?(); end

  def line(); end

  def line=(line); end

  def options(); end

  def options=(options); end

  def source_range(); end

  def source_range=(source_range); end

  def style(); end

  def to_sass(options=T.unsafe(nil)); end

  def to_scss(options=T.unsafe(nil)); end
end

class Sprockets::Autoload::Sass::Tree::Node
  def self.inherited(base); end
end

class Sprockets::Autoload::Sass::Tree::PropNode
  def custom_property?(); end

  def declaration(opts=T.unsafe(nil), fmt=T.unsafe(nil)); end

  def initialize(name, value, prop_syntax); end

  def name(); end

  def name=(name); end

  def name_source_range(); end

  def name_source_range=(name_source_range); end

  def pseudo_class_selector_message(); end

  def resolved_name(); end

  def resolved_name=(resolved_name); end

  def resolved_value(); end

  def resolved_value=(resolved_value); end

  def tabs(); end

  def tabs=(tabs); end

  def value(); end

  def value=(value); end

  def value_source_range(); end

  def value_source_range=(value_source_range); end
end

class Sprockets::Autoload::Sass::Tree::PropNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::ReturnNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sprockets::Autoload::Sass::Tree::ReturnNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::RootNode
  def initialize(template); end

  def render(); end

  def render_with_sourcemap(); end

  def template(); end
end

class Sprockets::Autoload::Sass::Tree::RootNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::RuleNode
  def add_rules(node); end

  def continued?(); end

  def debug_info(); end

  def filename=(filename); end

  def group_end(); end

  def group_end=(group_end); end

  def initialize(rule, selector_source_range=T.unsafe(nil)); end

  def line=(line); end

  def parsed_rules(); end

  def parsed_rules=(parsed_rules); end

  def resolved_rules(); end

  def resolved_rules=(resolved_rules); end

  def rule(); end

  def rule=(rule); end

  def selector_source_range(); end

  def selector_source_range=(selector_source_range); end

  def stack_trace(); end

  def stack_trace=(stack_trace); end

  def tabs(); end

  def tabs=(tabs); end
  PARENT = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Tree::RuleNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::SupportsNode
  def condition(); end

  def condition=(condition); end

  def initialize(name, condition); end

  def name=(name); end
end

class Sprockets::Autoload::Sass::Tree::SupportsNode
end

class Sprockets::Autoload::Sass::Tree::TraceNode
  def initialize(name); end

  def name(); end
end

class Sprockets::Autoload::Sass::Tree::TraceNode
  def self.from_node(name, node); end

  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::VariableNode
  def expr(); end

  def expr=(expr); end

  def global(); end

  def guarded(); end

  def initialize(name, expr, guarded, global); end

  def name(); end
end

class Sprockets::Autoload::Sass::Tree::VariableNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

module Sprockets::Autoload::Sass::Tree::Visitors
end

class Sprockets::Autoload::Sass::Tree::Visitors::Base
  def visit(node); end

  def visit_children(parent); end

  def visit_if(node); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Base
  def self.node_name(node); end

  def self.visit(root); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::CheckNesting
  def invalid_charset_parent?(parent, child); end

  def invalid_content_parent?(parent, child); end

  def invalid_extend_parent?(parent, child); end

  def invalid_function_child?(parent, child); end

  def invalid_function_parent?(parent, child); end

  def invalid_import_parent?(parent, child); end

  def invalid_mixindef_parent?(parent, child); end

  def invalid_prop_child?(parent, child); end

  def invalid_prop_parent?(parent, child); end

  def invalid_return_parent?(parent, child); end

  def visit_import(node); end

  def visit_mixindef(node); end

  def visit_root(node); end
  CONTROL_NODES = ::T.let(nil, ::T.untyped)
  INVALID_IMPORT_PARENTS = ::T.let(nil, ::T.untyped)
  SCRIPT_NODES = ::T.let(nil, ::T.untyped)
  VALID_EXTEND_PARENTS = ::T.let(nil, ::T.untyped)
  VALID_FUNCTION_CHILDREN = ::T.let(nil, ::T.untyped)
  VALID_PROP_CHILDREN = ::T.let(nil, ::T.untyped)
  VALID_PROP_PARENTS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Tree::Visitors::CheckNesting
end

class Sprockets::Autoload::Sass::Tree::Visitors::Convert
  def initialize(options, format); end

  def visit_atroot(node); end

  def visit_charset(node); end

  def visit_comment(node); end

  def visit_content(node); end

  def visit_cssimport(node); end

  def visit_debug(node); end

  def visit_directive(node); end

  def visit_each(node); end

  def visit_error(node); end

  def visit_extend(node); end

  def visit_for(node); end

  def visit_function(node); end

  def visit_import(node); end

  def visit_keyframerule(node); end

  def visit_media(node); end

  def visit_mixin(node); end

  def visit_mixindef(node); end

  def visit_prop(node); end

  def visit_return(node); end

  def visit_root(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_variable(node); end

  def visit_warn(node); end

  def visit_while(node); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Convert
  def self.visit(root, options, format); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Cssize
  def parent(); end

  def visit_atroot(node); end

  def visit_children_without_parent(node); end

  def visit_directive(node); end

  def visit_extend(node); end

  def visit_import(node); end

  def visit_keyframerule(node); end

  def visit_media(node); end

  def visit_prop(node); end

  def visit_root(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_trace(node); end

  def with_parent(parent); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Cssize::Bubble
  def bubbles?(); end

  def group_end(); end

  def group_end=(group_end); end

  def initialize(node); end

  def node(); end

  def node=(node); end

  def tabs(); end

  def tabs=(tabs); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Cssize::Bubble
end

class Sprockets::Autoload::Sass::Tree::Visitors::Cssize::Extend
  def directives(); end

  def directives=(_); end

  def extender(); end

  def extender=(_); end

  def node(); end

  def node=(_); end

  def success(); end

  def success=(_); end

  def target(); end

  def target=(_); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Cssize::Extend
  def self.[](*_); end

  def self.members(); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Cssize
end

class Sprockets::Autoload::Sass::Tree::Visitors::DeepCopy
  def visit_debug(node); end

  def visit_directive(node); end

  def visit_each(node); end

  def visit_error(node); end

  def visit_extend(node); end

  def visit_for(node); end

  def visit_function(node); end

  def visit_media(node); end

  def visit_mixin(node); end

  def visit_mixindef(node); end

  def visit_prop(node); end

  def visit_return(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_variable(node); end

  def visit_warn(node); end

  def visit_while(node); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::DeepCopy
end

class Sprockets::Autoload::Sass::Tree::Visitors::Extend
  def initialize(extends); end

  def visit_rule(node); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Extend
  def self.visit(root, extends); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Perform
  def initialize(env); end

  def visit_atroot(node); end

  def visit_comment(node); end

  def visit_content(node); end

  def visit_cssimport(node); end

  def visit_debug(node); end

  def visit_directive(node); end

  def visit_each(node); end

  def visit_error(node); end

  def visit_extend(node); end

  def visit_for(node); end

  def visit_function(node); end

  def visit_import(node); end

  def visit_media(node); end

  def visit_mixin(node); end

  def visit_mixindef(node); end

  def visit_prop(node); end

  def visit_return(node); end

  def visit_root(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_variable(node); end

  def visit_warn(node); end

  def visit_while(node); end

  def with_environment(env); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::Perform
  def self.perform_arguments(callable, args, splat, environment); end

  def self.perform_splat(splat, performed_keywords, kwarg_splat, environment); end

  def self.visit(root, environment=T.unsafe(nil)); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::SetOptions
  def initialize(options); end

  def visit_comment(node); end

  def visit_cssimport(node); end

  def visit_debug(node); end

  def visit_directive(node); end

  def visit_each(node); end

  def visit_error(node); end

  def visit_extend(node); end

  def visit_for(node); end

  def visit_function(node); end

  def visit_import(node); end

  def visit_media(node); end

  def visit_mixin(node); end

  def visit_mixindef(node); end

  def visit_prop(node); end

  def visit_return(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def visit_variable(node); end

  def visit_warn(node); end

  def visit_while(node); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::SetOptions
  def self.visit(root, options); end
end

class Sprockets::Autoload::Sass::Tree::Visitors::ToCss
  def erase!(chars); end

  def for_node(node, attr_prefix=T.unsafe(nil)); end

  def initialize(build_source_mapping=T.unsafe(nil)); end

  def lstrip(); end

  def output(s); end

  def prepend!(prefix); end

  def rstrip!(); end

  def source_mapping(); end

  def trailing_semicolon?(); end

  def visit_charset(node); end

  def visit_comment(node); end

  def visit_cssimport(node); end

  def visit_directive(node); end

  def visit_keyframerule(node); end

  def visit_media(node); end

  def visit_prop(node); end

  def visit_root(node); end

  def visit_rule(node); end

  def visit_supports(node); end

  def with_tabs(tabs); end
  NEWLINE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Tree::Visitors::ToCss
end

module Sprockets::Autoload::Sass::Tree::Visitors
  extend ::T::Sig
end

class Sprockets::Autoload::Sass::Tree::WarnNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sprockets::Autoload::Sass::Tree::WarnNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

class Sprockets::Autoload::Sass::Tree::WhileNode
  def expr(); end

  def expr=(expr); end

  def initialize(expr); end
end

class Sprockets::Autoload::Sass::Tree::WhileNode
  def self.invalid_child_method_name(); end

  def self.invalid_parent_method_name(); end

  def self.node_name(); end

  def self.visit_method(); end
end

module Sprockets::Autoload::Sass::Tree
  extend ::T::Sig
end

class Sprockets::Autoload::Sass::UnitConversionError
end

class Sprockets::Autoload::Sass::UnitConversionError
end

module Sprockets::Autoload::Sass::Util
  ATOMIC_WRITE_MUTEX = ::T.let(nil, ::T.untyped)
  BASE64_DIGITS = ::T.let(nil, ::T.untyped)
  BASE64_DIGIT_MAP = ::T.let(nil, ::T.untyped)
  CHARSET_REGEXP = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_VERSION_COMPONENTS = ::T.let(nil, ::T.untyped)
  UTF_16BE_BOM = ::T.let(nil, ::T.untyped)
  UTF_16LE_BOM = ::T.let(nil, ::T.untyped)
  UTF_8_BOM = ::T.let(nil, ::T.untyped)
  VLQ_BASE = ::T.let(nil, ::T.untyped)
  VLQ_BASE_MASK = ::T.let(nil, ::T.untyped)
  VLQ_BASE_SHIFT = ::T.let(nil, ::T.untyped)
  VLQ_CONTINUATION_BIT = ::T.let(nil, ::T.untyped)
end

class Sprockets::Autoload::Sass::Util::MultibyteStringScanner
  def byte_matched_size(); end

  def byte_pos(); end

  def check(pattern); end

  def check_until(pattern); end

  def initialize(str); end

  def match?(pattern); end

  def peek(len); end

  def peep(len); end

  def pos=(n); end

  def scan(pattern); end

  def scan_full(pattern, advance_pointer_p, return_string_p); end

  def scan_until(pattern); end

  def search_full(pattern, advance_pointer_p, return_string_p); end

  def skip(pattern); end

  def skip_until(pattern); end

  def string=(str); end
end

class Sprockets::Autoload::Sass::Util::MultibyteStringScanner
  def self.new(str); end
end

class Sprockets::Autoload::Sass::Util::NormalizedMap
  def [](k); end

  def []=(k, v); end

  def as_stored(); end

  def delete(k); end

  def denormalize(key); end

  def each(); end

  def empty?(); end

  def has_key?(k); end

  def initialize(map=T.unsafe(nil)); end

  def keys(); end

  def map(); end

  def method_missing(method, *args, &block); end

  def normalize(key); end

  def size(); end

  def sort_by(); end

  def to_a(); end

  def to_hash(); end

  def update(map); end

  def values(); end
end

class Sprockets::Autoload::Sass::Util::NormalizedMap
end

class Sprockets::Autoload::Sass::Util::StaticConditionalContext
  def initialize(set); end

  def method_missing(name, *args); end
end

class Sprockets::Autoload::Sass::Util::StaticConditionalContext
end

class Sprockets::Autoload::Sass::Util::SubsetMap
  def [](set); end

  def []=(set, value); end

  def each_value(); end

  def empty?(); end

  def get(set); end
end

class Sprockets::Autoload::Sass::Util::SubsetMap
end

module Sprockets::Autoload::Sass::Util
  extend ::Sprockets::Autoload::Sass::Util
  extend ::T::Sig
end

module Sprockets::Autoload::Sass::Version
  def version(); end
end

module Sprockets::Autoload::Sass::Version
  extend ::T::Sig
end

module Sprockets::Autoload::Sass
  extend ::Sprockets::Autoload::Sass::Version
  extend ::Sprockets::Autoload::Sass::Features
  extend ::T::Sig
  def self.compile(contents, options=T.unsafe(nil)); end

  def self.compile_file(filename, *args); end

  def self.load_paths(); end

  def self.logger(); end

  def self.logger=(l); end

  def self.tests_running(); end

  def self.tests_running=(tests_running); end
end

module Sprockets::Autoload
  extend ::T::Sig
end

class Sprockets::Base
  include ::Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Server
  include ::Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Engines
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::Bower
  def [](*args); end

  def cache(); end

  def cache=(cache); end

  def cache_get(key); end

  def cache_set(key, value); end

  def cached(); end

  def compress_from_root(uri); end

  def each_logical_path(*args, &block); end

  def expand_from_root(uri); end

  def find_all_linked_assets(path, options=T.unsafe(nil)); end

  def find_asset(path, options=T.unsafe(nil)); end

  def index(); end

  def logical_paths(); end

  def normalize_logical_path(path); end

  def resolve_with_compat(path, options=T.unsafe(nil)); end

  def resolve_without_compat(path, options=T.unsafe(nil)); end
end

class Sprockets::Base
end

module Sprockets::Bower
  def read_bower_main(dirname, filename); end

  def resolve_alternates(load_path, logical_path); end
  POSSIBLE_BOWER_JSONS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Bower
  extend ::T::Sig
end

class Sprockets::Bundle
end

class Sprockets::Bundle
  def self.call(input); end

  def self.process_bundle_reducers(assets, reducers); end
end

class Sprockets::Cache
  def fetch(key); end

  def get(key, local=T.unsafe(nil)); end

  def initialize(cache=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value, local=T.unsafe(nil)); end
  PEEK_SIZE = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def get(key); end

  def initialize(root, max_size=T.unsafe(nil), logger=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::FileStore
  def self.default_logger(); end
end

class Sprockets::Cache::GetWrapper
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::GetWrapper
end

class Sprockets::Cache::HashWrapper
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::HashWrapper
end

class Sprockets::Cache::MemoryStore
  def get(key); end

  def initialize(max_size=T.unsafe(nil)); end

  def set(key, value); end
  DEFAULT_MAX_SIZE = ::T.let(nil, ::T.untyped)
end

class Sprockets::Cache::MemoryStore
end

class Sprockets::Cache::NullStore
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::NullStore
end

class Sprockets::Cache::ReadWriteWrapper
  def get(key); end

  def set(key, value); end
end

class Sprockets::Cache::ReadWriteWrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache::Wrapper
end

class Sprockets::Cache
  def self.default_logger(); end
end

class Sprockets::CachedEnvironment
  def _entries(path); end

  def _load(uri); end

  def _processor_cache_key(processor); end

  def _resolve_dependency(str); end

  def _stat(path); end

  def initialize(environment); end

  def processor_cache_key(str); end
end

class Sprockets::CachedEnvironment
end

class Sprockets::ClosureCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::ClosureCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets::CoffeeScriptProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptProcessor
  extend ::T::Sig
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::CoffeeScriptTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::CoffeeScriptTemplate
  extend ::T::Sig
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::Compressing
  include ::Sprockets::Utils
  def compressors(); end

  def css_compressor(); end

  def css_compressor=(compressor); end

  def gzip=(gzip); end

  def gzip?(); end

  def js_compressor(); end

  def js_compressor=(compressor); end

  def register_compressor(mime_type, sym, klass); end

  def skip_gzip?(); end
end

module Sprockets::Compressing
  extend ::T::Sig
end

module Sprockets::Configuration
  include ::Sprockets::Dependencies
  include ::Sprockets::Compressing
  include ::Sprockets::Processing
  include ::Sprockets::Transformers
  include ::Sprockets::Engines
  include ::Sprockets::Mime
  include ::Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def computed_config(); end

  def computed_config=(computed_config); end

  def config(); end

  def config=(config); end

  def context_class(); end

  def digest_class(); end

  def digest_class=(klass); end

  def initialize_configuration(parent); end

  def logger(); end

  def logger=(logger); end

  def version(); end

  def version=(version); end
end

module Sprockets::Configuration
  extend ::T::Sig
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::ContentTypeMismatch
end

class Sprockets::Context
  def __LINE__(); end

  def __LINE__=(_); end

  def asset_data_uri(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def content_type(); end

  def depend_on(path); end

  def depend_on_asset(path); end

  def environment(); end

  def filename(); end

  def font_path(path); end

  def image_path(path); end

  def initialize(input); end

  def javascript_path(path); end

  def link_asset(path); end

  def load(uri); end

  def load_path(); end

  def logical_path(); end

  def metadata(); end

  def pathname(); end

  def require_asset(path); end

  def resolve(path, options=T.unsafe(nil)); end

  def resolve_with_compat(path, options=T.unsafe(nil)); end

  def resolve_without_compat(path, options=T.unsafe(nil)); end

  def root_path(); end

  def stub_asset(path); end

  def stylesheet_path(path); end

  def video_path(path); end
end

class Sprockets::Context
end

class Sprockets::ConversionError
end

class Sprockets::ConversionError
end

module Sprockets::Dependencies
  include ::Sprockets::URIUtils
  include ::Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def add_dependency(uri); end

  def depend_on(uri); end

  def dependencies(); end

  def dependency_resolvers(); end

  def register_dependency_resolver(scheme, &block); end

  def resolve_dependency(str); end
end

module Sprockets::Dependencies
  extend ::T::Sig
end

module Sprockets::DigestUtils
  def detect_digest_class(bytes); end

  def digest(obj); end

  def digest_class(); end

  def hexdigest_integrity_uri(hexdigest); end

  def integrity_uri(digest); end

  def pack_base64digest(bin); end

  def pack_hexdigest(bin); end

  def pack_urlsafe_base64digest(bin); end

  def unpack_hexdigest(hex); end
  DIGEST_SIZES = ::T.let(nil, ::T.untyped)
  HASH_ALGORITHMS = ::T.let(nil, ::T.untyped)
end

module Sprockets::DigestUtils
  extend ::Sprockets::DigestUtils
  extend ::T::Sig
end

class Sprockets::DirectiveProcessor
  def _call(input); end

  def call(input); end

  def compile_header_pattern(comments); end

  def extract_directives(header); end

  def initialize(options=T.unsafe(nil)); end

  def process_depend_on_asset_directive(path); end

  def process_depend_on_directive(path); end

  def process_directives(directives); end

  def process_link_directive(path); end

  def process_link_directory_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_link_tree_directive(path=T.unsafe(nil), accept=T.unsafe(nil)); end

  def process_require_directive(path); end

  def process_require_directory_directive(path=T.unsafe(nil)); end

  def process_require_self_directive(); end

  def process_require_tree_directive(path=T.unsafe(nil)); end

  def process_source(source); end

  def process_stub_directive(path); end
  DIRECTIVE_PATTERN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::DirectiveProcessor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::ERBProcessor
  def call(input); end

  def initialize(&block); end
end

class Sprockets::ERBProcessor
  def self.call(input); end

  def self.instance(); end
end

class Sprockets::ERBTemplate
  def call(*args); end
end

class Sprockets::ERBTemplate
end

module Sprockets::EcoProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoProcessor
  extend ::T::Sig
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EcoTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EcoTemplate
  extend ::T::Sig
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::EjsProcessor
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsProcessor
  extend ::T::Sig
  def self.cache_key(); end

  def self.call(input); end
end

module Sprockets::EjsTemplate
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::EjsTemplate
  extend ::T::Sig
  def self.cache_key(); end

  def self.call(*args); end
end

module Sprockets::EncodingUtils
  def base64(str); end

  def charlock_detect(str); end

  def deflate(str); end

  def detect(str); end

  def detect_css(str); end

  def detect_html(str); end

  def detect_unicode(str); end

  def detect_unicode_bom(str); end

  def gzip(str); end

  def scan_css_charset(str); end

  def unmarshaled_deflated(str, window_bits=T.unsafe(nil)); end
  BOM = ::T.let(nil, ::T.untyped)
  CHARSET_DETECT = ::T.let(nil, ::T.untyped)
  CHARSET_SIZE = ::T.let(nil, ::T.untyped)
  CHARSET_START = ::T.let(nil, ::T.untyped)
end

module Sprockets::EncodingUtils
  extend ::Sprockets::EncodingUtils
  extend ::T::Sig
end

module Sprockets::Engines
  include ::Sprockets::Utils
  def engine_mime_types(); end

  def engines(); end

  def register_engine(ext, klass, options=T.unsafe(nil)); end
end

module Sprockets::Engines
  extend ::T::Sig
end

class Sprockets::Environment
  def find_all_linked_assets(*args, &block); end

  def find_asset(*args); end

  def initialize(root=T.unsafe(nil)); end

  def load(*args); end
end

class Sprockets::Environment
end

class Sprockets::Error
end

class Sprockets::Error
end

class Sprockets::FileNotFound
end

class Sprockets::FileNotFound
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileOutsidePaths
end

class Sprockets::FileReader
end

class Sprockets::FileReader
  def self.call(input); end
end

module Sprockets::HTTPUtils
  def find_best_mime_type_match(q_value_header, available); end

  def find_best_q_match(q_values, available, &matcher); end

  def find_mime_type_matches(q_value_header, available); end

  def find_q_matches(q_values, available, &matcher); end

  def match_mime_type?(value, matcher); end

  def match_mime_type_keys(hash, mime_type); end

  def parse_q_values(values); end
end

module Sprockets::HTTPUtils
  extend ::Sprockets::HTTPUtils
  extend ::T::Sig
end

Sprockets::Index = Sprockets::CachedEnvironment

class Sprockets::JstProcessor
  def call(input); end

  def initialize(options=T.unsafe(nil)); end
end

class Sprockets::JstProcessor
  def self.call(input); end

  def self.default_namespace(); end

  def self.instance(); end
end

class Sprockets::LegacyProcProcessor
  def call(input); end

  def initialize(name, proc); end

  def name(); end

  def to_s(); end
end

class Sprockets::LegacyProcProcessor
end

class Sprockets::LegacyTiltProcessor
  def call(input); end

  def initialize(klass); end
end

class Sprockets::LegacyTiltProcessor
end

module Sprockets::Loader
  include ::Sprockets::DigestUtils
  include ::Sprockets::Transformers
  include ::Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::Processing
  include ::Sprockets::Mime
  include ::Sprockets::Engines
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def load(uri); end
end

module Sprockets::Loader
  extend ::T::Sig
end

class Sprockets::Manifest
  include ::Sprockets::ManifestUtils
  def assets(); end

  def clean(count=T.unsafe(nil), age=T.unsafe(nil)); end

  def clobber(); end

  def compile(*args); end

  def dir(); end

  def directory(); end

  def environment(); end

  def filename(); end

  def files(); end

  def filter_logical_paths(*args); end

  def find(*args); end

  def find_logical_paths(*args); end

  def find_sources(*args); end

  def initialize(*args); end

  def path(); end

  def remove(filename); end

  def save(); end
end

class Sprockets::Manifest
  def self.compile_match_filter(filter); end

  def self.compute_alias_logical_path(path); end

  def self.simple_logical_path?(str); end
end

module Sprockets::ManifestUtils
  def find_directory_manifest(dirname); end

  def generate_manifest_path(); end
  LEGACY_MANIFEST_RE = ::T.let(nil, ::T.untyped)
  MANIFEST_RE = ::T.let(nil, ::T.untyped)
end

module Sprockets::ManifestUtils
  extend ::Sprockets::ManifestUtils
  extend ::T::Sig
end

module Sprockets::Mime
  include ::Sprockets::Utils
  include ::Sprockets::HTTPUtils
  def mime_exts(); end

  def mime_type_charset_detecter(mime_type); end

  def mime_types(); end

  def read_file(filename, content_type=T.unsafe(nil)); end

  def register_mime_type(mime_type, options=T.unsafe(nil)); end
end

module Sprockets::Mime
  extend ::T::Sig
end

class Sprockets::NotFound
end

class Sprockets::NotFound
end

class Sprockets::NotImplementedError
end

class Sprockets::NotImplementedError
end

module Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  def entries_with_dependencies(path); end

  def file_digest_dependency_set(path); end

  def stat_directory_with_dependencies(dir); end

  def stat_sorted_tree_with_dependencies(dir); end
end

module Sprockets::PathDependencyUtils
  extend ::T::Sig
end

module Sprockets::PathDigestUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::DigestUtils
  def file_digest(path); end

  def files_digest(paths); end

  def stat_digest(path, stat); end
end

module Sprockets::PathDigestUtils
  extend ::T::Sig
end

module Sprockets::PathUtils
  def absolute_path?(path); end

  def atomic_write(filename); end

  def directory?(path); end

  def entries(path); end

  def file?(path); end

  def find_upwards(basename, path, root=T.unsafe(nil)); end

  def match_path_extname(path, extensions); end

  def path_extnames(path); end

  def path_parents(path, root=T.unsafe(nil)); end

  def paths_split(paths, filename); end

  def relative_path?(path); end

  def split_subpath(path, subpath); end

  def stat(path); end

  def stat_directory(dir); end

  def stat_sorted_tree(dir, &block); end

  def stat_tree(dir, &block); end
  SEPARATOR_PATTERN = ::T.let(nil, ::T.untyped)
end

module Sprockets::PathUtils
  extend ::Sprockets::PathUtils
  extend ::T::Sig
end

module Sprockets::Paths
  include ::Sprockets::Utils
  include ::Sprockets::PathUtils
  def append_path(path); end

  def clear_paths(); end

  def each_file(); end

  def paths(); end

  def prepend_path(path); end

  def root(); end
end

module Sprockets::Paths
  extend ::T::Sig
end

module Sprockets::Processing
  include ::Sprockets::Utils
  include ::Sprockets::URIUtils
  include ::Sprockets::ProcessorUtils
  def build_processors_uri(type, file_type, engine_extnames, pipeline); end

  def bundle_processors(); end

  def default_processors_for(type, file_type, engine_extnames); end

  def pipelines(); end

  def postprocessors(); end

  def preprocessors(); end

  def processors(); end

  def processors_for(type, file_type, engine_extnames, pipeline); end

  def register_bundle_metadata_reducer(mime_type, key, *args, &block); end

  def register_bundle_processor(*args, &block); end

  def register_pipeline(name, proc=T.unsafe(nil), &block); end

  def register_postprocessor(*args, &block); end

  def register_preprocessor(*args, &block); end

  def register_processor(*args, &block); end

  def resolve_processors_cache_key_uri(uri); end

  def self_processors_for(type, file_type, engine_extnames); end

  def unregister_bundle_processor(*args); end

  def unregister_postprocessor(*args); end

  def unregister_preprocessor(*args); end

  def unregister_processor(*args); end
end

module Sprockets::Processing
  extend ::T::Sig
end

module Sprockets::ProcessorUtils
  def call_processor(processor, input); end

  def call_processors(processors, input); end

  def compose_processors(*processors); end

  def processor_cache_key(processor); end

  def processors_cache_keys(processors); end

  def valid_processor_metadata_value?(value); end

  def validate_processor_result!(result); end
  VALID_METADATA_COMPOUND_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_COMPOUND_TYPES_HASH = ::T.let(nil, ::T.untyped)
  VALID_METADATA_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES = ::T.let(nil, ::T.untyped)
  VALID_METADATA_VALUE_TYPES_HASH = ::T.let(nil, ::T.untyped)
end

module Sprockets::ProcessorUtils
  extend ::Sprockets::ProcessorUtils
  extend ::T::Sig
end

module Sprockets::Rails
  VERSION = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Context
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  def compute_asset_path(path, options=T.unsafe(nil)); end
end

module Sprockets::Rails::Context
  extend ::T::Sig
  def self.included(klass); end
end

module Sprockets::Rails::Helper
  include ::ActionView::Helpers::TagHelper
  include ::ActionView::Helpers::CaptureHelper
  include ::ActionView::Helpers::OutputSafetyHelper
  include ::ActionView::Helpers::AssetTagHelper
  include ::ActionView::Helpers::AssetUrlHelper
  include ::Sprockets::Rails::Utils
  def asset_digest_path(path, options=T.unsafe(nil)); end

  def asset_integrity(path, options=T.unsafe(nil)); end

  def asset_resolver_strategies(); end

  def compute_asset_path(path, options=T.unsafe(nil)); end

  def compute_integrity?(options); end

  def javascript_include_tag(*sources); end

  def legacy_debug_path(path, debug); end

  def lookup_debug_asset(path, options=T.unsafe(nil)); end

  def path_with_extname(path, options); end

  def request_debug_assets?(); end

  def resolve_asset(); end

  def resolve_asset_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def secure_subresource_integrity_context?(); end

  def stylesheet_link_tag(*sources); end
  VIEW_ACCESSORS = ::T.let(nil, ::T.untyped)
end

module Sprockets::Rails::Helper
  extend ::T::Sig
  def self.extended(obj); end

  def self.included(klass); end
end

module Sprockets::Rails::HelperAssetResolvers
end

class Sprockets::Rails::HelperAssetResolvers::Environment
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Environment
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
  def asset_path(path, digest, allow_non_precompiled=T.unsafe(nil)); end

  def digest_path(path, allow_non_precompiled=T.unsafe(nil)); end

  def find_debug_asset(path); end

  def initialize(view); end

  def integrity(path); end
end

class Sprockets::Rails::HelperAssetResolvers::Manifest
end

module Sprockets::Rails::HelperAssetResolvers
  extend ::T::Sig
  def self.[](name); end
end

class Sprockets::Rails::QuietAssets
  def call(env); end

  def initialize(app); end
end

class Sprockets::Rails::QuietAssets
end

module Sprockets::Rails::RouteWrapper
  def internal?(); end

  def internal_assets_path?(); end
end

module Sprockets::Rails::RouteWrapper
  extend ::T::Sig
  def self.included(klass); end
end

module Sprockets::Rails::Utils
  def using_sprockets4?(); end
end

module Sprockets::Rails::Utils
  extend ::T::Sig
end

module Sprockets::Rails
  extend ::T::Sig
end

class Sprockets::Railtie
  include ::Sprockets::Rails::Utils
  def build_environment(app, initialized=T.unsafe(nil)); end
  LOOSE_APP_ASSETS = ::T.let(nil, ::T.untyped)
end

class Sprockets::Railtie::ManifestNeededError
  def initialize(); end
end

class Sprockets::Railtie::ManifestNeededError
end

class Sprockets::Railtie::OrderedOptions
  def configure(&block); end
end

class Sprockets::Railtie::OrderedOptions
end

class Sprockets::Railtie
  def self.build_manifest(app); end
end

module Sprockets::Resolve
  include ::Sprockets::PathDependencyUtils
  include ::Sprockets::PathUtils
  include ::Sprockets::URIUtils
  include ::Sprockets::HTTPUtils
  def dirname_matches(dirname, basename); end

  def parse_accept_options(mime_type, types); end

  def parse_path_extnames(path); end

  def path_matches(load_path, logical_name, logical_basename); end

  def resolve(path, options=T.unsafe(nil)); end

  def resolve!(path, options=T.unsafe(nil)); end

  def resolve_absolute_path(paths, filename, accept); end

  def resolve_alternates(load_path, logical_name); end

  def resolve_asset_uri(uri); end

  def resolve_logical_path(paths, logical_path, accept); end

  def resolve_relative_path(paths, path, dirname, accept); end

  def resolve_under_paths(paths, logical_name, accepts); end
end

module Sprockets::Resolve
  extend ::T::Sig
end

class Sprockets::SassCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::SassCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

Sprockets::SassFunctions = Sprockets::SassProcessor::Functions

class Sprockets::SassProcessor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil), &block); end
end

class Sprockets::SassProcessor::CacheStore
  def initialize(cache, version); end

  def path_to(key); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::SassProcessor::CacheStore
end

module Sprockets::SassProcessor::Functions
  def asset_data_url(path); end

  def asset_path(path, options=T.unsafe(nil)); end

  def asset_url(path, options=T.unsafe(nil)); end

  def audio_path(path); end

  def audio_url(path); end

  def font_path(path); end

  def font_url(path); end

  def image_path(path); end

  def image_url(path); end

  def javascript_path(path); end

  def javascript_url(path); end

  def sprockets_context(); end

  def sprockets_dependencies(); end

  def sprockets_environment(); end

  def stylesheet_path(path); end

  def stylesheet_url(path); end

  def video_path(path); end

  def video_url(path); end
end

module Sprockets::SassProcessor::Functions
  extend ::T::Sig
end

class Sprockets::SassProcessor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end

  def self.syntax(); end
end

class Sprockets::SassTemplate
end

class Sprockets::SassTemplate
  def self.call(*args); end
end

class Sprockets::ScssProcessor
end

class Sprockets::ScssProcessor
end

class Sprockets::ScssTemplate
end

class Sprockets::ScssTemplate
  def self.call(*args); end
end

module Sprockets::Server
  def call(env); end
end

module Sprockets::Server
  extend ::T::Sig
end

module Sprockets::Transformers
  include ::Sprockets::Utils
  include ::Sprockets::ProcessorUtils
  include ::Sprockets::HTTPUtils
  def compose_transformers(transformers, types); end

  def expand_transform_accepts(parsed_accepts); end

  def register_transformer(from, to, proc); end

  def resolve_transform_type(type, accept); end

  def transformers(); end
end

module Sprockets::Transformers
  extend ::T::Sig
end

class Sprockets::URITar
  def absolute_path?(); end

  def compress(); end

  def compressed_path(); end

  def expand(); end

  def initialize(uri, env); end

  def path(); end

  def root(); end

  def scheme(); end
end

class Sprockets::URITar
end

module Sprockets::URIUtils
  def build_asset_uri(path, params=T.unsafe(nil)); end

  def build_file_digest_uri(path); end

  def encode_uri_query_params(params); end

  def join_file_uri(scheme, host, path, query); end

  def join_uri(scheme, userinfo, host, port, registry, path, opaque, query, fragment); end

  def parse_asset_uri(uri); end

  def parse_file_digest_uri(uri); end

  def parse_uri_query_params(query); end

  def split_file_uri(uri); end

  def split_uri(uri); end

  def valid_asset_uri?(str); end
end

module Sprockets::URIUtils
  extend ::Sprockets::URIUtils
  extend ::T::Sig
end

class Sprockets::UglifierCompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::UglifierCompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

class Sprockets::UnloadedAsset
  def asset_key(); end

  def compressed_path(); end

  def dependency_history_key(); end

  def digest_key(digest); end

  def file_digest_key(stat); end

  def filename(); end

  def initialize(uri, env); end

  def params(); end

  def uri(); end
end

class Sprockets::UnloadedAsset
end

module Sprockets::Utils
  def concat_javascript_sources(buf, source); end

  def dfs(initial); end

  def dfs_paths(path); end

  def duplicable?(obj); end

  def hash_reassoc(hash, *keys, &block); end

  def hash_reassoc1(hash, key); end

  def module_include(base, mod); end

  def normalize_extension(extension); end

  def string_end_with_semicolon?(str); end
  UNBOUND_METHODS_BIND_TO_ANY_OBJECT = ::T.let(nil, ::T.untyped)
end

class Sprockets::Utils::Gzip
  def can_compress?(mime_types); end

  def cannot_compress?(mime_types); end

  def compress(target); end

  def initialize(asset); end
  COMPRESSABLE_MIME_TYPES = ::T.let(nil, ::T.untyped)
end

class Sprockets::Utils::Gzip
end

module Sprockets::Utils
  extend ::Sprockets::Utils
  extend ::T::Sig
end

class Sprockets::YUICompressor
  def cache_key(); end

  def call(input); end

  def initialize(options=T.unsafe(nil)); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Sprockets::YUICompressor
  def self.cache_key(); end

  def self.call(input); end

  def self.instance(); end
end

module Sprockets
  extend ::Sprockets::Configuration
  extend ::Sprockets::Dependencies
  extend ::Sprockets::Compressing
  extend ::Sprockets::Processing
  extend ::Sprockets::Transformers
  extend ::Sprockets::Engines
  extend ::Sprockets::Mime
  extend ::Sprockets::Paths
  extend ::Sprockets::Utils
  extend ::Sprockets::URIUtils
  extend ::Sprockets::PathDigestUtils
  extend ::Sprockets::ProcessorUtils
  extend ::Sprockets::HTTPUtils
  extend ::Sprockets::PathUtils
  extend ::Sprockets::DigestUtils
  extend ::T::Sig
end

class StandardError
  extend ::T::Sig
end

class StateHistory
  include ::StateHistory::GeneratedAssociationMethods
  def autosave_associated_records_for_order(*args); end

  def belongs_to_counter_cache_after_update(reflection); end
end

module StateHistory::GeneratedAssociationMethods
  def build_order(*args, &block); end

  def create_order(*args, &block); end

  def create_order!(*args, &block); end

  def order(); end

  def order=(value); end

  def reload_order(); end
end

module StateHistory::GeneratedAssociationMethods
  extend ::T::Sig
end

class StopIteration
  def result(); end
end

class StopIteration
  extend ::T::Sig
end

class String
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Colored2
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::String
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def +@(); end

  def -@(); end

  def []=(*_); end

  def acts_like_string?(); end

  def ansi(); end

  def at(position); end

  def black(string=T.unsafe(nil), &block); end

  def black!(string=T.unsafe(nil), &block); end

  def blue(string=T.unsafe(nil), &block); end

  def blue!(string=T.unsafe(nil), &block); end

  def bold(string=T.unsafe(nil), &block); end

  def bold!(string=T.unsafe(nil), &block); end

  def camelcase(first_letter=T.unsafe(nil)); end

  def camelize(first_letter=T.unsafe(nil)); end

  def casecmp?(_); end

  def classify(); end

  def constantize(); end

  def cyan(string=T.unsafe(nil), &block); end

  def cyan!(string=T.unsafe(nil), &block); end

  def danger_pluralize(count); end

  def danger_truncate(limit); end

  def danger_underscore(); end

  def dark(string=T.unsafe(nil), &block); end

  def dark!(string=T.unsafe(nil), &block); end

  def dasherize(); end

  def deconstantize(); end

  def delete_prefix(_); end

  def delete_prefix!(_); end

  def delete_suffix(_); end

  def delete_suffix!(_); end

  def demodulize(); end

  def each_grapheme_cluster(); end

  def encode(*_); end

  def encode!(*_); end

  def ends_with?(*_); end

  def exclude?(string); end

  def ext(newext=T.unsafe(nil)); end

  def first(limit=T.unsafe(nil)); end

  def foreign_key(separate_class_name_and_id_with_underscore=T.unsafe(nil)); end

  def from(position); end

  def grapheme_clusters(); end

  def green(string=T.unsafe(nil), &block); end

  def green!(string=T.unsafe(nil), &block); end

  def html_safe(); end

  def humanize(capitalize: T.unsafe(nil), keep_id_suffix: T.unsafe(nil)); end

  def in_time_zone(zone=T.unsafe(nil)); end

  def indent(amount, indent_string=T.unsafe(nil), indent_empty_lines=T.unsafe(nil)); end

  def indent!(amount, indent_string=T.unsafe(nil), indent_empty_lines=T.unsafe(nil)); end

  def inquiry(); end

  def is_utf8?(); end

  def italic(string=T.unsafe(nil), &block); end

  def italic!(string=T.unsafe(nil), &block); end

  def last(limit=T.unsafe(nil)); end

  def magenta(string=T.unsafe(nil), &block); end

  def magenta!(string=T.unsafe(nil), &block); end

  def match?(*_); end

  def mb_chars(); end

  def no_color(string=T.unsafe(nil), &block); end

  def no_color!(string=T.unsafe(nil), &block); end

  def normal(string=T.unsafe(nil), &block); end

  def normal!(string=T.unsafe(nil), &block); end

  def on(); end

  def parameterize(separator: T.unsafe(nil), preserve_case: T.unsafe(nil)); end

  def parse_csv(**options); end

  def pathmap(spec=T.unsafe(nil), &block); end

  def pathmap_explode(); end

  def pathmap_partial(n); end

  def pathmap_replace(patterns, &block); end

  def plain(string=T.unsafe(nil), &block); end

  def plain!(string=T.unsafe(nil), &block); end

  def pluralize(count=T.unsafe(nil), locale=T.unsafe(nil)); end

  def red(string=T.unsafe(nil), &block); end

  def red!(string=T.unsafe(nil), &block); end

  def remove(*patterns); end

  def remove!(*patterns); end

  def reverse!(); end

  def reversed(string=T.unsafe(nil), &block); end

  def reversed!(string=T.unsafe(nil), &block); end

  def safe_constantize(); end

  def shellescape(); end

  def shellsplit(); end

  def singularize(locale=T.unsafe(nil)); end

  def squish(); end

  def squish!(); end

  def starts_with?(*_); end

  def strip_heredoc(); end

  def strip_indent(); end

  def succ!(); end

  def surround_with_color(color: T.unsafe(nil), effect: T.unsafe(nil), color_self: T.unsafe(nil), string: T.unsafe(nil), &block); end

  def tableize(); end

  def titlecase(keep_id_suffix: T.unsafe(nil)); end

  def titleize(keep_id_suffix: T.unsafe(nil)); end

  def to(position); end

  def to_bol(); end

  def to_d(); end

  def to_date(); end

  def to_datetime(); end

  def to_eol(); end

  def to_nfc(); end

  def to_nfd(); end

  def to_nfkc(); end

  def to_nfkd(); end

  def to_time(form=T.unsafe(nil)); end

  def truncate(truncate_at, options=T.unsafe(nil)); end

  def truncate_words(words_count, options=T.unsafe(nil)); end

  def underlined(string=T.unsafe(nil), &block); end

  def underlined!(string=T.unsafe(nil), &block); end

  def underscore(); end

  def undump(); end

  def unicode_normalize(*_); end

  def unicode_normalize!(*_); end

  def unicode_normalized?(*_); end

  def unpack1(_); end

  def upcase_first(); end

  def white(string=T.unsafe(nil), &block); end

  def white!(string=T.unsafe(nil), &block); end

  def yellow(string=T.unsafe(nil), &block); end

  def yellow!(string=T.unsafe(nil), &block); end
  BLANK_RE = ::T.let(nil, ::T.untyped)
  ENCODED_BLANKS = ::T.let(nil, ::T.untyped)
end

class String
  extend ::T::Sig
end

class StringIO
  def length(); end

  def truncate(_); end

end

class StringIO
  extend ::T::Sig
end

class StringScanner
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(_); end

  def [](_); end

  def beginning_of_line?(); end

  def bol?(); end

  def captures(); end

  def charpos(); end

  def check(_); end

  def check_until(_); end

  def clear(); end

  def concat(_); end

  def empty?(); end

  def exist?(_); end

  def get_byte(); end

  def getbyte(); end

  def initialize(*_); end

  def match?(_); end

  def matched(); end

  def matched?(); end

  def matched_size(); end

  def peek(_); end

  def peep(_); end

  def pointer(); end

  def pointer=(pointer); end

  def pos(); end

  def pos=(pos); end

  def post_match(); end

  def pre_match(); end

  def reset(); end

  def rest(); end

  def rest?(); end

  def rest_size(); end

  def restsize(); end

  def scan_full(_, _1, _2); end

  def scan_until(_); end

  def search_full(_, _1, _2); end

  def size(); end

  def skip(_); end

  def skip_until(_); end

  def string(); end

  def string=(string); end

  def terminate(); end

  def unscan(); end

  def values_at(*_); end
  Id = ::T.let(nil, ::T.untyped)
  Version = ::T.let(nil, ::T.untyped)
end

class StringScanner::Error
  extend ::T::Sig
end

class StringScanner
  extend ::T::Sig
  def self.must_C_version(); end
end

module Stripe
  DEFAULT_CA_BUNDLE_PATH = ::T.let(nil, ::T.untyped)
  LEVEL_DEBUG = ::T.let(nil, ::T.untyped)
  LEVEL_ERROR = ::T.let(nil, ::T.untyped)
  LEVEL_INFO = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class Stripe::APIConnectionError
end

class Stripe::APIConnectionError
end

class Stripe::APIError
end

class Stripe::APIError
end

module Stripe::APIOperations
end

module Stripe::APIOperations::Create
  def create(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

module Stripe::APIOperations::Create
  extend ::T::Sig
end

module Stripe::APIOperations::Delete
  def delete(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

module Stripe::APIOperations::Delete
  extend ::T::Sig
end

module Stripe::APIOperations::List
  def all(filters=T.unsafe(nil), opts=T.unsafe(nil)); end

  def list(filters=T.unsafe(nil), opts=T.unsafe(nil)); end
end

module Stripe::APIOperations::List
  extend ::T::Sig
end

module Stripe::APIOperations::NestedResource
  def nested_resource_class_methods(resource, path: T.unsafe(nil), operations: T.unsafe(nil)); end
end

module Stripe::APIOperations::NestedResource
  extend ::T::Sig
end

module Stripe::APIOperations::Request
  def request(method, url, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

module Stripe::APIOperations::Request::ClassMethods
  def request(method, url, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

module Stripe::APIOperations::Request::ClassMethods
  extend ::T::Sig
end

module Stripe::APIOperations::Request
  extend ::T::Sig
  def self.included(base); end
end

module Stripe::APIOperations::Save
  def save(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

module Stripe::APIOperations::Save::ClassMethods
  def update(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

module Stripe::APIOperations::Save::ClassMethods
  extend ::T::Sig
end

module Stripe::APIOperations::Save
  extend ::T::Sig
  def self.included(base); end
end

module Stripe::APIOperations
  extend ::T::Sig
end

class Stripe::APIResource
  include ::Stripe::APIOperations::Request
  def refresh(); end

  def resource_url(); end

  def save_with_parent(); end

  def save_with_parent=(save_with_parent); end
end

class Stripe::APIResource
  extend ::Stripe::APIOperations::Request::ClassMethods
  def self.class_name(); end

  def self.resource_url(); end

  def self.retrieve(id, opts=T.unsafe(nil)); end

  def self.save_nested_resource(name); end
end

class Stripe::Account
  include ::Stripe::APIOperations::Delete
  include ::Stripe::APIOperations::Save
  def _deprecated_bank_account=(value); end

  def bank_account=(*args, &block); end

  def deauthorize(client_id=T.unsafe(nil), opts=T.unsafe(nil)); end

  def external_account=(value); end

  def legal_entity(); end

  def legal_entity=(_); end

  def reject(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def serialize_params_account(_obj, update_hash); end
  ARGUMENT_NOT_PROVIDED = ::T.let(nil, ::T.untyped)
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Account
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::NestedResource
  def self.create_external_account(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.create_login_link(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.delete_external_account(id, nested_id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.external_accounts_url(id, nested_id=T.unsafe(nil)); end

  def self.list_external_accounts(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.login_links_url(id, nested_id=T.unsafe(nil)); end

  def self.retrieve(id=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.retrieve_external_account(id, nested_id, opts=T.unsafe(nil)); end

  def self.update_external_account(id, nested_id, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class Stripe::AlipayAccount
  include ::Stripe::APIOperations::Save
  include ::Stripe::APIOperations::Delete
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::AlipayAccount
  extend ::Stripe::APIOperations::Save::ClassMethods
  def self.retrieve(_id, _opts=T.unsafe(nil)); end

  def self.update(_id, _params=T.unsafe(nil), _opts=T.unsafe(nil)); end
end

class Stripe::ApplePayDomain
  include ::Stripe::APIOperations::Delete
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ApplePayDomain
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
end

class Stripe::ApplicationFee
  def refund(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ApplicationFee
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::NestedResource
  def self.create_refund(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.list_refunds(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.refunds_url(id, nested_id=T.unsafe(nil)); end

  def self.retrieve_refund(id, nested_id, opts=T.unsafe(nil)); end

  def self.update_refund(id, nested_id, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class Stripe::ApplicationFeeRefund
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ApplicationFeeRefund
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::List
  def self.retrieve(_id, _api_key=T.unsafe(nil)); end

  def self.update(_id, _params=T.unsafe(nil), _opts=T.unsafe(nil)); end
end

class Stripe::AuthenticationError
end

class Stripe::AuthenticationError
end

class Stripe::Balance
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Balance
end

class Stripe::BalanceTransaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::BalanceTransaction
  extend ::Stripe::APIOperations::List
end

class Stripe::BankAccount
  include ::Stripe::APIOperations::Save
  include ::Stripe::APIOperations::Delete
  def verify(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::BankAccount
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::List
  def self.retrieve(_id, _opts=T.unsafe(nil)); end

  def self.update(_id, _params=T.unsafe(nil), _opts=T.unsafe(nil)); end
end

class Stripe::BitcoinReceiver
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::BitcoinReceiver
  extend ::Stripe::APIOperations::List
end

class Stripe::BitcoinTransaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::BitcoinTransaction
  extend ::Stripe::APIOperations::List
end

class Stripe::Card
  include ::Stripe::APIOperations::Save
  include ::Stripe::APIOperations::Delete
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Card
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::List
  def self.retrieve(_id, _opts=T.unsafe(nil)); end

  def self.update(_id, _params=T.unsafe(nil), _opts=T.unsafe(nil)); end
end

class Stripe::CardError
  def initialize(message, param, code, http_status: T.unsafe(nil), http_body: T.unsafe(nil), json_body: T.unsafe(nil), http_headers: T.unsafe(nil)); end

  def param(); end
end

class Stripe::CardError
end

class Stripe::Charge
  include ::Stripe::APIOperations::Save
  def capture(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def close_dispute(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def mark_as_fraudulent(); end

  def mark_as_safe(); end

  def refund(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def update_dispute(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Charge
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::CountrySpec
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::CountrySpec
  extend ::Stripe::APIOperations::List
end

class Stripe::Coupon
  include ::Stripe::APIOperations::Save
  include ::Stripe::APIOperations::Delete
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Coupon
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::List
end

class Stripe::Customer
  include ::Stripe::APIOperations::Delete
  include ::Stripe::APIOperations::Save
  def add_invoice_item(params, opts=T.unsafe(nil)); end

  def cancel_subscription(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def charges(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def create_subscription(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def create_upcoming_invoice(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def delete_discount(); end

  def invoice_items(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def invoices(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def source=(value); end

  def upcoming_invoice(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def update_subscription(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Customer
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::NestedResource
  def self.create_source(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.delete_source(id, nested_id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.detach_source(id, nested_id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.list_sources(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.retrieve_source(id, nested_id, opts=T.unsafe(nil)); end

  def self.sources_url(id, nested_id=T.unsafe(nil)); end

  def self.update_source(id, nested_id, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class Stripe::Dispute
  include ::Stripe::APIOperations::Save
  def close(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def close_url(); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Dispute
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::EphemeralKey
  include ::Stripe::APIOperations::Delete
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::EphemeralKey
  extend ::Stripe::APIOperations::Create
end

class Stripe::Event
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Event
  extend ::Stripe::APIOperations::List
end

class Stripe::ExchangeRate
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ExchangeRate
  extend ::Stripe::APIOperations::List
end

class Stripe::File
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
  OBJECT_NAME_ALT = ::T.let(nil, ::T.untyped)
end

class Stripe::File
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
end

class Stripe::FileLink
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::FileLink
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::List
end

Stripe::FileUpload = Stripe::File

class Stripe::IdempotencyError
end

class Stripe::IdempotencyError
end

class Stripe::InvalidRequestError
  def initialize(message, param, http_status: T.unsafe(nil), http_body: T.unsafe(nil), json_body: T.unsafe(nil), http_headers: T.unsafe(nil), code: T.unsafe(nil)); end

  def param(); end

  def param=(param); end
end

class Stripe::InvalidRequestError
end

class Stripe::Invoice
  include ::Stripe::APIOperations::Save
  def pay(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Invoice
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::Create
  def self.upcoming(params, opts=T.unsafe(nil)); end
end

class Stripe::InvoiceItem
  include ::Stripe::APIOperations::Delete
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::InvoiceItem
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::InvoiceLineItem
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::InvoiceLineItem
end

class Stripe::IssuerFraudRecord
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::IssuerFraudRecord
  extend ::Stripe::APIOperations::List
end

module Stripe::Issuing
end

class Stripe::Issuing::Authorization
  include ::Stripe::APIOperations::Save
  def approve(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def decline(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::Authorization
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::Issuing::Card
  include ::Stripe::APIOperations::Save
  def details(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::Card
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::Issuing::CardDetails
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::CardDetails
end

class Stripe::Issuing::Cardholder
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::Cardholder
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::Issuing::Dispute
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::Dispute
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::Issuing::Transaction
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Issuing::Transaction
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

module Stripe::Issuing
  extend ::T::Sig
end

class Stripe::ListObject
  include ::Stripe::APIOperations::List
  include ::Stripe::APIOperations::Request
  include ::Stripe::APIOperations::Create
  def auto_paging_each(&blk); end

  def empty?(); end

  def filters(); end

  def filters=(filters); end

  def initialize(*args); end

  def next_page(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def previous_page(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def resource_url(); end

  def retrieve(id, opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ListObject
  extend ::Stripe::APIOperations::Request::ClassMethods
  def self.empty_list(opts=T.unsafe(nil)); end
end

class Stripe::LoginLink
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::LoginLink
  def self.retrieve(_id, _opts=T.unsafe(nil)); end
end

module Stripe::OAuth
end

class Stripe::OAuth::InvalidClientError
end

class Stripe::OAuth::InvalidClientError
end

class Stripe::OAuth::InvalidGrantError
end

class Stripe::OAuth::InvalidGrantError
end

class Stripe::OAuth::InvalidRequestError
end

class Stripe::OAuth::InvalidRequestError
end

class Stripe::OAuth::InvalidScopeError
end

class Stripe::OAuth::InvalidScopeError
end

class Stripe::OAuth::OAuthError
  def initialize(code, description, http_status: T.unsafe(nil), http_body: T.unsafe(nil), json_body: T.unsafe(nil), http_headers: T.unsafe(nil)); end
end

class Stripe::OAuth::OAuthError
end

module Stripe::OAuth::OAuthOperations
end

module Stripe::OAuth::OAuthOperations
  extend ::Stripe::APIOperations::Request::ClassMethods
  extend ::T::Sig
  def self.request(method, url, params, opts); end
end

class Stripe::OAuth::UnsupportedGrantTypeError
end

class Stripe::OAuth::UnsupportedGrantTypeError
end

class Stripe::OAuth::UnsupportedResponseTypeError
end

class Stripe::OAuth::UnsupportedResponseTypeError
end

module Stripe::OAuth
  extend ::T::Sig
  def self.authorize_url(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.deauthorize(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.get_client_id(params=T.unsafe(nil)); end

  def self.token(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class Stripe::Order
  include ::Stripe::APIOperations::Save
  def pay(params, opts=T.unsafe(nil)); end

  def return_order(params, opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Order
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::OrderReturn
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::OrderReturn
  extend ::Stripe::APIOperations::List
end

class Stripe::PaymentIntent
  include ::Stripe::APIOperations::Save
  def cancel(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def capture(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def confirm(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::PaymentIntent
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::Payout
  include ::Stripe::APIOperations::Save
  def cancel(); end

  def cancel_url(); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Payout
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::PermissionError
end

class Stripe::PermissionError
end

class Stripe::Plan
  include ::Stripe::APIOperations::Delete
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Plan
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::Product
  include ::Stripe::APIOperations::Save
  include ::Stripe::APIOperations::Delete
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Product
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::RateLimitError
end

class Stripe::RateLimitError
end

class Stripe::Recipient
  include ::Stripe::APIOperations::Delete
  include ::Stripe::APIOperations::Save
  def transfers(); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Recipient
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::List
end

class Stripe::RecipientTransfer
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::RecipientTransfer
end

class Stripe::Refund
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Refund
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

module Stripe::Reporting
end

class Stripe::Reporting::ReportRun
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Reporting::ReportRun
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
end

class Stripe::Reporting::ReportType
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Reporting::ReportType
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
end

module Stripe::Reporting
  extend ::T::Sig
end

class Stripe::Reversal
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Reversal
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
  def self.retrieve(_id, _opts=T.unsafe(nil)); end

  def self.update(_id, _params=T.unsafe(nil), _opts=T.unsafe(nil)); end
end

class Stripe::SKU
  include ::Stripe::APIOperations::Save
  include ::Stripe::APIOperations::Delete
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::SKU
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
end

module Stripe::Sigma
end

class Stripe::Sigma::ScheduledQueryRun
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Sigma::ScheduledQueryRun
  extend ::Stripe::APIOperations::List
end

module Stripe::Sigma
  extend ::T::Sig
end

class Stripe::SignatureVerificationError
  def initialize(message, sig_header, http_body: T.unsafe(nil)); end

  def sig_header(); end

  def sig_header=(sig_header); end
end

class Stripe::SignatureVerificationError
end

class Stripe::SingletonAPIResource
end

class Stripe::SingletonAPIResource
  def self.retrieve(opts=T.unsafe(nil)); end
end

class Stripe::Source
  include ::Stripe::APIOperations::Save
  def _deprecated_delete(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def delete(*args, &block); end

  def detach(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def source_transactions(params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def verify(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Source
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::SourceTransaction
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::SourceTransaction
end

class Stripe::StripeClient
  def conn(); end

  def conn=(conn); end

  def execute_request(method, path, api_base: T.unsafe(nil), api_key: T.unsafe(nil), headers: T.unsafe(nil), params: T.unsafe(nil)); end

  def initialize(conn=T.unsafe(nil)); end

  def request(); end
end

class Stripe::StripeClient::RequestLogContext
  def account(); end

  def account=(account); end

  def api_key(); end

  def api_key=(api_key); end

  def api_version(); end

  def api_version=(api_version); end

  def body(); end

  def body=(body); end

  def dup_from_response(resp); end

  def idempotency_key(); end

  def idempotency_key=(idempotency_key); end

  def method(); end

  def method=(method); end

  def path(); end

  def path=(path); end

  def query_params(); end

  def query_params=(query_params); end

  def request_id(); end

  def request_id=(request_id); end
end

class Stripe::StripeClient::RequestLogContext
end

class Stripe::StripeClient::SystemProfiler
  def user_agent(); end
end

class Stripe::StripeClient::SystemProfiler
  def self.uname(); end

  def self.uname_from_system(); end

  def self.uname_from_system_ver(); end
end

class Stripe::StripeClient
  def self.active_client(); end

  def self.default_client(); end

  def self.default_conn(); end

  def self.should_retry?(e, num_retries); end

  def self.sleep_time(num_retries); end
end

class Stripe::StripeError
  def code(); end

  def http_body(); end

  def http_headers(); end

  def http_status(); end

  def initialize(message=T.unsafe(nil), http_status: T.unsafe(nil), http_body: T.unsafe(nil), json_body: T.unsafe(nil), http_headers: T.unsafe(nil), code: T.unsafe(nil)); end

  def json_body(); end

  def request_id(); end

  def response(); end

  def response=(response); end
end

class Stripe::StripeError
end

class Stripe::StripeObject
  include ::Enumerable
  def ==(other); end

  def [](k); end

  def []=(k, v); end

  def _deprecated_refresh_from(values, opts, partial=T.unsafe(nil)); end

  def add_accessors(keys, values); end

  def as_json(*a); end

  def deleted?(); end

  def dirty!(); end

  def each(&blk); end

  def eql?(other); end

  def initialize(id=T.unsafe(nil), opts=T.unsafe(nil)); end

  def initialize_from(values, opts, partial=T.unsafe(nil)); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(data); end

  def metaclass(); end

  def method_missing(name, *args); end

  def refresh_from(*args, &block); end

  def remove_accessors(keys); end

  def serialize_params(options=T.unsafe(nil)); end

  def serialize_params_value(value, original, unsaved, force, key: T.unsafe(nil)); end

  def to_hash(); end

  def to_json(*_a); end

  def to_s(*_args); end

  def update_attributes(values, opts=T.unsafe(nil), dirty: T.unsafe(nil)); end

  def values(); end
end

class Stripe::StripeObject
  extend ::Gem::Deprecate
  def self._deprecated_serialize_params(obj, options=T.unsafe(nil)); end

  def self.additive_object_param(name); end

  def self.additive_object_param?(name); end

  def self.construct_from(values, opts=T.unsafe(nil)); end

  def self.protected_fields(); end

  def self.serialize_params(*args, &block); end
end

class Stripe::StripeResponse
  def data(); end

  def data=(data); end

  def http_body(); end

  def http_body=(http_body); end

  def http_headers(); end

  def http_headers=(http_headers); end

  def http_status(); end

  def http_status=(http_status); end

  def request_id(); end

  def request_id=(request_id); end
end

class Stripe::StripeResponse
  def self.from_faraday_hash(http_resp); end

  def self.from_faraday_response(http_resp); end
end

class Stripe::Subscription
  include ::Stripe::APIOperations::Save
  include ::Stripe::APIOperations::Delete
  def delete_discount(); end

  def source=(value); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Subscription
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::SubscriptionItem
  include ::Stripe::APIOperations::Delete
  include ::Stripe::APIOperations::Save
  def usage_record_summaries(params=T.unsafe(nil), opts=T.unsafe(nil)); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::SubscriptionItem
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

module Stripe::Terminal
end

class Stripe::Terminal::ConnectionToken
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Terminal::ConnectionToken
  extend ::Stripe::APIOperations::Create
end

class Stripe::Terminal::Location
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Terminal::Location
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::Terminal::Reader
  include ::Stripe::APIOperations::Save
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Terminal::Reader
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Save::ClassMethods
end

module Stripe::Terminal
  extend ::T::Sig
end

class Stripe::ThreeDSecure
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::ThreeDSecure
  extend ::Stripe::APIOperations::Create
end

class Stripe::Token
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Token
  extend ::Stripe::APIOperations::Create
end

class Stripe::Topup
  include ::Stripe::APIOperations::Save
  def cancel(); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Topup
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
end

class Stripe::Transfer
  include ::Stripe::APIOperations::Save
  def cancel(); end

  def cancel_url(); end
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::Transfer
  extend ::Stripe::APIOperations::List
  extend ::Stripe::APIOperations::Create
  extend ::Stripe::APIOperations::Save::ClassMethods
  extend ::Stripe::APIOperations::NestedResource
  def self.create_reversal(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.list_reversals(id, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def self.retrieve_reversal(id, nested_id, opts=T.unsafe(nil)); end

  def self.reversals_url(id, nested_id=T.unsafe(nil)); end

  def self.update_reversal(id, nested_id, params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class Stripe::UsageRecord
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::UsageRecord
  def self.create(params=T.unsafe(nil), opts=T.unsafe(nil)); end
end

class Stripe::UsageRecordSummary
  OBJECT_NAME = ::T.let(nil, ::T.untyped)
end

class Stripe::UsageRecordSummary
end

module Stripe::Util
  OPTS_COPYABLE = ::T.let(nil, ::T.untyped)
  OPTS_PERSISTABLE = ::T.let(nil, ::T.untyped)
  OPTS_USER_SPECIFIED = ::T.let(nil, ::T.untyped)
end

module Stripe::Util
  extend ::T::Sig
  def self.check_api_key!(key); end

  def self.check_string_argument!(key); end

  def self.convert_to_stripe_object(data, opts=T.unsafe(nil)); end

  def self.encode_parameters(params); end

  def self.flatten_params(params, parent_key=T.unsafe(nil)); end

  def self.flatten_params_array(value, calculated_key); end

  def self.log_debug(message, data=T.unsafe(nil)); end

  def self.log_error(message, data=T.unsafe(nil)); end

  def self.log_info(message, data=T.unsafe(nil)); end

  def self.normalize_headers(headers); end

  def self.normalize_id(id); end

  def self.normalize_opts(opts); end

  def self.object_classes(); end

  def self.objects_to_ids(h); end

  def self.request_id_dashboard_url(request_id, api_key); end

  def self.secure_compare(a, b); end

  def self.symbolize_names(object); end

  def self.url_encode(key); end
end

module Stripe::Webhook
  DEFAULT_TOLERANCE = ::T.let(nil, ::T.untyped)
end

module Stripe::Webhook::Signature
  EXPECTED_SCHEME = ::T.let(nil, ::T.untyped)
end

module Stripe::Webhook::Signature
  extend ::T::Sig
  def self.verify_header(payload, header, secret, tolerance: T.unsafe(nil)); end
end

module Stripe::Webhook
  extend ::T::Sig
  def self.construct_event(payload, sig_header, secret, tolerance: T.unsafe(nil)); end
end

module Stripe
  extend ::T::Sig
  def self.api_base(); end

  def self.api_base=(api_base); end

  def self.api_key(); end

  def self.api_key=(api_key); end

  def self.api_version(); end

  def self.api_version=(api_version); end

  def self.app_info(); end

  def self.app_info=(info); end

  def self.ca_bundle_path(); end

  def self.ca_bundle_path=(path); end

  def self.ca_store(); end

  def self.client_id(); end

  def self.client_id=(client_id); end

  def self.connect_base(); end

  def self.connect_base=(connect_base); end

  def self.initial_network_retry_delay(); end

  def self.log_level(); end

  def self.log_level=(val); end

  def self.logger(); end

  def self.logger=(val); end

  def self.max_network_retries(); end

  def self.max_network_retries=(val); end

  def self.max_network_retry_delay(); end

  def self.open_timeout(); end

  def self.open_timeout=(open_timeout); end

  def self.read_timeout(); end

  def self.read_timeout=(read_timeout); end

  def self.set_app_info(name, partner_id: T.unsafe(nil), url: T.unsafe(nil), version: T.unsafe(nil)); end

  def self.stripe_account(); end

  def self.stripe_account=(stripe_account); end

  def self.uploads_base(); end

  def self.uploads_base=(uploads_base); end

  def self.uri_encode(*args, &block); end

  def self.verify_ssl_certs(); end

  def self.verify_ssl_certs=(verify_ssl_certs); end
end

module StripeMock
  VERSION = ::T.let(nil, ::T.untyped)
end

module StripeMock::CardErrors
end

module StripeMock::CardErrors
  extend ::T::Sig
  def self.add_json_body(error_values); end

  def self.argument_map(); end

  def self.get_decline_code(code); end
end

class StripeMock::Client
  def cleanup(); end

  def clear_server_data(); end

  def close!(); end

  def destroy_resource(type, id); end

  def error_queue(); end

  def generate_bank_token(recipient_params); end

  def generate_card_token(card_params); end

  def generate_webhook_event(event_data); end

  def get_conversion_rate(); end

  def get_server_data(key); end

  def initialize(port); end

  def mock_request(method, url, api_key: T.unsafe(nil), params: T.unsafe(nil), headers: T.unsafe(nil)); end

  def port(); end

  def server_debug?(); end

  def server_global_id_prefix(); end

  def set_account_balance(value); end

  def set_conversion_rate(value); end

  def set_server_debug(toggle); end

  def set_server_global_id_prefix(value); end

  def state(); end

  def timeout_wrap(tries=T.unsafe(nil)); end

  def upsert_stripe_object(object, attributes); end
end

class StripeMock::Client
end

class StripeMock::ClosedClientConnectionError
  def initialize(); end
end

class StripeMock::ClosedClientConnectionError
end

module StripeMock::Data
end

class StripeMock::Data::List
  def data(); end

  def has_more?(); end

  def initialize(data, options=T.unsafe(nil)); end

  def limit(); end

  def method_missing(method_name, *args, &block); end

  def respond_to?(method_name, priv=T.unsafe(nil)); end

  def starting_after(); end

  def to_h(); end

  def to_hash(); end

  def url(); end
end

class StripeMock::Data::List
end

module StripeMock::Data
  extend ::T::Sig
  def self.mock_account(params=T.unsafe(nil)); end

  def self.mock_api_error(); end

  def self.mock_balance(usd_balance=T.unsafe(nil)); end

  def self.mock_balance_transaction(params=T.unsafe(nil)); end

  def self.mock_balance_transactions(ids=T.unsafe(nil)); end

  def self.mock_bank_account(params=T.unsafe(nil)); end

  def self.mock_bank_account_token(params=T.unsafe(nil)); end

  def self.mock_card(params=T.unsafe(nil)); end

  def self.mock_card_token(params=T.unsafe(nil)); end

  def self.mock_charge(params=T.unsafe(nil)); end

  def self.mock_charge_array(); end

  def self.mock_country_spec(country_code); end

  def self.mock_coupon(params=T.unsafe(nil)); end

  def self.mock_customer(sources, params); end

  def self.mock_delete_discount_response(); end

  def self.mock_delete_subscription(params=T.unsafe(nil)); end

  def self.mock_dispute(params=T.unsafe(nil)); end

  def self.mock_dispute_evidence(); end

  def self.mock_dispute_evidence_details(); end

  def self.mock_disputes(ids=T.unsafe(nil)); end

  def self.mock_ephemeral_key(**params); end

  def self.mock_invalid_api_key_error(); end

  def self.mock_invalid_exp_year_error(); end

  def self.mock_invoice(lines, params=T.unsafe(nil)); end

  def self.mock_invoice_customer_array(); end

  def self.mock_invoice_item(params=T.unsafe(nil)); end

  def self.mock_line_item(params=T.unsafe(nil)); end

  def self.mock_list_object(data, params=T.unsafe(nil)); end

  def self.mock_missing_id_error(); end

  def self.mock_order(order_items, params); end

  def self.mock_order_item(params=T.unsafe(nil)); end

  def self.mock_paid_invoice(); end

  def self.mock_payout(params=T.unsafe(nil)); end

  def self.mock_plan(params=T.unsafe(nil)); end

  def self.mock_recipient(cards, params=T.unsafe(nil)); end

  def self.mock_recipient_array(); end

  def self.mock_refund(params=T.unsafe(nil)); end

  def self.mock_subscription(params=T.unsafe(nil)); end

  def self.mock_subscription_item(params=T.unsafe(nil)); end

  def self.mock_transfer(params=T.unsafe(nil)); end

  def self.mock_transfer_array(); end
end

class StripeMock::ErrorQueue
  include ::DRb::DRbUndumped
  def dequeue(); end

  def error_for_handler_name(handler_name); end

  def queue(error, handler_names); end
end

class StripeMock::ErrorQueue
  extend ::DRb::DRbUndumped
end

class StripeMock::Instance
  include ::StripeMock::RequestHandlers::Helpers
  include ::StripeMock::RequestHandlers::ParamValidators
  include ::StripeMock::RequestHandlers::ExternalAccounts
  include ::StripeMock::RequestHandlers::Accounts
  include ::StripeMock::RequestHandlers::Balance
  include ::StripeMock::RequestHandlers::BalanceTransactions
  include ::StripeMock::RequestHandlers::Charges
  include ::StripeMock::RequestHandlers::Cards
  include ::StripeMock::RequestHandlers::Sources
  include ::StripeMock::RequestHandlers::Subscriptions
  include ::StripeMock::RequestHandlers::Customers
  include ::StripeMock::RequestHandlers::Coupons
  include ::StripeMock::RequestHandlers::Disputes
  include ::StripeMock::RequestHandlers::Events
  include ::StripeMock::RequestHandlers::Invoices
  include ::StripeMock::RequestHandlers::InvoiceItems
  include ::StripeMock::RequestHandlers::Orders
  include ::StripeMock::RequestHandlers::Plans
  include ::StripeMock::RequestHandlers::Refunds
  include ::StripeMock::RequestHandlers::Recipients
  include ::StripeMock::RequestHandlers::Transfers
  include ::StripeMock::RequestHandlers::Tokens
  include ::StripeMock::RequestHandlers::CountrySpec
  include ::StripeMock::RequestHandlers::Payouts
  include ::StripeMock::RequestHandlers::EphemeralKey
  def account_balance(); end

  def account_balance=(account_balance); end

  def accounts(); end

  def balance(); end

  def balance_transactions(); end

  def bank_tokens(); end

  def charges(); end

  def conversion_rate(); end

  def conversion_rate=(conversion_rate); end

  def country_spec(); end

  def coupons(); end

  def customers(); end

  def debug(); end

  def debug=(debug); end

  def disputes(); end

  def error_queue(); end

  def error_queue=(error_queue); end

  def events(); end

  def generate_webhook_event(event_data); end

  def invoice_items(); end

  def invoices(); end

  def mock_request(method, url, api_key: T.unsafe(nil), api_base: T.unsafe(nil), params: T.unsafe(nil), headers: T.unsafe(nil)); end

  def orders(); end

  def payouts(); end

  def plans(); end

  def recipients(); end

  def refunds(); end

  def subscriptions(); end

  def subscriptions_items(); end

  def transfers(); end

  def upsert_stripe_object(object, attributes); end
  DUMMY_API_KEY = ::T.let(nil, ::T.untyped)
end

class StripeMock::Instance
  def self.add_handler(route, name); end

  def self.handler_for_method_url(method_url); end
end

module StripeMock::RequestHandlers
end

module StripeMock::RequestHandlers::Accounts
  def deauthorize(route, method_url, params, headers); end

  def get_account(route, method_url, params, headers); end

  def list_accounts(route, method_url, params, headers); end

  def new_account(route, method_url, params, headers); end

  def update_account(route, method_url, params, headers); end
  VALID_START_YEAR = ::T.let(nil, ::T.untyped)
end

module StripeMock::RequestHandlers::Accounts
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Balance
  def get_balance(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Balance
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::BalanceTransactions
  def get_balance_transaction(route, method_url, params, headers); end

  def list_balance_transactions(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::BalanceTransactions
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Cards
  def create_recipient_card(route, method_url, params, headers); end

  def delete_recipient_card(route, method_url, params, headers); end

  def retrieve_recipient_card(route, method_url, params, headers); end

  def retrieve_recipient_cards(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Cards
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Charges
  def capture_charge(route, method_url, params, headers); end

  def get_charge(route, method_url, params, headers); end

  def get_charges(route, method_url, params, headers); end

  def new_charge(route, method_url, params, headers); end

  def refund_charge(route, method_url, params, headers); end

  def update_charge(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Charges
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::CountrySpec
  def retrieve_country_spec(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::CountrySpec
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Coupons
  def delete_coupon(route, method_url, params, headers); end

  def get_coupon(route, method_url, params, headers); end

  def list_coupons(route, method_url, params, headers); end

  def new_coupon(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Coupons
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Customers
  def delete_customer(route, method_url, params, headers); end

  def delete_customer_discount(route, method_url, params, headers); end

  def get_customer(route, method_url, params, headers); end

  def list_customers(route, method_url, params, headers); end

  def new_customer(route, method_url, params, headers); end

  def update_customer(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Customers
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Disputes
  def close_dispute(route, method_url, params, headers); end

  def get_dispute(route, method_url, params, headers); end

  def list_disputes(route, method_url, params, headers); end

  def update_dispute(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Disputes
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::EphemeralKey
  def create_ephemeral_key(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::EphemeralKey
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Events
  def list_events(route, method_url, params, headers); end

  def retrieve_event(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Events
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::ExternalAccounts
  def create_external_account(route, method_url, params, headers); end

  def delete_external_account(route, method_url, params, headers); end

  def retrieve_external_account(route, method_url, params, headers); end

  def retrieve_external_accounts(route, method_url, params, headers); end

  def update_external_account(route, method_url, params, headers); end

  def verify_external_account(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::ExternalAccounts
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Helpers
  def add_card_to(type, type_id, params, objects); end

  def add_card_to_object(type, card, object, replace_current=T.unsafe(nil)); end

  def add_coupon_to_customer(customer, coupon); end

  def add_external_account_to(type, type_id, params, objects); end

  def add_external_account_to_object(type, source, object, replace_current=T.unsafe(nil)); end

  def add_refund_to_charge(refund, charge); end

  def add_source_to(type, type_id, params, objects); end

  def add_source_to_object(type, source, object, replace_current=T.unsafe(nil)); end

  def add_subscription_to_customer(cus, sub); end

  def bank_from_params(attrs_or_token); end

  def card_from_params(attrs_or_token); end

  def custom_subscription_params(plans, cus, options=T.unsafe(nil)); end

  def delete_card_from(type, type_id, card_id, objects); end

  def delete_subscription_from_customer(cus, subscription); end

  def generate_bank_token(bank_params=T.unsafe(nil)); end

  def generate_card_token(card_params=T.unsafe(nil)); end

  def get_bank_by_token(token); end

  def get_card(object, card_id, class_name=T.unsafe(nil)); end

  def get_card_by_token(token); end

  def get_card_or_bank_by_token(token); end

  def get_customer_subscription(customer, sub_id); end

  def get_ending_time(start_time, plan, intervals=T.unsafe(nil)); end

  def resolve_subscription_changes(subscription, plans, customer, options=T.unsafe(nil)); end

  def retrieve_object_cards(type, type_id, objects); end

  def total_items_amount(items); end

  def validate_card(card); end

  def verify_bank_account(object, bank_account_id, class_name=T.unsafe(nil)); end

  def verify_trial_end(trial_end); end
end

module StripeMock::RequestHandlers::Helpers
  extend ::T::Sig
end

module StripeMock::RequestHandlers::InvoiceItems
  def delete_invoice_item(route, method_url, params, headers); end

  def get_invoice_item(route, method_url, params, headers); end

  def list_invoice_items(route, method_url, params, headers); end

  def new_invoice_item(route, method_url, params, headers); end

  def update_invoice_item(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::InvoiceItems
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Invoices
  def get_invoice(route, method_url, params, headers); end

  def get_invoice_line_items(route, method_url, params, headers); end

  def list_invoices(route, method_url, params, headers); end

  def new_invoice(route, method_url, params, headers); end

  def pay_invoice(route, method_url, params, headers); end

  def upcoming_invoice(route, method_url, params, headers); end

  def update_invoice(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Invoices
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Orders
  def get_order(route, method_url, params, headers); end

  def list_orders(route, method_url, params, headers); end

  def new_order(route, method_url, params, headers); end

  def pay_order(route, method_url, params, headers); end

  def update_order(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Orders
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::ParamValidators
  def validate_create_plan_params(params); end
end

module StripeMock::RequestHandlers::ParamValidators
  extend ::T::Sig
end

module StripeMock::RequestHandlers::Payouts
  def get_payout(route, method_url, params, headers); end

  def list_payouts(route, method_url, params, headers); end

  def new_payout(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Payouts
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Plans
  def delete_plan(route, method_url, params, headers); end

  def get_plan(route, method_url, params, headers); end

  def list_plans(route, method_url, params, headers); end

  def new_plan(route, method_url, params, headers); end

  def update_plan(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Plans
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Recipients
  def get_recipient(route, method_url, params, headers); end

  def new_recipient(route, method_url, params, headers); end

  def update_recipient(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Recipients
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Refunds
  def get_refund(route, method_url, params, headers); end

  def get_refunds(route, method_url, params, headers); end

  def new_refund(route, method_url, params, headers); end

  def update_refund(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Refunds
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Sources
  def create_source(route, method_url, params, headers); end

  def delete_source(route, method_url, params, headers); end

  def retrieve_source(route, method_url, params, headers); end

  def retrieve_sources(route, method_url, params, headers); end

  def update_source(route, method_url, params, headers); end

  def verify_source(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Sources
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Subscriptions
  def cancel_subscription(route, method_url, params, headers); end

  def create_customer_subscription(route, method_url, params, headers); end

  def create_subscription(route, method_url, params, headers); end

  def retrieve_customer_subscription(route, method_url, params, headers); end

  def retrieve_customer_subscriptions(route, method_url, params, headers); end

  def retrieve_subscription(route, method_url, params, headers); end

  def retrieve_subscriptions(route, method_url, params, headers); end

  def update_subscription(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Subscriptions
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Tokens
  def create_token(route, method_url, params, headers); end

  def get_token(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Tokens
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers::Transfers
  def cancel_transfer(route, method_url, params, headers); end

  def get_all_transfers(route, method_url, params, headers); end

  def get_transfer(route, method_url, params, headers); end

  def new_transfer(route, method_url, params, headers); end
end

module StripeMock::RequestHandlers::Transfers
  extend ::T::Sig
  def self.included(klass); end
end

module StripeMock::RequestHandlers
  extend ::T::Sig
end

class StripeMock::Server
  def clear_data(); end

  def debug?(); end

  def destroy_resource(type, id); end

  def error_queue(); end

  def generate_bank_token(recipient_params); end

  def generate_card_token(card_params); end

  def generate_webhook_event(event_data); end

  def get_data(key); end

  def global_id_prefix(); end

  def mock_request(*args); end

  def ping(); end

  def set_account_balance(value); end

  def set_conversion_rate(value); end

  def set_debug(toggle); end

  def set_global_id_prefix(value); end

  def upsert_stripe_object(object, attributes); end
end

class StripeMock::Server
  def self.start_new(opts); end
end

class StripeMock::ServerTimeoutError
  def associated_error(); end

  def initialize(associated_error); end
end

class StripeMock::ServerTimeoutError
end

class StripeMock::StripeMockError
  def initialize(message); end
end

class StripeMock::StripeMockError
end

module StripeMock::TestStrategies
end

class StripeMock::TestStrategies::Base
  def create_coupon(params=T.unsafe(nil)); end

  def create_coupon_params(params=T.unsafe(nil)); end

  def create_coupon_percent_of_params(params=T.unsafe(nil)); end

  def create_plan_params(params=T.unsafe(nil)); end

  def delete_all_coupons(); end

  def generate_bank_token(bank_account_params=T.unsafe(nil)); end

  def generate_card_token(card_params=T.unsafe(nil)); end

  def prepare_card_error(); end
end

class StripeMock::TestStrategies::Base
end

class StripeMock::TestStrategies::Live
  def create_plan(params=T.unsafe(nil)); end

  def delete_coupon(id); end

  def delete_plan(plan_id); end

  def upsert_stripe_object(object, attributes); end
end

class StripeMock::TestStrategies::Live
end

class StripeMock::TestStrategies::Mock
  def create_plan(params=T.unsafe(nil)); end

  def delete_plan(plan_id); end

  def upsert_stripe_object(object, attributes=T.unsafe(nil)); end
end

class StripeMock::TestStrategies::Mock
end

module StripeMock::TestStrategies
  extend ::T::Sig
end

class StripeMock::UninitializedInstanceError
  def initialize(); end
end

class StripeMock::UninitializedInstanceError
end

class StripeMock::UnstartedStateError
  def initialize(); end
end

class StripeMock::UnstartedStateError
end

class StripeMock::UnsupportedRequestError
end

class StripeMock::UnsupportedRequestError
end

module StripeMock::Util
end

module StripeMock::Util
  extend ::T::Sig
  def self.card_merge(old_param, new_param); end

  def self.fingerprint(source); end

  def self.rmerge(desh_hash, source_hash); end
end

module StripeMock::Webhooks
end

module StripeMock::Webhooks
  extend ::T::Sig
  def self.event_list(); end
end

module StripeMock
  extend ::T::Sig
  def self.client(); end

  def self.create_test_helper(strategy=T.unsafe(nil)); end

  def self.default_currency(); end

  def self.default_currency=(default_currency); end

  def self.default_server_log_path(); end

  def self.default_server_log_path=(default_server_log_path); end

  def self.default_server_pid_path(); end

  def self.default_server_pid_path=(default_server_pid_path); end

  def self.generate_bank_token(bank_params=T.unsafe(nil)); end

  def self.generate_card_token(card_params=T.unsafe(nil)); end

  def self.get_test_helper_strategy(strategy); end

  def self.global_id_prefix(); end

  def self.global_id_prefix=(value); end

  def self.instance(); end

  def self.kill_server(pid_path=T.unsafe(nil)); end

  def self.mock(&block); end

  def self.mock_webhook_event(type, params=T.unsafe(nil)); end

  def self.mock_webhook_payload(type, params=T.unsafe(nil)); end

  def self.prepare_card_error(code, *handler_names); end

  def self.prepare_error(stripe_error, *handler_names); end

  def self.redirect_to_mock_server(method, url, api_key: T.unsafe(nil), api_base: T.unsafe(nil), params: T.unsafe(nil), headers: T.unsafe(nil)); end

  def self.restore_stripe_execute_request_method(); end

  def self.set_account_balance(value); end

  def self.set_conversion_rate(value); end

  def self.set_default_test_helper_strategy(strategy); end

  def self.spawn_server(opts=T.unsafe(nil)); end

  def self.start(); end

  def self.start_client(port=T.unsafe(nil)); end

  def self.state(); end

  def self.stop(); end

  def self.stop_client(opts=T.unsafe(nil)); end

  def self.toggle_debug(toggle); end

  def self.toggle_live(toggle); end

  def self.webhook_fixture_path(); end

  def self.webhook_fixture_path=(webhook_fixture_path); end
end

class Struct
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def [](_); end

  def []=(_, _1); end

  def dig(*_); end

  def each_pair(); end

  def length(); end

  def members(); end

  def select(*_); end

  def size(); end

  def to_a(); end

  def to_h(); end

  def values(); end

  def values_at(*_); end
end

Struct::Group = Etc::Group

class Struct::HTMLElementDescription
  def attrs_depr(); end

  def attrs_depr=(_); end

  def attrs_opt(); end

  def attrs_opt=(_); end

  def attrs_req(); end

  def attrs_req=(_); end

  def defaultsubelt(); end

  def defaultsubelt=(_); end

  def depr(); end

  def depr=(_); end

  def desc(); end

  def desc=(_); end

  def dtd(); end

  def dtd=(_); end

  def empty(); end

  def empty=(_); end

  def endTag(); end

  def endTag=(_); end

  def isinline(); end

  def isinline=(_); end

  def name(); end

  def name=(_); end

  def saveEndTag(); end

  def saveEndTag=(_); end

  def startTag(); end

  def startTag=(_); end

  def subelts(); end

  def subelts=(_); end
end

class Struct::HTMLElementDescription
  def self.[](*_); end

  def self.members(); end
end

Struct::Passwd = Etc::Passwd

Struct::Tms = Process::Tms

class Struct
  extend ::T::Sig
end

class StubSocket
  def close(); end

  def closed?(); end

  def continue_timeout(); end

  def continue_timeout=(continue_timeout); end

  def initialize(*args); end

  def read_timeout(); end

  def read_timeout=(read_timeout); end

  def readuntil(*args); end
end

class StubSocket
end

class Symbol
  include ::MessagePack::CoreExt
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def casecmp?(_); end

  def match?(*_); end

  def next(); end

  def to_msgpack_ext(); end

end

class Symbol
  extend ::T::Sig
  def self.from_msgpack_ext(data); end
end

class SynchronizedDelegator
  def method_missing(method, *args, &block); end

  def setup(); end

  def teardown(); end
end

class SynchronizedDelegator
end

class SyntaxError
  extend ::T::Sig
end

class SystemCallError
  def errno(); end
end

class SystemCallError
  extend ::T::Sig
end

class SystemExit
  def status(); end

  def success?(); end
end

class SystemExit
  extend ::T::Sig
end

class SystemStackError
  extend ::T::Sig
end

class TCPServer
  extend ::T::Sig
end

class TCPSocket
  extend ::T::Sig
end

class TSort::Cyclic
  extend ::T::Sig
end

module TSort
  extend ::T::Sig
end

module TZInfo
end

class TZInfo::AmbiguousTime
end

class TZInfo::AmbiguousTime
end

class TZInfo::Country
  include ::Comparable
  def _dump(limit); end

  def code(); end

  def eql?(c); end

  def name(); end

  def zone_identifiers(); end

  def zone_info(); end

  def zone_names(); end

  def zones(); end
end

class TZInfo::Country
  def self._load(data); end

  def self.all(); end

  def self.all_codes(); end

  def self.data_source(); end

  def self.get(identifier); end

  def self.init_countries(); end

  def self.new(identifier); end
end

module TZInfo::CountryIndexDefinition
end

module TZInfo::CountryIndexDefinition::ClassMethods
  def countries(); end

  def country(code, name, &block); end
end

module TZInfo::CountryIndexDefinition::ClassMethods
  extend ::T::Sig
end

module TZInfo::CountryIndexDefinition
  extend ::T::Sig
  def self.append_features(base); end
end

class TZInfo::CountryInfo
  def code(); end

  def initialize(code, name); end

  def name(); end

  def zone_identifiers(); end

  def zones(); end
end

class TZInfo::CountryInfo
end

class TZInfo::CountryTimezone
  def ==(ct); end

  def description(); end

  def description_or_friendly_identifier(); end

  def eql?(ct); end

  def identifier(); end

  def initialize(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end

  def latitude(); end

  def longitude(); end

  def timezone(); end
end

class TZInfo::CountryTimezone
  def self.new(identifier, latitude, longitude, description=T.unsafe(nil)); end

  def self.new!(*_); end
end

class TZInfo::DataSource
  def country_codes(); end

  def data_timezone_identifiers(); end

  def linked_timezone_identifiers(); end

  def load_country_info(code); end

  def load_timezone_info(identifier); end

  def timezone_identifiers(); end
end

class TZInfo::DataSource
  def self.create_default_data_source(); end

  def self.get(); end

  def self.set(data_source_or_type, *args); end
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataSourceNotFound
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezone
end

class TZInfo::DataTimezoneInfo
  def period_for_utc(utc); end

  def periods_for_local(local); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end
end

class TZInfo::DataTimezoneInfo
end

class TZInfo::InfoTimezone
  def info(); end

  def setup(info); end
end

class TZInfo::InfoTimezone
  def self.new(info); end
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidCountryCode
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidDataSource
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidTimezoneIdentifier
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoDirectory
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::InvalidZoneinfoFile
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezone
end

class TZInfo::LinkedTimezoneInfo
  def initialize(identifier, link_to_identifier); end

  def link_to_identifier(); end
end

class TZInfo::LinkedTimezoneInfo
end

class TZInfo::NoOffsetsDefined
end

class TZInfo::NoOffsetsDefined
end

module TZInfo::OffsetRationals
end

module TZInfo::OffsetRationals
  extend ::T::Sig
  def self.rational_for_offset(offset); end
end

class TZInfo::PeriodNotFound
end

class TZInfo::PeriodNotFound
end

module TZInfo::RubyCoreSupport
  HALF_DAYS_IN_DAY = ::T.let(nil, ::T.untyped)
end

module TZInfo::RubyCoreSupport
  extend ::T::Sig
  def self.datetime_new(y=T.unsafe(nil), m=T.unsafe(nil), d=T.unsafe(nil), h=T.unsafe(nil), min=T.unsafe(nil), s=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.datetime_new!(ajd=T.unsafe(nil), of=T.unsafe(nil), sg=T.unsafe(nil)); end

  def self.force_encoding(str, encoding); end

  def self.open_file(file_name, mode, opts, &block); end

  def self.rational_new!(numerator, denominator=T.unsafe(nil)); end

  def self.time_nsec(time); end

  def self.time_supports_64bit(); end

  def self.time_supports_negative(); end
end

class TZInfo::RubyCountryInfo
  def initialize(code, name, &block); end
end

class TZInfo::RubyCountryInfo::Zones
  def list(); end

  def timezone(identifier, latitude_numerator, latitude_denominator, longitude_numerator, longitude_denominator, description=T.unsafe(nil)); end
end

class TZInfo::RubyCountryInfo::Zones
end

class TZInfo::RubyCountryInfo
end

class TZInfo::RubyDataSource
  REQUIRE_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::RubyDataSource
  def self.load_country_index(); end

  def self.load_timezone_index(); end

  def self.require_data(*file); end

  def self.require_index(name); end
end

class TZInfo::TimeOrDateTime
  include ::Comparable
  def +(seconds); end

  def -(seconds); end

  def add_with_convert(seconds); end

  def day(); end

  def eql?(todt); end

  def hour(); end

  def initialize(timeOrDateTime); end

  def mday(); end

  def min(); end

  def mon(); end

  def month(); end

  def sec(); end

  def to_datetime(); end

  def to_i(); end

  def to_orig(); end

  def to_time(); end

  def usec(); end

  def year(); end
end

class TZInfo::TimeOrDateTime
  def self.wrap(timeOrDateTime); end
end

class TZInfo::Timezone
  include ::Comparable
  def _dump(limit); end

  def canonical_identifier(); end

  def canonical_zone(); end

  def current_period(); end

  def current_period_and_time(); end

  def current_time_and_period(); end

  def eql?(tz); end

  def friendly_identifier(skip_first_part=T.unsafe(nil)); end

  def identifier(); end

  def local_to_utc(local, dst=T.unsafe(nil)); end

  def name(); end

  def now(); end

  def offsets_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def period_for_local(local, dst=T.unsafe(nil)); end

  def period_for_utc(utc); end

  def periods_for_local(local); end

  def strftime(format, utc=T.unsafe(nil)); end

  def transitions_up_to(utc_to, utc_from=T.unsafe(nil)); end

  def utc_to_local(utc); end
end

class TZInfo::Timezone
  def self._load(data); end

  def self.all(); end

  def self.all_country_zone_identifiers(); end

  def self.all_country_zones(); end

  def self.all_data_zone_identifiers(); end

  def self.all_data_zones(); end

  def self.all_identifiers(); end

  def self.all_linked_zone_identifiers(); end

  def self.all_linked_zones(); end

  def self.data_source(); end

  def self.default_dst(); end

  def self.default_dst=(value); end

  def self.get(identifier); end

  def self.get_proxies(identifiers); end

  def self.get_proxy(identifier); end

  def self.init_loaded_zones(); end

  def self.new(identifier=T.unsafe(nil)); end

  def self.us_zone_identifiers(); end

  def self.us_zones(); end
end

module TZInfo::TimezoneDefinition
end

module TZInfo::TimezoneDefinition::ClassMethods
  def get(); end

  def linked_timezone(identifier, link_to_identifier); end

  def timezone(identifier); end
end

module TZInfo::TimezoneDefinition::ClassMethods
  extend ::T::Sig
end

module TZInfo::TimezoneDefinition
  extend ::T::Sig
  def self.append_features(base); end
end

module TZInfo::TimezoneIndexDefinition
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
  def data_timezones(); end

  def linked_timezone(identifier); end

  def linked_timezones(); end

  def timezone(identifier); end

  def timezones(); end
end

module TZInfo::TimezoneIndexDefinition::ClassMethods
  extend ::T::Sig
end

module TZInfo::TimezoneIndexDefinition
  extend ::T::Sig
  def self.append_features(base); end
end

class TZInfo::TimezoneInfo
  def create_timezone(); end

  def identifier(); end

  def initialize(identifier); end
end

class TZInfo::TimezoneInfo
end

class TZInfo::TimezoneOffset
  def ==(toi); end

  def abbreviation(); end

  def dst?(); end

  def eql?(toi); end

  def initialize(utc_offset, std_offset, abbreviation); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_offset(); end

  def utc_total_offset(); end
end

class TZInfo::TimezoneOffset
end

class TZInfo::TimezonePeriod
  def ==(p); end

  def abbreviation(); end

  def dst?(); end

  def end_transition(); end

  def eql?(p); end

  def initialize(start_transition, end_transition, offset=T.unsafe(nil)); end

  def local_after_start?(local); end

  def local_before_end?(local); end

  def local_end(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_time(); end

  def offset(); end

  def start_transition(); end

  def std_offset(); end

  def to_local(utc); end

  def to_utc(local); end

  def utc_after_start?(utc); end

  def utc_before_end?(utc); end

  def utc_end(); end

  def utc_end_time(); end

  def utc_offset(); end

  def utc_start(); end

  def utc_start_time(); end

  def utc_total_offset(); end

  def utc_total_offset_rational(); end

  def valid_for_local?(local); end

  def valid_for_utc?(utc); end

  def zone_identifier(); end
end

class TZInfo::TimezonePeriod
end

class TZInfo::TimezoneProxy
  def transitions_up_to(to, from=T.unsafe(nil)); end
end

class TZInfo::TimezoneProxy
  def self.new(identifier); end
end

class TZInfo::TimezoneTransition
  def ==(tti); end

  def at(); end

  def datetime(); end

  def eql?(tti); end

  def initialize(offset, previous_offset); end

  def local_end(); end

  def local_end_at(); end

  def local_end_time(); end

  def local_start(); end

  def local_start_at(); end

  def local_start_time(); end

  def offset(); end

  def previous_offset(); end

  def time(); end
end

class TZInfo::TimezoneTransition
end

class TZInfo::TimezoneTransitionDefinition
  def denominator(); end

  def initialize(offset, previous_offset, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end

  def numerator_or_time(); end
end

class TZInfo::TimezoneTransitionDefinition
end

class TZInfo::TransitionDataTimezoneInfo
  def offset(id, utc_offset, std_offset, abbreviation); end

  def transition(year, month, offset_id, numerator_or_timestamp, denominator_or_numerator=T.unsafe(nil), denominator=T.unsafe(nil)); end
end

class TZInfo::TransitionDataTimezoneInfo
end

class TZInfo::UnknownTimezone
end

class TZInfo::UnknownTimezone
end

class TZInfo::ZoneinfoCountryInfo
  def initialize(code, name, zones); end
end

class TZInfo::ZoneinfoCountryInfo
end

class TZInfo::ZoneinfoDataSource
  def initialize(zoneinfo_dir=T.unsafe(nil), alternate_iso3166_tab_path=T.unsafe(nil)); end

  def zoneinfo_dir(); end
  DEFAULT_ALTERNATE_ISO3166_TAB_SEARCH_PATH = ::T.let(nil, ::T.untyped)
  DEFAULT_SEARCH_PATH = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoDataSource
  def self.alternate_iso3166_tab_search_path(); end

  def self.alternate_iso3166_tab_search_path=(alternate_iso3166_tab_search_path); end

  def self.process_search_path(path, default); end

  def self.search_path(); end

  def self.search_path=(search_path); end
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoDirectoryNotFound
end

class TZInfo::ZoneinfoTimezoneInfo
  def initialize(identifier, file_path); end
  MAX_TIMESTAMP = ::T.let(nil, ::T.untyped)
  MIN_TIMESTAMP = ::T.let(nil, ::T.untyped)
end

class TZInfo::ZoneinfoTimezoneInfo
end

module TZInfo
  extend ::T::Sig
end

module Tax
  extend ::T::Sig
end

module Taxjar
end

module Taxjar::API
  include ::Taxjar::API::Utils
  def categories(options=T.unsafe(nil)); end

  def nexus_regions(options=T.unsafe(nil)); end

  def rates_for_location(postal_code, options=T.unsafe(nil)); end

  def summary_rates(options=T.unsafe(nil)); end

  def tax_for_order(options=T.unsafe(nil)); end

  def validate(options=T.unsafe(nil)); end
end

module Taxjar::API::Customer
  include ::Taxjar::API::Utils
  def create_customer(options=T.unsafe(nil)); end

  def delete_customer(id, options=T.unsafe(nil)); end

  def list_customers(options=T.unsafe(nil)); end

  def show_customer(id, options=T.unsafe(nil)); end

  def update_customer(options=T.unsafe(nil)); end
end

module Taxjar::API::Customer
  extend ::T::Sig
end

module Taxjar::API::Order
  include ::Taxjar::API::Utils
  def create_order(options=T.unsafe(nil)); end

  def delete_order(id, options=T.unsafe(nil)); end

  def list_orders(options=T.unsafe(nil)); end

  def show_order(id, options=T.unsafe(nil)); end

  def update_order(options=T.unsafe(nil)); end
end

module Taxjar::API::Order
  extend ::T::Sig
end

module Taxjar::API::Refund
  include ::Taxjar::API::Utils
  def create_refund(options=T.unsafe(nil)); end

  def delete_refund(id, options=T.unsafe(nil)); end

  def list_refunds(options=T.unsafe(nil)); end

  def show_refund(id, options=T.unsafe(nil)); end

  def update_refund(options=T.unsafe(nil)); end
end

module Taxjar::API::Refund
  extend ::T::Sig
end

class Taxjar::API::Request
  def client(); end

  def headers(); end

  def initialize(client, request_method, path, object_key, options=T.unsafe(nil)); end

  def object_key(); end

  def options(); end

  def path(); end

  def perform(); end

  def request_method(); end

  def uri(); end
  DEFAULT_API_URL = ::T.let(nil, ::T.untyped)
  SANDBOX_API_URL = ::T.let(nil, ::T.untyped)
end

class Taxjar::API::Request
end

module Taxjar::API::Utils
  def perform_delete_with_object(path, object_key, options, klass); end

  def perform_get_with_array(path, object_key, options); end

  def perform_get_with_object(path, object_key, options, klass); end

  def perform_get_with_objects(path, object_key, options, klass); end

  def perform_post_with_object(path, object_key, options, klass); end

  def perform_put_with_object(path, object_key, options, klass); end

  def perform_request(request_method, path, object_key, options=T.unsafe(nil)); end

  def perform_request_with_array(request_method, path, object_key, options); end

  def perform_request_with_object(request_method, path, object_key, options, klass); end

  def perform_request_with_objects(request_method, path, object_key, options, klass); end
end

module Taxjar::API::Utils
  extend ::T::Sig
end

module Taxjar::API
  extend ::T::Sig
end

class Taxjar::Base
  include ::Memoizable
  include ::Memoizable::InstanceMethods
  def [](method); end

  def attrs(); end

  def initialize(attributes=T.unsafe(nil)); end

  def map_collection(klass, key); end

  def to_h(); end

  def to_hash(); end
end

class Taxjar::Base
  extend ::Forwardable
  extend ::Memoizable::ModuleMethods
  def self.attr_reader(*attrs); end

  def self.define_attribute_method(key1, klass=T.unsafe(nil), key2=T.unsafe(nil)); end

  def self.define_predicate_method(key1, key2=T.unsafe(nil)); end

  def self.object_attr_reader(klass, key1, key2=T.unsafe(nil)); end
end

class Taxjar::Breakdown
  include ::ModelAttribute::InstanceMethods
  def city_tax_collectable(); end

  def city_tax_collectable=(value); end

  def city_tax_collectable_changed?(); end

  def city_tax_rate(); end

  def city_tax_rate=(value); end

  def city_tax_rate_changed?(); end

  def city_taxable_amount(); end

  def city_taxable_amount=(value); end

  def city_taxable_amount_changed?(); end

  def combined_tax_rate(); end

  def combined_tax_rate=(value); end

  def combined_tax_rate_changed?(); end

  def country_tax_collectable(); end

  def country_tax_collectable=(value); end

  def country_tax_collectable_changed?(); end

  def country_tax_rate(); end

  def country_tax_rate=(value); end

  def country_tax_rate_changed?(); end

  def country_taxable_amount(); end

  def country_taxable_amount=(value); end

  def country_taxable_amount_changed?(); end

  def county_tax_collectable(); end

  def county_tax_collectable=(value); end

  def county_tax_collectable_changed?(); end

  def county_tax_rate(); end

  def county_tax_rate=(value); end

  def county_tax_rate_changed?(); end

  def county_taxable_amount(); end

  def county_taxable_amount=(value); end

  def county_taxable_amount_changed?(); end

  def gst(); end

  def gst=(value); end

  def gst_changed?(); end

  def gst_tax_rate(); end

  def gst_tax_rate=(value); end

  def gst_tax_rate_changed?(); end

  def gst_taxable_amount(); end

  def gst_taxable_amount=(value); end

  def gst_taxable_amount_changed?(); end

  def line_items(); end

  def pst(); end

  def pst=(value); end

  def pst_changed?(); end

  def pst_tax_rate(); end

  def pst_tax_rate=(value); end

  def pst_tax_rate_changed?(); end

  def pst_taxable_amount(); end

  def pst_taxable_amount=(value); end

  def pst_taxable_amount_changed?(); end

  def qst(); end

  def qst=(value); end

  def qst_changed?(); end

  def qst_tax_rate(); end

  def qst_tax_rate=(value); end

  def qst_tax_rate_changed?(); end

  def qst_taxable_amount(); end

  def qst_taxable_amount=(value); end

  def qst_taxable_amount_changed?(); end

  def shipping(&block); end

  def shipping?(&block); end

  def special_district_tax_collectable(); end

  def special_district_tax_collectable=(value); end

  def special_district_tax_collectable_changed?(); end

  def special_district_taxable_amount(); end

  def special_district_taxable_amount=(value); end

  def special_district_taxable_amount_changed?(); end

  def special_tax_rate(); end

  def special_tax_rate=(value); end

  def special_tax_rate_changed?(); end

  def state_tax_collectable(); end

  def state_tax_collectable=(value); end

  def state_tax_collectable_changed?(); end

  def state_tax_rate(); end

  def state_tax_rate=(value); end

  def state_tax_rate_changed?(); end

  def state_taxable_amount(); end

  def state_taxable_amount=(value); end

  def state_taxable_amount_changed?(); end

  def tax_collectable(); end

  def tax_collectable=(value); end

  def tax_collectable_changed?(); end

  def taxable_amount(); end

  def taxable_amount=(value); end

  def taxable_amount_changed?(); end
end

class Taxjar::Breakdown
  extend ::ModelAttribute
end

class Taxjar::BreakdownLineItem
  include ::ModelAttribute::InstanceMethods
  def city_amount(); end

  def city_amount=(value); end

  def city_amount_changed?(); end

  def city_tax_rate(); end

  def city_tax_rate=(value); end

  def city_tax_rate_changed?(); end

  def city_taxable_amount(); end

  def city_taxable_amount=(value); end

  def city_taxable_amount_changed?(); end

  def combined_tax_rate(); end

  def combined_tax_rate=(value); end

  def combined_tax_rate_changed?(); end

  def country_tax_collectable(); end

  def country_tax_collectable=(value); end

  def country_tax_collectable_changed?(); end

  def country_tax_rate(); end

  def country_tax_rate=(value); end

  def country_tax_rate_changed?(); end

  def country_taxable_amount(); end

  def country_taxable_amount=(value); end

  def country_taxable_amount_changed?(); end

  def county_amount(); end

  def county_amount=(value); end

  def county_amount_changed?(); end

  def county_tax_rate(); end

  def county_tax_rate=(value); end

  def county_tax_rate_changed?(); end

  def county_taxable_amount(); end

  def county_taxable_amount=(value); end

  def county_taxable_amount_changed?(); end

  def gst(); end

  def gst=(value); end

  def gst_changed?(); end

  def gst_tax_rate(); end

  def gst_tax_rate=(value); end

  def gst_tax_rate_changed?(); end

  def gst_taxable_amount(); end

  def gst_taxable_amount=(value); end

  def gst_taxable_amount_changed?(); end

  def id(); end

  def id=(value); end

  def id_changed?(); end

  def pst(); end

  def pst=(value); end

  def pst_changed?(); end

  def pst_tax_rate(); end

  def pst_tax_rate=(value); end

  def pst_tax_rate_changed?(); end

  def pst_taxable_amount(); end

  def pst_taxable_amount=(value); end

  def pst_taxable_amount_changed?(); end

  def qst(); end

  def qst=(value); end

  def qst_changed?(); end

  def qst_tax_rate(); end

  def qst_tax_rate=(value); end

  def qst_tax_rate_changed?(); end

  def qst_taxable_amount(); end

  def qst_taxable_amount=(value); end

  def qst_taxable_amount_changed?(); end

  def special_district_amount(); end

  def special_district_amount=(value); end

  def special_district_amount_changed?(); end

  def special_district_taxable_amount(); end

  def special_district_taxable_amount=(value); end

  def special_district_taxable_amount_changed?(); end

  def special_tax_rate(); end

  def special_tax_rate=(value); end

  def special_tax_rate_changed?(); end

  def state_amount(); end

  def state_amount=(value); end

  def state_amount_changed?(); end

  def state_sales_tax_rate(); end

  def state_sales_tax_rate=(value); end

  def state_sales_tax_rate_changed?(); end

  def state_taxable_amount(); end

  def state_taxable_amount=(value); end

  def state_taxable_amount_changed?(); end

  def tax_collectable(); end

  def tax_collectable=(value); end

  def tax_collectable_changed?(); end

  def taxable_amount(); end

  def taxable_amount=(value); end

  def taxable_amount_changed?(); end
end

class Taxjar::BreakdownLineItem
  extend ::ModelAttribute
end

class Taxjar::Category
  include ::ModelAttribute::InstanceMethods
  def description(); end

  def description=(value); end

  def description_changed?(); end

  def name(); end

  def name=(value); end

  def name_changed?(); end

  def product_tax_code(); end

  def product_tax_code=(value); end

  def product_tax_code_changed?(); end
end

class Taxjar::Category
  extend ::ModelAttribute
end

class Taxjar::Client
  include ::Taxjar::API
  include ::Taxjar::API::Customer
  include ::Taxjar::API::Order
  include ::Taxjar::API::Refund
  include ::Taxjar::API::Utils
  def api_key(); end

  def api_key=(api_key); end

  def api_key?(); end

  def api_url(); end

  def api_url=(api_url); end

  def get_api_config(key); end

  def headers(); end

  def headers=(headers); end

  def initialize(options=T.unsafe(nil)); end

  def set_api_config(key, value); end

  def user_agent(); end
end

class Taxjar::Client
end

class Taxjar::Customer
  include ::ModelAttribute::InstanceMethods
  def city(); end

  def city=(value); end

  def city_changed?(); end

  def country(); end

  def country=(value); end

  def country_changed?(); end

  def customer_id(); end

  def customer_id=(value); end

  def customer_id_changed?(); end

  def exempt_regions(); end

  def exemption_type(); end

  def exemption_type=(value); end

  def exemption_type_changed?(); end

  def name(); end

  def name=(value); end

  def name_changed?(); end

  def state(); end

  def state=(value); end

  def state_changed?(); end

  def street(); end

  def street=(value); end

  def street_changed?(); end

  def zip(); end

  def zip=(value); end

  def zip_changed?(); end
end

class Taxjar::Customer
  extend ::ModelAttribute
end

class Taxjar::Error
  def code(); end

  def initialize(message=T.unsafe(nil), code=T.unsafe(nil)); end
  ERRORS = ::T.let(nil, ::T.untyped)
end

class Taxjar::Error::BadRequest
end

class Taxjar::Error::BadRequest
end

class Taxjar::Error::ClientError
end

class Taxjar::Error::ClientError
end

class Taxjar::Error::ConfigurationError
end

class Taxjar::Error::ConfigurationError
end

class Taxjar::Error::Forbidden
end

class Taxjar::Error::Forbidden
end

class Taxjar::Error::Gone
end

class Taxjar::Error::Gone
end

class Taxjar::Error::InternalServerError
end

class Taxjar::Error::InternalServerError
end

class Taxjar::Error::MethodNotAllowed
end

class Taxjar::Error::MethodNotAllowed
end

class Taxjar::Error::NotAcceptable
end

class Taxjar::Error::NotAcceptable
end

class Taxjar::Error::NotFound
end

class Taxjar::Error::NotFound
end

class Taxjar::Error::ServerError
end

class Taxjar::Error::ServerError
end

class Taxjar::Error::ServiceUnavailable
end

class Taxjar::Error::ServiceUnavailable
end

class Taxjar::Error::TooManyRequests
end

class Taxjar::Error::TooManyRequests
end

class Taxjar::Error::Unauthorized
end

class Taxjar::Error::Unauthorized
end

class Taxjar::Error::UnprocessableEntity
end

class Taxjar::Error::UnprocessableEntity
end

class Taxjar::Error
  def self.from_response(body); end
end

class Taxjar::ExemptRegion
  include ::ModelAttribute::InstanceMethods
  def country(); end

  def country=(value); end

  def country_changed?(); end

  def state(); end

  def state=(value); end

  def state_changed?(); end
end

class Taxjar::ExemptRegion
  extend ::ModelAttribute
end

class Taxjar::Jurisdictions
  include ::ModelAttribute::InstanceMethods
  def city(); end

  def city=(value); end

  def city_changed?(); end

  def country(); end

  def country=(value); end

  def country_changed?(); end

  def county(); end

  def county=(value); end

  def county_changed?(); end

  def state(); end

  def state=(value); end

  def state_changed?(); end
end

class Taxjar::Jurisdictions
  extend ::ModelAttribute
end

class Taxjar::LineItem
  include ::ModelAttribute::InstanceMethods
  def description(); end

  def description=(value); end

  def description_changed?(); end

  def discount(); end

  def discount=(value); end

  def discount_changed?(); end

  def id(); end

  def id=(value); end

  def id_changed?(); end

  def product_identifier(); end

  def product_identifier=(value); end

  def product_identifier_changed?(); end

  def product_tax_code(); end

  def product_tax_code=(value); end

  def product_tax_code_changed?(); end

  def quantity(); end

  def quantity=(value); end

  def quantity_changed?(); end

  def sales_tax(); end

  def sales_tax=(value); end

  def sales_tax_changed?(); end

  def unit_price(); end

  def unit_price=(value); end

  def unit_price_changed?(); end
end

class Taxjar::LineItem
  extend ::ModelAttribute
end

class Taxjar::NexusRegion
  include ::ModelAttribute::InstanceMethods
  def country(); end

  def country=(value); end

  def country_changed?(); end

  def country_code(); end

  def country_code=(value); end

  def country_code_changed?(); end

  def region(); end

  def region=(value); end

  def region_changed?(); end

  def region_code(); end

  def region_code=(value); end

  def region_code_changed?(); end
end

class Taxjar::NexusRegion
  extend ::ModelAttribute
end

class Taxjar::Order
  include ::ModelAttribute::InstanceMethods
  def amount(); end

  def amount=(value); end

  def amount_changed?(); end

  def from_city(); end

  def from_city=(value); end

  def from_city_changed?(); end

  def from_country(); end

  def from_country=(value); end

  def from_country_changed?(); end

  def from_state(); end

  def from_state=(value); end

  def from_state_changed?(); end

  def from_street(); end

  def from_street=(value); end

  def from_street_changed?(); end

  def from_zip(); end

  def from_zip=(value); end

  def from_zip_changed?(); end

  def line_items(); end

  def sales_tax(); end

  def sales_tax=(value); end

  def sales_tax_changed?(); end

  def shipping(); end

  def shipping=(value); end

  def shipping_changed?(); end

  def to_city(); end

  def to_city=(value); end

  def to_city_changed?(); end

  def to_country(); end

  def to_country=(value); end

  def to_country_changed?(); end

  def to_state(); end

  def to_state=(value); end

  def to_state_changed?(); end

  def to_street(); end

  def to_street=(value); end

  def to_street_changed?(); end

  def to_zip(); end

  def to_zip=(value); end

  def to_zip_changed?(); end

  def transaction_date(); end

  def transaction_date=(value); end

  def transaction_date_changed?(); end

  def transaction_id(); end

  def transaction_id=(value); end

  def transaction_id_changed?(); end

  def user_id(); end

  def user_id=(value); end

  def user_id_changed?(); end
end

class Taxjar::Order
  extend ::ModelAttribute
end

class Taxjar::Rate
  include ::ModelAttribute::InstanceMethods
  def city(); end

  def city=(value); end

  def city_changed?(); end

  def city_rate(); end

  def city_rate=(value); end

  def city_rate_changed?(); end

  def combined_district_rate(); end

  def combined_district_rate=(value); end

  def combined_district_rate_changed?(); end

  def combined_rate(); end

  def combined_rate=(value); end

  def combined_rate_changed?(); end

  def country(); end

  def country=(value); end

  def country_changed?(); end

  def country_rate(); end

  def country_rate=(value); end

  def country_rate_changed?(); end

  def county(); end

  def county=(value); end

  def county_changed?(); end

  def county_rate(); end

  def county_rate=(value); end

  def county_rate_changed?(); end

  def distance_sale_threshold(); end

  def distance_sale_threshold=(value); end

  def distance_sale_threshold_changed?(); end

  def freight_taxable(); end

  def freight_taxable=(value); end

  def freight_taxable?(); end

  def freight_taxable_changed?(); end

  def name(); end

  def name=(value); end

  def name_changed?(); end

  def parking_rate(); end

  def parking_rate=(value); end

  def parking_rate_changed?(); end

  def reduced_rate(); end

  def reduced_rate=(value); end

  def reduced_rate_changed?(); end

  def standard_rate(); end

  def standard_rate=(value); end

  def standard_rate_changed?(); end

  def state(); end

  def state=(value); end

  def state_changed?(); end

  def state_rate(); end

  def state_rate=(value); end

  def state_rate_changed?(); end

  def super_reduced_rate(); end

  def super_reduced_rate=(value); end

  def super_reduced_rate_changed?(); end

  def zip(); end

  def zip=(value); end

  def zip_changed?(); end
end

class Taxjar::Rate
  extend ::ModelAttribute
end

class Taxjar::Refund
  include ::ModelAttribute::InstanceMethods
  def amount(); end

  def amount=(value); end

  def amount_changed?(); end

  def from_city(); end

  def from_city=(value); end

  def from_city_changed?(); end

  def from_country(); end

  def from_country=(value); end

  def from_country_changed?(); end

  def from_state(); end

  def from_state=(value); end

  def from_state_changed?(); end

  def from_street(); end

  def from_street=(value); end

  def from_street_changed?(); end

  def from_zip(); end

  def from_zip=(value); end

  def from_zip_changed?(); end

  def line_items(); end

  def sales_tax(); end

  def sales_tax=(value); end

  def sales_tax_changed?(); end

  def shipping(); end

  def shipping=(value); end

  def shipping_changed?(); end

  def to_city(); end

  def to_city=(value); end

  def to_city_changed?(); end

  def to_country(); end

  def to_country=(value); end

  def to_country_changed?(); end

  def to_state(); end

  def to_state=(value); end

  def to_state_changed?(); end

  def to_street(); end

  def to_street=(value); end

  def to_street_changed?(); end

  def to_zip(); end

  def to_zip=(value); end

  def to_zip_changed?(); end

  def transaction_date(); end

  def transaction_date=(value); end

  def transaction_date_changed?(); end

  def transaction_id(); end

  def transaction_id=(value); end

  def transaction_id_changed?(); end

  def transaction_reference_id(); end

  def transaction_reference_id=(value); end

  def transaction_reference_id_changed?(); end

  def user_id(); end

  def user_id=(value); end

  def user_id_changed?(); end
end

class Taxjar::Refund
  extend ::ModelAttribute
end

class Taxjar::Shipping
  include ::ModelAttribute::InstanceMethods
  def city_amount(); end

  def city_amount=(value); end

  def city_amount_changed?(); end

  def city_tax_rate(); end

  def city_tax_rate=(value); end

  def city_tax_rate_changed?(); end

  def city_taxable_amount(); end

  def city_taxable_amount=(value); end

  def city_taxable_amount_changed?(); end

  def combined_tax_rate(); end

  def combined_tax_rate=(value); end

  def combined_tax_rate_changed?(); end

  def country_tax_collectable(); end

  def country_tax_collectable=(value); end

  def country_tax_collectable_changed?(); end

  def country_tax_rate(); end

  def country_tax_rate=(value); end

  def country_tax_rate_changed?(); end

  def country_taxable_amount(); end

  def country_taxable_amount=(value); end

  def country_taxable_amount_changed?(); end

  def county_amount(); end

  def county_amount=(value); end

  def county_amount_changed?(); end

  def county_tax_rate(); end

  def county_tax_rate=(value); end

  def county_tax_rate_changed?(); end

  def county_taxable_amount(); end

  def county_taxable_amount=(value); end

  def county_taxable_amount_changed?(); end

  def gst(); end

  def gst=(value); end

  def gst_changed?(); end

  def gst_tax_rate(); end

  def gst_tax_rate=(value); end

  def gst_tax_rate_changed?(); end

  def gst_taxable_amount(); end

  def gst_taxable_amount=(value); end

  def gst_taxable_amount_changed?(); end

  def pst(); end

  def pst=(value); end

  def pst_changed?(); end

  def pst_tax_rate(); end

  def pst_tax_rate=(value); end

  def pst_tax_rate_changed?(); end

  def pst_taxable_amount(); end

  def pst_taxable_amount=(value); end

  def pst_taxable_amount_changed?(); end

  def qst(); end

  def qst=(value); end

  def qst_changed?(); end

  def qst_tax_rate(); end

  def qst_tax_rate=(value); end

  def qst_tax_rate_changed?(); end

  def qst_taxable_amount(); end

  def qst_taxable_amount=(value); end

  def qst_taxable_amount_changed?(); end

  def special_district_amount(); end

  def special_district_amount=(value); end

  def special_district_amount_changed?(); end

  def special_tax_rate(); end

  def special_tax_rate=(value); end

  def special_tax_rate_changed?(); end

  def special_taxable_amount(); end

  def special_taxable_amount=(value); end

  def special_taxable_amount_changed?(); end

  def state_amount(); end

  def state_amount=(value); end

  def state_amount_changed?(); end

  def state_sales_tax_rate(); end

  def state_sales_tax_rate=(value); end

  def state_sales_tax_rate_changed?(); end

  def state_taxable_amount(); end

  def state_taxable_amount=(value); end

  def state_taxable_amount_changed?(); end

  def tax_collectable(); end

  def tax_collectable=(value); end

  def tax_collectable_changed?(); end

  def taxable_amount(); end

  def taxable_amount=(value); end

  def taxable_amount_changed?(); end
end

class Taxjar::Shipping
  extend ::ModelAttribute
end

class Taxjar::SummaryRate
  include ::ModelAttribute::InstanceMethods
  def average_rate(&block); end

  def average_rate?(&block); end

  def country(); end

  def country=(value); end

  def country_changed?(); end

  def country_code(); end

  def country_code=(value); end

  def country_code_changed?(); end

  def minimum_rate(&block); end

  def minimum_rate?(&block); end

  def region(); end

  def region=(value); end

  def region_changed?(); end

  def region_code(); end

  def region_code=(value); end

  def region_code_changed?(); end
end

class Taxjar::SummaryRate::AverageRate
  def label(); end

  def label=(value); end

  def label_changed?(); end

  def rate(); end

  def rate=(value); end

  def rate_changed?(); end
end

class Taxjar::SummaryRate::AverageRate
end

class Taxjar::SummaryRate::MinimumRate
  def label(); end

  def label=(value); end

  def label_changed?(); end

  def rate(); end

  def rate=(value); end

  def rate_changed?(); end
end

class Taxjar::SummaryRate::MinimumRate
end

class Taxjar::SummaryRate
  extend ::ModelAttribute
end

class Taxjar::Tax
  include ::ModelAttribute::InstanceMethods
  def amount_to_collect(); end

  def amount_to_collect=(value); end

  def amount_to_collect_changed?(); end

  def breakdown(&block); end

  def breakdown?(&block); end

  def freight_taxable(); end

  def freight_taxable=(value); end

  def freight_taxable?(); end

  def freight_taxable_changed?(); end

  def has_nexus(); end

  def has_nexus=(value); end

  def has_nexus?(); end

  def has_nexus_changed?(); end

  def jurisdictions(&block); end

  def jurisdictions?(&block); end

  def order_total_amount(); end

  def order_total_amount=(value); end

  def order_total_amount_changed?(); end

  def rate(); end

  def rate=(value); end

  def rate_changed?(); end

  def shipping(); end

  def shipping=(value); end

  def shipping_changed?(); end

  def tax_source(); end

  def tax_source=(value); end

  def tax_source_changed?(); end

  def taxable_amount(); end

  def taxable_amount=(value); end

  def taxable_amount_changed?(); end
end

class Taxjar::Tax
  extend ::ModelAttribute
end

class Taxjar::Validation
  include ::ModelAttribute::InstanceMethods
  def exists(); end

  def exists=(value); end

  def exists?(); end

  def exists_changed?(); end

  def valid(); end

  def valid=(value); end

  def valid?(); end

  def valid_changed?(); end

  def vies_available(); end

  def vies_available=(value); end

  def vies_available?(); end

  def vies_available_changed?(); end

  def vies_response(&block); end

  def vies_response?(&block); end
end

class Taxjar::Validation::ViesResponse
  def address(); end

  def address=(value); end

  def address_changed?(); end

  def name(); end

  def name=(value); end

  def name_changed?(); end

  def request_date(); end

  def request_date=(value); end

  def request_date_changed?(); end

  def vat_number(); end

  def vat_number=(value); end

  def vat_number_changed?(); end
end

class Taxjar::Validation::ViesResponse
end

class Taxjar::Validation
  extend ::ModelAttribute
end

module Taxjar::Version
end

module Taxjar::Version
  extend ::T::Sig
  def self.major(); end

  def self.minor(); end

  def self.patch(); end

  def self.pre(); end

  def self.to_a(); end

  def self.to_h(); end
end

module Taxjar
  extend ::T::Sig
end

class Tempfile
  def _close(); end

  def inspect(); end
end

class Tempfile::Remover
  def call(*args); end

  def initialize(tmpfile); end
end

class Tempfile::Remover
end

module Terminal
end

class Terminal::Table
  def <<(array); end

  def ==(other); end

  def add_row(array); end

  def add_separator(); end

  def align_column(n, alignment); end

  def cell_padding(); end

  def cell_spacing(); end

  def column(n, method=T.unsafe(nil), array=T.unsafe(nil)); end

  def column_width(n); end

  def column_with_headings(n, method=T.unsafe(nil)); end

  def columns(); end

  def headings(); end

  def headings=(arrays); end

  def initialize(options=T.unsafe(nil), &block); end

  def length_of_column(n); end

  def number_of_columns(); end

  def render(); end

  def rows(); end

  def rows=(array); end

  def style(); end

  def style=(options); end

  def title(); end

  def title=(title); end
  VERSION = ::T.let(nil, ::T.untyped)
end

class Terminal::Table::Cell
  def align(val, position, length); end

  def alignment(); end

  def alignment=(val); end

  def alignment?(); end

  def colspan(); end

  def escape(line); end

  def initialize(options=T.unsafe(nil)); end

  def lines(); end

  def render(line=T.unsafe(nil)); end

  def to_s(line=T.unsafe(nil)); end

  def value(); end

  def value_for_column_width_recalc(); end

  def width(); end
end

class Terminal::Table::Cell
end

class Terminal::Table::Row
  def <<(item); end

  def [](index); end

  def add_cell(item); end

  def cells(); end

  def height(); end

  def initialize(table, array=T.unsafe(nil)); end

  def number_of_columns(); end

  def render(); end

  def table(); end
end

class Terminal::Table::Row
end

class Terminal::Table::Separator
end

class Terminal::Table::Separator
end

class Terminal::Table::Style
  def alignment(); end

  def alignment=(alignment); end

  def all_separators(); end

  def all_separators=(all_separators); end

  def apply(options); end

  def border_bottom(); end

  def border_bottom=(border_bottom); end

  def border_i(); end

  def border_i=(border_i); end

  def border_top(); end

  def border_top=(border_top); end

  def border_x(); end

  def border_x=(border_x); end

  def border_y(); end

  def border_y=(border_y); end

  def initialize(options=T.unsafe(nil)); end

  def margin_left(); end

  def margin_left=(margin_left); end

  def on_change(attr); end

  def padding_left(); end

  def padding_left=(padding_left); end

  def padding_right(); end

  def padding_right=(padding_right); end

  def width(); end

  def width=(width); end
end

class Terminal::Table::Style
  def self.defaults(); end

  def self.defaults=(options); end
end

module Terminal::Table::TableHelper
  def table(headings=T.unsafe(nil), *rows, &block); end
end

module Terminal::Table::TableHelper
  extend ::T::Sig
end

class Terminal::Table
end

module Terminal
  extend ::T::Sig
end

class Thor
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def help(command=T.unsafe(nil), subcommand=T.unsafe(nil)); end
  HELP_MAPPINGS = ::T.let(nil, ::T.untyped)
  TEMPLATE_EXTNAME = ::T.let(nil, ::T.untyped)
  THOR_RESERVED_WORDS = ::T.let(nil, ::T.untyped)
end

module Thor::Actions
  def _cleanup_options_and_set(options, key); end

  def _shared_configuration(); end

  def action(instance); end

  def add_file(destination, *args, &block); end

  def add_link(destination, *args); end

  def append_file(path, *args, &block); end

  def append_to_file(path, *args, &block); end

  def apply(path, config=T.unsafe(nil)); end

  def behavior(); end

  def behavior=(behavior); end

  def chmod(path, mode, config=T.unsafe(nil)); end

  def comment_lines(path, flag, *args); end

  def copy_file(source, *args, &block); end

  def create_file(destination, *args, &block); end

  def create_link(destination, *args); end

  def destination_root(); end

  def destination_root=(root); end

  def directory(source, *args, &block); end

  def empty_directory(destination, config=T.unsafe(nil)); end

  def find_in_source_paths(file); end

  def get(source, *args, &block); end

  def gsub_file(path, flag, *args, &block); end

  def in_root(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def inject_into_class(path, klass, *args, &block); end

  def inject_into_file(destination, *args, &block); end

  def insert_into_file(destination, *args, &block); end

  def inside(dir=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def link_file(source, *args); end

  def prepend_file(path, *args, &block); end

  def prepend_to_file(path, *args, &block); end

  def relative_to_original_destination_root(path, remove_dot=T.unsafe(nil)); end

  def remove_dir(path, config=T.unsafe(nil)); end

  def remove_file(path, config=T.unsafe(nil)); end

  def run(command, config=T.unsafe(nil)); end

  def run_ruby_script(command, config=T.unsafe(nil)); end

  def source_paths(); end

  def template(source, *args, &block); end

  def thor(command, *args); end

  def uncomment_lines(path, flag, *args); end
end

class Thor::Actions::CreateFile
  def data(); end

  def force_on_collision?(); end

  def force_or_skip_or_conflict(force, skip, &block); end

  def identical?(); end

  def initialize(base, destination, data, config=T.unsafe(nil)); end

  def on_conflict_behavior(&block); end

  def render(); end
end

class Thor::Actions::CreateFile
end

class Thor::Actions::EmptyDirectory
  def base(); end

  def config(); end

  def convert_encoded_instructions(filename); end

  def destination(); end

  def destination=(destination); end

  def exists?(); end

  def given_destination(); end

  def initialize(base, destination, config=T.unsafe(nil)); end

  def invoke!(); end

  def invoke_with_conflict_check(&block); end

  def on_conflict_behavior(); end

  def pretend?(); end

  def relative_destination(); end

  def revoke!(); end

  def say_status(status, color); end
end

class Thor::Actions::EmptyDirectory
end

module Thor::Actions
  extend ::T::Sig
  def self.included(base); end
end

class Thor::AmbiguousCommandError
end

class Thor::AmbiguousCommandError
end

Thor::AmbiguousTaskError = Thor::AmbiguousCommandError

class Thor::Argument
  def banner(); end

  def default(); end

  def default_banner(); end

  def description(); end

  def enum(); end

  def human_name(); end

  def initialize(name, options=T.unsafe(nil)); end

  def name(); end

  def required(); end

  def required?(); end

  def show_default?(); end

  def type(); end

  def usage(); end

  def valid_type?(type); end

  def validate!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Argument
end

class Thor::Arguments
  def initialize(arguments=T.unsafe(nil)); end

  def parse(args); end

  def remaining(); end
  NUMERIC = ::T.let(nil, ::T.untyped)
end

class Thor::Arguments
  def self.parse(*args); end

  def self.split(args); end
end

module Thor::Base
  def args(); end

  def args=(args); end

  def initialize(args=T.unsafe(nil), local_options=T.unsafe(nil), config=T.unsafe(nil)); end

  def options(); end

  def options=(options); end

  def parent_options(); end

  def parent_options=(parent_options); end
end

module Thor::Base
  extend ::T::Sig
  def self.included(base); end

  def self.register_klass_file(klass); end

  def self.shell(); end

  def self.shell=(shell); end

  def self.subclass_files(); end

  def self.subclasses(); end
end

class Thor::Command
  def formatted_usage(klass, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def handle_argument_error?(instance, error, caller); end

  def handle_no_method_error?(instance, error, caller); end

  def hidden?(); end

  def initialize(name, description, long_description, usage, options=T.unsafe(nil), disable_class_options=T.unsafe(nil)); end

  def local_method?(instance, name); end

  def not_debugging?(instance); end

  def private_method?(instance); end

  def public_method?(instance); end

  def required_options(); end

  def run(instance, args=T.unsafe(nil)); end

  def sans_backtrace(backtrace, caller); end
  FILE_REGEXP = ::T.let(nil, ::T.untyped)
end

class Thor::Command
end

module Thor::CoreExt
end

class Thor::CoreExt::HashWithIndifferentAccess
  def [](key); end

  def []=(key, value); end

  def convert_key(key); end

  def delete(key); end

  def fetch(key, *args); end

  def initialize(hash=T.unsafe(nil)); end

  def key?(key); end

  def merge(other); end

  def merge!(other); end

  def method_missing(method, *args); end

  def values_at(*indices); end
end

class Thor::CoreExt::HashWithIndifferentAccess
end

class Thor::CoreExt::OrderedHash
end

class Thor::CoreExt::OrderedHash
end

module Thor::CoreExt
  extend ::T::Sig
end

class Thor::DynamicCommand
  def initialize(name, options=T.unsafe(nil)); end
end

class Thor::DynamicCommand
end

Thor::DynamicTask = Thor::DynamicCommand

class Thor::Error
end

class Thor::Error
end

class Thor::Group
  include ::Thor::Base
  include ::Thor::Invocation
  include ::Thor::Shell
  def _invoke_for_class_method(klass, command=T.unsafe(nil), *args, &block); end
end

class Thor::Group
  def self.banner(); end

  def self.desc(description=T.unsafe(nil)); end

  def self.get_options_from_invocations(group_options, base_options); end

  def self.handle_argument_error(command, error, _args, arity); end

  def self.help(shell); end

  def self.invocation_blocks(); end

  def self.invocations(); end

  def self.invoke(*names, &block); end

  def self.invoke_from_option(*names, &block); end

  def self.printable_commands(*_); end

  def self.printable_tasks(*_); end

  def self.remove_invocation(*names); end

  def self.self_command(); end

  def self.self_task(); end
end

class Thor::HiddenCommand
end

class Thor::HiddenCommand
end

Thor::HiddenTask = Thor::HiddenCommand

module Thor::Invocation
  def _parse_initialization_options(args, opts, config); end

  def _retrieve_class_and_command(name, sent_command=T.unsafe(nil)); end

  def _retrieve_class_and_task(name, sent_command=T.unsafe(nil)); end

  def _shared_configuration(); end

  def current_command_chain(); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil), &block); end

  def invoke(name=T.unsafe(nil), *args); end

  def invoke_all(); end

  def invoke_command(command, *args); end

  def invoke_task(command, *args); end

  def invoke_with_padding(*args); end
end

module Thor::Invocation
  extend ::T::Sig
  def self.included(base); end
end

class Thor::InvocationError
end

class Thor::InvocationError
end

module Thor::LineEditor
end

class Thor::LineEditor::Basic
  def initialize(prompt, options); end

  def options(); end

  def prompt(); end

  def readline(); end
end

class Thor::LineEditor::Basic
  def self.available?(); end
end

class Thor::LineEditor::Readline
end

class Thor::LineEditor::Readline::PathCompletion
  def initialize(text); end

  def matches(); end
end

class Thor::LineEditor::Readline::PathCompletion
end

class Thor::LineEditor::Readline
end

module Thor::LineEditor
  extend ::T::Sig
  def self.best_available(); end

  def self.readline(prompt, options=T.unsafe(nil)); end
end

class Thor::MalformattedArgumentError
end

class Thor::MalformattedArgumentError
end

class Thor::Option
  def aliases(); end

  def array?(); end

  def boolean?(); end

  def dasherize(str); end

  def dasherized?(); end

  def group(); end

  def hash?(); end

  def hide(); end

  def lazy_default(); end

  def numeric?(); end

  def string?(); end

  def switch_name(); end

  def undasherize(str); end

  def usage(padding=T.unsafe(nil)); end

  def validate_default_type!(); end
  VALID_TYPES = ::T.let(nil, ::T.untyped)
end

class Thor::Option
  def self.parse(key, value); end
end

class Thor::Options
  def check_unknown!(); end

  def current_is_switch?(); end

  def current_is_switch_formatted?(); end

  def initialize(hash_options=T.unsafe(nil), defaults=T.unsafe(nil), stop_on_unknown=T.unsafe(nil)); end

  def normalize_switch(arg); end

  def parse_boolean(switch); end

  def parse_peek(switch, option); end

  def parsing_options?(); end

  def switch?(arg); end

  def switch_option(arg); end
  EQ_RE = ::T.let(nil, ::T.untyped)
  LONG_RE = ::T.let(nil, ::T.untyped)
  OPTS_END = ::T.let(nil, ::T.untyped)
  SHORT_NUM = ::T.let(nil, ::T.untyped)
  SHORT_RE = ::T.let(nil, ::T.untyped)
  SHORT_SQ_RE = ::T.let(nil, ::T.untyped)
end

class Thor::Options
  def self.to_switches(options); end
end

module Thor::RakeCompat
  include ::Rake::DSL
  include ::Rake::FileUtilsExt
  include ::FileUtils
  include ::FileUtils::StreamUtils_
end

module Thor::RakeCompat
  extend ::T::Sig
  def self.included(base); end

  def self.rake_classes(); end
end

class Thor::RequiredArgumentMissingError
end

class Thor::RequiredArgumentMissingError
end

module Thor::Sandbox
end

module Thor::Sandbox
  extend ::T::Sig
end

module Thor::Shell
  def _shared_configuration(); end

  def ask(*args, &block); end

  def error(*args, &block); end

  def file_collision(*args, &block); end

  def initialize(args=T.unsafe(nil), options=T.unsafe(nil), config=T.unsafe(nil)); end

  def no?(*args, &block); end

  def print_in_columns(*args, &block); end

  def print_table(*args, &block); end

  def print_wrapped(*args, &block); end

  def say(*args, &block); end

  def say_status(*args, &block); end

  def set_color(*args, &block); end

  def shell(); end

  def shell=(shell); end

  def terminal_width(*args, &block); end

  def with_padding(); end

  def yes?(*args, &block); end
  SHELL_DELEGATED_METHODS = ::T.let(nil, ::T.untyped)
end

module Thor::Shell
  extend ::T::Sig
end

Thor::Task = Thor::Command

class Thor::UndefinedCommandError
end

class Thor::UndefinedCommandError
end

Thor::UndefinedTaskError = Thor::UndefinedCommandError

class Thor::UnknownArgumentError
end

class Thor::UnknownArgumentError
end

module Thor::Util
end

module Thor::Util
  extend ::T::Sig
  def self.camel_case(str); end

  def self.escape_globs(path); end

  def self.find_by_namespace(namespace); end

  def self.find_class_and_command_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.find_class_and_task_by_namespace(namespace, fallback=T.unsafe(nil)); end

  def self.globs_for(path); end

  def self.load_thorfile(path, content=T.unsafe(nil), debug=T.unsafe(nil)); end

  def self.namespace_from_thor_class(constant); end

  def self.namespaces_in_content(contents, file=T.unsafe(nil)); end

  def self.ruby_command(); end

  def self.snake_case(str); end

  def self.thor_classes_in(klass); end

  def self.thor_root(); end

  def self.thor_root_glob(); end

  def self.user_home(); end
end

class Thor
  def self.banner(command, namespace=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.check_unknown_options!(options=T.unsafe(nil)); end

  def self.command_help(shell, command_name); end

  def self.default_command(meth=T.unsafe(nil)); end

  def self.default_task(meth=T.unsafe(nil)); end

  def self.desc(usage, description, options=T.unsafe(nil)); end

  def self.disable_class_options(); end

  def self.dispatch(meth, given_args, given_opts, config); end

  def self.dynamic_command_class(); end

  def self.find_command_possibilities(meth); end

  def self.find_task_possibilities(meth); end

  def self.help(shell, subcommand=T.unsafe(nil)); end

  def self.long_desc(long_description, options=T.unsafe(nil)); end

  def self.map(mappings=T.unsafe(nil)); end

  def self.method_option(name, options=T.unsafe(nil)); end

  def self.method_options(options=T.unsafe(nil)); end

  def self.normalize_command_name(meth); end

  def self.normalize_task_name(meth); end

  def self.option(name, options=T.unsafe(nil)); end

  def self.options(options=T.unsafe(nil)); end

  def self.package_name(name, _=T.unsafe(nil)); end

  def self.printable_commands(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.printable_tasks(all=T.unsafe(nil), subcommand=T.unsafe(nil)); end

  def self.register(klass, subcommand_name, usage, description, options=T.unsafe(nil)); end

  def self.retrieve_command_name(args); end

  def self.retrieve_task_name(args); end

  def self.stop_on_unknown_option(); end

  def self.stop_on_unknown_option!(*command_names); end

  def self.stop_on_unknown_option?(command); end

  def self.subcommand(subcommand, subcommand_class); end

  def self.subcommand_classes(); end

  def self.subcommand_help(cmd); end

  def self.subcommands(); end

  def self.subtask(subcommand, subcommand_class); end

  def self.subtask_help(cmd); end

  def self.subtasks(); end

  def self.task_help(shell, command_name); end
end

class Thread
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def abort_on_exception(); end

  def abort_on_exception=(abort_on_exception); end

  def add_trace_func(_); end

  def backtrace(*_); end

  def backtrace_locations(*_); end

  def exit(); end

  def fetch(*_); end

  def group(); end

  def initialize(*_); end

  def join(*_); end

  def key?(_); end

  def keys(); end

  def name(); end

  def name=(name); end

  def pending_interrupt?(*_); end

  def priority(); end

  def priority=(priority); end

  def report_on_exception(); end

  def report_on_exception=(report_on_exception); end

  def run(); end

  def safe_level(); end

  def status(); end

  def stop?(); end

  def terminate(); end

  def thread_variable?(_); end

  def thread_variable_get(_); end

  def thread_variable_set(_, _1); end

  def thread_variables(); end

  def value(); end

  def wakeup(); end
end

class Thread::Backtrace
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Thread::Backtrace::Location
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class Thread::Backtrace::Location
  extend ::T::Sig
end

class Thread::Backtrace
  extend ::T::Sig
end

class Thread::ConditionVariable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def broadcast(); end

  def marshal_dump(); end

  def signal(); end

  def wait(*_); end
end

class Thread::ConditionVariable
  extend ::T::Sig
end

class Thread::Mutex
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def lock(); end

  def locked?(); end

  def owned?(); end

  def synchronize(); end

  def try_lock(); end

  def unlock(); end
end

class Thread::Mutex
  extend ::T::Sig
end

class Thread::Queue
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def <<(_); end

  def clear(); end

  def close(); end

  def closed?(); end

  def deq(*_); end

  def empty?(); end

  def enq(_); end

  def length(); end

  def marshal_dump(); end

  def num_waiting(); end

  def pop(*_); end

  def push(_); end

  def shift(*_); end

  def size(); end
end

class Thread::Queue
  extend ::T::Sig
end

class Thread::SizedQueue
  def <<(*_); end

  def enq(*_); end

  def initialize(_); end

  def max(); end

  def max=(max); end

  def push(*_); end
end

class Thread::SizedQueue
  extend ::T::Sig
end

class Thread
  extend ::T::Sig
  def self.abort_on_exception(); end

  def self.abort_on_exception=(abort_on_exception); end

  def self.exclusive(&block); end

  def self.exit(); end

  def self.fork(*_); end

  def self.handle_interrupt(_); end

  def self.kill(_); end

  def self.list(); end

  def self.pass(); end

  def self.pending_interrupt?(*_); end

  def self.report_on_exception(); end

  def self.report_on_exception=(report_on_exception); end

  def self.start(*_); end

  def self.stop(); end
end

class ThreadError
  extend ::T::Sig
end

class ThreadGroup
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def add(_); end

  def enclose(); end

  def enclosed?(); end

  def list(); end
  Default = ::T.let(nil, ::T.untyped)
end

class ThreadGroup
  extend ::T::Sig
end

module ThreadSafe
  NULL = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

ThreadSafe::Array = Array

class ThreadSafe::AtomicReferenceCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def empty?(); end

  def get_and_set(key, value); end

  def get_or_default(key, else_value=T.unsafe(nil)); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end
  DEFAULT_CAPACITY = ::T.let(nil, ::T.untyped)
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MAX_CAPACITY = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  NOW_RESIZING = ::T.let(nil, ::T.untyped)
  TRANSFER_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  include ::ThreadSafe::Util::CheapLockable
  def initialize(hash, key, value, next_node=T.unsafe(nil)); end

  def key(); end

  def key?(key); end

  def locked?(); end

  def matches?(key, hash); end

  def pure_hash(); end

  def try_await_lock(table, i); end

  def try_lock_via_hash(node_hash=T.unsafe(nil)); end

  def unlock_via_hash(locked_hash, node_hash); end
  HASH_BITS = ::T.let(nil, ::T.untyped)
  LOCKED = ::T.let(nil, ::T.untyped)
  MOVED = ::T.let(nil, ::T.untyped)
  SPIN_LOCK_ATTEMPTS = ::T.let(nil, ::T.untyped)
  WAITING = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::AtomicReferenceCacheBackend::Node
  extend ::ThreadSafe::Util::Volatile
  def self.locked_hash?(hash); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
  def cas_new_node(i, hash, key, value); end

  def delete_node_at(i, node, predecessor_node); end

  def try_lock_via_hash(i, node, node_hash); end

  def try_to_cas_in_computed(i, hash, key); end
end

class ThreadSafe::AtomicReferenceCacheBackend::Table
end

class ThreadSafe::AtomicReferenceCacheBackend
  extend ::ThreadSafe::Util::Volatile
end

class ThreadSafe::Cache
  def each_key(); end

  def each_value(); end

  def empty?(); end

  def fetch(key, default_value=T.unsafe(nil)); end

  def fetch_or_store(key, default_value=T.unsafe(nil)); end

  def get(key); end

  def initialize(options=T.unsafe(nil), &block); end

  def key(value); end

  def keys(); end

  def marshal_dump(); end

  def marshal_load(hash); end

  def put(key, value); end

  def put_if_absent(key, value); end

  def values(); end
end

class ThreadSafe::Cache
end

ThreadSafe::ConcurrentCacheBackend = ThreadSafe::MriCacheBackend

ThreadSafe::Hash = Hash

class ThreadSafe::MriCacheBackend
  WRITE_LOCK = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::MriCacheBackend
end

class ThreadSafe::NonConcurrentCacheBackend
  def [](key); end

  def []=(key, value); end

  def clear(); end

  def compute(key); end

  def compute_if_absent(key); end

  def compute_if_present(key); end

  def delete(key); end

  def delete_pair(key, value); end

  def each_pair(); end

  def get_and_set(key, value); end

  def get_or_default(key, default_value); end

  def initialize(options=T.unsafe(nil)); end

  def key?(key); end

  def merge_pair(key, value); end

  def replace_if_exists(key, new_value); end

  def replace_pair(key, old_value, new_value); end

  def size(); end

  def value?(value); end
end

class ThreadSafe::NonConcurrentCacheBackend
end

class ThreadSafe::SynchronizedCacheBackend
  include ::Mutex_m
  def lock(); end

  def locked?(); end

  def synchronize(&block); end

  def try_lock(); end

  def unlock(); end
end

class ThreadSafe::SynchronizedCacheBackend
end

module ThreadSafe::Util
  CPU_COUNT = ::T.let(nil, ::T.untyped)
  FIXNUM_BIT_SIZE = ::T.let(nil, ::T.untyped)
  MAX_INT = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Adder
  def add(x); end

  def decrement(); end

  def increment(); end

  def reset(); end

  def sum(); end
end

class ThreadSafe::Util::Adder
end

class ThreadSafe::Util::AtomicReference
  def compare_and_set(old_value, new_value); end

  def get(); end

  def initialize(value=T.unsafe(nil)); end

  def set(new_value); end

  def value(); end

  def value=(new_value); end
end

class ThreadSafe::Util::AtomicReference
end

module ThreadSafe::Util::CheapLockable
  def cas_mutex(old_value, new_value); end

  def compare_and_set_mutex(old_value, new_value); end

  def lazy_set_mutex(value); end

  def mutex(); end

  def mutex=(value); end
end

module ThreadSafe::Util::CheapLockable
  extend ::ThreadSafe::Util::Volatile
  extend ::T::Sig
end

class ThreadSafe::Util::PowerOfTwoTuple
  def hash_to_index(hash); end

  def next_in_size_table(); end

  def volatile_get_by_hash(hash); end

  def volatile_set_by_hash(hash, value); end
end

class ThreadSafe::Util::PowerOfTwoTuple
end

class ThreadSafe::Util::Striped64
  def busy?(); end

  def initialize(); end

  def retry_update(x, hash_code, was_uncontended); end
  THREAD_LOCAL_KEY = ::T.let(nil, ::T.untyped)
end

class ThreadSafe::Util::Striped64::Cell
  def cas(old_value, new_value); end

  def cas_computed(); end

  def padding_(); end
end

class ThreadSafe::Util::Striped64::Cell
end

class ThreadSafe::Util::Striped64
  extend ::ThreadSafe::Util::Volatile
end

module ThreadSafe::Util::Volatile
  def attr_volatile(*attr_names); end
end

module ThreadSafe::Util::Volatile
  extend ::T::Sig
end

class ThreadSafe::Util::VolatileTuple
  include ::Enumerable
  def cas(i, old_value, new_value); end

  def compare_and_set(i, old_value, new_value); end

  def each(); end

  def initialize(size); end

  def size(); end

  def volatile_get(i); end

  def volatile_set(i, value); end
end

class ThreadSafe::Util::VolatileTuple
end

module ThreadSafe::Util::XorShiftRandom
  def get(); end

  def xorshift(x); end
  MAX_XOR_SHIFTABLE_INT = ::T.let(nil, ::T.untyped)
end

module ThreadSafe::Util::XorShiftRandom
  extend ::ThreadSafe::Util::XorShiftRandom
  extend ::T::Sig
end

module ThreadSafe::Util
  extend ::T::Sig
end

module ThreadSafe
  extend ::T::Sig
end

module Threadsafe
end

module Threadsafe
  extend ::T::Sig
  def self.const_missing(name); end
end

class Time
  include ::DateAndTime::Compatibility
  include ::DateAndTime::Calculations
  include ::DateAndTime::Zones
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def acts_like_time?(); end

  def advance(options); end

  def ago(seconds); end

  def at_beginning_of_day(); end

  def at_beginning_of_hour(); end

  def at_beginning_of_minute(); end

  def at_end_of_day(); end

  def at_end_of_hour(); end

  def at_end_of_minute(); end

  def at_midday(); end

  def at_middle_of_day(); end

  def at_midnight(); end

  def at_noon(); end

  def beginning_of_day(); end

  def beginning_of_hour(); end

  def beginning_of_minute(); end

  def change(options); end

  def compare_with_coercion(other); end

  def compare_without_coercion(_); end

  def end_of_day(); end

  def end_of_hour(); end

  def end_of_minute(); end

  def eql_with_coercion(other); end

  def eql_without_coercion(_); end

  def formatted_offset(colon=T.unsafe(nil), alternate_utc_string=T.unsafe(nil)); end

  def in(seconds); end

  def midday(); end

  def middle_of_day(); end

  def midnight(); end

  def minus_with_coercion(other); end

  def minus_with_duration(other); end

  def minus_without_coercion(other); end

  def minus_without_duration(_); end

  def noon(); end

  def plus_with_duration(other); end

  def plus_without_duration(_); end

  def rfc3339(fraction_digits=T.unsafe(nil)); end

  def sec_fraction(); end

  def seconds_since_midnight(); end

  def seconds_until_end_of_day(); end

  def since(seconds); end

  def to_default_s(); end

  def to_formatted_s(format=T.unsafe(nil)); end

  COMMON_YEAR_DAYS_IN_MONTH = ::T.let(nil, ::T.untyped)
  DATE_FORMATS = ::T.let(nil, ::T.untyped)
end

class Time
  extend ::T::Sig
  def self.===(other); end

  def self.at_with_coercion(*args); end

  def self.at_without_coercion(*_); end

  def self.current(); end

  def self.days_in_month(month, year=T.unsafe(nil)); end

  def self.days_in_year(year=T.unsafe(nil)); end

  def self.find_zone(time_zone); end

  def self.find_zone!(time_zone); end

  def self.mock_time(); end

  def self.new(*args); end

  def self.new_with_mock_time(*args); end

  def self.new_without_mock_time(*_); end

  def self.now_with_mock_time(); end

  def self.now_without_mock_time(); end

  def self.rfc3339(str); end

  def self.use_zone(time_zone); end

  def self.zone(); end

  def self.zone=(time_zone); end

  def self.zone_default(); end

  def self.zone_default=(zone_default); end

end

class Timecop
  include ::Singleton
  VERSION = ::T.let(nil, ::T.untyped)
end

class Timecop::SafeModeException
  def initialize(); end
end

class Timecop::SafeModeException
end

class Timecop::TimeStackItem
  def date(date_klass=T.unsafe(nil)); end

  def datetime(datetime_klass=T.unsafe(nil)); end

  def day(); end

  def hour(); end

  def initialize(mock_type, *args); end

  def min(); end

  def mock_type(); end

  def month(); end

  def scaled_time(); end

  def scaling_factor(); end

  def sec(); end

  def time(time_klass=T.unsafe(nil)); end

  def travel_offset(); end

  def travel_offset_days(); end

  def utc_offset(); end

  def year(); end
end

class Timecop::TimeStackItem
end

class Timecop
  extend ::Singleton::SingletonClassMethods
  def self.baseline(); end

  def self.baseline=(baseline); end

  def self.freeze(*args, &block); end

  def self.instance(); end

  def self.return(&block); end

  def self.return_to_baseline(); end

  def self.safe_mode=(safe); end

  def self.safe_mode?(); end

  def self.scale(*args, &block); end

  def self.thread_safe(); end

  def self.thread_safe=(t); end

  def self.top_stack_item(); end

  def self.travel(*args, &block); end
end

class Timeout::Error
  include ::REST::Error::Timeout
  include ::REST::Error
end

class Timeout::Error
  extend ::T::Sig
end

module Timeout
  extend ::T::Sig
end

class TracePoint
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def event(); end
end

class TracePoint
  extend ::T::Sig
end

class Transaction
  include ::Transaction::GeneratedAssociationMethods
  include ::PaperTrail::Model::InstanceMethods
  def after_add_for_versions(); end

  def after_add_for_versions=(val); end

  def after_add_for_versions?(); end

  def after_remove_for_versions(); end

  def after_remove_for_versions=(val); end

  def after_remove_for_versions?(); end

  def autosave_associated_records_for_order(*args); end

  def autosave_associated_records_for_versions(*args); end

  def before_add_for_versions(); end

  def before_add_for_versions=(val); end

  def before_add_for_versions?(); end

  def before_remove_for_versions(); end

  def before_remove_for_versions=(val); end

  def before_remove_for_versions?(); end

  def belongs_to_counter_cache_after_update(reflection); end

  def paper_trail_event(); end

  def paper_trail_event=(paper_trail_event); end

  def paper_trail_options(); end

  def paper_trail_options=(val); end

  def paper_trail_options?(); end

  def validate_associated_records_for_versions(*args); end

  def version(); end

  def version=(version); end

  def version_association_name(); end

  def version_association_name=(val); end

  def version_association_name?(); end

  def version_class_name(); end

  def version_class_name=(val); end

  def version_class_name?(); end

  def versions_association_name(); end

  def versions_association_name=(val); end

  def versions_association_name?(); end
end

module Transaction::GeneratedAssociationMethods
  def build_order(*args, &block); end

  def create_order(*args, &block); end

  def create_order!(*args, &block); end

  def order(); end

  def order=(value); end

  def reload_order(); end

  def version_ids(); end

  def version_ids=(ids); end

  def versions(); end

  def versions=(value); end
end

module Transaction::GeneratedAssociationMethods
  extend ::T::Sig
end

class Transaction
  def self.after_add_for_versions(); end

  def self.after_add_for_versions=(val); end

  def self.after_add_for_versions?(); end

  def self.after_remove_for_versions(); end

  def self.after_remove_for_versions=(val); end

  def self.after_remove_for_versions?(); end

  def self.before_add_for_versions(); end

  def self.before_add_for_versions=(val); end

  def self.before_add_for_versions?(); end

  def self.before_remove_for_versions(); end

  def self.before_remove_for_versions=(val); end

  def self.before_remove_for_versions?(); end

  def self.paper_trail_options(); end

  def self.paper_trail_options=(val); end

  def self.paper_trail_options?(); end

  def self.version_association_name(); end

  def self.version_association_name=(val); end

  def self.version_association_name?(); end

  def self.version_class_name(); end

  def self.version_class_name=(val); end

  def self.version_class_name?(); end

  def self.versions_association_name(); end

  def self.versions_association_name=(val); end

  def self.versions_association_name?(); end
end

class TransactionEvent
end

module TransactionFeeCalculator
  extend ::T::Sig
end

class TrueClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::MessagePack::CoreExt
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class TrueClass
  extend ::T::Sig
end

class TypeError
  extend ::T::Sig
end

class Types::BaseEnum
end

class Types::BaseField
end

class Types::BaseInputObject
end

module Types::BaseInterface
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
end

module Types::BaseInterface::DefinitionMethods
end

module Types::BaseInterface::DefinitionMethods
  extend ::T::Sig
end

module Types::BaseInterface
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::Types::BaseInterface::DefinitionMethods
  extend ::T::Sig
end

class Types::BaseObject
end

class Types::BaseScalar
end

class Types::BaseUnion
end

class Types::BuyOrderType
  include ::Types::OrderInterface
  include ::Types::BaseInterface
  include ::GraphQL::Schema::Interface
end

class Types::DateTimeType
end

class Types::OfferOrderType
  include ::Types::OrderInterface
  include ::Types::BaseInterface
  include ::GraphQL::Schema::Interface
end

class Types::OrderEdgeType
end

module Types::OrderInterface
  include ::GraphQL::Schema::Interface
  include ::GraphQL::Schema::Member::GraphQLTypeNames
  def buyer_phone_number(**args); end

  def buyer_total_cents(**args); end

  def code(**args); end

  def commission_fee_cents(**args); end

  def commission_rate(**args); end

  def created_at(**args); end

  def credit_card_id(**args); end

  def currency_code(**args); end

  def id(**args); end

  def items_total_cents(**args); end

  def last_approved_at(**args); end

  def last_submitted_at(**args); end

  def last_transaction_failed?(**args); end

  def line_items(**args); end

  def mode(**args); end

  def seller_total_cents(**args); end

  def shipping_total_cents(**args); end

  def state(**args); end

  def state_expires_at(**args); end

  def state_reason(**args); end

  def state_updated_at(**args); end

  def tax_total_cents(**args); end

  def total_list_price_cents(**args); end

  def transaction_fee_cents(**args); end

  def updated_at(**args); end
end

module Types::OrderInterface::DefinitionMethods
  def resolve_type(object, _context); end
end

module Types::OrderInterface::DefinitionMethods
  extend ::T::Sig
end

module Types::OrderInterface
  extend ::GraphQL::Schema::Member::CachedGraphQLDefinition
  extend ::GraphQL::Relay::TypeExtensions
  extend ::GraphQL::Schema::Member::HasPath
  extend ::GraphQL::Schema::Member::AcceptsDefinition::ToGraphQLExtension
  extend ::Types::BaseInterface::DefinitionMethods
  extend ::Types::OrderInterface::DefinitionMethods
  extend ::T::Sig
end

class Types::Pagination::PageableConnection
end

module Types::Pagination
  extend ::T::Sig
end

class Types::Ship
  def address_line1(); end

  def address_line2(); end

  def city(); end

  def country(); end

  def name(); end

  def postal_code(); end

  def region(); end
end

module Types
  extend ::T::Sig
end

class UDPSocket
  extend ::T::Sig
end

module UNF
  VERSION = ::T.let(nil, ::T.untyped)
end

class UNF::Normalizer
  include ::Singleton
  def normalize(_, _1); end
end

class UNF::Normalizer
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end

  def self.normalize(string, form); end
end

module UNF
  extend ::T::Sig
end

class UNIXServer
  extend ::T::Sig
end

class UNIXSocket
  extend ::T::Sig
end

module URI
  include ::URI::RFC2396_REGEXP
end

class URI::BadURIError
  extend ::T::Sig
end

class URI::Error
  extend ::T::Sig
end

module URI::Escape
  def decode(*arg); end

  def encode(*arg); end

  def escape(*arg); end

  def unescape(*arg); end
end

module URI::Escape
  extend ::T::Sig
end

class URI::FTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end

  def set_typecode(v); end

  def typecode(); end

  def typecode=(typecode); end
end

class URI::FTP
  extend ::T::Sig
  def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
end

class URI::GID
  def app(); end

  def model_id(); end

  def model_name(); end

  def params(); end

  def query=(query); end

  def set_params(params); end

  def set_path(path); end

  def set_query(query); end
  COMPONENT = ::T.let(nil, ::T.untyped)
  PATH_REGEXP = ::T.let(nil, ::T.untyped)
end

class URI::GID::MissingModelIdError
end

class URI::GID::MissingModelIdError
end

class URI::GID
  def self.create(app, model, params=T.unsafe(nil)); end

  def self.parse(uri); end

  def self.validate_app(app); end
end

class URI::Generic
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def +(oth); end

  def -(oth); end

  def ==(oth); end

  def absolute(); end

  def absolute?(); end

  def coerce(oth); end

  def component(); end

  def component_ary(); end

  def default_port(); end

  def eql?(oth); end

  def find_proxy(env=T.unsafe(nil)); end

  def fragment(); end

  def fragment=(v); end

  def hierarchical?(); end

  def host(); end

  def host=(v); end

  def hostname(); end

  def hostname=(v); end

  def initialize(scheme, userinfo, host, port, registry, path, opaque, query, fragment, parser=T.unsafe(nil), arg_check=T.unsafe(nil)); end

  def merge(oth); end

  def merge!(oth); end

  def normalize(); end

  def normalize!(); end

  def opaque(); end

  def opaque=(v); end

  def parser(); end

  def password(); end

  def password=(password); end

  def path(); end

  def path=(v); end

  def port(); end

  def port=(v); end

  def query(); end

  def query=(v); end

  def registry(); end

  def registry=(v); end

  def relative?(); end

  def route_from(oth); end

  def route_to(oth); end

  def scheme(); end

  def scheme=(v); end

  def select(*components); end

  def set_host(v); end

  def set_opaque(v); end

  def set_password(v); end

  def set_path(v); end

  def set_port(v); end

  def set_registry(v); end

  def set_scheme(v); end

  def set_user(v); end

  def set_userinfo(user, password=T.unsafe(nil)); end

  def user(); end

  def user=(user); end

  def userinfo(); end

  def userinfo=(userinfo); end
end

class URI::Generic
  extend ::T::Sig
  def self.build(args); end

  def self.build2(args); end

  def self.component(); end

  def self.default_port(); end

  def self.use_proxy?(hostname, addr, port, no_proxy); end

  def self.use_registry(); end
end

class URI::HTTP
  include ::OpenURI::OpenRead
  def buffer_open(buf, proxy, options); end

  def request_uri(); end
end

class URI::HTTP
  extend ::T::Sig
end

class URI::HTTPS
  extend ::T::Sig
end

class URI::InvalidComponentError
  extend ::T::Sig
end

class URI::InvalidURIError
  extend ::T::Sig
end

class URI::LDAP
  def attributes(); end

  def attributes=(val); end

  def dn(); end

  def dn=(val); end

  def extensions(); end

  def extensions=(val); end

  def filter(); end

  def filter=(val); end

  def initialize(*arg); end

  def scope(); end

  def scope=(val); end

  def set_attributes(val); end

  def set_dn(val); end

  def set_extensions(val); end

  def set_filter(val); end

  def set_scope(val); end
end

class URI::LDAP
  extend ::T::Sig
end

class URI::LDAPS
  extend ::T::Sig
end

class URI::MailTo
  def headers(); end

  def headers=(v); end

  def initialize(*arg); end

  def set_headers(v); end

  def set_to(v); end

  def to(); end

  def to=(v); end

  def to_mailtext(); end

  def to_rfc822text(); end
end

class URI::MailTo
  extend ::T::Sig
end

URI::Parser = URI::RFC2396_Parser

URI::REGEXP = URI::RFC2396_REGEXP

class URI::RFC2396_Parser
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def escape(str, unsafe=T.unsafe(nil)); end

  def extract(str, schemes=T.unsafe(nil)); end

  def initialize(opts=T.unsafe(nil)); end

  def join(*uris); end

  def make_regexp(schemes=T.unsafe(nil)); end

  def parse(uri); end

  def pattern(); end

  def regexp(); end

  def split(uri); end

  def unescape(str, escaped=T.unsafe(nil)); end
end

class URI::RFC2396_Parser
  extend ::T::Sig
end

module URI::RFC2396_REGEXP::PATTERN
  extend ::T::Sig
end

module URI::RFC2396_REGEXP
  extend ::T::Sig
end

class URI::RFC3986_Parser
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def join(*uris); end

  def parse(uri); end

  def regexp(); end

  def split(uri); end
  RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
end

class URI::RFC3986_Parser
  extend ::T::Sig
end

module URI::Util
  extend ::T::Sig
  def self.make_components_hash(klass, array_hash); end
end

module URI
  extend ::T::Sig
  extend ::URI::Escape
  def self.decode_www_form(str, enc=T.unsafe(nil), separator: T.unsafe(nil), use__charset_: T.unsafe(nil), isindex: T.unsafe(nil)); end

  def self.encode_www_form(enum, enc=T.unsafe(nil)); end

  def self.encode_www_form_component(str, enc=T.unsafe(nil)); end

  def self.get_encoding(label); end

  def self.parser(); end
end

class UnboundMethod
  include ::MethodSource::MethodExtensions
  include ::MethodSource::SourceLocation::UnboundMethodExtensions
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  def clone(); end

  def original_name(); end
end

class UnboundMethod
  extend ::T::Sig
end

class UncaughtThrowError
  def tag(); end

  def value(); end
end

class UncaughtThrowError
  extend ::T::Sig
end

module Unicode
end

module Unicode::DisplayWidth
  DATA_DIRECTORY = ::T.let(nil, ::T.untyped)
  DEPTHS = ::T.let(nil, ::T.untyped)
  INDEX = ::T.let(nil, ::T.untyped)
  INDEX_FILENAME = ::T.let(nil, ::T.untyped)
  NO_STRING_EXT = ::T.let(nil, ::T.untyped)
  UNICODE_VERSION = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

module Unicode::DisplayWidth
  extend ::T::Sig
  def self.emoji_extra_width_of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), _=T.unsafe(nil)); end

  def self.of(string, ambiguous=T.unsafe(nil), overwrite=T.unsafe(nil), options=T.unsafe(nil)); end
end

module Unicode
  extend ::T::Sig
end

module UnicodeNormalize
end

module UnicodeNormalize
  extend ::T::Sig
end

module UnitConverter
  extend ::T::Sig
end

class UploadIO
  def content_type(); end

  def initialize(filename_or_io, content_type, filename=T.unsafe(nil), opts=T.unsafe(nil)); end

  def io(); end

  def local_path(); end

  def method_missing(*args); end

  def opts(); end

  def original_filename(); end

  def respond_to?(meth, include_all=T.unsafe(nil)); end
end

class UploadIO
  def self.convert!(io, content_type, original_filename, local_path); end
end

module UrlHelper
  extend ::T::Sig
end

Visitor = Psych::Visitors::Visitor

class WEBrick::HTTPServlet::AbstractServlet
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
end

class WEBrick::HTTPServlet::AbstractServlet
  extend ::T::Sig
end

module Warden
end

class Warden::Config
  def deep_dup(key, other); end

  def default_scope(); end

  def default_scope=(value); end

  def default_strategies(*strategies); end

  def failure_app(); end

  def failure_app=(value); end

  def initialize(other=T.unsafe(nil)); end

  def intercept_401(); end

  def intercept_401=(value); end

  def scope_defaults(scope, opts=T.unsafe(nil)); end

  def serialize_from_session(*args, &block); end

  def serialize_into_session(*args, &block); end

  def silence_missing_strategies!(); end

  def silence_missing_strategies?(); end

  def strategies(); end
end

class Warden::Config
  def self.hash_accessor(*names); end
end

module Warden::Hooks
  def _after_failed_fetch(); end

  def _after_set_user(); end

  def _before_failure(); end

  def _before_logout(); end

  def _on_request(); end

  def _run_callbacks(kind, *args); end

  def after_authentication(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def after_failed_fetch(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def after_fetch(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def after_set_user(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def before_failure(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def before_logout(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def on_request(options=T.unsafe(nil), method=T.unsafe(nil), &block); end

  def prepend_after_authentication(options=T.unsafe(nil), &block); end

  def prepend_after_fetch(options=T.unsafe(nil), &block); end

  def prepend_after_set_user(options=T.unsafe(nil), &block); end

  def prepend_before_failure(options=T.unsafe(nil), &block); end

  def prepend_before_logout(options=T.unsafe(nil), &block); end

  def prepend_on_request(options=T.unsafe(nil), &block); end
end

module Warden::Hooks
  extend ::T::Sig
end

class Warden::Manager
  def _run_callbacks(*args); end

  def call(env); end

  def config(); end

  def config=(config); end

  def initialize(app, options=T.unsafe(nil)); end
end

class Warden::Manager
  extend ::Warden::Hooks
  def self.serialize_from_session(scope=T.unsafe(nil), &block); end

  def self.serialize_into_session(scope=T.unsafe(nil), &block); end
end

module Warden::Mixins
end

module Warden::Mixins::Common
  def cookies(); end

  def params(); end

  def raw_session(); end

  def request(); end

  def reset_session!(); end

  def session(); end

  def warden_cookies(); end
end

module Warden::Mixins::Common
  extend ::T::Sig
end

module Warden::Mixins
  extend ::T::Sig
end

class Warden::NotAuthenticated
end

class Warden::NotAuthenticated
end

class Warden::Proxy
  include ::Warden::Mixins::Common
  def asset_request?(); end

  def authenticate(*args); end

  def authenticate!(*args); end

  def authenticate?(*args); end

  def authenticated?(scope=T.unsafe(nil)); end

  def clear_strategies_cache!(*args); end

  def config(); end

  def custom_failure!(); end

  def custom_failure?(); end

  def custom_response(*args, &block); end

  def default_strategies(*args, &block); end

  def env(); end

  def errors(); end

  def headers(*args, &block); end

  def initialize(env, manager); end

  def inspect(*args); end

  def lock!(); end

  def logout(*scopes); end

  def manager(); end

  def message(); end

  def on_request(); end

  def result(); end

  def session(scope=T.unsafe(nil)); end

  def session_serializer(); end

  def set_user(user, opts=T.unsafe(nil)); end

  def status(*args, &block); end

  def to_s(*args); end

  def unauthenticated?(scope=T.unsafe(nil)); end

  def user(argument=T.unsafe(nil)); end

  def winning_strategies(); end

  def winning_strategy(); end

  def winning_strategy=(winning_strategy); end
  ENV_SESSION_OPTIONS = ::T.let(nil, ::T.untyped)
  ENV_WARDEN_ERRORS = ::T.let(nil, ::T.untyped)
end

class Warden::Proxy::Errors
  include ::Enumerable
  def add(field_name, message); end

  def clear!(); end

  def each(); end

  def empty?(); end

  def full_messages(); end

  def method_missing(meth, *args, &block); end

  def on(field_name); end
end

class Warden::Proxy::Errors
end

class Warden::Proxy
  extend ::Forwardable
end

class Warden::SessionSerializer
  def delete(scope, user=T.unsafe(nil)); end

  def deserialize(key); end

  def env(); end

  def fetch(scope); end

  def initialize(env); end

  def key_for(scope); end

  def serialize(user); end

  def session(); end

  def store(user, scope); end

  def stored?(scope); end
end

class Warden::SessionSerializer
end

module Warden::Strategies
end

class Warden::Strategies::Base
  include ::Warden::Mixins::Common
  def _run!(); end

  def clear!(); end

  def custom!(response); end

  def custom_response(); end

  def custom_response=(custom_response); end

  def env(); end

  def errors(); end

  def fail(message=T.unsafe(nil)); end

  def fail!(message=T.unsafe(nil)); end

  def halt!(); end

  def halted?(); end

  def headers(header=T.unsafe(nil)); end

  def initialize(env, scope=T.unsafe(nil)); end

  def message(); end

  def message=(message); end

  def pass(); end

  def performed?(); end

  def redirect!(url, params=T.unsafe(nil), opts=T.unsafe(nil)); end

  def result(); end

  def result=(result); end

  def scope(); end

  def status(); end

  def store?(); end

  def success!(user, message=T.unsafe(nil)); end

  def successful?(); end

  def user(); end

  def user=(user); end

  def valid?(); end
end

class Warden::Strategies::Base
end

module Warden::Strategies
  extend ::T::Sig
  def self.[](label); end

  def self._strategies(); end

  def self.add(label, strategy=T.unsafe(nil), &block); end

  def self.clear!(); end

  def self.update(label, &block); end
end

module Warden::Test
end

module Warden::Test::Helpers
  def login_as(user, opts=T.unsafe(nil)); end

  def logout(*scopes); end
end

module Warden::Test::Helpers
  extend ::T::Sig
  def self.included(_base); end
end

module Warden::Test::Mock
  def warden(); end
end

class Warden::Test::Mock::Session
  def app(); end

  def app=(app); end

  def call(e); end

  def initialize(app, _configs=T.unsafe(nil)); end
end

class Warden::Test::Mock::Session
end

module Warden::Test::Mock
  extend ::T::Sig
  def self.included(_base); end
end

module Warden::Test::WardenHelpers
  def _on_next_request(); end

  def asset_paths(); end

  def asset_paths=(*vals); end

  def on_next_request(&blk); end

  def test_reset!(); end
end

module Warden::Test::WardenHelpers
  extend ::T::Sig
end

module Warden::Test
  extend ::T::Sig
end

class Warden::UserNotSet
end

class Warden::UserNotSet
end

module Warden
  extend ::T::Sig
  def self.test_mode!(); end
end

module Warning
  def warn(_); end
end

module Warning
  extend ::T::Sig
  extend ::Warning
end

module WebMock
  include ::WebMock::API
  def after_request(*args, &block); end

  def allow_net_connect!(*args, &block); end

  def disable_net_connect!(*args, &block); end

  def net_connect_allowed?(*args, &block); end

  def registered_request?(*args, &block); end

  def reset_callbacks(*args, &block); end

  def reset_webmock(*args, &block); end
  VERSION = ::T.let(nil, ::T.untyped)
end

module WebMock::API
  def a_request(method, uri); end

  def assert_not_requested(*args, &block); end

  def assert_requested(*args, &block); end

  def hash_excluding(*args); end

  def hash_including(*args); end

  def refute_requested(*args, &block); end

  def remove_request_stub(stub); end

  def stub_http_request(method, uri); end

  def stub_request(method, uri); end
end

module WebMock::API
  extend ::WebMock::API
  extend ::T::Sig
  def self.request(method, uri); end
end

class WebMock::AssertionFailure
end

class WebMock::AssertionFailure
  def self.error_class(); end

  def self.error_class=(error_class); end

  def self.failure(message); end
end

class WebMock::BodyPattern
  include ::WebMock::RSpecMatcherDetector
  def initialize(pattern); end

  def matches?(body, content_type=T.unsafe(nil)); end

  def pattern(); end
  BODY_FORMATS = ::T.let(nil, ::T.untyped)
end

class WebMock::BodyPattern
end

class WebMock::CallbackRegistry
end

class WebMock::CallbackRegistry
  def self.add_callback(options, block); end

  def self.any_callbacks?(); end

  def self.callbacks(); end

  def self.invoke_callbacks(options, request_signature, response); end

  def self.reset(); end
end

class WebMock::Config
  include ::Singleton
  def allow(); end

  def allow=(allow); end

  def allow_localhost(); end

  def allow_localhost=(allow_localhost); end

  def allow_net_connect(); end

  def allow_net_connect=(allow_net_connect); end

  def net_http_connect_on_start(); end

  def net_http_connect_on_start=(net_http_connect_on_start); end

  def query_values_notation(); end

  def query_values_notation=(query_values_notation); end

  def show_body_diff(); end

  def show_body_diff=(show_body_diff); end

  def show_stubbing_instructions(); end

  def show_stubbing_instructions=(show_stubbing_instructions); end
end

class WebMock::Config
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class WebMock::Deprecation
end

class WebMock::Deprecation
  def self.warning(message); end
end

class WebMock::DynamicResponse
  def initialize(responder); end

  def responder(); end

  def responder=(responder); end
end

class WebMock::DynamicResponse
end

class WebMock::HashValidator
  def initialize(hash); end

  def validate_keys(*valid_keys); end
end

class WebMock::HashValidator
end

class WebMock::HeadersPattern
  def initialize(pattern); end

  def matches?(headers); end

  def pp_to_s(); end
end

class WebMock::HeadersPattern
end

class WebMock::HttpLibAdapter
end

class WebMock::HttpLibAdapter
  def self.adapter_for(lib); end
end

class WebMock::HttpLibAdapterRegistry
  include ::Singleton
  def each_adapter(&block); end

  def http_lib_adapters(); end

  def http_lib_adapters=(http_lib_adapters); end

  def register(lib, adapter); end
end

class WebMock::HttpLibAdapterRegistry
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module WebMock::HttpLibAdapters
end

class WebMock::HttpLibAdapters::HttpRbAdapter
end

class WebMock::HttpLibAdapters::HttpRbAdapter
  def self.disable!(); end

  def self.enable!(); end

  def self.enabled?(); end
end

class WebMock::HttpLibAdapters::NetHttpAdapter
end

WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetBufferedIO = Net::BufferedIO

WebMock::HttpLibAdapters::NetHttpAdapter::OriginalNetHTTP = Net::HTTP

class WebMock::HttpLibAdapters::NetHttpAdapter
  def self.disable!(); end

  def self.enable!(); end
end

module WebMock::HttpLibAdapters
  extend ::T::Sig
end

module WebMock::Matchers
  def have_been_made(); end

  def have_been_requested(); end

  def have_not_been_made(); end

  def have_not_requested(method, uri); end

  def have_requested(method, uri); end
end

class WebMock::Matchers::AnyArgMatcher
  def ==(other); end

  def initialize(ignore); end
end

class WebMock::Matchers::AnyArgMatcher
end

class WebMock::Matchers::HashArgumentMatcher
  def ==(_actual, &block); end

  def initialize(expected); end
end

class WebMock::Matchers::HashArgumentMatcher
  def self.from_rspec_matcher(matcher); end
end

class WebMock::Matchers::HashExcludingMatcher
  def ==(actual); end
end

class WebMock::Matchers::HashExcludingMatcher
end

class WebMock::Matchers::HashIncludingMatcher
  def ==(actual); end
end

class WebMock::Matchers::HashIncludingMatcher
end

module WebMock::Matchers
  extend ::T::Sig
end

class WebMock::MethodPattern
  def initialize(pattern); end

  def matches?(method); end
end

class WebMock::MethodPattern
end

class WebMock::NetConnectNotAllowedError
  def initialize(request_signature); end
end

class WebMock::NetConnectNotAllowedError
end

module WebMock::NetHTTPUtility
end

module WebMock::NetHTTPUtility
  extend ::T::Sig
  def self.check_right_http_connection(); end

  def self.puts_warning_for_right_http_if_needed(); end

  def self.request_signature_from_request(net_http, request, body=T.unsafe(nil)); end

  def self.validate_headers(headers); end
end

module WebMock::RSpecMatcherDetector
  def rSpecHashExcludingMatcher?(matcher); end

  def rSpecHashIncludingMatcher?(matcher); end
end

module WebMock::RSpecMatcherDetector
  extend ::T::Sig
end

class WebMock::RackResponse
  def body_from_rack_response(response); end

  def build_rack_env(request); end

  def evaluate(request); end

  def initialize(app); end

  def session(); end

  def session_options(); end
end

class WebMock::RackResponse
end

class WebMock::RequestBodyDiff
  def body_diff(); end

  def initialize(request_signature, request_stub); end
end

class WebMock::RequestBodyDiff
end

class WebMock::RequestExecutionVerifier
  def at_least_times_executed(); end

  def at_least_times_executed=(at_least_times_executed); end

  def at_most_times_executed(); end

  def at_most_times_executed=(at_most_times_executed); end

  def description(); end

  def does_not_match?(); end

  def expected_times_executed(); end

  def expected_times_executed=(expected_times_executed); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(request_pattern=T.unsafe(nil), expected_times_executed=T.unsafe(nil), at_least_times_executed=T.unsafe(nil), at_most_times_executed=T.unsafe(nil)); end

  def matches?(); end

  def request_pattern(); end

  def request_pattern=(request_pattern); end

  def times_executed(); end

  def times_executed=(times_executed); end
end

class WebMock::RequestExecutionVerifier
  def self.executed_requests_message(); end
end

class WebMock::RequestPattern
  def body_pattern(); end

  def headers_pattern(); end

  def initialize(method, uri, options=T.unsafe(nil)); end

  def matches?(request_signature); end

  def method_pattern(); end

  def uri_pattern(); end

  def with(options=T.unsafe(nil), &block); end
end

class WebMock::RequestPattern
end

class WebMock::RequestPatternMatcher
  def at_least_once(); end

  def at_least_times(times); end

  def at_least_twice(); end

  def at_most_once(); end

  def at_most_times(times); end

  def at_most_twice(); end

  def description(); end

  def does_not_match?(request_pattern); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def matches?(request_pattern); end

  def negative_failure_message(); end

  def once(); end

  def times(times); end

  def twice(); end
end

class WebMock::RequestPatternMatcher
end

class WebMock::RequestRegistry
  include ::Singleton
  def requested_signatures(); end

  def requested_signatures=(requested_signatures); end

  def reset!(); end

  def times_executed(request_pattern); end
end

class WebMock::RequestRegistry
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class WebMock::RequestSignature
  def ==(other); end

  def body(); end

  def body=(body); end

  def eql?(other); end

  def headers(); end

  def headers=(headers); end

  def initialize(method, uri, options=T.unsafe(nil)); end

  def json_headers?(); end

  def method(); end

  def method=(method); end

  def uri(); end

  def uri=(uri); end

  def url_encoded?(); end
end

class WebMock::RequestSignature
end

class WebMock::RequestSignatureSnippet
  def initialize(request_signature); end

  def request_signature(); end

  def request_stub(); end

  def request_stubs(); end

  def stubbing_instructions(); end
end

class WebMock::RequestSignatureSnippet
end

class WebMock::RequestStub
  def and_raise(*exceptions); end

  def and_return(*response_hashes, &block); end

  def and_timeout(); end

  def has_responses?(); end

  def initialize(method, uri); end

  def matches?(request_signature); end

  def request_pattern(); end

  def request_pattern=(request_pattern); end

  def response(); end

  def then(); end

  def times(number); end

  def to_rack(app, options=T.unsafe(nil)); end

  def to_raise(*exceptions); end

  def to_return(*response_hashes, &block); end

  def to_timeout(); end

  def with(params=T.unsafe(nil), &block); end
end

class WebMock::RequestStub
  def self.from_request_signature(signature); end
end

class WebMock::Response
  def ==(other); end

  def body(); end

  def body=(body); end

  def evaluate(request_signature); end

  def exception(); end

  def exception=(exception); end

  def headers(); end

  def headers=(headers); end

  def initialize(options=T.unsafe(nil)); end

  def options=(options); end

  def raise_error_if_any(); end

  def should_timeout(); end

  def status(); end

  def status=(status); end
end

class WebMock::Response::InvalidBody
end

class WebMock::Response::InvalidBody
end

class WebMock::Response
end

class WebMock::ResponseFactory
end

class WebMock::ResponseFactory
  def self.response_for(options); end
end

class WebMock::ResponsesSequence
  def end?(); end

  def initialize(responses); end

  def next_response(); end

  def times_to_repeat(); end

  def times_to_repeat=(times_to_repeat); end
end

class WebMock::ResponsesSequence
end

class WebMock::StubRegistry
  include ::Singleton
  def global_stubs(); end

  def register_global_stub(&block); end

  def register_request_stub(stub); end

  def registered_request?(request_signature); end

  def remove_request_stub(stub); end

  def request_stubs(); end

  def request_stubs=(request_stubs); end

  def reset!(); end

  def response_for_request(request_signature); end
end

class WebMock::StubRegistry
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

class WebMock::StubRequestSnippet
  def body_pattern(); end

  def initialize(request_stub); end

  def to_s(with_response=T.unsafe(nil)); end
end

class WebMock::StubRequestSnippet
end

class WebMock::URIAddressablePattern
  def matches?(uri); end
end

class WebMock::URIAddressablePattern
end

class WebMock::URIPattern
  include ::WebMock::RSpecMatcherDetector
  def add_query_params(query_params); end

  def initialize(pattern); end
end

class WebMock::URIPattern
end

class WebMock::URIRegexpPattern
  def matches?(uri); end
end

class WebMock::URIRegexpPattern
end

class WebMock::URIStringPattern
  def matches?(uri); end
end

class WebMock::URIStringPattern
end

module WebMock::Util
end

class WebMock::Util::HashCounter
  def each(&block); end

  def get(key); end

  def hash=(hash); end

  def put(key, num=T.unsafe(nil)); end

  def select(&block); end
end

class WebMock::Util::HashCounter
end

class WebMock::Util::HashKeysStringifier
end

class WebMock::Util::HashKeysStringifier
  def self.stringify_keys!(arg, options=T.unsafe(nil)); end
end

class WebMock::Util::Headers
end

class WebMock::Util::Headers
  def self.basic_auth_header(*credentials); end

  def self.decode_userinfo_from_header(header); end

  def self.normalize_headers(headers); end

  def self.pp_headers_string(headers); end

  def self.sorted_headers_string(headers); end
end

class WebMock::Util::JSON
end

class WebMock::Util::JSON::ParseError
end

class WebMock::Util::JSON::ParseError
end

class WebMock::Util::JSON
  def self.convert_json_to_yaml(json); end

  def self.parse(json); end

  def self.unescape(str); end
end

class WebMock::Util::QueryMapper
end

class WebMock::Util::QueryMapper
  def self.collect_query_hash(query_array, empty_accumulator, options); end

  def self.collect_query_parts(query); end

  def self.dehash(hash); end

  def self.fill_accumulator_for_dot(accumulator, key, value); end

  def self.fill_accumulator_for_flat(accumulator, key, value); end

  def self.fill_accumulator_for_flat_array(accumulator, key, value); end

  def self.fill_accumulator_for_subscript(accumulator, key, value); end

  def self.normalize_query_hash(query_hash, empty_accumulator, options); end

  def self.query_to_values(query, options=T.unsafe(nil)); end

  def self.to_query(parent, value, options=T.unsafe(nil)); end

  def self.values_to_query(new_query_values, options=T.unsafe(nil)); end
end

class WebMock::Util::URI
  ADDRESSABLE_URIS = ::T.let(nil, ::T.untyped)
  NORMALIZED_URIS = ::T.let(nil, ::T.untyped)
end

module WebMock::Util::URI::CharacterClasses
  USERINFO = ::T.let(nil, ::T.untyped)
end

module WebMock::Util::URI::CharacterClasses
  extend ::T::Sig
end

class WebMock::Util::URI
  def self.encode_unsafe_chars_in_userinfo(userinfo); end

  def self.heuristic_parse(uri); end

  def self.is_uri_localhost?(uri); end

  def self.normalize_uri(uri); end

  def self.sort_query_values(query_values); end

  def self.strip_default_port_from_uri_string(uri_string); end

  def self.uris_encoded_and_unencoded(uris); end

  def self.uris_with_inferred_port_and_without(uris); end

  def self.uris_with_scheme_and_without(uris); end

  def self.uris_with_trailing_slash_and_without(uris); end

  def self.variations_of_uri_as_strings(uri_object, only_with_scheme: T.unsafe(nil)); end
end

class WebMock::Util::ValuesStringifier
end

class WebMock::Util::ValuesStringifier
  def self.stringify_values(value); end
end

module WebMock::Util
  extend ::T::Sig
end

class WebMock::VersionChecker
  def check_version!(); end

  def initialize(library_name, library_version, min_patch_level, max_minor_version=T.unsafe(nil), unsupported_versions=T.unsafe(nil)); end
end

class WebMock::VersionChecker
end

class WebMock::WebMockMatcher
  def at_least_once(); end

  def at_least_times(times); end

  def at_least_twice(); end

  def description(); end

  def does_not_match?(webmock); end

  def failure_message(); end

  def failure_message_when_negated(); end

  def initialize(method, uri); end

  def matches?(webmock); end

  def negative_failure_message(); end

  def once(); end

  def times(times); end

  def twice(); end

  def with(options=T.unsafe(nil), &block); end
end

class WebMock::WebMockMatcher
end

module WebMock
  extend ::WebMock::API
  extend ::T::Sig
  def self.after_request(options=T.unsafe(nil), &block); end

  def self.allow_net_connect!(options=T.unsafe(nil)); end

  def self.disable!(options=T.unsafe(nil)); end

  def self.disable_net_connect!(options=T.unsafe(nil)); end

  def self.enable!(); end

  def self.globally_stub_request(&block); end

  def self.hide_body_diff!(); end

  def self.hide_stubbing_instructions!(); end

  def self.included(clazz); end

  def self.net_connect_allowed?(uri=T.unsafe(nil)); end

  def self.net_connect_explicit_allowed?(allowed, uri=T.unsafe(nil)); end

  def self.print_executed_requests(); end

  def self.registered_request?(request_signature); end

  def self.request(method, uri); end

  def self.reset!(); end

  def self.reset_callbacks(); end

  def self.reset_webmock(); end

  def self.show_body_diff!(); end

  def self.show_body_diff?(); end

  def self.show_stubbing_instructions!(); end

  def self.show_stubbing_instructions?(); end

  def self.version(); end
end

module XPath
  include ::XPath::DSL
end

module XPath::DSL
  def !(*args); end

  def !=(rhs); end

  def %(rhs); end

  def &(rhs); end

  def *(rhs); end

  def +(*expressions); end

  def /(rhs); end

  def <(rhs); end

  def <=(rhs); end

  def ==(rhs); end

  def >(rhs); end

  def >=(rhs); end

  def [](expression); end

  def ancestor(*element_names); end

  def ancestor_or_self(*element_names); end

  def and(rhs); end

  def anywhere(*expressions); end

  def attr(expression); end

  def attribute(*element_names); end

  def axis(name, *element_names); end

  def binary_operator(name, rhs); end

  def boolean(*args); end

  def ceiling(*args); end

  def child(*expressions); end

  def concat(*args); end

  def contains(*args); end

  def contains_word(word); end

  def count(*args); end

  def css(selector); end

  def current(); end

  def descendant(*expressions); end

  def descendant_or_self(*element_names); end

  def divide(rhs); end

  def ends_with(suffix); end

  def equals(rhs); end

  def false(*args); end

  def floor(*args); end

  def following(*element_names); end

  def following_sibling(*element_names); end

  def function(name, *arguments); end

  def gt(rhs); end

  def gte(rhs); end

  def id(*args); end

  def inverse(*args); end

  def is(expression); end

  def lang(*args); end

  def last(); end

  def local_name(*args); end

  def lowercase(); end

  def lt(rhs); end

  def lte(rhs); end

  def method(name, *arguments); end

  def minus(rhs); end

  def mod(rhs); end

  def multiply(rhs); end

  def n(*args); end

  def namespace(*element_names); end

  def namespace_uri(*args); end

  def next_sibling(*expressions); end

  def normalize(*args); end

  def normalize_space(*args); end

  def not(*args); end

  def not_equals(rhs); end

  def number(*args); end

  def one_of(*expressions); end

  def or(rhs); end

  def parent(*element_names); end

  def plus(rhs); end

  def position(); end

  def preceding(*element_names); end

  def preceding_sibling(*element_names); end

  def previous_sibling(*expressions); end

  def qname(); end

  def round(*args); end

  def self(*element_names); end

  def self_axis(*element_names); end

  def starts_with(*args); end

  def string(*args); end

  def string_length(*args); end

  def substring(*args); end

  def substring_after(*args); end

  def substring_before(*args); end

  def sum(*args); end

  def text(); end

  def translate(*args); end

  def true(*args); end

  def union(*expressions); end

  def uppercase(); end

  def where(expression); end

  def |(rhs); end

  def ~(*args); end
  AXES = ::T.let(nil, ::T.untyped)
  LOWERCASE_LETTERS = ::T.let(nil, ::T.untyped)
  METHODS = ::T.let(nil, ::T.untyped)
  OPERATORS = ::T.let(nil, ::T.untyped)
  UPPERCASE_LETTERS = ::T.let(nil, ::T.untyped)
end

module XPath::DSL
  extend ::T::Sig
end

class XPath::Expression
  include ::XPath::DSL
  def arguments(); end

  def arguments=(arguments); end

  def expression(); end

  def expression=(expression); end

  def initialize(expression, *arguments); end

  def to_s(type=T.unsafe(nil)); end

  def to_xpath(type=T.unsafe(nil)); end
end

class XPath::Expression
end

class XPath::Literal
  def initialize(value); end

  def value(); end
end

class XPath::Literal
end

class XPath::Renderer
  def anywhere(element_names); end

  def attribute(current, name); end

  def axis(current, name, element_names); end

  def binary_operator(name, left, right); end

  def child(current, element_names); end

  def convert_argument(argument); end

  def css(current, selector); end

  def descendant(current, element_names); end

  def function(name, *arguments); end

  def initialize(type); end

  def is(one, two); end

  def literal(node); end

  def render(node); end

  def string_literal(string); end

  def text(current); end

  def this_node(); end

  def union(*expressions); end

  def variable(name); end

  def where(on, condition); end
end

class XPath::Renderer
  def self.render(node, type); end
end

class XPath::Union
  include ::Enumerable
  def arguments(); end

  def each(&block); end

  def expression(); end

  def expressions(); end

  def initialize(*expressions); end

  def method_missing(*args); end

  def to_s(type=T.unsafe(nil)); end

  def to_xpath(type=T.unsafe(nil)); end
end

class XPath::Union
end

module XPath
  extend ::XPath::DSL
  extend ::T::Sig
  def self.generate(); end
end

YAML = Psych

YAMLTree = Psych::Visitors::YAMLTree

class ZeroDivisionError
  extend ::T::Sig
end

module Zip
  def case_insensitive_match(); end

  def case_insensitive_match=(case_insensitive_match); end

  def continue_on_exists_proc(); end

  def continue_on_exists_proc=(continue_on_exists_proc); end

  def default_compression(); end

  def default_compression=(default_compression); end

  def force_entry_names_encoding(); end

  def force_entry_names_encoding=(force_entry_names_encoding); end

  def on_exists_proc(); end

  def on_exists_proc=(on_exists_proc); end

  def reset!(); end

  def setup(); end

  def sort_entries(); end

  def sort_entries=(sort_entries); end

  def unicode_names(); end

  def unicode_names=(unicode_names); end

  def warn_invalid_date(); end

  def warn_invalid_date=(warn_invalid_date); end

  def write_zip64_support(); end

  def write_zip64_support=(write_zip64_support); end
  CDIR_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  CENTRAL_DIRECTORY_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  FILE_TYPE_DIR = ::T.let(nil, ::T.untyped)
  FILE_TYPE_FILE = ::T.let(nil, ::T.untyped)
  FILE_TYPE_SYMLINK = ::T.let(nil, ::T.untyped)
  FSTYPES = ::T.let(nil, ::T.untyped)
  FSTYPE_ACORN = ::T.let(nil, ::T.untyped)
  FSTYPE_AMIGA = ::T.let(nil, ::T.untyped)
  FSTYPE_ATARI = ::T.let(nil, ::T.untyped)
  FSTYPE_ATHEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_BEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_CPM = ::T.let(nil, ::T.untyped)
  FSTYPE_FAT = ::T.let(nil, ::T.untyped)
  FSTYPE_HPFS = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC = ::T.let(nil, ::T.untyped)
  FSTYPE_MAC_OSX = ::T.let(nil, ::T.untyped)
  FSTYPE_MVS = ::T.let(nil, ::T.untyped)
  FSTYPE_NTFS = ::T.let(nil, ::T.untyped)
  FSTYPE_QDOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TANDEM = ::T.let(nil, ::T.untyped)
  FSTYPE_THEOS = ::T.let(nil, ::T.untyped)
  FSTYPE_TOPS20 = ::T.let(nil, ::T.untyped)
  FSTYPE_UNIX = ::T.let(nil, ::T.untyped)
  FSTYPE_VFAT = ::T.let(nil, ::T.untyped)
  FSTYPE_VMS = ::T.let(nil, ::T.untyped)
  FSTYPE_VM_CMS = ::T.let(nil, ::T.untyped)
  FSTYPE_Z_SYSTEM = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_SIGNATURE = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_STATIC_HEADER_LENGTH = ::T.let(nil, ::T.untyped)
  LOCAL_ENTRY_TRAILING_DESCRIPTOR_LENGTH = ::T.let(nil, ::T.untyped)
  RUNNING_ON_WINDOWS = ::T.let(nil, ::T.untyped)
  VERSION_MADE_BY = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT = ::T.let(nil, ::T.untyped)
  VERSION_NEEDED_TO_EXTRACT_ZIP64 = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  include ::Enumerable
  def ==(other); end

  def comment(); end

  def each(&proc); end

  def entries(); end

  def get_64_e_o_c_d(buf); end

  def get_e_o_c_d(buf); end

  def initialize(entries=T.unsafe(nil), comment=T.unsafe(nil)); end

  def read_64_e_o_c_d(buf); end

  def read_central_directory_entries(io); end

  def read_e_o_c_d(buf); end

  def read_from_stream(io); end

  def size(); end

  def start_buf(io); end

  def write_to_stream(io); end

  def zip64_file?(buf); end
  END_OF_CDS = ::T.let(nil, ::T.untyped)
  MAX_END_OF_CDS_SIZE = ::T.let(nil, ::T.untyped)
  STATIC_EOCD_SIZE = ::T.let(nil, ::T.untyped)
  ZIP64_END_OF_CDS = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_LOCATOR = ::T.let(nil, ::T.untyped)
end

class Zip::CentralDirectory
  def self.read_from_stream(io); end
end

class Zip::CompressionMethodError
end

class Zip::CompressionMethodError
end

class Zip::Compressor
  def finish(); end
end

class Zip::Compressor
end

class Zip::DOSTime
  def dos_equals(other); end

  def to_binary_dos_date(); end

  def to_binary_dos_time(); end
end

class Zip::DOSTime
  def self.parse_binary_dos_format(binaryDosDate, binaryDosTime); end
end

class Zip::Decompressor
  def initialize(input_stream); end
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
end

class Zip::Decompressor
end

class Zip::Decrypter
end

class Zip::Decrypter
end

class Zip::Deflater
  def <<(data); end

  def crc(); end

  def initialize(output_stream, level=T.unsafe(nil), encrypter=T.unsafe(nil)); end

  def size(); end
end

class Zip::Deflater
end

class Zip::DestinationFileExistsError
end

class Zip::DestinationFileExistsError
end

class Zip::Encrypter
end

class Zip::Encrypter
end

class Zip::Entry
  def ==(other); end

  def calculate_local_header_size(); end

  def cdir_header_size(); end

  def check_c_dir_entry_comment_size(); end

  def check_c_dir_entry_signature(); end

  def check_c_dir_entry_static_header_length(buf); end

  def check_name(name); end

  def clean_up(); end

  def comment(); end

  def comment=(comment); end

  def comment_size(); end

  def compressed_size(); end

  def compressed_size=(compressed_size); end

  def compression_method(); end

  def compression_method=(compression_method); end

  def crc(); end

  def crc=(crc); end

  def directory?(); end

  def dirty(); end

  def dirty=(dirty); end

  def external_file_attributes(); end

  def external_file_attributes=(external_file_attributes); end

  def extra(); end

  def extra=(extra); end

  def extra_size(); end

  def extract(dest_path=T.unsafe(nil), &block); end

  def file?(); end

  def file_stat(path); end

  def file_type_is?(type); end

  def filepath(); end

  def follow_symlinks(); end

  def follow_symlinks=(follow_symlinks); end

  def fstype(); end

  def fstype=(fstype); end

  def ftype(); end

  def gather_fileinfo_from_srcpath(src_path); end

  def get_extra_attributes_from_path(path); end

  def get_input_stream(&block); end

  def get_raw_input_stream(&block); end

  def gp_flags(); end

  def gp_flags=(gp_flags); end

  def header_signature(); end

  def header_signature=(header_signature); end

  def initialize(*args); end

  def internal_file_attributes(); end

  def internal_file_attributes=(internal_file_attributes); end

  def local_entry_offset(); end

  def local_header_offset(); end

  def local_header_offset=(local_header_offset); end

  def mtime(); end

  def name(); end

  def name=(name); end

  def name_is_directory?(); end

  def name_safe?(); end

  def name_size(); end

  def next_header_offset(); end

  def pack_c_dir_entry(); end

  def pack_local_entry(); end

  def parent_as_string(); end

  def read_c_dir_entry(io); end

  def read_c_dir_extra_field(io); end

  def read_local_entry(io); end

  def restore_ownership(); end

  def restore_ownership=(restore_ownership); end

  def restore_permissions(); end

  def restore_permissions=(restore_permissions); end

  def restore_times(); end

  def restore_times=(restore_times); end

  def set_default_vars_values(); end

  def set_extra_attributes_on_path(dest_path); end

  def set_ftype_from_c_dir_entry(); end

  def set_unix_permissions_on_path(dest_path); end

  def size(); end

  def size=(size); end

  def symlink?(); end

  def time(); end

  def time=(value); end

  def unix_gid(); end

  def unix_gid=(unix_gid); end

  def unix_perms(); end

  def unix_perms=(unix_perms); end

  def unix_uid(); end

  def unix_uid=(unix_uid); end

  def unpack_c_dir_entry(buf); end

  def unpack_local_entry(buf); end

  def verify_local_header_size!(); end

  def write_c_dir_entry(io); end

  def write_local_entry(io, rewrite=T.unsafe(nil)); end

  def write_to_zip_output_stream(zip_output_stream); end

  def zipfile(); end

  def zipfile=(zipfile); end
  DEFLATED = ::T.let(nil, ::T.untyped)
  EFS = ::T.let(nil, ::T.untyped)
  STORED = ::T.let(nil, ::T.untyped)
end

class Zip::Entry
  def self.read_c_dir_entry(io); end

  def self.read_local_entry(io); end

  def self.read_zip_64_long(io); end

  def self.read_zip_long(io); end

  def self.read_zip_short(io); end
end

class Zip::EntryExistsError
end

class Zip::EntryExistsError
end

class Zip::EntryNameError
end

class Zip::EntryNameError
end

class Zip::EntrySet
  include ::Enumerable
  def <<(entry); end

  def ==(other); end

  def delete(entry); end

  def each(); end

  def entries(); end

  def entry_order(); end

  def entry_order=(entry_order); end

  def entry_set(); end

  def entry_set=(entry_set); end

  def find_entry(entry); end

  def glob(pattern, flags=T.unsafe(nil)); end

  def include?(entry); end

  def initialize(an_enumerable=T.unsafe(nil)); end

  def length(); end

  def parent(entry); end

  def push(entry); end

  def size(); end

  def sorted_entries(); end
end

class Zip::EntrySet
end

class Zip::Error
end

class Zip::Error
end

class Zip::ExtraField
  def c_dir_size(); end

  def create(name); end

  def create_unknown_item(); end

  def extra_field_type_exist(binstr, id, len, i); end

  def extra_field_type_unknown(binstr, len, i); end

  def initialize(binstr=T.unsafe(nil)); end

  def local_size(); end

  def merge(binstr); end

  def ordered_values(); end

  def to_c_dir_bin(); end

  def to_local_bin(); end
  ID_MAP = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Generic
  def ==(other); end

  def initial_parse(binstr); end

  def to_c_dir_bin(); end

  def to_local_bin(); end
end

class Zip::ExtraField::Generic
  def self.register_map(); end
end

class Zip::ExtraField::IUnix
  def gid(); end

  def gid=(gid); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def uid(); end

  def uid=(uid); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::IUnix
end

class Zip::ExtraField::NTFS
  def atime(); end

  def atime=(atime); end

  def ctime(); end

  def ctime=(ctime); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(mtime); end

  def pack_for_c_dir(); end

  def pack_for_local(); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
  SEC_TO_UNIX_EPOCH = ::T.let(nil, ::T.untyped)
  WINDOWS_TICK = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::NTFS
end

class Zip::ExtraField::OldUnix
  def atime(); end

  def atime=(atime); end

  def gid(); end

  def gid=(gid); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(mtime); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def uid(); end

  def uid=(uid); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::OldUnix
end

class Zip::ExtraField::UniversalTime
  def atime(); end

  def atime=(atime); end

  def ctime(); end

  def ctime=(ctime); end

  def flag(); end

  def flag=(flag); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def mtime(); end

  def mtime=(mtime); end

  def pack_for_c_dir(); end

  def pack_for_local(); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::UniversalTime
end

class Zip::ExtraField::Zip64
  def compressed_size(); end

  def compressed_size=(compressed_size); end

  def disk_start_number(); end

  def disk_start_number=(disk_start_number); end

  def initialize(binstr=T.unsafe(nil)); end

  def merge(binstr); end

  def original_size(); end

  def original_size=(original_size); end

  def pack_for_c_dir(); end

  def pack_for_local(); end

  def parse(original_size, compressed_size, relative_header_offset=T.unsafe(nil), disk_start_number=T.unsafe(nil)); end

  def relative_header_offset(); end

  def relative_header_offset=(relative_header_offset); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64
end

class Zip::ExtraField::Zip64Placeholder
  def initialize(_binstr=T.unsafe(nil)); end

  def pack_for_local(); end
  HEADER_ID = ::T.let(nil, ::T.untyped)
end

class Zip::ExtraField::Zip64Placeholder
end

class Zip::ExtraField
end

class Zip::File
  def add(entry, src_path, &continue_on_exists_proc); end

  def close(); end

  def comment=(comment); end

  def commit(); end

  def commit_required?(); end

  def extract(entry, dest_path, &block); end

  def find_entry(entry_name); end

  def get_entry(entry); end

  def get_input_stream(entry, &aProc); end

  def get_output_stream(entry, permission_int=T.unsafe(nil), comment=T.unsafe(nil), extra=T.unsafe(nil), compressed_size=T.unsafe(nil), crc=T.unsafe(nil), compression_method=T.unsafe(nil), size=T.unsafe(nil), time=T.unsafe(nil), &aProc); end

  def glob(*args, &block); end

  def initialize(file_name, create=T.unsafe(nil), buffer=T.unsafe(nil), options=T.unsafe(nil)); end

  def mkdir(entryName, permissionInt=T.unsafe(nil)); end

  def name(); end

  def read(entry); end

  def remove(entry); end

  def rename(entry, new_name, &continue_on_exists_proc); end

  def replace(entry, srcPath); end

  def restore_ownership(); end

  def restore_ownership=(restore_ownership); end

  def restore_permissions(); end

  def restore_permissions=(restore_permissions); end

  def restore_times(); end

  def restore_times=(restore_times); end

  def write_buffer(io=T.unsafe(nil)); end
  CREATE = ::T.let(nil, ::T.untyped)
  DATA_BUFFER_SIZE = ::T.let(nil, ::T.untyped)
  IO_METHODS = ::T.let(nil, ::T.untyped)
  MAX_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  MIN_SEGMENT_SIZE = ::T.let(nil, ::T.untyped)
  SPLIT_SIGNATURE = ::T.let(nil, ::T.untyped)
  ZIP64_EOCD_SIGNATURE = ::T.let(nil, ::T.untyped)
end

class Zip::File
  def self.add_buffer(); end

  def self.foreach(aZipFileName, &block); end

  def self.get_partial_zip_file_name(zip_file_name, partial_zip_file_name); end

  def self.get_segment_count_for_split(zip_file_size, segment_size); end

  def self.get_segment_size_for_split(segment_size); end

  def self.open(file_name, create=T.unsafe(nil)); end

  def self.open_buffer(io, options=T.unsafe(nil)); end

  def self.put_split_signature(szip_file, segment_size); end

  def self.save_splited_part(zip_file, partial_zip_file_name, zip_file_size, szip_file_index, segment_size, segment_count); end

  def self.split(zip_file_name, segment_size=T.unsafe(nil), delete_zip_file=T.unsafe(nil), partial_zip_file_name=T.unsafe(nil)); end
end

class Zip::GPFBit3Error
end

class Zip::GPFBit3Error
end

module Zip::IOExtras
  CHUNK_SIZE = ::T.let(nil, ::T.untyped)
  RANGE_ALL = ::T.let(nil, ::T.untyped)
end

module Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Zip::IOExtras::FakeIO
  def each(a_sep_string=T.unsafe(nil)); end

  def each_line(a_sep_string=T.unsafe(nil)); end

  def flush(); end

  def gets(a_sep_string=T.unsafe(nil), number_of_bytes=T.unsafe(nil)); end

  def initialize(); end

  def lineno(); end

  def lineno=(lineno); end

  def pos(); end

  def read(number_of_bytes=T.unsafe(nil), buf=T.unsafe(nil)); end

  def readline(a_sep_string=T.unsafe(nil)); end

  def readlines(a_sep_string=T.unsafe(nil)); end

  def ungetc(byte); end
end

module Zip::IOExtras::AbstractInputStream
  extend ::T::Sig
end

module Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO
  def print(*params); end

  def printf(a_format_string, *params); end

  def putc(an_object); end

  def puts(*params); end

  def write(data); end
end

module Zip::IOExtras::AbstractOutputStream
  extend ::T::Sig
end

module Zip::IOExtras::FakeIO
  def kind_of?(object); end
end

module Zip::IOExtras::FakeIO
  extend ::T::Sig
end

module Zip::IOExtras
  extend ::T::Sig
  def self.copy_stream(ostream, istream); end

  def self.copy_stream_n(ostream, istream, nbytes); end
end

class Zip::Inflater
  def eof(); end

  def eof?(); end

  def initialize(input_stream, decrypter=T.unsafe(nil)); end

  def input_finished?(); end

  def produce_input(); end

  def sysread(number_of_bytes=T.unsafe(nil), buf=T.unsafe(nil)); end
end

class Zip::Inflater
end

class Zip::InputStream
  include ::Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::Zip::IOExtras::FakeIO
  def close(); end

  def eof(); end

  def eof?(); end

  def get_decompressor(); end

  def get_io(io_or_file, offset=T.unsafe(nil)); end

  def get_next_entry(); end

  def initialize(context, offset=T.unsafe(nil), decrypter=T.unsafe(nil)); end

  def input_finished?(); end

  def open_entry(); end

  def produce_input(); end

  def rewind(); end

  def sysread(number_of_bytes=T.unsafe(nil), buf=T.unsafe(nil)); end
end

class Zip::InputStream
  def self.open(filename_or_io, offset=T.unsafe(nil), decrypter=T.unsafe(nil)); end

  def self.open_buffer(filename_or_io, offset=T.unsafe(nil)); end
end

class Zip::InternalError
end

class Zip::InternalError
end

class Zip::NullCompressor
  include ::Singleton
  def <<(_data); end

  def compressed_size(); end

  def size(); end
end

class Zip::NullCompressor
  extend ::Singleton::SingletonClassMethods
  def self.instance(); end
end

module Zip::NullDecompressor
end

module Zip::NullDecompressor
  extend ::T::Sig
  def self.eof(); end

  def self.input_finished?(); end

  def self.produce_input(); end

  def self.sysread(_numberOfBytes=T.unsafe(nil), _buf=T.unsafe(nil)); end
end

class Zip::NullDecrypter
  include ::Zip::NullEncryption
  def decrypt(data); end

  def reset!(_header); end
end

class Zip::NullDecrypter
end

class Zip::NullEncrypter
  include ::Zip::NullEncryption
  def data_descriptor(_crc32, _compressed_size, _uncomprssed_size); end

  def encrypt(data); end

  def header(_mtime); end

  def reset!(); end
end

class Zip::NullEncrypter
end

module Zip::NullEncryption
  def gp_flags(); end

  def header_bytesize(); end
end

module Zip::NullEncryption
  extend ::T::Sig
end

module Zip::NullInputStream
  include ::Zip::NullDecompressor
  include ::Zip::IOExtras::AbstractInputStream
  include ::Enumerable
  include ::ActiveSupport::ToJsonWithActiveSupportEncoder
  include ::Zip::IOExtras::FakeIO
end

module Zip::NullInputStream
  extend ::T::Sig
end

class Zip::OutputStream
  include ::Zip::IOExtras::AbstractOutputStream
  include ::Zip::IOExtras::FakeIO
  def <<(data); end

  def close(); end

  def close_buffer(); end

  def comment(); end

  def comment=(comment); end

  def copy_raw_entry(entry); end

  def finish(); end

  def initialize(file_name, stream=T.unsafe(nil), encrypter=T.unsafe(nil)); end

  def put_next_entry(entry_name, comment=T.unsafe(nil), extra=T.unsafe(nil), compression_method=T.unsafe(nil), level=T.unsafe(nil)); end
end

class Zip::OutputStream
  def self.open(file_name, encrypter=T.unsafe(nil)); end

  def self.write_buffer(io=T.unsafe(nil), encrypter=T.unsafe(nil)); end
end

class Zip::PassThruCompressor
  def <<(data); end

  def crc(); end

  def initialize(outputStream); end

  def size(); end
end

class Zip::PassThruCompressor
end

class Zip::PassThruDecompressor
  def eof(); end

  def eof?(); end

  def initialize(input_stream, chars_to_read); end

  def input_finished?(); end

  def produce_input(); end

  def sysread(number_of_bytes=T.unsafe(nil), buf=T.unsafe(nil)); end
end

class Zip::PassThruDecompressor
end

class Zip::StreamableDirectory
  def initialize(zipfile, entry, srcPath=T.unsafe(nil), permissionInt=T.unsafe(nil)); end
end

class Zip::StreamableDirectory
end

class Zip::StreamableStream
  def clean_up(); end

  def get_input_stream(); end

  def get_output_stream(); end

  def initialize(entry); end

  def write_to_zip_output_stream(aZipOutputStream); end
end

class Zip::StreamableStream
end

class Zip::TraditionalDecrypter
  include ::Zip::TraditionalEncryption
  def decrypt(data); end

  def reset!(header); end
end

class Zip::TraditionalDecrypter
end

class Zip::TraditionalEncrypter
  include ::Zip::TraditionalEncryption
  def data_descriptor(crc32, compressed_size, uncomprssed_size); end

  def encrypt(data); end

  def header(mtime); end

  def reset!(); end
end

class Zip::TraditionalEncrypter
end

module Zip::TraditionalEncryption
  def decrypt_byte(); end

  def gp_flags(); end

  def header_bytesize(); end

  def initialize(password); end

  def reset_keys!(); end

  def update_keys(n); end
end

module Zip::TraditionalEncryption
  extend ::T::Sig
end

Zip::ZipCompressionMethodError = Zip::CompressionMethodError

Zip::ZipDestinationFileExistsError = Zip::DestinationFileExistsError

Zip::ZipEntryExistsError = Zip::EntryExistsError

Zip::ZipEntryNameError = Zip::EntryNameError

Zip::ZipError = Zip::Error

Zip::ZipInternalError = Zip::InternalError

module Zip
  extend ::Zip
  extend ::T::Sig
end

module Zlib
  ASCII = ::T.let(nil, ::T.untyped)
  BEST_COMPRESSION = ::T.let(nil, ::T.untyped)
  BEST_SPEED = ::T.let(nil, ::T.untyped)
  BINARY = ::T.let(nil, ::T.untyped)
  DEFAULT_COMPRESSION = ::T.let(nil, ::T.untyped)
  DEFAULT_STRATEGY = ::T.let(nil, ::T.untyped)
  DEF_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  FILTERED = ::T.let(nil, ::T.untyped)
  FINISH = ::T.let(nil, ::T.untyped)
  FIXED = ::T.let(nil, ::T.untyped)
  FULL_FLUSH = ::T.let(nil, ::T.untyped)
  HUFFMAN_ONLY = ::T.let(nil, ::T.untyped)
  MAX_MEM_LEVEL = ::T.let(nil, ::T.untyped)
  MAX_WBITS = ::T.let(nil, ::T.untyped)
  NO_COMPRESSION = ::T.let(nil, ::T.untyped)
  NO_FLUSH = ::T.let(nil, ::T.untyped)
  OS_AMIGA = ::T.let(nil, ::T.untyped)
  OS_ATARI = ::T.let(nil, ::T.untyped)
  OS_CODE = ::T.let(nil, ::T.untyped)
  OS_CPM = ::T.let(nil, ::T.untyped)
  OS_MACOS = ::T.let(nil, ::T.untyped)
  OS_MSDOS = ::T.let(nil, ::T.untyped)
  OS_OS2 = ::T.let(nil, ::T.untyped)
  OS_QDOS = ::T.let(nil, ::T.untyped)
  OS_RISCOS = ::T.let(nil, ::T.untyped)
  OS_TOPS20 = ::T.let(nil, ::T.untyped)
  OS_UNIX = ::T.let(nil, ::T.untyped)
  OS_UNKNOWN = ::T.let(nil, ::T.untyped)
  OS_VMCMS = ::T.let(nil, ::T.untyped)
  OS_VMS = ::T.let(nil, ::T.untyped)
  OS_WIN32 = ::T.let(nil, ::T.untyped)
  OS_ZSYSTEM = ::T.let(nil, ::T.untyped)
  RLE = ::T.let(nil, ::T.untyped)
  SYNC_FLUSH = ::T.let(nil, ::T.untyped)
  TEXT = ::T.let(nil, ::T.untyped)
  UNKNOWN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
  ZLIB_VERSION = ::T.let(nil, ::T.untyped)
end

class Zlib::BufError
end

class Zlib::BufError
end

class Zlib::DataError
end

class Zlib::DataError
end

class Zlib::Deflate
  def <<(_); end

  def deflate(*_); end

  def flush(*_); end

  def initialize(*_); end

  def params(_, _1); end

  def set_dictionary(_); end
end

class Zlib::Deflate
  def self.deflate(*_); end
end

class Zlib::Error
end

class Zlib::Error
end

class Zlib::GzipFile
  def close(); end

  def closed?(); end

  def comment(); end

  def crc(); end

  def finish(); end

  def level(); end

  def mtime(); end

  def orig_name(); end

  def os_code(); end

  def sync(); end

  def sync=(sync); end

  def to_io(); end
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::CRCError
end

class Zlib::GzipFile::Error
  include ::REST::Error::Protocol
  include ::REST::Error
  def input(); end
end

class Zlib::GzipFile::Error
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::LengthError
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile::NoFooter
end

class Zlib::GzipFile
  def self.wrap(*_); end
end

class Zlib::GzipReader
  include ::Enumerable
  def bytes(); end

  def each(*_); end

  def each_byte(); end

  def each_char(); end

  def each_line(*_); end

  def eof(); end

  def eof?(); end

  def external_encoding(); end

  def getbyte(); end

  def getc(); end

  def initialize(*_); end

  def lineno(); end

  def lineno=(lineno); end

  def lines(*_); end

  def pos(); end

  def read(*_); end

  def readbyte(); end

  def readchar(); end

  def readpartial(*_); end

  def rewind(); end

  def tell(); end

  def ungetbyte(_); end

  def ungetc(_); end

  def unused(); end
end

class Zlib::GzipReader
  def self.open(*_); end
end

class Zlib::GzipWriter
  def <<(_); end

  def comment=(comment); end

  def flush(*_); end

  def initialize(*_); end

  def mtime=(mtime); end

  def orig_name=(orig_name); end

  def pos(); end

  def tell(); end

  def write(*_); end
end

class Zlib::GzipWriter
  def self.open(*_); end
end

class Zlib::Inflate
  def <<(_); end

  def add_dictionary(_); end

  def inflate(_); end

  def initialize(*_); end

  def set_dictionary(_); end

  def sync(_); end

  def sync_point?(); end
end

class Zlib::Inflate
  def self.inflate(_); end
end

class Zlib::MemError
end

class Zlib::MemError
end

class Zlib::NeedDict
end

class Zlib::NeedDict
end

class Zlib::StreamEnd
end

class Zlib::StreamEnd
end

class Zlib::StreamError
end

class Zlib::StreamError
end

class Zlib::VersionError
end

class Zlib::VersionError
end

class Zlib::ZStream
  def adler(); end

  def avail_in(); end

  def avail_out(); end

  def avail_out=(avail_out); end

  def close(); end

  def closed?(); end

  def data_type(); end

  def end(); end

  def ended?(); end

  def finish(); end

  def finished?(); end

  def flush_next_in(); end

  def flush_next_out(); end

  def reset(); end

  def stream_end?(); end

  def total_in(); end

  def total_out(); end
end

class Zlib::ZStream
end

module Zlib
  extend ::T::Sig
  def self.adler32(*_); end

  def self.adler32_combine(_, _1, _2); end

  def self.crc32(*_); end

  def self.crc32_combine(_, _1, _2); end

  def self.crc_table(); end

  def self.deflate(*_); end

  def self.gunzip(_); end

  def self.gzip(*_); end

  def self.inflate(_); end

  def self.zlib_version(); end
end
